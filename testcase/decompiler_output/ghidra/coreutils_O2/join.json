{
    "00103000": "\n/* WARNING: Removing unreachable block (ram,0x00103024) */\n/* WARNING: Removing unreachable block (ram,0x00103030) */\n\nvoid register_tm_clones(void)\n\n{\n  return;\n}\n\n", 
    "00106fc0": "\nvoid quotearg_custom(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  quotearg_n_custom(0,param_1,param_2,param_3);\n  return;\n}\n\n", 
    "00103bd0": "\nvoid prjoin(undefined1 *param_1,undefined1 *param_2)\n\n{\n  int iVar1;\n  undefined1 *puVar2;\n  int *piVar3;\n  undefined8 uVar4;\n  \n  iVar1 = tab;\n  if (tab < 0) {\n    iVar1 = 0x20;\n  }\n  piVar3 = outlist_head._16_8_;\n  if (outlist_head._16_8_ == (int *)0x0) {\n    puVar2 = param_1;\n    uVar4 = join_field_1;\n    if (param_1 == uni_blank) {\n      puVar2 = param_2;\n      uVar4 = join_field_2;\n    }\n    prfield_isra_0(uVar4,*(undefined8 *)(puVar2 + 0x18),puVar2 + 0x28);\n    prfields(param_1,join_field_1,autocount_1);\n    prfields(param_2,join_field_2,autocount_2);\n  }\n  else {\n    while( true ) {\n      if (*piVar3 == 0) {\n        puVar2 = param_1;\n        uVar4 = join_field_1;\n        if (param_1 == uni_blank) {\n          puVar2 = param_2;\n          uVar4 = join_field_2;\n        }\n      }\n      else {\n        uVar4 = *(undefined8 *)(piVar3 + 2);\n        puVar2 = param_2;\n        if (*piVar3 == 1) {\n          puVar2 = param_1;\n        }\n      }\n      prfield_isra_0(uVar4,*(undefined8 *)(puVar2 + 0x18),puVar2 + 0x28);\n      piVar3 = *(int **)(piVar3 + 4);\n      if (piVar3 == (int *)0x0) break;\n      putchar_unlocked((int)(char)iVar1);\n    }\n  }\n  putchar_unlocked((int)eolchar);\n  return;\n}\n\n", 
    "00103ab0": "\nvoid prfield_isra_0(ulong param_1,ulong param_2,long *param_3)\n\n{\n  void *__n;\n  void **ppvVar1;\n  \n  if (param_1 < param_2) {\n    ppvVar1 = (void **)(param_1 * 0x10 + *param_3);\n    __n = ppvVar1[1];\n    if (__n != (void *)0x0) {\n      fwrite_unlocked(*ppvVar1,1,(size_t)__n,stdout);\n      return;\n    }\n  }\n  if (empty_filler != (char *)0x0) {\n    fputs_unlocked(empty_filler,stdout);\n    return;\n  }\n  return;\n}\n\n", 
    "00103cf0": "\nvoid system_join(undefined8 param_1,undefined8 param_2)\n\n{\n  long *plVar1;\n  long lVar2;\n  bool bVar3;\n  bool bVar4;\n  char cVar5;\n  char cVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  undefined1 *puVar9;\n  ulong uVar10;\n  long in_FS_OFFSET;\n  ulong local_98;\n  void *local_80;\n  ulong local_78;\n  undefined local_70 [8];\n  long *local_68 [2];\n  long local_58;\n  undefined local_50 [8];\n  long *local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  fadvise(param_1,2);\n  fadvise(param_2,2);\n  initseq(&local_78);\n  getseq(param_1,&local_78,1);\n  initseq(&local_58);\n  getseq(param_2,&local_58,2);\n  if (autoformat != '\\0') {\n    autocount_1 = local_78;\n    if (local_78 != 0) {\n      autocount_1 = *(ulong *)(*local_68[0] + 0x18);\n    }\n    autocount_2 = local_58;\n    if (local_58 != 0) {\n      autocount_2 = *(long *)(*local_48 + 0x18);\n    }\n  }\n  if (join_header_lines == '\\0') {\nLAB_00103e08:\n    if (local_78 != 0) {\n      while( true ) {\n        uVar10 = local_78;\n        if (local_58 == 0) goto LAB_00103e90;\n        iVar7 = keycmp_isra_0(*(undefined8 *)(*local_68[0] + 0x18),*local_68[0] + 0x28,\n                              *(undefined8 *)(*local_48 + 0x18),*local_48 + 0x28,join_field_1,\n                              join_field_2);\n        if (iVar7 < 0) {\n          if (print_unpairables_1 != '\\0') {\n            prjoin(*local_68[0],uni_blank);\n          }\n          advance_seq(param_1,&local_78,1,1);\n          seen_unpairable = 1;\n          goto LAB_00103e08;\n        }\n        if (iVar7 == 0) break;\n        if (print_unpairables_2 != '\\0') {\n          prjoin(uni_blank,*local_48);\n        }\n        advance_seq(param_2,&local_58,1,2);\n        seen_unpairable = 1;\n        if (local_78 == 0) goto LAB_00103e8e;\n      }\n      do {\n        cVar6 = advance_seq(param_1,&local_78,0,1);\n        if (cVar6 == '\\0') {\n          local_78 = local_78 + 1;\n          bVar3 = true;\n          goto LAB_00103fd2;\n        }\n        iVar7 = keycmp_isra_0(*(undefined8 *)(local_68[0][local_78 - 1] + 0x18),\n                              local_68[0][local_78 - 1] + 0x28,*(undefined8 *)(*local_48 + 0x18),\n                              *local_48 + 0x28,join_field_1,join_field_2);\n      } while (iVar7 == 0);\n      bVar3 = false;\nLAB_00103fd2:\n      do {\n        cVar6 = advance_seq(param_2,&local_58,0,2);\n        if (cVar6 == '\\0') {\n          local_58 = local_58 + 1;\n          bVar4 = true;\n          goto joined_r0x00103ffa;\n        }\n        iVar7 = keycmp_isra_0(*(undefined8 *)(*local_68[0] + 0x18),*local_68[0] + 0x28,\n                              *(undefined8 *)(local_48[local_58 + -1] + 0x18),\n                              local_48[local_58 + -1] + 0x28,join_field_1,join_field_2);\n      } while (iVar7 == 0);\n      bVar4 = false;\njoined_r0x00103ffa:\n      if ((print_pairables != '\\0') && (local_98 = 0, local_78 != 1)) {\n        do {\n          uVar10 = 0;\n          if (local_58 != 1) {\n            do {\n              plVar1 = local_48 + uVar10;\n              uVar10 = uVar10 + 1;\n              prjoin(local_68[0][local_98],*plVar1);\n            } while (uVar10 < local_58 - 1U);\n          }\n          local_98 = local_98 + 1;\n        } while (local_98 < local_78 - 1);\n      }\n      if (!bVar3) {\n        lVar2 = *local_68[0];\n        *local_68[0] = local_68[0][local_78 - 1];\n        local_68[0][local_78 - 1] = lVar2;\n      }\n      local_78 = (ulong)!bVar3;\n      if (bVar4) {\n        local_58 = 0;\n      }\n      else {\n        lVar2 = *local_48;\n        *local_48 = local_48[local_58 + -1];\n        local_48[local_58 + -1] = lVar2;\n        local_58 = 1;\n      }\n      goto LAB_00103e08;\n    }\n  }\n  else {\n    if (local_78 != 0) {\n      puVar8 = uni_blank;\n      puVar9 = (undefined1 *)*local_68[0];\n      if (local_58 != 0) goto LAB_00104287;\nLAB_00103dd2:\n      prjoin(puVar9,puVar8);\n      prevline._0_8_ = 0;\n      prevline._8_8_ = 0;\n      if (local_78 != 0) {\n        advance_seq(param_1,&local_78,1,1);\n      }\n      if (local_58 != 0) {\n        advance_seq(param_2,&local_58,1,2);\n      }\n      goto LAB_00103e08;\n    }\n    if (local_58 != 0) {\n      puVar9 = uni_blank;\nLAB_00104287:\n      puVar8 = (undefined1 *)*local_48;\n      goto LAB_00103dd2;\n    }\n  }\nLAB_00103e8e:\n  uVar10 = 0;\nLAB_00103e90:\n  local_80 = (void *)0x0;\n  cVar6 = print_unpairables_1;\n  if ((check_input_order == 2) ||\n     (((char)issued_disorder_warning != '\\0' && (issued_disorder_warning._1_1_ != '\\0')))) {\n    if ((print_unpairables_1 != '\\0') && (cVar6 = '\\0', uVar10 != 0)) {\nLAB_00104317:\n      prjoin(*local_68[0],uni_blank);\n      goto LAB_00103ed3;\n    }\nLAB_001041af:\n    if ((print_unpairables_2 == '\\0') && (cVar6 == '\\0')) goto LAB_001041bf;\n  }\n  else if (uVar10 != 0) {\n    if (print_unpairables_1 != '\\0') goto LAB_00104317;\n    cVar6 = '\\x01';\nLAB_00103ed3:\n    if (local_58 != 0) {\n      seen_unpairable = 1;\n    }\n    do {\n      cVar5 = get_line(param_1,&local_80,1);\n      if (cVar5 == '\\0') break;\n      cVar5 = (char)issued_disorder_warning;\n    } while (((print_unpairables_1 != '\\0') &&\n             (prjoin(local_80,uni_blank), cVar5 = print_unpairables_1,\n             (char)issued_disorder_warning == '\\0')) || (cVar5 != '\\0'));\n    goto LAB_001041af;\n  }\n  if (local_58 != 0) {\n    if (print_unpairables_2 != '\\0') {\n      prjoin(uni_blank,*local_48);\n    }\n    if (local_78 != 0) {\n      seen_unpairable = 1;\n    }\n    do {\n      cVar6 = get_line(param_2,&local_80,2);\n      if (cVar6 == '\\0') break;\n      cVar6 = issued_disorder_warning._1_1_;\n    } while (((print_unpairables_2 != '\\0') &&\n             (prjoin(uni_blank,local_80), cVar6 = print_unpairables_2,\n             issued_disorder_warning._1_1_ == '\\0')) || (cVar6 != '\\0'));\n  }\nLAB_001041bf:\n  freeline(local_80);\n  free(local_80);\n  delseq_isra_0(local_70,local_68);\n  delseq_isra_0(local_50,&local_48);\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00106990": "\nuint set_char_quoting(undefined1 *param_1,byte param_2,uint param_3)\n\n{\n  uint uVar1;\n  uint uVar2;\n  \n  if (param_1 == (undefined1 *)0x0) {\n    param_1 = default_quoting_options;\n  }\n  uVar1 = *(uint *)(param_1 + (ulong)(param_2 >> 5) * 4 + 8);\n  uVar2 = uVar1 >> (param_2 & 0x1f);\n  *(uint *)(param_1 + (ulong)(param_2 >> 5) * 4 + 8) =\n       ((param_3 ^ uVar2) & 1) << (param_2 & 0x1f) ^ uVar1;\n  return uVar2 & 1;\n}\n\n", 
    "00107040": "\nvoid dup_safer(undefined8 param_1)\n\n{\n  rpl_fcntl(param_1,0,3);\n  return;\n}\n\n", 
    "00108250": "\nuint c_isblank(int param_1,undefined8 param_2,uint param_3)\n\n{\n  uint in_EAX;\n  \n  return in_EAX & 0xffffff00 | (uint)(param_1 == 0x20) | param_3 & 0xffffff00 | (uint)(param_1 == 9)\n  ;\n}\n\n", 
    "00107af0": "\nuint xstrtoul(byte *param_1,byte **param_2,uint param_3,ulong *param_4,char *param_5)\n\n{\n  byte bVar1;\n  uint uVar2;\n  int *piVar3;\n  ushort **ppuVar4;\n  byte *pbVar5;\n  ulong uVar6;\n  char *pcVar7;\n  int iVar8;\n  undefined8 uVar9;\n  uint uVar10;\n  byte bVar11;\n  long in_FS_OFFSET;\n  byte *local_50;\n  ulong local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (0x24 < param_3) {\n                    /* WARNING: Subroutine does not return */\n    __assert_fail(\"0 <= strtol_base && strtol_base <= 36\",\"lib/xstrtol.c\",0x60,\"xstrtoul\");\n  }\n  if (param_2 == (byte **)0x0) {\n    param_2 = &local_50;\n  }\n  piVar3 = __errno_location();\n  *piVar3 = 0;\n  bVar11 = *param_1;\n  ppuVar4 = __ctype_b_loc();\n  pbVar5 = param_1;\n  while ((*(byte *)((long)*ppuVar4 + (ulong)bVar11 * 2 + 1) & 0x20) != 0) {\n    bVar11 = pbVar5[1];\n    pbVar5 = pbVar5 + 1;\n  }\n  if (bVar11 != 0x2d) {\n    uVar6 = strtoul((char *)param_1,(char **)param_2,param_3);\n    pbVar5 = *param_2;\n    local_48 = uVar6;\n    if (pbVar5 != param_1) {\n      if (*piVar3 == 0) {\n        uVar10 = 0;\n      }\n      else {\n        uVar10 = 1;\n        if (*piVar3 != 0x22) goto LAB_00107beb;\n      }\n      if ((param_5 != (char *)0x0) && (bVar11 = *pbVar5, bVar11 != 0)) {\n        iVar8 = (int)(char)bVar11;\nLAB_00107c2c:\n        pcVar7 = strchr(param_5,iVar8);\n        if (pcVar7 == (char *)0x0) {\nswitchD_00107c80_caseD_43:\n          uVar10 = uVar10 | 2;\n          *param_4 = local_48;\n          goto LAB_00107bb2;\n        }\n        switch(bVar11) {\n        case 0x45:\n        case 0x47:\n        case 0x4b:\n        case 0x4d:\n        case 0x50:\n        case 0x54:\n        case 0x59:\n        case 0x5a:\n        case 0x67:\n        case 0x6b:\n        case 0x6d:\n        case 0x74:\n          pcVar7 = strchr(param_5,0x30);\n          if (pcVar7 == (char *)0x0) goto switchD_00107c56_caseD_46;\n          bVar1 = pbVar5[1];\n          if (bVar1 == 0x44) {\n            iVar8 = 2;\n            uVar9 = 1000;\n          }\n          else if (bVar1 == 0x69) {\n            uVar9 = 0x400;\n            iVar8 = (pbVar5[2] == 0x42) + 1 + (uint)(pbVar5[2] == 0x42);\n          }\n          else {\n            iVar8 = (bVar1 == 0x42) + 1;\n            uVar9 = 0x400;\n            if (bVar1 == 0x42) {\n              uVar9 = 1000;\n            }\n          }\n          break;\n        default:\nswitchD_00107c56_caseD_46:\n          iVar8 = 1;\n          uVar9 = 0x400;\n        }\n        switch(bVar11) {\n        case 0x42:\n          uVar2 = bkm_scale(&local_48,0x400);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n          break;\n        default:\n          goto switchD_00107c80_caseD_43;\n        case 0x45:\n          uVar2 = bkm_scale_by_power(&local_48,uVar9,6);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n          break;\n        case 0x47:\n        case 0x67:\n          uVar2 = bkm_scale_by_power(&local_48,uVar9,3);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n          break;\n        case 0x4b:\n        case 0x6b:\n          uVar2 = bkm_scale_by_power(&local_48,uVar9,1);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n          break;\n        case 0x4d:\n        case 0x6d:\n          uVar2 = bkm_scale_by_power(&local_48,uVar9,2);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n          break;\n        case 0x50:\n          uVar2 = bkm_scale_by_power(&local_48,uVar9,5);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n          break;\n        case 0x54:\n        case 0x74:\n          uVar2 = bkm_scale_by_power(&local_48,uVar9,4);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n          break;\n        case 0x59:\n          uVar2 = bkm_scale_by_power(&local_48,uVar9,8);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n          break;\n        case 0x5a:\n          uVar2 = bkm_scale_by_power(&local_48,uVar9,7);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n          break;\n        case 0x62:\n          uVar2 = bkm_scale(&local_48,0x200);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n          break;\n        case 99:\n          break;\n        case 0x77:\n          uVar2 = bkm_scale(&local_48,2);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n        }\n        uVar6 = local_48;\n        *param_2 = pbVar5 + iVar8;\n        if (pbVar5[iVar8] != 0) {\n          uVar10 = uVar10 | 2;\n        }\n      }\n      *param_4 = uVar6;\n      goto LAB_00107bb2;\n    }\n    if ((param_5 != (char *)0x0) && (bVar11 = *param_1, bVar11 != 0)) {\n      iVar8 = (int)(char)bVar11;\n      pcVar7 = strchr(param_5,iVar8);\n      if (pcVar7 != (char *)0x0) {\n        local_48 = 1;\n        uVar10 = 0;\n        goto LAB_00107c2c;\n      }\n    }\n  }\nLAB_00107beb:\n  uVar10 = 4;\nLAB_00107bb2:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar10;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00108490": "\nchar * locale_charset(void)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = nl_langinfo(0xe);\n  if (pcVar1 != (char *)0x0) {\n    if (*pcVar1 == '\\0') {\n      pcVar1 = \"ASCII\";\n    }\n    return pcVar1;\n  }\n  return \"ASCII\";\n}\n\n", 
    "00106f10": "\nvoid quotearg_n_custom_mem\n               (undefined4 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n               undefined8 param_5)\n\n{\n  long in_FS_OFFSET;\n  undefined8 local_68;\n  undefined8 uStack_60;\n  undefined8 local_58;\n  undefined8 uStack_50;\n  undefined8 local_48;\n  undefined8 uStack_40;\n  undefined8 local_38;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  local_68 = default_quoting_options._0_8_;\n  uStack_60 = default_quoting_options._8_8_;\n  local_38 = default_quoting_options._48_8_;\n  local_58 = default_quoting_options._16_8_;\n  uStack_50 = default_quoting_options._24_8_;\n  local_48 = default_quoting_options._32_8_;\n  uStack_40 = default_quoting_options._40_8_;\n  set_custom_quoting(&local_68);\n  quotearg_n_options(param_1,param_4,param_5,&local_68);\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "001076a0": "\nvoid xmalloc(size_t param_1)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = malloc(param_1);\n  if ((pvVar1 == (void *)0x0) && (param_1 != 0)) {\n                    /* WARNING: Subroutine does not return */\n    xalloc_die();\n  }\n  return;\n}\n\n", 
    "00103a00": "\nvoid getseq(undefined8 param_1,ulong *param_2,undefined4 param_3)\n\n{\n  ulong uVar1;\n  char cVar2;\n  ulong uVar3;\n  ulong uVar4;\n  undefined8 *puVar5;\n  \n  uVar4 = *param_2;\n  uVar3 = param_2[2];\n  if (uVar4 == param_2[1]) {\n    uVar3 = x2nrealloc(uVar3,param_2 + 1,8);\n    uVar4 = *param_2;\n    param_2[2] = uVar3;\n    uVar1 = param_2[1];\n    if (uVar4 < uVar1) {\n      puVar5 = (undefined8 *)(uVar3 + uVar4 * 8);\n      do {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n      } while (puVar5 != (undefined8 *)(uVar3 + uVar1 * 8));\n    }\n  }\n  cVar2 = get_line(param_1,uVar3 + uVar4 * 8,param_3);\n  if (cVar2 != '\\0') {\n    *param_2 = *param_2 + 1;\n  }\n  return;\n}\n\n", 
    "0010f090": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t mbrtowc(wchar_t *__pwc,char *__s,size_t __n,mbstate_t *__p)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* mbrtowc@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00104e50": "\nbool strcaseeq9(long param_1,long param_2)\n\n{\n  int iVar1;\n  \n  iVar1 = c_strcasecmp(param_1 + 9,param_2 + 9);\n  return iVar1 == 0;\n}\n\n", 
    "00102700": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t fwrite(void *__ptr,size_t __size,size_t __n,FILE *__s)\n\n{\n  size_t sVar1;\n  \n  sVar1 = (*(code *)PTR_fwrite_0010df98)();\n  return sVar1;\n}\n\n", 
    "0010f098": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * strchr(char *__s,int __c)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strchr@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00103110": "\nlong string_to_join_field(undefined8 param_1)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  long in_FS_OFFSET;\n  long local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = xstrtoul(param_1,0,10,&local_28,&DAT_0010905f);\n  if (iVar1 == 1) {\n    local_28 = -2;\n  }\n  else {\n    if ((iVar1 != 0) || (local_28 == 0)) {\n      uVar2 = quote(param_1);\n      uVar3 = dcgettext(0,\"invalid field number: %s\",5);\n                    /* WARNING: Subroutine does not return */\n      error(1,0,uVar3,uVar2);\n    }\n    local_28 = local_28 + -1;\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_28;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00106fb0": "\nvoid quotearg_n_custom(void)\n\n{\n  quotearg_n_custom_mem();\n  return;\n}\n\n", 
    "00107830": "\nvoid xcalloc(size_t param_1,ulong param_2)\n\n{\n  void *pvVar1;\n  \n  if ((-1 < SUB168(ZEXT816(param_1) * ZEXT816(param_2),0)) &&\n     (SUB168(ZEXT816(param_1) * ZEXT816(param_2) >> 0x40,0) == 0)) {\n    pvVar1 = calloc(param_1,param_2);\n    if (pvVar1 != (void *)0x0) {\n      return;\n    }\n  }\n                    /* WARNING: Subroutine does not return */\n  xalloc_die();\n}\n\n", 
    "00102020": "\nvoid FUN_00102020(void)\n\n{\n                    /* WARNING: Treating indirect jump as call */\n  (*(code *)PTR_0010ddf8)();\n  return;\n}\n\n", 
    "00103350": "\nvoid add_field(uint param_1,long param_2)\n\n{\n  uint **ppuVar1;\n  uint *puVar2;\n  \n  if (2 < param_1) {\n                    /* WARNING: Subroutine does not return */\n    __assert_fail(\"file == 0 || file == 1 || file == 2\",\"src/join.c\",0x333,\"add_field\");\n  }\n  if ((param_1 == 0) && (param_2 != 0)) {\n                    /* WARNING: Subroutine does not return */\n    __assert_fail(\"file != 0 || field == 0\",\"src/join.c\",0x334,\"add_field\");\n  }\n  puVar2 = (uint *)xmalloc(0x18);\n  *puVar2 = param_1;\n  *(long *)(puVar2 + 2) = param_2;\n  *(undefined8 *)(puVar2 + 4) = 0;\n  ppuVar1 = (uint **)(outlist_end + 0x10);\n  outlist_end = (undefined *)puVar2;\n  *ppuVar1 = puVar2;\n  return;\n}\n\n", 
    "00107030": "\nvoid quote(undefined8 param_1)\n\n{\n  quote_n(0,param_1);\n  return;\n}\n\n", 
    "00108240": "\nbool c_isascii(uint param_1)\n\n{\n  return param_1 < 0x80;\n}\n\n", 
    "00104f60": "\nundefined8 strcaseeq6(long param_1,undefined8 param_2,byte param_3,char param_4,char param_5)\n\n{\n  char cVar1;\n  byte bVar2;\n  undefined8 uVar3;\n  \n  cVar1 = c_isupper((int)(char)param_3);\n  bVar2 = *(byte *)(param_1 + 6);\n  if (cVar1 != '\\0') {\n    bVar2 = bVar2 & 0xdf;\n  }\n  if (param_3 != bVar2) {\n    return 0;\n  }\n  if (param_3 == 0) {\n    return 1;\n  }\n  uVar3 = strcaseeq7(param_1,param_2,(int)param_4,(int)param_5);\n  return uVar3;\n}\n\n", 
    "001031b0": "\nvoid decode_field_spec(char *param_1,int *param_2,undefined8 *param_3)\n\n{\n  char cVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  \n  cVar1 = *param_1;\n  if (cVar1 == '0') {\n    if (param_1[1] == '\\0') {\n      *param_2 = 0;\n      *param_3 = 0;\n      return;\n    }\n  }\n  else {\n    if (1 < (byte)(cVar1 - 0x31U)) {\n      uVar2 = quote();\n      uVar3 = dcgettext(0,\"invalid file number in field spec: %s\",5);\n                    /* WARNING: Subroutine does not return */\n      error(1,0,uVar3,uVar2);\n    }\n    if (param_1[1] == '.') {\n      *param_2 = cVar1 + -0x30;\n      uVar2 = string_to_join_field(param_1 + 2);\n      *param_3 = uVar2;\n      return;\n    }\n  }\n  uVar2 = quote();\n  uVar3 = dcgettext(0,\"invalid field specifier: %s\",5);\n                    /* WARNING: Subroutine does not return */\n  error(1,0,uVar3,uVar2);\n}\n\n", 
    "00107a30": "\nundefined4 xmemcoll0(undefined8 param_1,long param_2,undefined8 param_3,long param_4)\n\n{\n  undefined4 uVar1;\n  int *piVar2;\n  \n  uVar1 = memcoll0();\n  piVar2 = __errno_location();\n  if (*piVar2 == 0) {\n    return uVar1;\n  }\n  collate_error(*piVar2,param_1,param_2 + -1,param_3,param_4 + -1);\n  return uVar1;\n}\n\n", 
    "001080a0": "\nvoid rpl_fflush(FILE *param_1)\n\n{\n  int iVar1;\n  \n  if (param_1 != (FILE *)0x0) {\n    iVar1 = __freading();\n    if (iVar1 != 0) {\n      clear_ungetc_buffer_preserving_position(param_1);\n      fflush(param_1);\n      return;\n    }\n  }\n  fflush(param_1);\n  return;\n}\n\n", 
    "00106da0": "\nvoid quotearg_char_mem(undefined8 param_1,undefined8 param_2,char param_3,undefined8 param_4)\n\n{\n  undefined8 *puVar1;\n  long in_FS_OFFSET;\n  undefined8 local_48;\n  undefined8 uStack_40;\n  undefined8 local_38;\n  undefined8 uStack_30;\n  undefined8 local_28;\n  undefined8 uStack_20;\n  undefined8 local_18;\n  long local_10;\n  \n  puVar1 = &local_48;\n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_48 = default_quoting_options._0_8_;\n  uStack_40 = default_quoting_options._8_8_;\n  local_38 = default_quoting_options._16_8_;\n  uStack_30 = default_quoting_options._24_8_;\n  local_28 = default_quoting_options._32_8_;\n  uStack_20 = default_quoting_options._40_8_;\n  local_18 = default_quoting_options._48_8_;\n  set_char_quoting(&local_48,(int)param_3,1,param_4,param_1,param_2);\n  quotearg_n_options(0,param_1,param_2,puVar1);\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00107740": "\nvoid xnrealloc(undefined8 param_1,ulong param_2,ulong param_3)\n\n{\n  if ((-1 < SUB168(ZEXT816(param_2) * ZEXT816(param_3),0)) &&\n     (SUB168(ZEXT816(param_2) * ZEXT816(param_3) >> 0x40,0) == 0)) {\n    xrealloc();\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  xalloc_die();\n}\n\n", 
    "00104aa0": "\nFILE * fopen_safer(char *param_1,char *param_2)\n\n{\n  uint uVar1;\n  int iVar2;\n  int iVar3;\n  FILE *__stream;\n  FILE *pFVar4;\n  int *piVar5;\n  \n  __stream = fopen(param_1,param_2);\n  pFVar4 = __stream;\n  if ((__stream != (FILE *)0x0) && (uVar1 = fileno(__stream), uVar1 < 3)) {\n    iVar2 = dup_safer(uVar1);\n    if (iVar2 < 0) {\n      piVar5 = __errno_location();\n      pFVar4 = (FILE *)0x0;\n      iVar2 = *piVar5;\n      rpl_fclose(__stream);\n      *piVar5 = iVar2;\n    }\n    else {\n      iVar3 = rpl_fclose(__stream);\n      if ((iVar3 == 0) && (pFVar4 = fdopen(iVar2,param_2), pFVar4 != (FILE *)0x0)) {\n        return pFVar4;\n      }\n      piVar5 = __errno_location();\n      iVar3 = *piVar5;\n      close(iVar2);\n      *piVar5 = iVar3;\n      pFVar4 = (FILE *)0x0;\n    }\n  }\n  return pFVar4;\n}\n\n", 
    "00106fe0": "\nvoid quotearg_custom_mem(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4\n                        )\n\n{\n  quotearg_n_custom_mem(0,param_1,param_2,param_3,param_4);\n  return;\n}\n\n", 
    "00104ce0": "\nvoid freebuffer(long param_1)\n\n{\n  free(*(void **)(param_1 + 0x10));\n  return;\n}\n\n", 
    "00106770": "\nundefined1 *\nquotearg_n_options(int param_1,undefined8 param_2,undefined8 param_3,undefined4 *param_4)\n\n{\n  long lVar1;\n  int iVar2;\n  uint uVar3;\n  undefined4 uVar4;\n  ulong uVar5;\n  int *piVar6;\n  undefined1 (*pauVar7) [16];\n  ulong uVar8;\n  undefined1 *__ptr;\n  \n  piVar6 = __errno_location();\n  iVar2 = *piVar6;\n  if (param_1 < 0) {\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  pauVar7 = (undefined1 (*) [16])slotvec;\n  if (nslots <= param_1) {\n    if (param_1 == 0x7fffffff) {\n                    /* WARNING: Subroutine does not return */\n      xalloc_die();\n    }\n    if (slotvec == slotvec0) {\n      pauVar7 = (undefined1 (*) [16])xrealloc(0);\n      slotvec = (undefined *)pauVar7;\n      *pauVar7 = slotvec0;\n    }\n    else {\n      pauVar7 = (undefined1 (*) [16])xrealloc(slotvec);\n      slotvec = (undefined *)pauVar7;\n    }\n    memset(pauVar7[nslots],0,(long)((param_1 + 1) - nslots) << 4);\n    nslots = param_1 + 1;\n  }\n  uVar3 = param_4[1];\n  pauVar7 = pauVar7[param_1];\n  uVar5 = *(ulong *)*pauVar7;\n  __ptr = *(undefined1 **)(*pauVar7 + 8);\n  uVar8 = quotearg_buffer_restyled\n                    (__ptr,uVar5,param_2,param_3,*param_4,uVar3 | 1,param_4 + 2,\n                     *(undefined8 *)(param_4 + 10),*(undefined8 *)(param_4 + 0xc));\n  if (uVar5 <= uVar8) {\n    lVar1 = uVar8 + 1;\n    *(long *)*pauVar7 = lVar1;\n    if (__ptr != slot0) {\n      free(__ptr);\n    }\n    __ptr = (undefined1 *)xcharalloc(lVar1);\n    uVar4 = *param_4;\n    *(undefined1 **)(*pauVar7 + 8) = __ptr;\n    quotearg_buffer_restyled\n              (__ptr,lVar1,param_2,param_3,uVar4,uVar3 | 1,param_4 + 2,*(undefined8 *)(param_4 + 10)\n               ,*(undefined8 *)(param_4 + 0xc));\n  }\n  *piVar6 = iVar2;\n  return __ptr;\n}\n\n", 
    "001026b0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fseeko(FILE *__stream,__off_t __off,int __whence)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_fseeko_0010df70)();\n  return iVar1;\n}\n\n", 
    "00107060": "\nundefined8\nversion_etc_arn(FILE *param_1,long param_2,undefined8 param_3,undefined8 param_4,undefined8 *param_5\n               ,undefined8 param_6)\n\n{\n  undefined8 uVar1;\n  char *pcVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  undefined8 uVar5;\n  undefined8 uVar6;\n  undefined8 local_60;\n  undefined8 local_58;\n  undefined8 local_50;\n  undefined8 local_48;\n  \n  if (param_2 == 0) {\n    __fprintf_chk(param_1,1,\"%s %s\\n\",param_3,param_4);\n  }\n  else {\n    __fprintf_chk(param_1,1,\"%s (%s) %s\\n\",param_2,param_3,param_4);\n  }\n  uVar1 = dcgettext(0,&DAT_0010a55b,5);\n  __fprintf_chk(param_1,1,\"Copyright %s %d Free Software Foundation, Inc.\",uVar1,0x7e2);\n  pcVar2 = (char *)dcgettext(0,\n                             \"\\nLicense GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>.\\nThis is free software: you are free to change and redistribute it.\\nThere is NO WARRANTY, to the extent permitted by law.\\n\\n\"\n                             ,5);\n  fputs_unlocked(pcVar2,param_1);\n  switch(param_6) {\n  case 0:\n                    /* WARNING: Subroutine does not return */\n    abort();\n  case 1:\n    uVar1 = *param_5;\n    uVar4 = dcgettext(0,\"Written by %s.\\n\",5);\n    uVar1 = __fprintf_chk(param_1,1,uVar4,uVar1);\n    return uVar1;\n  case 2:\n    uVar1 = param_5[1];\n    uVar4 = *param_5;\n    uVar5 = dcgettext(0,\"Written by %s and %s.\\n\",5);\n    uVar1 = __fprintf_chk(param_1,1,uVar5,uVar4,uVar1);\n    return uVar1;\n  case 3:\n    uVar1 = param_5[2];\n    uVar4 = param_5[1];\n    uVar5 = *param_5;\n    uVar6 = dcgettext(0,\"Written by %s, %s, and %s.\\n\",5);\n    uVar1 = __fprintf_chk(param_1,1,uVar6,uVar5,uVar4,uVar1);\n    return uVar1;\n  case 4:\n    uVar1 = param_5[3];\n    uVar4 = param_5[2];\n    uVar5 = param_5[1];\n    uVar6 = *param_5;\n    uVar3 = dcgettext(0,\"Written by %s, %s, %s,\\nand %s.\\n\",5);\n    goto LAB_00107329;\n  case 5:\n    uVar1 = param_5[3];\n    uVar4 = param_5[2];\n    uVar5 = param_5[1];\n    uVar6 = *param_5;\n    uVar3 = dcgettext(0,\"Written by %s, %s, %s,\\n%s, and %s.\\n\",5);\nLAB_00107329:\n    __fprintf_chk(param_1,1,uVar3,uVar6,uVar5,uVar4);\n    return uVar1;\n  case 6:\n    local_58 = param_5[5];\n    local_60 = param_5[4];\n    uVar1 = param_5[3];\n    uVar4 = param_5[2];\n    uVar5 = param_5[1];\n    uVar6 = *param_5;\n    uVar3 = dcgettext(0,\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\",5);\n    goto LAB_001073cb;\n  case 7:\n    local_58 = param_5[5];\n    local_60 = param_5[4];\n    uVar1 = param_5[3];\n    uVar4 = param_5[2];\n    uVar5 = param_5[1];\n    uVar6 = *param_5;\n    uVar3 = dcgettext(0,\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\",5);\nLAB_001073cb:\n    uVar1 = __fprintf_chk(param_1,1,uVar3,uVar6,uVar5,uVar4,uVar1,local_60,local_58);\n    return uVar1;\n  case 8:\n    local_48 = param_5[7];\n    local_50 = param_5[6];\n    local_58 = param_5[5];\n    local_60 = param_5[4];\n    uVar1 = param_5[3];\n    uVar4 = param_5[2];\n    uVar5 = param_5[1];\n    uVar6 = *param_5;\n    uVar3 = dcgettext(0,\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\",5);\n    goto LAB_0010717d;\n  case 9:\n    local_48 = param_5[7];\n    pcVar2 = \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\";\n    local_50 = param_5[6];\n    local_58 = param_5[5];\n    local_60 = param_5[4];\n    uVar1 = param_5[3];\n    uVar4 = param_5[2];\n    uVar5 = param_5[1];\n    uVar6 = *param_5;\n    break;\n  default:\n    local_48 = param_5[7];\n    pcVar2 = \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\";\n    local_50 = param_5[6];\n    local_58 = param_5[5];\n    local_60 = param_5[4];\n    uVar1 = param_5[3];\n    uVar4 = param_5[2];\n    uVar5 = param_5[1];\n    uVar6 = *param_5;\n  }\n  uVar3 = dcgettext(0,pcVar2,5);\nLAB_0010717d:\n  uVar1 = __fprintf_chk(param_1,1,uVar3,uVar6,uVar5,uVar4,uVar1,local_60,local_58,local_50,local_48)\n  ;\n  return uVar1;\n}\n\n", 
    "00108270": "\nulong c_iscntrl(uint param_1)\n\n{\n  ulong in_RAX;\n  \n  if ((int)param_1 < 0x20) {\n    return (ulong)(~param_1 >> 0x1f);\n  }\n  return in_RAX & 0xffffffffffffff00 | (ulong)(param_1 == 0x7f);\n}\n\n", 
    "001049b0": "\nvoid close_stdout(void)\n\n{\n  int iVar1;\n  int *piVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  \n  iVar1 = close_stream(stdout);\n  if (iVar1 != 0) {\n    piVar2 = __errno_location();\n    if ((ignore_EPIPE == '\\0') || (*piVar2 != 0x20)) {\n      uVar3 = dcgettext(0,\"write error\",5);\n      if (file_name != 0) {\n        uVar4 = quotearg_colon();\n                    /* WARNING: Subroutine does not return */\n        error(0,*piVar2,\"%s: %s\",uVar4,uVar3);\n      }\n                    /* WARNING: Subroutine does not return */\n      error(0,*piVar2,\"%s\",uVar3);\n    }\n  }\n  iVar1 = close_stream(stderr);\n  if (iVar1 == 0) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  _exit(exit_failure);\n}\n\n", 
    "001076c0": "\nvoid xnmalloc(ulong param_1,ulong param_2)\n\n{\n  if ((-1 < SUB168(ZEXT816(param_1) * ZEXT816(param_2),0)) &&\n     (SUB168(ZEXT816(param_1) * ZEXT816(param_2) >> 0x40,0) == 0)) {\n    xmalloc();\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  xalloc_die();\n}\n\n", 
    "0010f190": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nFILE * fopen(char *__filename,char *__modes)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fopen@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010f070": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t __ctype_get_mb_cur_max(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __ctype_get_mb_cur_max@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00104e70": "\nundefined8 strcaseeq8(long param_1,undefined8 param_2,byte param_3)\n\n{\n  char cVar1;\n  byte bVar2;\n  undefined8 uVar3;\n  \n  cVar1 = c_isupper((int)(char)param_3);\n  bVar2 = *(byte *)(param_1 + 8);\n  if (cVar1 != '\\0') {\n    bVar2 = bVar2 & 0xdf;\n  }\n  if (param_3 != bVar2) {\n    return 0;\n  }\n  if (param_3 == 0) {\n    return 1;\n  }\n  uVar3 = strcaseeq9(param_1,param_2);\n  return uVar3;\n}\n\n", 
    "001081f0": "\nulong c_isalnum(int param_1)\n\n{\n  ulong in_RAX;\n  ulong uVar1;\n  \n  if (param_1 < 0x5b) {\n    uVar1 = 1;\n    if (param_1 < 0x41) {\n      return (ulong)(param_1 - 0x30U < 10);\n    }\n  }\n  else {\n    uVar1 = in_RAX & 0xffffffffffffff00 | (ulong)(param_1 - 0x61U < 0x1a);\n  }\n  return uVar1;\n}\n\n", 
    "0010f198": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nulong strtoul(char *__nptr,char **__endptr,int __base)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strtoul@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00102720": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint mbsinit(mbstate_t *__ps)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_mbsinit_0010dfa8)();\n  return iVar1;\n}\n\n", 
    "0010f078": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t strlen(char *__s)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strlen@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00102600": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fflush(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_fflush_0010df18)();\n  return iVar1;\n}\n\n", 
    "00107610": "\nvoid emit_bug_reporting_address(void)\n\n{\n  FILE *__stream;\n  undefined8 uVar1;\n  char *__s;\n  \n  uVar1 = dcgettext(0,\"\\nReport bugs to: %s\\n\",5);\n  __printf_chk(1,uVar1,\"bug-coreutils@gnu.org\");\n  uVar1 = dcgettext(0,\"%s home page: <%s>\\n\",5);\n  __printf_chk(1,uVar1,\"GNU coreutils\",\"https://www.gnu.org/software/coreutils/\");\n  __stream = stdout;\n  __s = (char *)dcgettext(0,\"General help using GNU software: <https://www.gnu.org/gethelp/>\\n\",5);\n  fputs_unlocked(__s,__stream);\n  return;\n}\n\n", 
    "00104cd0": "\nvoid readlinebuffer(undefined8 param_1,undefined8 param_2)\n\n{\n  readlinebuffer_delim(param_1,param_2,10);\n  return;\n}\n\n", 
    "00104bb0": "\nlong * readlinebuffer_delim(long *param_1,FILE *param_2,uint param_3)\n\n{\n  long lVar1;\n  int iVar2;\n  uint uVar3;\n  char *pcVar4;\n  char *pcVar5;\n  char cVar6;\n  char *pcVar7;\n  uint uVar8;\n  \n  cVar6 = (char)param_3;\n  pcVar4 = (char *)param_1[2];\n  pcVar7 = pcVar4 + *param_1;\n  iVar2 = feof_unlocked(param_2);\n  pcVar5 = pcVar4;\n  if (iVar2 != 0) {\n    return (long *)0x0;\n  }\n  do {\n    uVar3 = getc_unlocked(param_2);\n    if (uVar3 == 0xffffffff) {\n      if (pcVar4 == pcVar5) {\n        return (long *)0x0;\n      }\n      iVar2 = ferror_unlocked(param_2);\n      if (iVar2 != 0) {\n        return (long *)0x0;\n      }\n      if (pcVar5[-1] == cVar6) goto LAB_00104ca4;\n      if (pcVar5 != pcVar7) {\n        *pcVar5 = cVar6;\n        pcVar5 = pcVar5 + 1;\n        goto LAB_00104ca4;\n      }\n      uVar3 = (int)cVar6;\n      uVar8 = param_3 & 0xff;\nLAB_00104c4c:\n      lVar1 = *param_1;\n      pcVar4 = (char *)x2realloc(pcVar4,param_1);\n      pcVar5 = pcVar4 + lVar1;\n      param_1[2] = (long)pcVar4;\n      pcVar7 = pcVar4 + *param_1;\n      uVar8 = uVar8 & 0xff;\n    }\n    else {\n      uVar8 = uVar3;\n      if (pcVar5 == pcVar7) goto LAB_00104c4c;\n    }\n    *pcVar5 = (char)uVar8;\n    pcVar5 = pcVar5 + 1;\n    if ((int)cVar6 == uVar3) {\nLAB_00104ca4:\n      param_1[1] = (long)pcVar5 - (long)pcVar4;\n      return param_1;\n    }\n  } while( true );\n}\n\n", 
    "00108380": "\nint c_tolower(int param_1)\n\n{\n  if (param_1 - 0x41U < 0x1a) {\n    param_1 = param_1 + 0x20;\n  }\n  return param_1;\n}\n\n", 
    "001026a0": "\nvoid error(void)\n\n{\n  (*(code *)PTR_error_0010df68)();\n  return;\n}\n\n", 
    "001049a0": "\nvoid close_stdout_set_ignore_EPIPE(undefined param_1)\n\n{\n  ignore_EPIPE = param_1;\n  return;\n}\n\n", 
    "00104d40": "\nvoid set_program_name(char *param_1)\n\n{\n  char *pcVar1;\n  long lVar2;\n  ulong uVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  bool bVar6;\n  bool bVar7;\n  byte bVar8;\n  \n  bVar8 = 0;\n  if (param_1 == (char *)0x0) {\n    fwrite(\"A NULL argv[0] was passed through an exec system call.\\n\",1,0x37,stderr);\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  pcVar1 = strrchr(param_1,0x2f);\n  if (pcVar1 != (char *)0x0) {\n    program_name = pcVar1 + 1;\n    uVar3 = (long)program_name - (long)param_1;\n    bVar6 = uVar3 < 6;\n    bVar7 = uVar3 == 6;\n    if (6 < (long)uVar3) {\n      lVar2 = 7;\n      pbVar4 = (byte *)(pcVar1 + -6);\n      pbVar5 = (byte *)\"/.libs/\";\n      do {\n        if (lVar2 == 0) break;\n        lVar2 = lVar2 + -1;\n        bVar6 = *pbVar4 < *pbVar5;\n        bVar7 = *pbVar4 == *pbVar5;\n        pbVar4 = pbVar4 + (ulong)bVar8 * -2 + 1;\n        pbVar5 = pbVar5 + (ulong)bVar8 * -2 + 1;\n      } while (bVar7);\n      if ((!bVar6 && !bVar7) == bVar6) {\n        if (((pcVar1[1] != 'l') || (pcVar1[2] != 't')) || (pcVar1[3] != '-')) {\n          program_invocation_name = program_name;\n          return;\n        }\n        param_1 = pcVar1 + 4;\n        program_invocation_short_name = param_1;\n      }\n    }\n  }\n  program_name = param_1;\n  program_invocation_name = param_1;\n  return;\n}\n\n", 
    "0010f080": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __stack_chk_fail(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __stack_chk_fail@@GLIBC_2.4 */\n  halt_baddata();\n}\n\n", 
    "0010f088": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid getopt_long(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* getopt_long@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00102710": "\nvoid __fprintf_chk(void)\n\n{\n  (*(code *)PTR___fprintf_chk_0010dfa0)();\n  return;\n}\n\n", 
    "00106950": "\nundefined4 get_quoting_style(undefined1 *param_1)\n\n{\n  if ((undefined4 *)param_1 == (undefined4 *)0x0) {\n    param_1 = default_quoting_options;\n  }\n  return *(undefined4 *)param_1;\n}\n\n", 
    "00102590": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint ferror_unlocked(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_ferror_unlocked_0010dee0)();\n  return iVar1;\n}\n\n", 
    "00102470": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fclose(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_fclose_0010de50)();\n  return iVar1;\n}\n\n", 
    "00107000": "\nvoid quote_n_mem(void)\n\n{\n  quotearg_n_options();\n  return;\n}\n\n", 
    "001078a0": "\nvoid xstrdup(char *param_1)\n\n{\n  size_t sVar1;\n  \n  sVar1 = strlen(param_1);\n  xmemdup(param_1,sVar1 + 1);\n  return;\n}\n\n", 
    "0010f050": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid textdomain(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* textdomain@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001069f0": "\nvoid set_custom_quoting(undefined1 *param_1,long param_2,long param_3)\n\n{\n  if ((undefined4 *)param_1 == (undefined4 *)0x0) {\n    param_1 = default_quoting_options;\n  }\n  *(undefined4 *)param_1 = 10;\n  if ((param_2 != 0) && (param_3 != 0)) {\n    *(long *)((long)param_1 + 0x28) = param_2;\n    *(long *)((long)param_1 + 0x30) = param_3;\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "001023f0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid abort(void)\n\n{\n  (*(code *)PTR_abort_0010de10)();\n  return;\n}\n\n", 
    "0010f170": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * setlocale(int __category,char *__locale)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* setlocale@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00106a30": "\nvoid quotearg_buffer(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n                    undefined1 *param_5)\n\n{\n  int iVar1;\n  int *piVar2;\n  \n  if ((undefined4 *)param_5 == (undefined4 *)0x0) {\n    param_5 = default_quoting_options;\n  }\n  piVar2 = __errno_location();\n  iVar1 = *piVar2;\n  quotearg_buffer_restyled\n            (param_1,param_2,param_3,param_4,*(undefined4 *)param_5,\n             *(undefined4 *)((long)param_5 + 4),(undefined4 *)((long)param_5 + 8),\n             *(undefined8 *)((long)param_5 + 0x28),*(undefined8 *)((long)param_5 + 0x30));\n  *piVar2 = iVar1;\n  return;\n}\n\n", 
    "001082b0": "\nbool c_islower(int param_1)\n\n{\n  return param_1 - 0x61U < 0x1a;\n}\n\n", 
    "0010f058": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fclose(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fclose@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00106c70": "\nvoid quotearg_n_mem(void)\n\n{\n  quotearg_n_options();\n  return;\n}\n\n", 
    "00107e80": "\nint rpl_fclose(FILE *param_1)\n\n{\n  int iVar1;\n  int iVar2;\n  int *piVar3;\n  __off_t _Var4;\n  \n  iVar1 = fileno(param_1);\n  if (-1 < iVar1) {\n    iVar1 = __freading();\n    if (iVar1 != 0) {\n      iVar1 = fileno(param_1);\n      _Var4 = lseek(iVar1,0,1);\n      if (_Var4 == -1) goto LAB_00107eef;\n    }\n    iVar1 = rpl_fflush(param_1);\n    if (iVar1 != 0) {\n      piVar3 = __errno_location();\n      iVar1 = *piVar3;\n      iVar2 = fclose(param_1);\n      if (iVar1 != 0) {\n        *piVar3 = iVar1;\n        iVar2 = -1;\n      }\n      return iVar2;\n    }\n  }\nLAB_00107eef:\n  iVar1 = fclose(param_1);\n  return iVar1;\n}\n\n", 
    "0010f178": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __printf_chk(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __printf_chk@@GLIBC_2.3.4 */\n  halt_baddata();\n}\n\n", 
    "00102580": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fputs_unlocked(char *__s,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_fputs_unlocked_0010ded8)();\n  return iVar1;\n}\n\n", 
    "00102460": "\nvoid textdomain(void)\n\n{\n  (*(code *)PTR_textdomain_0010de48)();\n  return;\n}\n\n", 
    "00108320": "\nbool c_isspace(int param_1)\n\n{\n  if (param_1 < 0xe) {\n    return 8 < param_1;\n  }\n  return param_1 == 0x20;\n}\n\n", 
    "00104e00": "\nint * quoting_options_from_style(int *param_1,int param_2)\n\n{\n  if (param_2 != 10) {\n    *param_1 = param_2;\n    param_1[1] = 0;\n    *(undefined8 *)(param_1 + 2) = 0;\n    *(undefined8 *)(param_1 + 4) = 0;\n    *(undefined8 *)(param_1 + 6) = 0;\n    *(undefined8 *)(param_1 + 8) = 0;\n    *(undefined8 *)(param_1 + 10) = 0;\n    *(undefined8 *)(param_1 + 0xc) = 0;\n    return param_1;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "0010f180": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid error(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* error@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001023e0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid free(void *__ptr)\n\n{\n  (*(code *)PTR_free_0010de08)();\n  return;\n}\n\n", 
    "001082a0": "\nbool c_isgraph(int param_1)\n\n{\n  return param_1 - 0x21U < 0x5e;\n}\n\n", 
    "0010f060": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid bindtextdomain(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* bindtextdomain@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001083c0": "\nint c_strcasecmp(undefined *param_1,undefined *param_2)\n\n{\n  byte bVar1;\n  byte bVar2;\n  int iVar3;\n  \n  iVar3 = 0;\n  if (param_1 != param_2) {\n    do {\n      bVar1 = c_tolower(*param_1);\n      bVar2 = c_tolower(*param_2);\n      if (bVar1 == 0) break;\n      param_1 = param_1 + 1;\n      param_2 = param_2 + 1;\n    } while (bVar1 == bVar2);\n    iVar3 = (uint)bVar1 - (uint)bVar2;\n  }\n  return iVar3;\n}\n\n", 
    "00106d80": "\nvoid quotearg_style_mem(undefined4 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  quotearg_n_style_mem(0,param_1,param_2,param_3);\n  return;\n}\n\n", 
    "00107900": "\nvoid collate_error(undefined4 param_1)\n\n{\n  undefined8 uVar1;\n  \n  uVar1 = dcgettext(0,\"string comparison failed\",5);\n                    /* WARNING: Subroutine does not return */\n  error(0,param_1,uVar1);\n}\n\n", 
    "0010f188": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fseeko(FILE *__stream,__off_t __off,int __whence)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fseeko@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010f068": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid dcgettext(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* dcgettext@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00107700": "\nvoid * xrealloc(void *param_1,size_t param_2)\n\n{\n  void *pvVar1;\n  \n  if ((param_2 == 0) && (param_1 != (void *)0x0)) {\n    free(param_1);\n    return (void *)0x0;\n  }\n  pvVar1 = realloc(param_1,param_2);\n  if ((pvVar1 == (void *)0x0) && (param_2 != 0)) {\n                    /* WARNING: Subroutine does not return */\n    xalloc_die();\n  }\n  return pvVar1;\n}\n\n", 
    "0010f0e0": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint memcmp(void *__s1,void *__s2,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* memcmp@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00102490": "\nvoid dcgettext(void)\n\n{\n  (*(code *)PTR_dcgettext_0010de60)();\n  return;\n}\n\n", 
    "00106970": "\nvoid set_quoting_style(undefined1 *param_1,undefined4 param_2)\n\n{\n  if ((undefined4 *)param_1 == (undefined4 *)0x0) {\n    param_1 = default_quoting_options;\n  }\n  *(undefined4 *)param_1 = param_2;\n  return;\n}\n\n", 
    "0010f0e8": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fputs_unlocked(char *__s,FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fputs_unlocked@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00107020": "\nvoid quote_n(undefined8 param_1,undefined8 param_2)\n\n{\n  quote_n_mem(param_1,param_2,0xffffffffffffffff);\n  return;\n}\n\n", 
    "00108350": "\nulong c_isxdigit(int param_1)\n\n{\n  ulong uVar1;\n  \n  if (param_1 - 0x30U < 0x37) {\n    uVar1 = 1L << ((byte)(param_1 - 0x30U) & 0x3f);\n    return uVar1 & 0xffffffffffffff00 | (ulong)((uVar1 & 0x7e0000007e03ff) != 0);\n  }\n  return 0;\n}\n\n", 
    "00108590": "\nundefined4 memcoll(void *param_1,size_t param_2,void *param_3,size_t param_4)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  undefined uVar3;\n  undefined uVar4;\n  int iVar5;\n  undefined4 uVar6;\n  int *piVar7;\n  \n  if ((param_2 == param_4) && (iVar5 = memcmp(param_1,param_3,param_2), iVar5 == 0)) {\n    piVar7 = __errno_location();\n    *piVar7 = 0;\n    return 0;\n  }\n  puVar1 = (undefined *)((long)param_1 + param_2);\n  puVar2 = (undefined *)((long)param_3 + param_4);\n  uVar3 = *puVar1;\n  uVar4 = *puVar2;\n  *puVar1 = 0;\n  *puVar2 = 0;\n  uVar6 = strcoll_loop(param_1,param_2 + 1,param_3,param_4 + 1);\n  *puVar1 = uVar3;\n  *puVar2 = uVar4;\n  return uVar6;\n}\n\n", 
    "00103b00": "\nvoid prfields(long param_1,ulong param_2,ulong param_3)\n\n{\n  int iVar1;\n  ulong uVar2;\n  ulong uVar3;\n  ulong uVar4;\n  \n  if (autoformat == '\\0') {\n    param_3 = *(ulong *)(param_1 + 0x18);\n  }\n  iVar1 = tab;\n  if (tab < 0) {\n    iVar1 = 0x20;\n  }\n  uVar4 = param_2;\n  if (param_3 <= param_2) {\n    uVar4 = param_3;\n  }\n  uVar2 = 0;\n  if (uVar4 != 0) {\n    do {\n      putchar_unlocked((int)(char)iVar1);\n      uVar3 = uVar2 + 1;\n      prfield_isra_0(uVar2,*(undefined8 *)(param_1 + 0x18),param_1 + 0x28);\n      uVar2 = uVar3;\n    } while (uVar3 != uVar4);\n  }\n  param_2 = param_2 + 1;\n  if (param_2 < param_3) {\n    do {\n      putchar_unlocked((int)(char)iVar1);\n      uVar4 = param_2 + 1;\n      prfield_isra_0(param_2,*(undefined8 *)(param_1 + 0x18),param_1 + 0x28);\n      param_2 = uVar4;\n    } while (param_3 != uVar4);\n  }\n  return;\n}\n\n", 
    "0010f150": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __freading(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __freading@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001078c0": "\nvoid xalloc_die(void)\n\n{\n  undefined8 uVar1;\n  \n  uVar1 = dcgettext(0,\"memory exhausted\",5);\n                    /* WARNING: Subroutine does not return */\n  error(exit_failure,0,\"%s\",uVar1);\n}\n\n", 
    "0010f030": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid _exit(int __status)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* _exit@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001032c0": "\nvoid freeline(long param_1)\n\n{\n  if (param_1 != 0) {\n    free(*(void **)(param_1 + 0x28));\n    *(undefined8 *)(param_1 + 0x28) = 0;\n    free(*(void **)(param_1 + 0x10));\n    *(undefined8 *)(param_1 + 0x10) = 0;\n    return;\n  }\n  return;\n}\n\n", 
    "001033e0": "\nvoid add_field_list(char *param_1)\n\n{\n  char *__s;\n  char *pcVar1;\n  long in_FS_OFFSET;\n  undefined4 local_3c;\n  undefined8 local_38;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  pcVar1 = strpbrk(param_1,\", \\t\");\n  while (pcVar1 != (char *)0x0) {\n    *pcVar1 = '\\0';\n    __s = pcVar1 + 1;\n    decode_field_spec(param_1,&local_3c,&local_38);\n    add_field(local_3c,local_38);\n    pcVar1 = strpbrk(__s,\", \\t\");\n    param_1 = __s;\n  }\n  decode_field_spec(param_1,&local_3c,&local_38);\n  add_field(local_3c,local_38);\n  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n", 
    "0010f158": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t fwrite_unlocked(void *__ptr,size_t __size,size_t __n,FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fwrite_unlocked@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001082d0": "\nulong c_ispunct(int param_1)\n\n{\n  ulong in_RAX;\n  \n  if (0x60 < param_1) {\n    return in_RAX & 0xffffffffffffff00 | (ulong)(param_1 - 0x7bU < 4);\n  }\n  if (param_1 < 0x5b) {\n    if (param_1 < 0x30) {\n      return in_RAX & 0xffffffffffffff00 | (ulong)(0x20 < param_1);\n    }\n    return in_RAX & 0xffffffffffffff00 | (ulong)(param_1 - 0x3aU < 7);\n  }\n  return 1;\n}\n\n", 
    "0010f038": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __fpending(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __fpending@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00106c90": "\nvoid quotearg_mem(undefined8 param_1,undefined8 param_2)\n\n{\n  quotearg_n_mem(0,param_1,param_2);\n  return;\n}\n\n", 
    "00107810": "\nvoid xzalloc(size_t param_1)\n\n{\n  void *__s;\n  \n  __s = (void *)xmalloc();\n  memset(__s,0,param_1);\n  return;\n}\n\n", 
    "00102000": "\nint _init(EVP_PKEY_CTX *ctx)\n\n{\n  undefined *puVar1;\n  \n  puVar1 = PTR___gmon_start___0010dfd8;\n  if (PTR___gmon_start___0010dfd8 != (undefined *)0x0) {\n    puVar1 = (undefined *)(*(code *)PTR___gmon_start___0010dfd8)();\n  }\n  return (int)puVar1;\n}\n\n", 
    "00104ed0": "\nundefined8 strcaseeq7(long param_1,undefined8 param_2,byte param_3,char param_4)\n\n{\n  char cVar1;\n  byte bVar2;\n  undefined8 uVar3;\n  \n  cVar1 = c_isupper((int)(char)param_3);\n  bVar2 = *(byte *)(param_1 + 7);\n  if (cVar1 != '\\0') {\n    bVar2 = bVar2 & 0xdf;\n  }\n  if (param_3 != bVar2) {\n    return 0;\n  }\n  if (param_3 == 0) {\n    return 1;\n  }\n  uVar3 = strcaseeq8(param_1,param_2,(int)param_4);\n  return uVar3;\n}\n\n", 
    "00102480": "\nvoid bindtextdomain(void)\n\n{\n  (*(code *)PTR_bindtextdomain_0010de58)();\n  return;\n}\n\n", 
    "00104ff0": "\nundefined8\nstrcaseeq5(long param_1,undefined8 param_2,byte param_3,char param_4,char param_5,char param_6)\n\n{\n  char cVar1;\n  byte bVar2;\n  undefined8 uVar3;\n  \n  cVar1 = c_isupper((int)(char)param_3);\n  bVar2 = *(byte *)(param_1 + 5);\n  if (cVar1 != '\\0') {\n    bVar2 = bVar2 & 0xdf;\n  }\n  if (param_3 != bVar2) {\n    return 0;\n  }\n  if (param_3 == 0) {\n    return 1;\n  }\n  uVar3 = strcaseeq6(param_1,param_2,(int)param_4,(int)param_5,(int)param_6);\n  return uVar3;\n}\n\n", 
    "0010f0f0": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint ferror_unlocked(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* ferror_unlocked@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00107010": "\nvoid quote_mem(undefined8 param_1,undefined8 param_2)\n\n{\n  quote_n_mem(0,param_1,param_2);\n  return;\n}\n\n", 
    "00108220": "\nbool c_isalpha(int param_1)\n\n{\n  if (param_1 < 0x5b) {\n    return 0x40 < param_1;\n  }\n  return param_1 - 0x61U < 0x1a;\n}\n\n", 
    "00107ac0": "\nuint bkm_scale_by_power(undefined8 param_1,uint param_2,int param_3)\n\n{\n  uint uVar1;\n  uint uVar2;\n  ulong uVar3;\n  \n  uVar3 = (ulong)param_2;\n  param_3 = param_3 + -1;\n  uVar2 = 0;\n  do {\n    uVar1 = bkm_scale(param_1,uVar3 & 0xffffffff);\n    param_3 = param_3 + -1;\n    uVar2 = uVar2 | uVar1;\n  } while (param_3 != -1);\n  return uVar2;\n}\n\n", 
    "00108340": "\nbool c_isupper(int param_1)\n\n{\n  return param_1 - 0x41U < 0x1a;\n}\n\n", 
    "0010f0f8": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * calloc(size_t __nmemb,size_t __size)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* calloc@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010f160": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * realloc(void *__ptr,size_t __size)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* realloc@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010f040": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint getc_unlocked(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* getc_unlocked@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001079d0": "\nundefined4 xmemcoll(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  undefined4 uVar1;\n  int *piVar2;\n  \n  uVar1 = memcoll();\n  piVar2 = __errno_location();\n  if (*piVar2 == 0) {\n    return uVar1;\n  }\n  collate_error(*piVar2,param_1,param_2,param_3,param_4);\n  return uVar1;\n}\n\n", 
    "001055b0": "\nulong quotearg_buffer_restyled\n                (undefined *param_1,ulong param_2,char *param_3,ulong param_4,int param_5,\n                uint param_6,long param_7,char *param_8,char *param_9)\n\n{\n  byte *__s1;\n  bool bVar1;\n  bool bVar2;\n  bool bVar3;\n  bool bVar4;\n  bool bVar5;\n  bool bVar6;\n  int iVar7;\n  size_t sVar8;\n  ushort **ppuVar9;\n  long lVar10;\n  char cVar11;\n  uint uVar12;\n  ulong uVar13;\n  byte bVar14;\n  ulong uVar15;\n  char *pcVar16;\n  ulong uVar17;\n  ulong uVar18;\n  ulong uVar19;\n  long in_FS_OFFSET;\n  bool bVar20;\n  bool bVar21;\n  bool bVar22;\n  bool bVar23;\n  bool bVar24;\n  size_t local_c8;\n  char *local_98;\n  ulong local_90;\n  char *local_78;\n  char *local_70;\n  bool local_64;\n  wint_t local_4c;\n  mbstate_t local_48;\n  long local_40;\n  \n  local_70 = param_8;\n  local_78 = param_9;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  sVar8 = __ctype_get_mb_cur_max();\n  uVar12 = param_6 & 2;\n  bVar20 = uVar12 != 0;\n  switch(param_5) {\n  case 0:\n    bVar6 = true;\n    bVar2 = false;\n    uVar18 = 0;\n    local_64 = false;\n    local_90 = 0;\n    bVar20 = false;\n    bVar1 = false;\n    local_c8 = 0;\n    local_98 = (char *)0x0;\n    break;\n  case 2:\n    if (uVar12 == 0) {\n      bVar1 = false;\nLAB_00105a37:\n      if (param_2 == 0) {\n        local_90 = 0;\n        bVar2 = false;\n        bVar6 = true;\n        local_64 = false;\n        goto LAB_00105a59;\n      }\n      bVar2 = false;\n      local_64 = false;\n      bVar6 = true;\n      uVar13 = 0;\n      local_90 = param_2;\n      goto LAB_00105ff6;\n    }\n    bVar2 = false;\n    uVar18 = 0;\n    bVar6 = true;\n    local_64 = false;\n    local_90 = 0;\n    bVar20 = true;\n    bVar1 = false;\n    local_c8 = 1;\n    local_98 = \"\\'\";\n    break;\n  case 3:\n    bVar1 = true;\n    goto LAB_001059af;\n  case 4:\n    if (uVar12 == 0) {\n      bVar1 = true;\n      goto LAB_00105a37;\n    }\n  case 1:\n    bVar1 = false;\nLAB_001059af:\n    bVar6 = true;\n    local_64 = false;\n    bVar20 = true;\n    local_90 = 0;\n    bVar2 = false;\n    uVar18 = 0;\n    param_5 = 2;\n    local_c8 = 1;\n    local_98 = \"\\'\";\n    break;\n  case 5:\n    if (uVar12 == 0) {\n      if (param_2 != 0) {\n        *param_1 = 0x22;\n      }\n      bVar6 = true;\n      local_64 = false;\n      local_90 = 0;\n      bVar2 = false;\n      bVar20 = false;\n      uVar18 = 1;\n      bVar1 = true;\n      local_c8 = 1;\n      local_98 = \"\\\"\";\n    }\n    else {\n      bVar2 = false;\n      uVar18 = 0;\n      bVar6 = true;\n      local_64 = false;\n      local_90 = 0;\n      bVar20 = true;\n      bVar1 = true;\n      local_c8 = 1;\n      local_98 = \"\\\"\";\n    }\n    break;\n  case 6:\n    bVar2 = false;\n    uVar18 = 0;\n    bVar6 = true;\n    local_64 = false;\n    param_5 = 5;\n    local_90 = 0;\n    bVar20 = true;\n    bVar1 = true;\n    local_c8 = 1;\n    local_98 = \"\\\"\";\n    break;\n  case 7:\n    bVar6 = true;\n    bVar2 = false;\n    uVar18 = 0;\n    local_64 = false;\n    local_90 = 0;\n    bVar20 = false;\n    bVar1 = true;\n    local_c8 = 0;\n    local_98 = (char *)0x0;\n    break;\n  case 8:\n  case 9:\n  case 10:\n    if (param_5 != 10) {\n      local_70 = (char *)gettext_quote(&DAT_00109e29,param_5);\n      local_78 = (char *)gettext_quote(&DAT_00109e19);\n    }\n    uVar18 = 0;\n    if (uVar12 == 0) {\n      cVar11 = *local_70;\n      while (cVar11 != '\\0') {\n        if (uVar18 < param_2) {\n          param_1[uVar18] = cVar11;\n        }\n        uVar18 = uVar18 + 1;\n        cVar11 = local_70[uVar18];\n      }\n    }\n    bVar2 = false;\n    local_c8 = strlen(local_78);\n    local_98 = local_78;\n    bVar6 = true;\n    local_64 = false;\n    local_90 = 0;\n    bVar1 = true;\n    break;\n  default:\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  do {\n    uVar13 = 0;\n    bVar4 = local_64;\nLAB_00105700:\n    bVar21 = param_4 != uVar13;\n    if (param_4 == 0xffffffffffffffff) {\n      bVar21 = param_3[uVar13] != '\\0';\n    }\n    bVar24 = bVar1;\n    if (bVar21) {\n      bVar23 = (bool)(param_5 != 2 & bVar1);\n      __s1 = (byte *)(param_3 + uVar13);\n      uVar17 = uVar13;\n      bVar3 = bVar2;\n      bVar5 = bVar23;\n      if (!bVar23) {\n        uVar15 = (ulong)*__s1;\n        switch(uVar15) {\n        case 0:\n          if (bVar1) goto switchD_00105f60_caseD_0;\n          bVar5 = false;\n          uVar15 = 0;\n          if ((param_6 & 1) != 0) goto code_r0x00105efb;\n          goto LAB_00105ceb;\n        default:\nswitchD_00105e10_caseD_1:\n          bVar22 = bVar1;\n          if (sVar8 != 1) {\n            local_48 = (mbstate_t)0x0;\n            if (param_4 == 0xffffffffffffffff) {\n              param_4 = strlen(param_3);\n            }\n            uVar17 = 0;\n            do {\n              uVar19 = uVar13 + uVar17;\n              lVar10 = rpl_mbrtowc(&local_4c,param_3 + uVar19,param_4 - uVar19,&local_48);\n              if (lVar10 == 0) break;\n              if (lVar10 == -1) {\n                bVar21 = false;\n                goto LAB_001061e8;\n              }\n              if (lVar10 == -2) goto joined_r0x001065fa;\n              if (((param_5 == 2) && (bVar20)) && (lVar10 != 1)) {\n                pcVar16 = param_3 + uVar19 + 1;\n                do {\n                  if (((byte)(*pcVar16 + 0xa5U) < 0x22) &&\n                     ((1L << (*pcVar16 + 0xa5U & 0x3f) & 0x20000002bU) != 0)) {\n                    param_5 = 2;\n                    goto LAB_00105bd0;\n                  }\n                  pcVar16 = pcVar16 + 1;\n                } while (param_3 + uVar19 + lVar10 != pcVar16);\n              }\n              iVar7 = iswprint(local_4c);\n              if (iVar7 == 0) {\n                bVar21 = false;\n              }\n              uVar17 = uVar17 + lVar10;\n              iVar7 = mbsinit(&local_48);\n            } while (iVar7 == 0);\n            bVar22 = (bool)((bVar21 ^ 1U) & bVar1);\n            goto LAB_001061e8;\n          }\n          ppuVar9 = __ctype_b_loc();\n          uVar17 = 1;\n          bVar22 = ((*ppuVar9)[uVar15] & 0x4000) == 0;\n          bVar21 = !bVar22;\n          bVar22 = (bool)(bVar22 & bVar1);\n          goto LAB_00105971;\n        case 7:\n          uVar15 = 7;\n          bVar14 = 0x61;\n          break;\n        case 8:\n          uVar15 = 8;\n          bVar14 = 0x62;\n          break;\n        case 9:\n          uVar15 = 9;\n          bVar14 = 0x74;\n          goto LAB_00105eb8;\n        case 10:\n          uVar15 = 10;\n          bVar14 = 0x6e;\n          goto LAB_00105eb8;\n        case 0xb:\n          uVar15 = 0xb;\n          bVar14 = 0x76;\n          break;\n        case 0xc:\n          uVar15 = 0xc;\n          bVar14 = 0x66;\n          break;\n        case 0xd:\n          uVar15 = 0xd;\n          bVar14 = 0x72;\nLAB_00105eb8:\n          bVar23 = (bool)(param_5 == 2 & bVar20);\n          if (bVar23) goto LAB_00105bc7;\n          break;\n        case 0x20:\n          uVar15 = 0x20;\n          goto LAB_00105bb4;\n        case 0x21:\n        case 0x22:\n        case 0x24:\n        case 0x26:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x3b:\n        case 0x3c:\n        case 0x3d:\n        case 0x3e:\n        case 0x5b:\n        case 0x5e:\n        case 0x60:\n        case 0x7c:\n          bVar21 = false;\nLAB_00105bb4:\n          bVar22 = param_5 == 2;\n          bVar23 = bVar21;\n          if ((!bVar20) || (!bVar22)) goto LAB_001058d8;\n          goto LAB_00105bc7;\n        case 0x23:\n        case 0x7e:\nLAB_00105bab:\n          bVar22 = param_5 == 2;\n          if (uVar13 == 0) goto LAB_00105bb4;\n          goto LAB_001058d5;\n        case 0x25:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x2f:\n        case 0x30:\n        case 0x31:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x41:\n        case 0x42:\n        case 0x43:\n        case 0x44:\n        case 0x45:\n        case 0x46:\n        case 0x47:\n        case 0x48:\n        case 0x49:\n        case 0x4a:\n        case 0x4b:\n        case 0x4c:\n        case 0x4d:\n        case 0x4e:\n        case 0x4f:\n        case 0x50:\n        case 0x51:\n        case 0x52:\n        case 0x53:\n        case 0x54:\n        case 0x55:\n        case 0x56:\n        case 0x57:\n        case 0x58:\n        case 0x59:\n        case 0x5a:\n        case 0x5d:\n        case 0x5f:\n        case 0x61:\n        case 0x62:\n        case 99:\n        case 100:\n        case 0x65:\n        case 0x66:\n        case 0x67:\n        case 0x68:\n        case 0x69:\n        case 0x6a:\n        case 0x6b:\n        case 0x6c:\n        case 0x6d:\n        case 0x6e:\n        case 0x6f:\n        case 0x70:\n        case 0x71:\n        case 0x72:\n        case 0x73:\n        case 0x74:\n        case 0x75:\n        case 0x76:\n        case 0x77:\n        case 0x78:\n        case 0x79:\n        case 0x7a:\n          goto switchD_00105e10_caseD_25;\n        case 0x27:\nswitchD_00105e10_caseD_27:\n          bVar4 = bVar21;\n          if (param_5 != 2) {\n            bVar22 = false;\n            uVar15 = 0x27;\n            bVar23 = bVar21;\n            goto LAB_001058d8;\n          }\n          if (!bVar20) {\n            if ((param_2 == 0) || (uVar13 = 0, uVar15 = param_2, local_90 != 0)) {\n              if (uVar18 < param_2) {\n                param_1[uVar18] = 0x27;\n              }\n              if (uVar18 + 1 < param_2) {\n                param_1[uVar18 + 1] = 0x5c;\n              }\n              uVar13 = param_2;\n              uVar15 = local_90;\n              if (uVar18 + 2 < param_2) {\n                param_1[uVar18 + 2] = 0x27;\n              }\n            }\n            bVar14 = 0x27;\n            uVar18 = uVar18 + 3;\n            param_2 = uVar13;\n            local_90 = uVar15;\n            bVar3 = false;\n            bVar22 = false;\n            goto joined_r0x001058fb;\n          }\n          goto LAB_00105bd0;\n        case 0x3f:\nswitchD_00105e10_caseD_3f:\n          if (param_5 != 2) {\n            if ((((param_5 == 5) && ((param_6 & 4) != 0)) && (uVar17 = uVar13 + 2, uVar17 < param_4)\n                ) && (param_3[uVar13 + 1] == '?')) {\n              uVar15 = (ulong)(byte)param_3[uVar17];\n              switch(param_3[uVar17]) {\n              case '!':\n              case '\\'':\n              case '(':\n              case ')':\n              case '-':\n              case '/':\n              case '<':\n              case '=':\n              case '>':\n                goto switchD_0010655e_caseD_21;\n              default:\n                break;\n              }\n            }\n            bVar22 = false;\n            uVar15 = 0x3f;\n            bVar23 = false;\n            goto LAB_001058d8;\n          }\n          if (!bVar20) {\n            bVar14 = 0x3f;\n            bVar22 = false;\n            bVar21 = false;\n            goto joined_r0x001058fb;\n          }\n          goto LAB_00105bd0;\n        case 0x5c:\n          if (param_5 != 2) goto switchD_00105808_caseD_5c;\n          if (!bVar20) {\nLAB_00105e48:\n            uVar13 = uVar13 + 1;\n            bVar21 = false;\n            bVar14 = 0x5c;\n            goto LAB_00105e60;\n          }\n          goto LAB_00105bd0;\n        case 0x7b:\n        case 0x7d:\nswitchD_00105e10_caseD_7b:\n          bVar23 = param_4 != 1;\n          if (param_4 == 0xffffffffffffffff) {\n            bVar23 = param_3[1] != '\\0';\n          }\n          bVar22 = param_5 == 2;\n          if (!bVar23) goto LAB_00105bab;\nLAB_001058d5:\n          bVar23 = false;\n          goto LAB_001058d8;\n        }\nLAB_00105ce0:\n        bVar5 = bVar23;\n        if (!bVar1) {\nLAB_00105ceb:\n          bVar14 = (byte)uVar15;\n          bVar23 = false;\n          bVar21 = false;\n          bVar22 = false;\n          if (!bVar20) goto LAB_001058f8;\n          goto LAB_00105820;\n        }\nLAB_00105d20:\n        bVar21 = false;\n        goto joined_r0x00105d31;\n      }\n      if (local_c8 != 0) {\n        if ((param_4 == 0xffffffffffffffff) && (1 < local_c8)) {\n          param_4 = strlen(param_3);\n        }\n        if ((param_4 < uVar13 + local_c8) || (iVar7 = memcmp(__s1,local_98,local_c8), iVar7 != 0))\n        goto LAB_00105f40;\n        if (!bVar20) {\n          uVar15 = (ulong)*__s1;\n          switch(uVar15) {\n          case 0:\n            goto switchD_00105808_caseD_0;\n          default:\n            goto switchD_00105e10_caseD_1;\n          case 7:\n            goto switchD_00105f60_caseD_7;\n          case 8:\n            goto switchD_00105f60_caseD_8;\n          case 9:\n            goto switchD_00105808_caseD_9;\n          case 10:\n            goto switchD_00105f60_caseD_a;\n          case 0xb:\n            goto switchD_00105f60_caseD_b;\n          case 0xc:\n            goto switchD_00105f60_caseD_c;\n          case 0xd:\n            goto switchD_00105f60_caseD_d;\n          case 0x20:\n            goto LAB_00105f89;\n          case 0x21:\n          case 0x22:\n          case 0x24:\n          case 0x26:\n          case 0x28:\n          case 0x29:\n          case 0x2a:\n          case 0x3b:\n          case 0x3c:\n          case 0x3d:\n          case 0x3e:\n          case 0x5b:\n          case 0x5e:\n          case 0x60:\n          case 0x7c:\n            goto switchD_00105808_caseD_21;\n          case 0x23:\n          case 0x7e:\n            goto LAB_00105f71;\n          case 0x25:\n          case 0x2b:\n          case 0x2c:\n          case 0x2d:\n          case 0x2e:\n          case 0x2f:\n          case 0x30:\n          case 0x31:\n          case 0x32:\n          case 0x33:\n          case 0x34:\n          case 0x35:\n          case 0x36:\n          case 0x37:\n          case 0x38:\n          case 0x39:\n          case 0x3a:\n          case 0x41:\n          case 0x42:\n          case 0x43:\n          case 0x44:\n          case 0x45:\n          case 0x46:\n          case 0x47:\n          case 0x48:\n          case 0x49:\n          case 0x4a:\n          case 0x4b:\n          case 0x4c:\n          case 0x4d:\n          case 0x4e:\n          case 0x4f:\n          case 0x50:\n          case 0x51:\n          case 0x52:\n          case 0x53:\n          case 0x54:\n          case 0x55:\n          case 0x56:\n          case 0x57:\n          case 0x58:\n          case 0x59:\n          case 0x5a:\n          case 0x5d:\n          case 0x5f:\n          case 0x61:\n          case 0x62:\n          case 99:\n          case 100:\n          case 0x65:\n          case 0x66:\n          case 0x67:\n          case 0x68:\n          case 0x69:\n          case 0x6a:\n          case 0x6b:\n          case 0x6c:\n          case 0x6d:\n          case 0x6e:\n          case 0x6f:\n          case 0x70:\n          case 0x71:\n          case 0x72:\n          case 0x73:\n          case 0x74:\n          case 0x75:\n          case 0x76:\n          case 0x77:\n          case 0x78:\n          case 0x79:\n          case 0x7a:\n            goto LAB_00105818;\n          case 0x27:\n            goto switchD_00105e10_caseD_27;\n          case 0x3f:\n            goto switchD_00105e10_caseD_3f;\n          case 0x5c:\n            goto switchD_00105808_caseD_5c;\n          case 0x7b:\n          case 0x7d:\n            goto switchD_00105e10_caseD_7b;\n          }\n        }\n        goto LAB_00105bde;\n      }\nLAB_00105f40:\n      uVar15 = (ulong)*__s1;\n      switch(uVar15) {\n      case 0:\nswitchD_00105f60_caseD_0:\n        if (!bVar20) {\n          bVar5 = false;\nswitchD_00105808_caseD_0:\n          bVar24 = param_5 == 2;\n          bVar3 = (bool)((bVar2 ^ 1U) & bVar24);\n          if (bVar3) {\n            if (uVar18 < param_2) {\n              param_1[uVar18] = 0x27;\n            }\n            if (uVar18 + 1 < param_2) {\n              param_1[uVar18 + 1] = 0x24;\n            }\n            if (uVar18 + 2 < param_2) {\n              param_1[uVar18 + 2] = 0x27;\n            }\n            uVar15 = uVar18 + 3;\n            bVar2 = bVar3;\n            if (param_2 <= uVar18 + 3) {\n              bVar14 = 0x30;\n              uVar18 = uVar18 + 4;\n              bVar22 = bVar3;\n              bVar21 = false;\n              goto joined_r0x001058fb;\n            }\nLAB_0010639b:\n            param_1[uVar15] = 0x5c;\n            uVar18 = uVar15;\n          }\n          else {\n            uVar15 = uVar18;\n            if (uVar18 < param_2) goto LAB_0010639b;\n          }\n          uVar19 = uVar18 + 1;\n          bVar22 = bVar21;\n          if (param_5 != 2) {\n            uVar15 = 0x30;\n            if ((uVar13 + 1 < param_4) && ((byte)(param_3[uVar13 + 1] - 0x30U) < 10)) {\n              if (uVar19 < param_2) {\n                param_1[uVar19] = 0x30;\n              }\n              if (uVar18 + 2 < param_2) {\n                param_1[uVar18 + 2] = 0x30;\n              }\n              uVar19 = uVar18 + 3;\n              uVar15 = 0x30;\n            }\n            goto LAB_001063d8;\n          }\n          bVar14 = 0x30;\n          uVar18 = uVar19;\n          bVar3 = bVar2;\n          bVar21 = false;\n          goto joined_r0x001058fb;\n        }\n        bVar24 = param_5 == 2;\n        goto LAB_00105bd0;\n      default:\n        bVar23 = false;\n        goto switchD_00105e10_caseD_1;\n      case 7:\nswitchD_00105f60_caseD_7:\n        bVar14 = 0x61;\n        break;\n      case 8:\nswitchD_00105f60_caseD_8:\n        bVar14 = 0x62;\n        break;\n      case 9:\n        bVar23 = false;\nswitchD_00105808_caseD_9:\n        uVar15 = 9;\n        bVar14 = 0x74;\n        goto LAB_00105ce0;\n      case 10:\nswitchD_00105f60_caseD_a:\n        bVar14 = 0x6e;\n        goto LAB_00105d20;\n      case 0xb:\nswitchD_00105f60_caseD_b:\n        bVar14 = 0x76;\n        goto LAB_00105d20;\n      case 0xc:\nswitchD_00105f60_caseD_c:\n        bVar14 = 0x66;\n        break;\n      case 0xd:\nswitchD_00105f60_caseD_d:\n        bVar14 = 0x72;\n        goto LAB_00105d20;\n      case 0x20:\n        bVar5 = false;\nLAB_00105f89:\n        uVar15 = 0x20;\n        goto LAB_00105818;\n      case 0x21:\n      case 0x22:\n      case 0x24:\n      case 0x26:\n      case 0x28:\n      case 0x29:\n      case 0x2a:\n      case 0x3b:\n      case 0x3c:\n      case 0x3d:\n      case 0x3e:\n      case 0x5b:\n      case 0x5e:\n      case 0x60:\n      case 0x7c:\n        bVar5 = false;\nswitchD_00105808_caseD_21:\n        bVar22 = false;\n        goto LAB_001058d5;\n      case 0x23:\n      case 0x7e:\n        bVar5 = false;\nLAB_00105f71:\n        if (uVar13 == 0) {\n          bVar22 = false;\n          goto LAB_001058d8;\n        }\n        bVar23 = false;\n        bVar22 = false;\n        goto LAB_00105820;\n      case 0x25:\n      case 0x2b:\n      case 0x2c:\n      case 0x2d:\n      case 0x2e:\n      case 0x2f:\n      case 0x30:\n      case 0x31:\n      case 0x32:\n      case 0x33:\n      case 0x34:\n      case 0x35:\n      case 0x36:\n      case 0x37:\n      case 0x38:\n      case 0x39:\n      case 0x3a:\n      case 0x41:\n      case 0x42:\n      case 0x43:\n      case 0x44:\n      case 0x45:\n      case 0x46:\n      case 0x47:\n      case 0x48:\n      case 0x49:\n      case 0x4a:\n      case 0x4b:\n      case 0x4c:\n      case 0x4d:\n      case 0x4e:\n      case 0x4f:\n      case 0x50:\n      case 0x51:\n      case 0x52:\n      case 0x53:\n      case 0x54:\n      case 0x55:\n      case 0x56:\n      case 0x57:\n      case 0x58:\n      case 0x59:\n      case 0x5a:\n      case 0x5d:\n      case 0x5f:\n      case 0x61:\n      case 0x62:\n      case 99:\n      case 100:\n      case 0x65:\n      case 0x66:\n      case 0x67:\n      case 0x68:\n      case 0x69:\n      case 0x6a:\n      case 0x6b:\n      case 0x6c:\n      case 0x6d:\n      case 0x6e:\n      case 0x6f:\n      case 0x70:\n      case 0x71:\n      case 0x72:\n      case 0x73:\n      case 0x74:\n      case 0x75:\n      case 0x76:\n      case 0x77:\n      case 0x78:\n      case 0x79:\n      case 0x7a:\n        bVar5 = false;\nLAB_00105818:\n        bVar22 = false;\n        goto LAB_00105820;\n      case 0x27:\n        bVar5 = false;\n        goto switchD_00105e10_caseD_27;\n      case 0x3f:\n        bVar5 = false;\n        goto switchD_00105e10_caseD_3f;\n      case 0x5c:\n        bVar23 = false;\nswitchD_00105808_caseD_5c:\n        if (((bool)(bVar1 & bVar20)) && (local_c8 != 0)) goto LAB_00105e48;\n        uVar15 = 0x5c;\n        bVar14 = 0x5c;\n        goto LAB_00105ce0;\n      case 0x7b:\n      case 0x7d:\n        bVar5 = false;\n        goto switchD_00105e10_caseD_7b;\n      }\n      if (bVar20) goto LAB_00105d40;\n      bVar21 = false;\n      goto LAB_00105896;\n    }\n    if ((uVar18 == 0) && ((bool)(bVar20 & param_5 == 2))) {\nLAB_00105bc7:\n      param_5 = 2;\nLAB_00105bd0:\n      if (bVar24) {\n        param_5 = 4;\n      }\nLAB_00105bde:\n      uVar13 = quotearg_buffer_restyled\n                         (param_1,param_2,param_3,param_4,param_5,param_6 & 0xfffffffd,0,local_70,\n                          local_78);\n      goto LAB_00105c18;\n    }\n    bVar21 = (bool)(param_5 == 2 & (bVar20 ^ 1U));\n    bVar20 = (bool)(bVar20 ^ 1U);\n    if ((!bVar21) || (bVar20 = bVar21, !bVar4)) {\nLAB_00106665:\n      uVar13 = uVar18;\n      if (((local_98 != (char *)0x0) && (bVar20)) && (cVar11 = *local_98, cVar11 != '\\0')) {\n        do {\n          if (uVar13 < param_2) {\n            param_1[uVar13] = cVar11;\n          }\n          uVar13 = uVar13 + 1;\n          cVar11 = local_98[uVar13 - uVar18];\n        } while (cVar11 != '\\0');\n      }\n      if (uVar13 < param_2) {\n        param_1[uVar13] = 0;\n      }\nLAB_00105c18:\n      if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n        return uVar13;\n      }\n                    /* WARNING: Subroutine does not return */\n      __stack_chk_fail();\n    }\n    if (bVar6) {\n      uVar13 = quotearg_buffer_restyled\n                         (param_1,local_90,param_3,param_4,5,param_6,param_7,local_70,local_78);\n      goto LAB_00105c18;\n    }\n    local_64 = param_2 == 0 && local_90 != 0;\n    uVar13 = local_90;\n    bVar20 = bVar4;\n    if (param_2 != 0 || local_90 == 0) goto LAB_00106665;\nLAB_00105ff6:\n    *param_1 = 0x27;\n    param_2 = local_90;\n    local_90 = uVar13;\nLAB_00105a59:\n    bVar20 = false;\n    uVar18 = 1;\n    param_5 = 2;\n    local_c8 = 1;\n    local_98 = \"\\'\";\n  } while( true );\ncode_r0x00105efb:\n  uVar13 = uVar13 + 1;\n  goto LAB_00105700;\nswitchD_0010655e_caseD_21:\n  if (!bVar20) {\n    if (uVar18 < param_2) {\n      param_1[uVar18] = 0x3f;\n    }\n    if (uVar18 + 1 < param_2) {\n      param_1[uVar18 + 1] = 0x22;\n    }\n    if (uVar18 + 2 < param_2) {\n      param_1[uVar18 + 2] = 0x22;\n    }\n    if (uVar18 + 3 < param_2) {\n      param_1[uVar18 + 3] = 0x3f;\n    }\n    uVar19 = uVar18 + 4;\n    bVar24 = false;\n    bVar22 = false;\nLAB_001063d8:\n    bVar14 = (byte)uVar15;\n    bVar23 = false;\n    bVar21 = false;\n    uVar13 = uVar17;\n    uVar18 = uVar19;\n    bVar3 = bVar2;\n    if ((bool)(bVar1 ^ 1U | bVar24)) goto joined_r0x001058fb;\n    goto LAB_00105820;\n  }\n  goto LAB_00105bde;\njoined_r0x001065fa:\n  while ((uVar19 < param_4 && (param_3[uVar19] != '\\0'))) {\n    uVar17 = uVar17 + 1;\n    uVar19 = uVar13 + uVar17;\n  }\n  bVar21 = false;\nLAB_001061e8:\n  if (1 < uVar17) {\nLAB_001061f2:\n    bVar24 = false;\n    uVar17 = uVar17 + uVar13;\n    uVar19 = uVar13;\n    do {\n      bVar14 = (byte)uVar15;\n      if (bVar22) {\n        bVar24 = param_5 == 2;\n        if (bVar20) goto LAB_00105bd0;\n        bVar24 = (bool)(bVar24 & (bVar3 ^ 1U));\n        if (bVar24) {\n          if (uVar18 < param_2) {\n            param_1[uVar18] = 0x27;\n          }\n          if (uVar18 + 1 < param_2) {\n            param_1[uVar18 + 1] = 0x24;\n          }\n          if (uVar18 + 2 < param_2) {\n            param_1[uVar18 + 2] = 0x27;\n          }\n          uVar18 = uVar18 + 3;\n          bVar3 = bVar24;\n        }\n        if (uVar18 < param_2) {\n          param_1[uVar18] = 0x5c;\n        }\n        if (uVar18 + 1 < param_2) {\n          param_1[uVar18 + 1] = (char)(uVar15 >> 6) + '0';\n        }\n        if (uVar18 + 2 < param_2) {\n          param_1[uVar18 + 2] = ((byte)(uVar15 >> 3) & 7) + 0x30;\n        }\n        uVar13 = uVar19 + 1;\n        uVar18 = uVar18 + 3;\n        bVar14 = (bVar14 & 7) + 0x30;\n        bVar24 = bVar22;\n        if (uVar17 <= uVar13) goto LAB_001058a8;\n      }\n      else {\n        bVar2 = (bool)((bVar24 ^ 1U) & bVar3);\n        if (bVar23) {\n          if (uVar18 < param_2) {\n            param_1[uVar18] = 0x5c;\n          }\n          uVar18 = uVar18 + 1;\n        }\n        uVar13 = uVar19 + 1;\n        if (uVar17 <= uVar13) goto LAB_00105e60;\n        if (bVar2) {\n          if (uVar18 < param_2) {\n            param_1[uVar18] = 0x27;\n          }\n          if (uVar18 + 1 < param_2) {\n            param_1[uVar18 + 1] = 0x27;\n          }\n          uVar18 = uVar18 + 2;\n          bVar23 = false;\n          bVar3 = false;\n        }\n        else {\n          bVar23 = false;\n        }\n      }\n      uVar19 = uVar19 + 1;\n      if (uVar18 < param_2) {\n        param_1[uVar18] = bVar14;\n      }\n      uVar15 = (ulong)(byte)param_3[uVar19];\n      uVar18 = uVar18 + 1;\n    } while( true );\n  }\nLAB_00105971:\n  bVar5 = bVar23;\n  if (bVar22) {\n    bVar21 = false;\n    bVar22 = bVar1;\n    goto LAB_001061f2;\n  }\nswitchD_00105e10_caseD_25:\n  bVar22 = param_5 == 2;\n  bVar23 = bVar21;\nLAB_001058d8:\n  bVar14 = (byte)uVar15;\n  bVar22 = (bool)(bVar22 | bVar1 ^ 1U);\n  if ((!bVar22) || (bVar22 = false, bVar21 = bVar23, bVar20)) {\nLAB_00105820:\n    bVar14 = (byte)uVar15;\n    uVar17 = uVar13;\n    bVar3 = bVar2;\n    bVar21 = bVar23;\n    if ((param_7 == 0) || ((*(uint *)(param_7 + (uVar15 >> 5) * 4) >> (bVar14 & 0x1f) & 1) == 0))\n    goto joined_r0x001058fb;\n  }\n  else {\nLAB_001058f8:\n    uVar17 = uVar13;\n    bVar22 = false;\njoined_r0x001058fb:\n    uVar13 = uVar17;\n    bVar2 = bVar3;\n    if (!bVar5) {\n      uVar13 = uVar17 + 1;\n      bVar2 = (bool)((bVar22 ^ 1U) & bVar3);\nLAB_00105e60:\n      if (bVar2) {\n        if (uVar18 < param_2) {\n          param_1[uVar18] = 0x27;\n        }\n        if (uVar18 + 1 < param_2) {\n          param_1[uVar18 + 1] = 0x27;\n        }\n        uVar18 = uVar18 + 2;\n        bVar3 = false;\n      }\n      goto LAB_001058a8;\n    }\n  }\njoined_r0x00105d31:\n  if (bVar20) {\nLAB_00105d40:\n    bVar24 = (bool)(bVar1 & param_5 == 2);\n    goto LAB_00105bd0;\n  }\n  bVar24 = (bool)((bVar2 ^ 1U) & param_5 == 2);\n  if (bVar24) {\n    if (uVar18 < param_2) {\n      param_1[uVar18] = 0x27;\n    }\n    if (uVar18 + 1 < param_2) {\n      param_1[uVar18 + 1] = 0x24;\n    }\n    if (uVar18 + 2 < param_2) {\n      param_1[uVar18 + 2] = 0x27;\n    }\n    uVar18 = uVar18 + 3;\n    bVar2 = bVar24;\n  }\nLAB_00105896:\n  if (uVar18 < param_2) {\n    param_1[uVar18] = 0x5c;\n  }\n  uVar18 = uVar18 + 1;\n  uVar13 = uVar13 + 1;\n  bVar3 = bVar2;\nLAB_001058a8:\n  bVar2 = bVar3;\n  if (uVar18 < param_2) {\n    param_1[uVar18] = bVar14;\n  }\n  uVar18 = uVar18 + 1;\n  if (!bVar21) {\n    bVar6 = false;\n  }\n  goto LAB_00105700;\n}\n\n", 
    "001034f0": "\nvoid xfields(long param_1)\n\n{\n  undefined *puVar1;\n  char cVar2;\n  void *pvVar3;\n  size_t __n;\n  undefined *__s;\n  undefined *puVar4;\n  \n  __s = *(undefined **)(param_1 + 0x10);\n  __n = *(long *)(param_1 + 8) - 1;\n  puVar1 = __s + __n;\n  if (__s != puVar1) {\n    if (-1 < tab) {\n      if (tab != 10) {\n        while( true ) {\n          __n = (long)puVar1 - (long)__s;\n          pvVar3 = memchr(__s,tab,__n);\n          if (pvVar3 == (void *)0x0) break;\n          extract_field(param_1,__s,(long)pvVar3 - (long)__s);\n          __s = (undefined *)((long)pvVar3 + 1);\n        }\n      }\n      goto LAB_0010352e;\n    }\n    do {\n      puVar4 = __s + 1;\n      cVar2 = field_sep(*__s);\n      if (cVar2 == '\\0') goto LAB_001035d2;\n      __s = puVar4;\n    } while (puVar1 != puVar4);\n  }\n  return;\n  while( true ) {\n    while (cVar2 = field_sep(*puVar4), cVar2 == '\\0') {\n      puVar4 = puVar4 + 1;\n      if (puVar1 == puVar4) {\n        __n = (long)puVar1 - (long)__s;\n        goto LAB_0010352e;\n      }\n    }\n    extract_field(param_1,__s,(long)puVar4 - (long)__s);\n    __s = puVar4;\n    if (puVar1 == puVar4) {\n      return;\n    }\n    do {\n      __s = __s + 1;\n      if (puVar1 == __s) {\n        __n = 0;\n        __s = puVar1;\n        goto LAB_0010352e;\n      }\n      cVar2 = field_sep(*__s);\n    } while (cVar2 != '\\0');\n    if (puVar1 == __s) break;\nLAB_001035d2:\n    puVar4 = __s + 1;\n    if (puVar1 == puVar4) {\n      __n = 1;\n      goto LAB_0010352e;\n    }\n  }\n  __n = 0;\n  __s = puVar1;\nLAB_0010352e:\n  extract_field(param_1,__s,__n);\n  return;\n}\n\n", 
    "0010f168": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nFILE * fdopen(int __fd,char *__modes)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fdopen@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001082c0": "\nbool c_isprint(int param_1)\n\n{\n  return param_1 - 0x20U < 0x5f;\n}\n\n", 
    "0010f048": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fcntl(int __fd,int __cmd,...)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fcntl@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00106c80": "\nvoid quotearg(undefined8 param_1)\n\n{\n  quotearg_n(0,param_1);\n  return;\n}\n\n", 
    "00107800": "\nvoid x2realloc(undefined8 param_1,undefined8 param_2)\n\n{\n  x2nrealloc(param_1,param_2,1);\n  return;\n}\n\n", 
    "00102670": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nFILE * fdopen(int __fd,char *__modes)\n\n{\n  FILE *pFVar1;\n  \n  pFVar1 = (FILE *)(*(code *)PTR_fdopen_0010df50)();\n  return pFVar1;\n}\n\n", 
    "00102550": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint posix_fadvise(int __fd,__off_t __offset,__off_t __len,int __advise)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_posix_fadvise_0010dec0)();\n  return iVar1;\n}\n\n", 
    "0010f1e0": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nushort ** __ctype_b_loc(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __ctype_b_loc@@GLIBC_2.3 */\n  halt_baddata();\n}\n\n", 
    "00102430": "\nvoid __fpending(void)\n\n{\n  (*(code *)PTR___fpending_0010de30)();\n  return;\n}\n\n", 
    "0010f0c0": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint close(int __fd)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* close@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00103640": "\nvoid reset_line_isra_0(undefined8 *param_1)\n\n{\n  *param_1 = 0;\n  return;\n}\n\n", 
    "0010f018": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint * __errno_location(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __errno_location@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00107560": "\nvoid version_etc(void)\n\n{\n  long lVar1;\n  long in_FS_OFFSET;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  version_etc_va();\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00103080": "\nvoid frame_dummy(void)\n\n{\n  register_tm_clones();\n  return;\n}\n\n", 
    "0010f1e8": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __cxa_finalize(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __cxa_finalize@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010f0c8": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint posix_fadvise(int __fd,__off_t __offset,__off_t __len,int __advise)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* posix_fadvise@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001025f0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * malloc(size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = (void *)(*(code *)PTR_malloc_0010df10)();\n  return pvVar1;\n}\n\n", 
    "001024d0": "\nvoid getopt_long(void)\n\n{\n  (*(code *)PTR_getopt_long_0010de80)();\n  return;\n}\n\n", 
    "001034a0": "\nvoid init_linep(undefined8 *param_1)\n\n{\n  undefined8 uVar1;\n  \n  uVar1 = xcalloc(1,0x30);\n  *param_1 = uVar1;\n  return;\n}\n\n", 
    "0010f130": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fflush(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fflush@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00106e70": "\nvoid quotearg_n_style_colon(undefined4 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  long in_FS_OFFSET;\n  undefined8 local_98;\n  undefined8 uStack_90;\n  undefined8 local_88;\n  undefined8 uStack_80;\n  undefined8 local_78;\n  undefined8 uStack_70;\n  undefined8 local_68;\n  undefined8 local_58;\n  undefined8 uStack_50;\n  undefined8 local_48;\n  undefined8 uStack_40;\n  undefined8 local_38;\n  undefined8 uStack_30;\n  undefined8 local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  quoting_options_from_style(&local_98);\n  puVar1 = &local_58;\n  local_58 = local_98;\n  uStack_50 = uStack_90;\n  local_48 = local_88;\n  uStack_40 = uStack_80;\n  local_38 = local_78;\n  uStack_30 = uStack_70;\n  local_28 = local_68;\n  set_char_quoting(puVar1,0x3a,1);\n  quotearg_n_options(param_1,param_3,0xffffffffffffffff,puVar1);\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "0010f138": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * nl_langinfo(nl_item __item)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* nl_langinfo@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010f010": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid abort(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* abort@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00102780": "\nundefined main(int param_1,undefined8 *param_2)\n\n{\n  byte bVar1;\n  char *pcVar2;\n  char cVar3;\n  int iVar4;\n  uint uVar5;\n  long lVar6;\n  long lVar7;\n  undefined8 uVar8;\n  undefined8 uVar9;\n  int *piVar10;\n  byte *pbVar11;\n  byte *pbVar12;\n  long in_FS_OFFSET;\n  bool bVar13;\n  bool bVar14;\n  byte bVar15;\n  int local_64;\n  int local_60;\n  int local_5c;\n  long local_58;\n  undefined local_50 [8];\n  undefined8 local_48;\n  long local_40;\n  \n  bVar15 = 0;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_60 = 0;\n  local_48 = 0;\n  local_5c = 0;\n  set_program_name(*param_2);\n  setlocale(6,\"\");\n  bindtextdomain(\"coreutils\",\"/usr/local/share/locale\");\n  textdomain(\"coreutils\");\n  hard_LC_COLLATE = hard_locale(3);\n  atexit(close_stdout);\n  atexit(free_spareline);\n  print_pairables = 1;\n  seen_unpairable = 0;\n  issued_disorder_warning = 0;\n  check_input_order = 0;\n  while( true ) {\n    iVar4 = getopt_long((long)param_1 & 0xffffffff,param_2,\"-a:e:i1:2:j:o:t:v:z\",longopts,0);\n    pbVar12 = optarg;\n    if (iVar4 == -1) {\n      local_60 = 0;\n      if (optind < param_1) {\n        do {\n          lVar6 = (long)optind;\n          optind = optind + 1;\n          add_file_name_constprop_0(param_2[lVar6],local_50,&local_48,&local_5c,&local_60,&local_64)\n          ;\n        } while (optind < param_1);\n      }\n      if (local_5c != 2) {\n        if (local_5c == 0) {\n          uVar9 = dcgettext(0,\"missing operand\",5);\n                    /* WARNING: Subroutine does not return */\n          error(0,0,uVar9);\n        }\n        uVar9 = quote(param_2[(long)param_1 - 1]);\n        uVar8 = dcgettext(0,\"missing operand after %s\",5);\n                    /* WARNING: Subroutine does not return */\n        error(0,0,uVar8,uVar9);\n      }\n      if ((int)local_48 != 0) {\n        set_join_field(&join_field_1,0);\n        set_join_field(&join_field_2,0);\n      }\n      if (local_48._4_4_ != 0) {\n        set_join_field(&join_field_1,1);\n        set_join_field(&join_field_2,1);\n      }\n      pcVar2 = g_names._0_8_;\n      if (join_field_1 == -1) {\n        join_field_1 = 0;\n      }\n      if (join_field_2 == -1) {\n        join_field_2 = 0;\n      }\n      iVar4 = strcmp(g_names._0_8_,\"-\");\n      lVar6 = stdin;\n      if (iVar4 != 0) {\n        lVar6 = fopen_safer(pcVar2,\"r\");\n      }\n      pcVar2 = g_names._8_8_;\n      if (lVar6 == 0) {\n        uVar9 = quotearg_n_style_colon(0,3,g_names._0_8_);\n        piVar10 = __errno_location();\n                    /* WARNING: Subroutine does not return */\n        error(1,*piVar10,\"%s\",uVar9);\n      }\n      iVar4 = strcmp(g_names._8_8_,\"-\");\n      lVar7 = stdin;\n      if (iVar4 != 0) {\n        lVar7 = fopen_safer(pcVar2,\"r\");\n      }\n      if (lVar7 == 0) {\n        uVar9 = quotearg_n_style_colon(0,3,g_names._8_8_);\n        piVar10 = __errno_location();\n                    /* WARNING: Subroutine does not return */\n        error(1,*piVar10,\"%s\",uVar9);\n      }\n      if (lVar6 == lVar7) {\n        uVar9 = dcgettext(0,\"both files cannot be standard input\",5);\n        piVar10 = __errno_location();\n                    /* WARNING: Subroutine does not return */\n        error(1,*piVar10,uVar9);\n      }\n      system_join(lVar6,lVar7);\n      iVar4 = rpl_fclose(lVar6);\n      if (iVar4 == 0) {\n        iVar4 = rpl_fclose(lVar7);\n        if (iVar4 != 0) {\n          uVar9 = quotearg_n_style_colon(0,3,g_names._8_8_);\n          piVar10 = __errno_location();\n                    /* WARNING: Subroutine does not return */\n          error(1,*piVar10,\"%s\",uVar9);\n        }\n        if ((char)issued_disorder_warning == '\\0') {\n        }\n        else {\n          issued_disorder_warning._1_1_ = 1;\n        }\n        if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n          return issued_disorder_warning._1_1_;\n        }\n                    /* WARNING: Subroutine does not return */\n        __stack_chk_fail();\n      }\n      uVar9 = quotearg_n_style_colon(0,3,g_names._0_8_);\n      piVar10 = __errno_location();\n                    /* WARNING: Subroutine does not return */\n      error(1,*piVar10,\"%s\",uVar9);\n    }\n    local_64 = 0;\n    if (0x82 < iVar4) break;\n    if (iVar4 < 0x31) {\n      if (iVar4 == -0x82) {\n                    /* WARNING: Subroutine does not return */\n        usage(0);\n      }\n      if (iVar4 != 1) {\n        if (iVar4 == -0x83) {\n          version_etc(stdout,&DAT_00109087,\"GNU coreutils\",Version,\"Mike Haertel\",0);\n                    /* WARNING: Subroutine does not return */\n          exit(0);\n        }\n        break;\n      }\n      add_file_name_constprop_0(optarg,local_50,&local_48,&local_5c);\n      local_60 = local_64;\n    }\n    else {\n      bVar13 = 0xffef63a7 < (&switchD_001028a4::switchdataD_00109c58)[iVar4 - 0x31];\n      bVar14 = (&switchD_001028a4::switchdataD_00109c58)[iVar4 - 0x31] == 0xffef63a8;\n      switch(iVar4) {\n      case 0x31:\n        uVar9 = string_to_join_field(optarg);\n        set_join_field(&join_field_1,uVar9);\n        local_60 = local_64;\n        break;\n      case 0x32:\n        uVar9 = string_to_join_field(optarg);\n        set_join_field(&join_field_2,uVar9);\n        local_60 = local_64;\n        break;\n      default:\n        goto switchD_001028a4_caseD_33;\n      case 0x65:\n        if ((empty_filler != (byte *)0x0) &&\n           (iVar4 = strcmp((char *)empty_filler,(char *)optarg), iVar4 != 0)) {\n          uVar9 = dcgettext(0,\"conflicting empty-field replacement strings\",5);\n                    /* WARNING: Subroutine does not return */\n          error(1,0,uVar9);\n        }\n        local_60 = 0;\n        empty_filler = pbVar12;\n        break;\n      case 0x69:\n        ignore_case = 1;\n        local_60 = 0;\n        break;\n      case 0x6a:\n        bVar1 = *optarg;\n        if ((((byte)(bVar1 - 0x31) < 2) && (optarg[1] == 0)) &&\n           (optarg == (byte *)(param_2[(long)optind + -1] + 2))) {\n          local_64 = (bVar1 == 0x32) + 1;\n          piVar10 = (int *)((long)&local_48 + (ulong)(bVar1 == 0x32) * 4);\n          *piVar10 = *piVar10 + 1;\n          local_60 = local_64;\n        }\n        else {\n          uVar9 = string_to_join_field();\n          set_join_field(&join_field_1,uVar9);\n          set_join_field(&join_field_2,join_field_1);\n          local_60 = local_64;\n        }\n        break;\n      case 0x6f:\n        lVar6 = 5;\n        pbVar11 = &DAT_0010913d;\n        do {\n          if (lVar6 == 0) break;\n          lVar6 = lVar6 + -1;\n          bVar13 = *pbVar12 < *pbVar11;\n          bVar14 = *pbVar12 == *pbVar11;\n          pbVar12 = pbVar12 + (ulong)bVar15 * -2 + 1;\n          pbVar11 = pbVar11 + (ulong)bVar15 * -2 + 1;\n        } while (bVar14);\n        cVar3 = (!bVar13 && !bVar14) - bVar13;\n        if (cVar3 == '\\0') {\n          autoformat = 1;\n          local_60 = (int)cVar3;\n        }\n        else {\n          add_field_list(optarg);\n          local_64 = 3;\n          local_60 = 3;\n        }\n        break;\n      case 0x74:\n        uVar5 = (uint)*optarg;\n        if (*optarg == 0) {\n          uVar5 = 10;\n        }\n        else if (optarg[1] != 0) {\n          iVar4 = strcmp((char *)optarg,\"\\\\0\");\n          if (iVar4 != 0) {\n            uVar9 = quote(pbVar12);\n            uVar8 = dcgettext(0,\"multi-character tab %s\",5);\n                    /* WARNING: Subroutine does not return */\n            error(1,0,uVar8,uVar9);\n          }\n          uVar5 = 0;\n        }\n        if ((-1 < (int)tab) && (tab != uVar5)) {\n          uVar9 = dcgettext(0,\"incompatible tabs\",5);\n                    /* WARNING: Subroutine does not return */\n          error(1,0,uVar9);\n        }\n        tab = uVar5;\n        local_60 = 0;\n        break;\n      case 0x76:\n        print_pairables = 0;\n      case 0x61:\n        iVar4 = xstrtoul(optarg,0,10,&local_58);\n        if ((iVar4 != 0) || (1 < local_58 - 1U)) {\n          uVar9 = quote(optarg);\n          uVar8 = dcgettext(0,\"invalid field number: %s\",5);\n                    /* WARNING: Subroutine does not return */\n          error(1,0,uVar8,uVar9);\n        }\n        local_60 = local_64;\n        if (local_58 == 1) {\n          print_unpairables_1 = 1;\n        }\n        else {\n          print_unpairables_2 = 1;\n        }\n        break;\n      case 0x7a:\n        eolchar = 0;\n        local_60 = 0;\n        break;\n      case 0x80:\n        check_input_order = 1;\n        local_60 = 0;\n        break;\n      case 0x81:\n        check_input_order = 2;\n        local_60 = 0;\n        break;\n      case 0x82:\n        join_header_lines = 1;\n        local_60 = 0;\n      }\n    }\n  }\nswitchD_001028a4_caseD_33:\n                    /* WARNING: Subroutine does not return */\n  usage(1);\n}\n\n", 
    "00102660": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * realloc(void *__ptr,size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = (void *)(*(code *)PTR_realloc_0010df48)();\n  return pvVar1;\n}\n\n", 
    "0010f0d0": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * memchr(void *__s,int __c,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* memchr@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00102540": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint close(int __fd)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_close_0010deb8)();\n  return iVar1;\n}\n\n", 
    "00102420": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid _exit(int __status)\n\n{\n  (*(code *)PTR__exit_0010de28)();\n  return;\n}\n\n", 
    "00106bb0": "\nvoid quotearg_free(void)\n\n{\n  void **ppvVar1;\n  void *__ptr;\n  undefined *__ptr_00;\n  void **ppvVar2;\n  \n  __ptr_00 = slotvec;\n  if (1 < nslots) {\n    ppvVar2 = (void **)(slotvec + 0x18);\n    ppvVar1 = (void **)(slotvec + (ulong)(nslots - 2) * 0x10 + 0x28);\n    do {\n      __ptr = *ppvVar2;\n      ppvVar2 = ppvVar2 + 2;\n      free(__ptr);\n    } while (ppvVar2 != ppvVar1);\n  }\n  if (*(undefined1 **)(__ptr_00 + 8) != slot0) {\n    free(*(undefined1 **)(__ptr_00 + 8));\n    slotvec0._8_8_ = slot0;\n    slotvec0._0_8_ = 0x100;\n  }\n  if (__ptr_00 != slotvec0) {\n    free(__ptr_00);\n    slotvec = slotvec0;\n  }\n  nslots = 1;\n  return;\n}\n\n", 
    "00108640": "\nundefined8 memcoll0(void *param_1,size_t param_2,void *param_3,size_t param_4)\n\n{\n  int iVar1;\n  int *piVar2;\n  undefined8 uVar3;\n  \n  if (param_2 == param_4) {\n    iVar1 = memcmp(param_1,param_3,param_2);\n    if (iVar1 == 0) {\n      piVar2 = __errno_location();\n      *piVar2 = 0;\n      return 0;\n    }\n  }\n  uVar3 = strcoll_loop(param_1,param_2,param_3,param_4);\n  return uVar3;\n}\n\n", 
    "0010276f": "\nvoid set_custom_quoting_cold(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "0010f0d8": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __libc_start_main(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __libc_start_main@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00108080": "\nvoid clear_ungetc_buffer_preserving_position(uint *param_1)\n\n{\n  if ((*param_1 & 0x100) == 0) {\n    return;\n  }\n  rpl_fseeko(param_1,0,1);\n  return;\n}\n\n", 
    "001025e0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fileno(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_fileno_0010df08)();\n  return iVar1;\n}\n\n", 
    "001024c0": "\nvoid __stack_chk_fail(void)\n\n{\n  (*(code *)PTR___stack_chk_fail_0010de78)();\n  return;\n}\n\n", 
    "0010f140": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint strcoll(char *__s1,char *__s2)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strcoll@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010276a": "\nvoid quotearg_n_options_cold(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "0010f020": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint strncmp(char *__s1,char *__s2,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strncmp@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00106e60": "\nvoid quotearg_colon_mem(undefined8 param_1,undefined8 param_2)\n\n{\n  quotearg_char_mem(param_1,param_2,0x3a);\n  return;\n}\n\n", 
    "001074d0": "\nvoid version_etc_va(void)\n\n{\n  uint uVar1;\n  long *plVar2;\n  long lVar3;\n  uint *in_R8;\n  long lVar4;\n  long in_FS_OFFSET;\n  long local_68 [11];\n  long local_10;\n  \n  lVar4 = 0;\n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  do {\n    uVar1 = *in_R8;\n    if (uVar1 < 0x30) {\n      *in_R8 = uVar1 + 8;\n      lVar3 = *(long *)((ulong)uVar1 + *(long *)(in_R8 + 4));\n      local_68[lVar4] = lVar3;\n    }\n    else {\n      plVar2 = *(long **)(in_R8 + 2);\n      *(long **)(in_R8 + 2) = plVar2 + 1;\n      lVar3 = *plVar2;\n      local_68[lVar4] = lVar3;\n    }\n  } while ((lVar3 != 0) && (lVar4 = lVar4 + 1, lVar4 != 10));\n  version_etc_arn();\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "0010f148": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * strpbrk(char *__s,char *__accept)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strpbrk@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010f028": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid _ITM_deregisterTMCloneTable(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n  halt_baddata();\n}\n\n", 
    "00102410": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint strncmp(char *__s1,char *__s2,size_t __n)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_strncmp_0010de20)();\n  return iVar1;\n}\n\n", 
    "00102774": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid version_etc_arn_cold(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "00102450": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fcntl(int __fd,int __cmd,...)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_fcntl_0010de40)();\n  return iVar1;\n}\n\n", 
    "00103300": "\nvoid free_spareline(void)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = spareline._0_8_;\n  if (spareline._0_8_ != (void *)0x0) {\n    freeline(spareline._0_8_);\n    free(pvVar1);\n  }\n  pvVar1 = spareline._8_8_;\n  if (spareline._8_8_ != (void *)0x0) {\n    freeline(spareline._8_8_);\n    free(pvVar1);\n    return;\n  }\n  return;\n}\n\n", 
    "0010f1c0": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid _ITM_registerTMCloneTable(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n  halt_baddata();\n}\n\n", 
    "0010f118": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint putchar_unlocked(int __c)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* putchar_unlocked@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00102690": "\nvoid __printf_chk(void)\n\n{\n  (*(code *)PTR___printf_chk_0010df60)();\n  return;\n}\n\n", 
    "00104990": "\nvoid close_stdout_set_file_name(undefined8 param_1)\n\n{\n  file_name = param_1;\n  return;\n}\n\n", 
    "00102570": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint memcmp(void *__s1,void *__s2,size_t __n)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_memcmp_0010ded0)();\n  return iVar1;\n}\n\n", 
    "0010f1c8": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint mbsinit(mbstate_t *__ps)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* mbsinit@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010f0a0": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * strrchr(char *__s,int __c)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strrchr@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001034c0": "\nuint field_sep(byte param_1)\n\n{\n  ushort **ppuVar1;\n  uint extraout_EDX;\n  \n  ppuVar1 = __ctype_b_loc();\n  return (*ppuVar1)[param_1] & 1 | extraout_EDX & 0xffffff00 | (uint)(param_1 == 10);\n}\n\n", 
    "001023d0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\n__int32_t ** __ctype_toupper_loc(void)\n\n{\n  __int32_t **pp_Var1;\n  \n  pp_Var1 = (__int32_t **)(*(code *)PTR___ctype_toupper_loc_0010de00)();\n  return pp_Var1;\n}\n\n", 
    "001069d0": "\nundefined4 set_quoting_flags(undefined1 *param_1,undefined4 param_2)\n\n{\n  undefined4 uVar1;\n  \n  if (param_1 == (undefined1 *)0x0) {\n    param_1 = default_quoting_options;\n  }\n  uVar1 = *(undefined4 *)(param_1 + 4);\n  *(undefined4 *)(param_1 + 4) = param_2;\n  return uVar1;\n}\n\n", 
    "001047f0": "\nvoid add_file_name_constprop_0\n               (undefined8 param_1,int *param_2,int *param_3,int *param_4,int *param_5,\n               undefined4 *param_6)\n\n{\n  int iVar1;\n  int iVar2;\n  ulong uVar3;\n  long lVar4;\n  undefined8 uVar5;\n  undefined8 uVar6;\n  long lVar7;\n  int iVar8;\n  \n  iVar8 = *param_4;\n  if (iVar8 == 2) {\n    iVar1 = *param_2;\n    uVar3 = (ulong)(iVar1 == 0);\n    uVar5 = *(undefined8 *)(g_names + uVar3 * 8);\n    iVar2 = param_2[uVar3];\n    if (iVar2 == 2) {\n      param_3[1] = param_3[1] + -1;\n      uVar5 = string_to_join_field(uVar5);\n      set_join_field(&join_field_2,uVar5);\n    }\n    else if (iVar2 < 3) {\n      if (iVar2 == 0) {\n        uVar5 = quotearg_style(4,param_1);\n        uVar6 = dcgettext(0,\"extra operand %s\",5);\n                    /* WARNING: Subroutine does not return */\n        error(0,0,uVar6,uVar5);\n      }\n      if (iVar2 == 1) {\n        *param_3 = *param_3 + -1;\n        uVar5 = string_to_join_field(uVar5);\n        set_join_field(&join_field_1,uVar5);\n      }\n    }\n    else if (iVar2 == 3) {\n      add_field_list();\n    }\n    if (iVar1 == 0) {\n      lVar4 = 8;\n      lVar7 = 4;\n    }\n    else {\n      lVar7 = 4;\n      *param_2 = param_2[1];\n      g_names._0_8_ = g_names._8_8_;\n      lVar4 = 8;\n    }\n  }\n  else {\n    lVar4 = (long)iVar8;\n    iVar8 = iVar8 + 1;\n    lVar7 = lVar4 * 4;\n    lVar4 = lVar4 << 3;\n  }\n  *(int *)((long)param_2 + lVar7) = *param_5;\n  *(undefined8 *)(g_names + lVar4) = param_1;\n  *param_4 = iVar8;\n  if (*param_5 == 3) {\n    *param_6 = 3;\n  }\n  return;\n}\n\n", 
    "0010f1b8": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __fprintf_chk(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __fprintf_chk@@GLIBC_2.3.4 */\n  halt_baddata();\n}\n\n", 
    "001024f0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * strchr(char *__s,int __c)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_strchr_0010de90)();\n  return pcVar1;\n}\n\n", 
    "00106c50": "\nvoid quotearg_n(undefined8 param_1,undefined8 param_2)\n\n{\n  quotearg_n_options(param_1,param_2,0xffffffffffffffff,default_quoting_options);\n  return;\n}\n\n", 
    "001084d0": "\nint strcoll_loop(char *param_1,long param_2,char *param_3,long param_4)\n\n{\n  int iVar1;\n  int *piVar2;\n  size_t sVar3;\n  size_t sVar4;\n  \n  piVar2 = __errno_location();\n  while( true ) {\n    *piVar2 = 0;\n    iVar1 = strcoll(param_1,param_3);\n    if (iVar1 != 0) {\n      return iVar1;\n    }\n    sVar3 = strlen(param_1);\n    sVar4 = strlen(param_3);\n    param_1 = param_1 + sVar3 + 1;\n    param_3 = param_3 + sVar4 + 1;\n    param_4 = param_4 - (sVar4 + 1);\n    param_2 = param_2 - (sVar3 + 1);\n    if (param_2 == 0) break;\n    if (param_4 == 0) {\n      return 1;\n    }\n  }\n  return -(uint)(param_4 != 0);\n}\n\n", 
    "00106d70": "\nvoid quotearg_style(undefined4 param_1,undefined8 param_2)\n\n{\n  quotearg_n_style(0,param_1,param_2);\n  return;\n}\n\n", 
    "00104b90": "\nvoid initbuffer(undefined (*param_1) [16])\n\n{\n  *(undefined8 *)param_1[1] = 0;\n  *param_1 = (undefined  [16])0x0;\n  return;\n}\n\n", 
    "00104a70": "\nvoid fadvise(FILE *param_1,int param_2)\n\n{\n  int __fd;\n  \n  if (param_1 != (FILE *)0x0) {\n    __fd = fileno(param_1);\n    fdadvise(__fd,0,0,param_2);\n    return;\n  }\n  return;\n}\n\n", 
    "0010f110": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * memcpy(void *__dest,void *__src,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* memcpy@@GLIBC_2.14 */\n  halt_baddata();\n}\n\n", 
    "00102560": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * memchr(void *__s,int __c,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = (void *)(*(code *)PTR_memchr_0010dec8)();\n  return pvVar1;\n}\n\n", 
    "00103650": "\nvoid delseq_isra_0(ulong *param_1,void **param_2)\n\n{\n  long lVar1;\n  ulong uVar2;\n  \n  if (*param_1 != 0) {\n    uVar2 = 0;\n    do {\n      freeline(*(undefined8 *)((long)*param_2 + uVar2 * 8));\n      lVar1 = uVar2 * 8;\n      uVar2 = uVar2 + 1;\n      free(*(void **)((long)*param_2 + lVar1));\n    } while (uVar2 < *param_1);\n  }\n  free(*param_2);\n  return;\n}\n\n", 
    "00102440": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint getc_unlocked(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_getc_unlocked_0010de38)();\n  return iVar1;\n}\n\n", 
    "00104620": "\nvoid usage(int param_1)\n\n{\n  FILE *pFVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  char *pcVar4;\n  \n  uVar2 = program_name;\n  if (param_1 == 0) {\n    uVar3 = dcgettext(0,\"Usage: %s [OPTION]... FILE1 FILE2\\n\",5);\n    __printf_chk(1,uVar3,uVar2);\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\n                               \"For each pair of input lines with identical join fields, write a line to\\nstandard output.  The default join field is the first, delimited by blanks.\\n\"\n                               ,5);\n    fputs_unlocked(pcVar4,pFVar1);\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\"\\nWhen FILE1 or FILE2 (not both) is -, read standard input.\\n\",5);\n    fputs_unlocked(pcVar4,pFVar1);\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\n                               \"\\n  -a FILENUM        also print unpairable lines from file FILENUM, where\\n                      FILENUM is 1 or 2, corresponding to FILE1 or FILE2\\n  -e EMPTY          replace missing input fields with EMPTY\\n\"\n                               ,5);\n    fputs_unlocked(pcVar4,pFVar1);\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\n                               \"  -i, --ignore-case  ignore differences in case when comparing fields\\n  -j FIELD          equivalent to \\'-1 FIELD -2 FIELD\\'\\n  -o FORMAT         obey FORMAT while constructing output line\\n  -t CHAR           use CHAR as input and output field separator\\n\"\n                               ,5);\n    fputs_unlocked(pcVar4,pFVar1);\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\n                               \"  -v FILENUM        like -a FILENUM, but suppress joined output lines\\n  -1 FIELD          join on this FIELD of file 1\\n  -2 FIELD          join on this FIELD of file 2\\n  --check-order     check that the input is correctly sorted, even\\n                      if all input lines are pairable\\n  --nocheck-order   do not check that the input is correctly sorted\\n  --header          treat the first line in each file as field headers,\\n                      print them without trying to pair them\\n\"\n                               ,5);\n    fputs_unlocked(pcVar4,pFVar1);\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\"  -z, --zero-terminated     line delimiter is NUL, not newline\\n\",\n                               5);\n    fputs_unlocked(pcVar4,pFVar1);\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\"      --help     display this help and exit\\n\",5);\n    fputs_unlocked(pcVar4,pFVar1);\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\"      --version  output version information and exit\\n\",5);\n    fputs_unlocked(pcVar4,pFVar1);\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\n                               \"\\nUnless -t CHAR is given, leading blanks separate fields and are ignored,\\nelse fields are separated by CHAR.  Any FIELD is a field number counted\\nfrom 1.  FORMAT is one or more comma or blank separated specifications,\\neach being \\'FILENUM.FIELD\\' or \\'0\\'.  Default FORMAT outputs the join field,\\nthe remaining fields from FILE1, the remaining fields from FILE2, all\\nseparated by CHAR.  If FORMAT is the keyword \\'auto\\', then the first\\nline of each file determines the number of fields output for each line.\\n\\nImportant: FILE1 and FILE2 must be sorted on the join fields.\\nE.g., use \\\"sort -k 1b,1\\\" if \\'join\\' has no options,\\nor use \\\"join -t \\'\\'\\\" if \\'sort\\' has no options.\\nNote, comparisons honor the rules specified by \\'LC_COLLATE\\'.\\nIf the input is not sorted and some lines cannot be joined, a\\nwarning message will be given.\\n\"\n                               ,5);\n    fputs_unlocked(pcVar4,pFVar1);\n    emit_ancillary_info_constprop_0();\n  }\n  else {\n    uVar3 = dcgettext(0,\"Try \\'%s --help\\' for more information.\\n\",5);\n    __fprintf_chk(stderr,1,uVar3,uVar2);\n  }\n                    /* WARNING: Subroutine does not return */\n  exit(param_1);\n}\n\n", 
    "0010f1d0": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint iswprint(wint_t __wc)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* iswprint@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010f0b0": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid __assert_fail(char *__assertion,char *__file,uint __line,char *__function)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __assert_fail@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010f128": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * malloc(size_t __size)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* malloc@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010f008": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid free(void *__ptr)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* free@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00108420": "\nulong close_stream(FILE *param_1)\n\n{\n  int iVar1;\n  long lVar2;\n  ulong uVar3;\n  int *piVar4;\n  \n  lVar2 = __fpending();\n  iVar1 = ferror_unlocked(param_1);\n  uVar3 = rpl_fclose(param_1);\n  if (iVar1 == 0) {\n    if ((int)uVar3 == 0) {\n      return uVar3;\n    }\n    if (lVar2 == 0) {\n      piVar4 = __errno_location();\n      return (ulong)-(uint)(*piVar4 != 9);\n    }\n  }\n  else if ((int)uVar3 == 0) {\n    piVar4 = __errno_location();\n    *piVar4 = 0;\n    return 0xffffffff;\n  }\n  return 0xffffffff;\n}\n\n", 
    "00102680": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * setlocale(int __category,char *__locale)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_setlocale_0010df58)();\n  return pcVar1;\n}\n\n", 
    "00106ab0": "\nundefined8\nquotearg_alloc_mem(undefined8 param_1,undefined8 param_2,long *param_3,undefined1 *param_4)\n\n{\n  int iVar1;\n  int *piVar2;\n  long lVar3;\n  undefined8 uVar4;\n  uint uVar5;\n  \n  if ((undefined4 *)param_4 == (undefined4 *)0x0) {\n    param_4 = default_quoting_options;\n  }\n  piVar2 = __errno_location();\n  iVar1 = *piVar2;\n  uVar5 = (uint)(param_3 == (long *)0x0) | *(uint *)((long)param_4 + 4);\n  lVar3 = quotearg_buffer_restyled\n                    (0,0,param_1,param_2,*(undefined4 *)param_4,uVar5,\n                     (undefined4 *)((long)param_4 + 8),*(undefined8 *)((long)param_4 + 0x28),\n                     *(undefined8 *)((long)param_4 + 0x30));\n  uVar4 = xcharalloc(lVar3 + 1);\n  quotearg_buffer_restyled\n            (uVar4,lVar3 + 1,param_1,param_2,*(undefined4 *)param_4,uVar5,\n             (undefined4 *)((long)param_4 + 8),*(undefined8 *)((long)param_4 + 0x28),\n             *(undefined8 *)((long)param_4 + 0x30));\n  *piVar2 = iVar1;\n  if (param_3 != (long *)0x0) {\n    *param_3 = lVar3;\n  }\n  return uVar4;\n}\n\n", 
    "00105150": "\nundefined8\nstrcaseeq3(long param_1,undefined8 param_2,byte param_3,char param_4,char param_5,char param_6,\n          char param_7)\n\n{\n  char cVar1;\n  byte bVar2;\n  undefined8 uVar3;\n  \n  cVar1 = c_isupper((int)(char)param_3);\n  bVar2 = *(byte *)(param_1 + 3);\n  if (cVar1 != '\\0') {\n    bVar2 = bVar2 & 0xdf;\n  }\n  if (param_3 != bVar2) {\n    return 0;\n  }\n  if (param_3 == 0) {\n    return 1;\n  }\n  uVar3 = strcaseeq4(param_1,param_2,(int)param_4,(int)param_5,(int)param_6,(int)param_7);\n  return uVar3;\n}\n\n", 
    "0010f1d8": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint feof_unlocked(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* feof_unlocked@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010f0b8": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * memset(void *__s,int __c,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* memset@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00103090": "\nvoid extract_field(long param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  long lVar1;\n  ulong uVar2;\n  undefined8 *puVar3;\n  \n  uVar2 = *(ulong *)(param_1 + 0x18);\n  lVar1 = *(long *)(param_1 + 0x28);\n  if (*(ulong *)(param_1 + 0x20) <= uVar2) {\n    lVar1 = x2nrealloc(lVar1,param_1 + 0x20,0x10);\n    uVar2 = *(ulong *)(param_1 + 0x18);\n    *(long *)(param_1 + 0x28) = lVar1;\n  }\n  puVar3 = (undefined8 *)(lVar1 + uVar2 * 0x10);\n  *puVar3 = param_2;\n  puVar3[1] = param_3;\n  *(ulong *)(param_1 + 0x18) = uVar2 + 1;\n  return;\n}\n\n", 
    "001024e0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t mbrtowc(wchar_t *__pwc,char *__s,size_t __n,mbstate_t *__p)\n\n{\n  size_t sVar1;\n  \n  sVar1 = (*(code *)PTR_mbrtowc_0010de88)();\n  return sVar1;\n}\n\n", 
    "001023c0": "\nvoid __cxa_finalize(void)\n\n{\n  (*(code *)PTR___cxa_finalize_0010dfe8)();\n  return;\n}\n\n", 
    "0010f0a8": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\n__off_t lseek(int __fd,__off_t __offset,int __whence)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* lseek@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001083a0": "\nint c_toupper(int param_1)\n\n{\n  if (param_1 - 0x61U < 0x1a) {\n    param_1 = param_1 + -0x20;\n  }\n  return param_1;\n}\n\n", 
    "00104a60": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fdadvise(int __fd,__off_t __offset,__off_t __len,int __advise)\n\n{\n  int iVar1;\n  \n  iVar1 = posix_fadvise(__fd,__offset,__len,__advise);\n  return iVar1;\n}\n\n", 
    "00103a90": "\nvoid advance_seq(undefined8 param_1,ulong *param_2,char param_3,undefined4 param_4)\n\n{\n  ulong uVar1;\n  char cVar2;\n  ulong uVar3;\n  ulong uVar4;\n  undefined8 *puVar5;\n  \n  if (param_3 != '\\0') {\n    *param_2 = 0;\n  }\n  uVar4 = *param_2;\n  uVar3 = param_2[2];\n  if (uVar4 == param_2[1]) {\n    uVar3 = x2nrealloc(uVar3,param_2 + 1,8);\n    uVar4 = *param_2;\n    param_2[2] = uVar3;\n    uVar1 = param_2[1];\n    if (uVar4 < uVar1) {\n      puVar5 = (undefined8 *)(uVar3 + uVar4 * 8);\n      do {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n      } while (puVar5 != (undefined8 *)(uVar3 + uVar1 * 8));\n    }\n  }\n  cVar2 = get_line(param_1,uVar3 + uVar4 * 8,param_4);\n  if (cVar2 != '\\0') {\n    *param_2 = *param_2 + 1;\n  }\n  return;\n}\n\n", 
    "0010f120": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fileno(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fileno@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010f000": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\n__int32_t ** __ctype_toupper_loc(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __ctype_toupper_loc@@GLIBC_2.3 */\n  halt_baddata();\n}\n\n", 
    "00106910": "\nvoid clone_quoting_options(undefined1 *param_1)\n\n{\n  int iVar1;\n  int *piVar2;\n  \n  piVar2 = __errno_location();\n  iVar1 = *piVar2;\n  if (param_1 == (undefined1 *)0x0) {\n    param_1 = default_quoting_options;\n  }\n  xmemdup(param_1,0x38);\n  *piVar2 = iVar1;\n  return;\n}\n\n", 
    "00102750": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nushort ** __ctype_b_loc(void)\n\n{\n  ushort **ppuVar1;\n  \n  ppuVar1 = (ushort **)(*(code *)PTR___ctype_b_loc_0010dfc0)();\n  return ppuVar1;\n}\n\n", 
    "00106ca0": "\nvoid quotearg_n_style(undefined4 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  long in_FS_OFFSET;\n  undefined auStack_58 [56];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  quoting_options_from_style(auStack_58);\n  quotearg_n_options(param_1,param_3,0xffffffffffffffff,auStack_58);\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00108730": "\nint atexit(__func *__func)\n\n{\n  int iVar1;\n  \n  iVar1 = __cxa_atexit(__func,0,__dso_handle);\n  return iVar1;\n}\n\n", 
    "00103040": "\nvoid __do_global_dtors_aux(void)\n\n{\n  if (completed_8061 == '\\0') {\n    if (PTR___cxa_finalize_0010dfe8 != (undefined *)0x0) {\n      __cxa_finalize(__dso_handle);\n    }\n    deregister_tm_clones();\n    completed_8061 = 1;\n    return;\n  }\n  return;\n}\n\n", 
    "001025b0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint strcmp(char *__s1,char *__s2)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_strcmp_0010def0)();\n  return iVar1;\n}\n\n", 
    "001036a0": "\nuint keycmp_isra_0(ulong param_1,long *param_2,ulong param_3,long *param_4,ulong param_5,\n                  ulong param_6)\n\n{\n  void *__s1;\n  void *pvVar1;\n  void *__s2;\n  uint uVar2;\n  void *pvVar3;\n  void **ppvVar4;\n  void *pvVar5;\n  \n  if (param_5 < param_1) {\n    ppvVar4 = (void **)(param_5 * 0x10 + *param_2);\n    __s1 = *ppvVar4;\n    pvVar1 = ppvVar4[1];\n    if (param_3 <= param_6) {\n      return (uint)(pvVar1 != (void *)0x0);\n    }\n    ppvVar4 = (void **)(param_6 * 0x10 + *param_4);\n    __s2 = *ppvVar4;\n    pvVar5 = ppvVar4[1];\n    if (pvVar1 == (void *)0x0) {\nLAB_0010376b:\n      return -(uint)(pvVar5 != (void *)0x0);\n    }\n    if (pvVar5 == (void *)0x0) {\n      uVar2 = 1;\n    }\n    else {\n      if (ignore_case == '\\0') {\n        if (hard_LC_COLLATE != '\\0') {\n          uVar2 = xmemcoll(__s1,pvVar1,__s2,pvVar5);\n          return uVar2;\n        }\n        pvVar3 = pvVar5;\n        if (pvVar1 <= pvVar5) {\n          pvVar3 = pvVar1;\n        }\n        uVar2 = memcmp(__s1,__s2,(size_t)pvVar3);\n      }\n      else {\n        pvVar3 = pvVar5;\n        if (pvVar1 <= pvVar5) {\n          pvVar3 = pvVar1;\n        }\n        uVar2 = memcasecmp(__s1,__s2,pvVar3);\n      }\n      if (uVar2 == 0) {\n        if (pvVar5 <= pvVar1) {\n          return (uint)(pvVar1 != pvVar5);\n        }\n        uVar2 = 0xffffffff;\n      }\n    }\n  }\n  else {\n    if (param_6 < param_3) {\n      pvVar5 = *(void **)(param_6 * 0x10 + *param_4 + 8);\n      goto LAB_0010376b;\n    }\n    uVar2 = 0;\n  }\n  return uVar2;\n}\n\n", 
    "0010f1a0": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __cxa_atexit(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __cxa_atexit@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00108290": "\nbool c_isdigit(int param_1)\n\n{\n  return param_1 - 0x30U < 10;\n}\n\n", 
    "001026d0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nulong strtoul(char *__nptr,char **__endptr,int __base)\n\n{\n  ulong uVar1;\n  \n  uVar1 = (*(code *)PTR_strtoul_0010df80)();\n  return uVar1;\n}\n\n", 
    "00106e30": "\nvoid quotearg_char(undefined8 param_1,char param_2)\n\n{\n  quotearg_char_mem(param_1,0xffffffffffffffff,(int)param_2);\n  return;\n}\n\n", 
    "001086b0": "\nvoid __libc_csu_init(EVP_PKEY_CTX *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  long lVar1;\n  \n  _init(param_1);\n  lVar1 = 0;\n  do {\n    (*(code *)(&__frame_dummy_init_array_entry)[lVar1])((ulong)param_1 & 0xffffffff,param_2,param_3)\n    ;\n    lVar1 = lVar1 + 1;\n  } while (lVar1 != 1);\n  return;\n}\n\n", 
    "00102740": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint feof_unlocked(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_feof_unlocked_0010dfb8)();\n  return iVar1;\n}\n\n", 
    "00102620": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint strcoll(char *__s1,char *__s2)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_strcoll_0010df28)();\n  return iVar1;\n}\n\n", 
    "00102500": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * strrchr(char *__s,int __c)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_strrchr_0010de98)();\n  return pcVar1;\n}\n\n", 
    "00108720": "\nvoid __libc_csu_fini(void)\n\n{\n  return;\n}\n\n", 
    "00105210": "\nundefined8\nstrcaseeq2(long param_1,undefined8 param_2,byte param_3,char param_4,char param_5,char param_6,\n          char param_7)\n\n{\n  char cVar1;\n  byte bVar2;\n  undefined8 uVar3;\n  \n  cVar1 = c_isupper((int)(char)param_3);\n  bVar2 = *(byte *)(param_1 + 2);\n  if (cVar1 != '\\0') {\n    bVar2 = bVar2 & 0xdf;\n  }\n  if (param_3 != bVar2) {\n    return 0;\n  }\n  if (param_3 == 0) {\n    return 1;\n  }\n  uVar3 = strcaseeq3(param_1,param_2,(int)param_4,(int)param_5,(int)param_6,(int)param_7);\n  return uVar3;\n}\n\n", 
    "00104cf0": "\nint memcasecmp(long param_1,long param_2,long param_3)\n\n{\n  int iVar1;\n  __int32_t **pp_Var2;\n  long lVar3;\n  \n  if (param_3 == 0) {\n    return 0;\n  }\n  pp_Var2 = __ctype_toupper_loc();\n  lVar3 = 0;\n  do {\n    iVar1 = (*pp_Var2)[*(byte *)(param_1 + lVar3)] - (*pp_Var2)[*(byte *)(param_2 + lVar3)];\n    if (iVar1 != 0) {\n      return iVar1;\n    }\n    lVar3 = lVar3 + 1;\n  } while (lVar3 != param_3);\n  return iVar1;\n}\n\n", 
    "00107870": "\nvoid xmemdup(void *param_1,size_t param_2)\n\n{\n  void *__dest;\n  \n  __dest = (void *)xmalloc(param_2);\n  memcpy(__dest,param_1,param_2);\n  return;\n}\n\n", 
    "0010f108": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __gmon_start__(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n  halt_baddata();\n}\n\n", 
    "00103270": "\nvoid set_join_field(long *param_1,long param_2)\n\n{\n  long lVar1;\n  undefined8 uVar2;\n  \n  lVar1 = *param_1;\n  if ((lVar1 != -1) && (lVar1 != param_2)) {\n    uVar2 = dcgettext(0,\"incompatible join fields %lu, %lu\",5);\n                    /* WARNING: Subroutine does not return */\n    error(1,0,uVar2,lVar1 + 1,param_2 + 1);\n  }\n  *param_1 = param_2;\n  return;\n}\n\n", 
    "001026c0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nFILE * fopen(char *__filename,char *__modes)\n\n{\n  FILE *pFVar1;\n  \n  pFVar1 = (FILE *)(*(code *)PTR_fopen_0010df78)();\n  return pFVar1;\n}\n\n", 
    "001037b0": "\nvoid check_order(long param_1,long param_2,int param_3)\n\n{\n  ulong uVar1;\n  long lVar2;\n  undefined8 uVar3;\n  int iVar4;\n  undefined8 uVar5;\n  undefined4 uVar6;\n  ulong uVar7;\n  long lVar8;\n  undefined8 uVar9;\n  \n  if (check_input_order == 2) {\n    return;\n  }\n  if (((check_input_order == 1) || (seen_unpairable != '\\0')) &&\n     (lVar8 = (long)(param_3 + -1), *(char *)((long)&issued_disorder_warning + lVar8) == '\\0')) {\n    uVar9 = join_field_1;\n    if (param_3 != 1) {\n      uVar9 = join_field_2;\n    }\n    iVar4 = keycmp_isra_0(*(undefined8 *)(param_1 + 0x18),param_1 + 0x28,\n                          *(undefined8 *)(param_2 + 0x18),param_2 + 0x28,uVar9,uVar9);\n    if (0 < iVar4) {\n      uVar1 = *(ulong *)(param_2 + 8);\n      lVar2 = *(long *)(param_2 + 0x10);\n      uVar6 = 0;\n      if (uVar1 != 0) {\n        uVar7 = uVar1 - 1;\n        if (*(char *)(lVar2 + -1 + uVar1) == '\\n') {\n          if (0x7fffffff < uVar7) {\n            uVar7 = 0x7fffffff;\n          }\n          uVar6 = (undefined4)uVar7;\n        }\n        else {\n          uVar6 = 0x7fffffff;\n          if (uVar1 < 0x80000000) {\n            uVar6 = (undefined4)uVar1;\n          }\n        }\n      }\n      uVar9 = *(undefined8 *)(line_no + lVar8 * 8);\n      uVar3 = *(undefined8 *)(g_names + lVar8 * 8);\n      uVar5 = dcgettext(0,\"%s:%lu: is not sorted: %.*s\",5);\n                    /* WARNING: Subroutine does not return */\n      error(check_input_order == 1,0,uVar5,uVar3,uVar9,uVar6,lVar2);\n    }\n  }\n  return;\n}\n\n", 
    "0010f1b0": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t fwrite(void *__ptr,size_t __size,size_t __n,FILE *__s)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fwrite@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001025a0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * calloc(size_t __nmemb,size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = (void *)(*(code *)PTR_calloc_0010dee8)();\n  return pvVar1;\n}\n\n", 
    "00108160": "\nsize_t rpl_mbrtowc(wchar_t *param_1,byte *param_2,size_t param_3,mbstate_t *param_4)\n\n{\n  char cVar1;\n  size_t sVar2;\n  long in_FS_OFFSET;\n  wchar_t local_34;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_1 == (wchar_t *)0x0) {\n    param_1 = &local_34;\n  }\n  sVar2 = mbrtowc(param_1,(char *)param_2,param_3,param_4);\n  if ((0xfffffffffffffffd < sVar2) && (param_3 != 0)) {\n    cVar1 = hard_locale(0);\n    if (cVar1 == '\\0') {\n      sVar2 = 1;\n      *param_1 = (uint)*param_2;\n    }\n  }\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return sVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00106d00": "\nvoid quotearg_n_style_mem\n               (undefined4 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  long in_FS_OFFSET;\n  undefined auStack_68 [56];\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  quoting_options_from_style(auStack_68);\n  quotearg_n_options(param_1,param_3,param_4,auStack_68);\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00107f10": "\n/* WARNING: Restarted to delay deadcode elimination for space: stack */\n\nint rpl_fcntl(ulong param_1,int param_2,ulong param_3)\n\n{\n  long lVar1;\n  int iVar2;\n  uint uVar3;\n  int iVar4;\n  int *piVar5;\n  int __fd;\n  long in_FS_OFFSET;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_2 != 0x406) {\n    iVar2 = fcntl((int)param_1,param_2,param_3);\n    goto LAB_00107f94;\n  }\n  if (have_dupfd_cloexec_3397 < 0) {\n    iVar2 = rpl_fcntl(param_1,0,param_3 & 0xffffffff);\n    if ((iVar2 < 0) || (__fd = iVar2, have_dupfd_cloexec_3397 != -1)) goto LAB_00107f94;\nLAB_00107fd1:\n    uVar3 = fcntl(__fd,1);\n    if (-1 < (int)uVar3) {\n      iVar4 = fcntl(__fd,2,(ulong)(uVar3 | 1));\n      iVar2 = __fd;\n      if (iVar4 != -1) goto LAB_00107f94;\n    }\n    piVar5 = __errno_location();\n    iVar2 = -1;\n    iVar4 = *piVar5;\n    close(__fd);\n    *piVar5 = iVar4;\n  }\n  else {\n    iVar2 = fcntl((int)param_1,0x406);\n    if (iVar2 < 0) {\n      piVar5 = __errno_location();\n      if (*piVar5 == 0x16) {\n        iVar2 = rpl_fcntl(param_1 & 0xffffffff,0,param_3 & 0xffffffff);\n        if (iVar2 < 0) goto LAB_00107f94;\n        have_dupfd_cloexec_3397 = -1;\n        __fd = iVar2;\n        goto LAB_00107fd1;\n      }\n    }\n    have_dupfd_cloexec_3397 = 1;\n  }\nLAB_00107f94:\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "0010f1a8": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid exit(int __status)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* exit@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001053d0": "\nundefined8\nstrcaseeq0_constprop_0\n          (byte *param_1,undefined8 param_2,byte param_3,char param_4,char param_5,char param_6,\n          char param_7,char param_8,char param_9)\n\n{\n  char cVar1;\n  byte bVar2;\n  undefined8 uVar3;\n  \n  cVar1 = c_isupper((int)(char)param_3);\n  bVar2 = *param_1;\n  if (cVar1 != '\\0') {\n    bVar2 = bVar2 & 0xdf;\n  }\n  uVar3 = 0;\n  if (bVar2 == param_3) {\n    uVar3 = strcaseeq1(param_1,param_2,(int)param_4,(int)param_5,(int)param_6,(int)param_7,\n                       (int)param_8,(int)param_9,0,0);\n  }\n  return uVar3;\n}\n\n", 
    "00102730": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint iswprint(wint_t __wc)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_iswprint_0010dfb0)();\n  return iVar1;\n}\n\n", 
    "001080e0": "\nint rpl_fseeko(FILE *param_1,__off_t param_2,int param_3)\n\n{\n  int iVar1;\n  __off_t _Var2;\n  \n  if (((param_1->_IO_read_end == param_1->_IO_read_ptr) &&\n      (param_1->_IO_write_ptr == param_1->_IO_write_base)) &&\n     (param_1->_IO_save_base == (char *)0x0)) {\n    iVar1 = fileno(param_1);\n    _Var2 = lseek(iVar1,param_2,param_3);\n    if (_Var2 == -1) {\n      iVar1 = -1;\n    }\n    else {\n      param_1->_flags = param_1->_flags & 0xffffffef;\n      param_1->_offset = _Var2;\n      iVar1 = 0;\n    }\n    return iVar1;\n  }\n  iVar1 = fseeko(param_1,param_2,param_3);\n  return iVar1;\n}\n\n", 
    "00102610": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * nl_langinfo(nl_item __item)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_nl_langinfo_0010df20)();\n  return pcVar1;\n}\n\n", 
    "0010f100": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint strcmp(char *__s1,char *__s2)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strcmp@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00102fa0": "\nvoid _start(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 unaff_retaddr;\n  undefined auStack_8 [8];\n  \n  (*(code *)PTR___libc_start_main_0010dfd0)\n            (main,unaff_retaddr,&stack0x00000008,__libc_csu_init,__libc_csu_fini,param_3,auStack_8);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n", 
    "00102650": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t fwrite_unlocked(void *__ptr,size_t __size,size_t __n,FILE *__stream)\n\n{\n  size_t sVar1;\n  \n  sVar1 = (*(code *)PTR_fwrite_unlocked_0010df40)();\n  return sVar1;\n}\n\n", 
    "00102530": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * memset(void *__s,int __c,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = (void *)(*(code *)PTR_memset_0010deb0)();\n  return pvVar1;\n}\n\n", 
    "00106ba0": "\nvoid quotearg_alloc(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  quotearg_alloc_mem(param_1,param_2,0,param_3);\n  return;\n}\n\n", 
    "00105480": "\nchar * gettext_quote(char *param_1,int param_2)\n\n{\n  int iVar1;\n  char *pcVar2;\n  undefined8 uVar3;\n  \n  pcVar2 = (char *)dcgettext(0,param_1,5);\n  if (param_1 == pcVar2) {\n    uVar3 = locale_charset();\n    iVar1 = strcaseeq0_constprop_0(uVar3,\"UTF-8\",0x55,0x54,0x46,0x2d,0x38,0,0);\n    if (iVar1 == 0) {\n      iVar1 = strcaseeq0_constprop_0(uVar3,\"GB18030\",0x47,0x42,0x31,0x38,0x30,0x33,0x30);\n      if (iVar1 == 0) {\n        pcVar2 = \"\\\"\";\n        if (param_2 != 9) {\n          pcVar2 = \"\\'\";\n        }\n        return pcVar2;\n      }\n      if (*pcVar2 == '`') {\n        pcVar2 = &DAT_00109e11;\n      }\n      else {\n        pcVar2 = &DAT_00109e0e;\n      }\n    }\n    else if (*pcVar2 == '`') {\n      pcVar2 = &DAT_00109e15;\n    }\n    else {\n      pcVar2 = &DAT_00109e0a;\n    }\n  }\n  return pcVar2;\n}\n\n", 
    "001026f0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid exit(int __status)\n\n{\n  (*(code *)PTR_exit_0010df90)();\n  return;\n}\n\n", 
    "001025d0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint putchar_unlocked(int __c)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_putchar_unlocked_0010df00)();\n  return iVar1;\n}\n\n", 
    "001024b0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t strlen(char *__s)\n\n{\n  size_t sVar1;\n  \n  sVar1 = (*(code *)PTR_strlen_0010de70)();\n  return sVar1;\n}\n\n", 
    "00106e50": "\nvoid quotearg_colon(undefined8 param_1)\n\n{\n  quotearg_char(param_1,0x3a);\n  return;\n}\n\n", 
    "001050a0": "\nundefined8\nstrcaseeq4(long param_1,undefined8 param_2,byte param_3,char param_4,char param_5,char param_6,\n          char param_7)\n\n{\n  char cVar1;\n  byte bVar2;\n  undefined8 uVar3;\n  \n  cVar1 = c_isupper((int)(char)param_3);\n  bVar2 = *(byte *)(param_1 + 4);\n  if (cVar1 != '\\0') {\n    bVar2 = bVar2 & 0xdf;\n  }\n  if (param_3 != bVar2) {\n    return 0;\n  }\n  if (param_3 == 0) {\n    return 1;\n  }\n  uVar3 = strcaseeq5(param_1,param_2,(int)param_4,(int)param_5,(int)param_6,(int)param_7);\n  return uVar3;\n}\n\n", 
    "001052e0": "\nundefined8\nstrcaseeq1(long param_1,undefined8 param_2,byte param_3,char param_4,char param_5,char param_6,\n          char param_7)\n\n{\n  char cVar1;\n  byte bVar2;\n  undefined8 uVar3;\n  \n  cVar1 = c_isupper((int)(char)param_3);\n  bVar2 = *(byte *)(param_1 + 1);\n  if (cVar1 != '\\0') {\n    bVar2 = bVar2 & 0xdf;\n  }\n  if (param_3 != bVar2) {\n    return 0;\n  }\n  if (param_3 == 0) {\n    return 1;\n  }\n  uVar3 = strcaseeq2(param_1,param_2,(int)param_4,(int)param_5,(int)param_6,(int)param_7);\n  return uVar3;\n}\n\n", 
    "00102520": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid __assert_fail(char *__assertion,char *__file,uint __line,char *__function)\n\n{\n  (*(code *)PTR___assert_fail_0010dea8)();\n  return;\n}\n\n", 
    "00102400": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint * __errno_location(void)\n\n{\n  int *piVar1;\n  \n  piVar1 = (int *)(*(code *)PTR___errno_location_0010de18)();\n  return piVar1;\n}\n\n", 
    "00102765": "\nvoid quotearg_buffer_restyled_cold(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "00108744": "\nvoid _fini(void)\n\n{\n  return;\n}\n\n", 
    "00102760": "\nvoid quoting_options_from_style_cold(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "00102fd0": "\n/* WARNING: Removing unreachable block (ram,0x00102fe3) */\n/* WARNING: Removing unreachable block (ram,0x00102fef) */\n\nvoid deregister_tm_clones(void)\n\n{\n  return;\n}\n\n", 
    "00102640": "\nvoid __freading(void)\n\n{\n  (*(code *)PTR___freading_0010df38)();\n  return;\n}\n\n", 
    "00107770": "\nvoid x2nrealloc(long param_1,ulong *param_2,ulong param_3)\n\n{\n  undefined auVar1 [16];\n  ulong uVar2;\n  ulong uVar3;\n  \n  uVar3 = *param_2;\n  if (param_1 == 0) {\n    if (uVar3 == 0) {\n      uVar3 = (ulong)(0x80 < param_3) +\n              SUB168((ZEXT816(0) << 0x40 | ZEXT816(0x80)) / ZEXT816(param_3),0);\n    }\n    uVar2 = (ulong)(SUB168(ZEXT816(uVar3) * ZEXT816(param_3) >> 0x40,0) != 0);\n    if ((SUB168(ZEXT816(uVar3) * ZEXT816(param_3),0) < 0) || (uVar2 != 0)) goto LAB_001077cb;\n  }\n  else {\n    auVar1 = ZEXT816(0) << 0x40 | ZEXT816(0x5555555555555554);\n    uVar2 = SUB168(auVar1 % ZEXT816(param_3),0);\n    if (SUB168(auVar1 / ZEXT816(param_3),0) <= uVar3) {\nLAB_001077cb:\n                    /* WARNING: Subroutine does not return */\n      xalloc_die(param_1,uVar3,uVar2);\n    }\n    uVar3 = (uVar3 >> 1) + 1 + uVar3;\n  }\n  *param_2 = uVar3;\n  xrealloc(param_1,uVar3 * param_3);\n  return;\n}\n\n", 
    "00104380": "\nvoid emit_ancillary_info_constprop_0(void)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  char *pcVar3;\n  long lVar4;\n  undefined **ppuVar5;\n  byte *pbVar6;\n  byte *pbVar7;\n  undefined1 *puVar8;\n  long in_FS_OFFSET;\n  bool bVar9;\n  bool bVar10;\n  undefined *local_98;\n  char *local_90;\n  char *local_88;\n  char *local_80 [5];\n  char *local_58;\n  char *local_50;\n  char *local_48;\n  char *local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  long local_20;\n  \n  pbVar7 = (byte *)0x109106;\n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_80[3] = \"sha256sum\";\n  local_98 = &DAT_0010908c;\n  local_90 = \"test invocation\";\n  local_80[0] = \"Multi-call invocation\";\n  local_80[1] = \"sha224sum\";\n  local_58 = \"sha384sum\";\n  local_48 = \"sha512sum\";\n  local_88 = \"coreutils\";\n  local_80[2] = \"sha2 utilities\";\n  local_80[4] = \"sha2 utilities\";\n  local_50 = \"sha2 utilities\";\n  local_40 = \"sha2 utilities\";\n  local_38 = 0;\n  local_30 = 0;\n  ppuVar5 = &local_98;\n  while( true ) {\n    bVar9 = false;\n    bVar10 = pbVar7 == (byte *)0x0;\n    if (bVar10) break;\n    lVar4 = 5;\n    pbVar6 = &DAT_00109087;\n    do {\n      if (lVar4 == 0) break;\n      lVar4 = lVar4 + -1;\n      bVar9 = *pbVar6 < *pbVar7;\n      bVar10 = *pbVar6 == *pbVar7;\n      pbVar6 = pbVar6 + 1;\n      pbVar7 = pbVar7 + 1;\n    } while (bVar10);\n    if ((!bVar9 && !bVar10) == bVar9) break;\n    pbVar7 = *(byte **)((long)ppuVar5 + 0x20);\n    ppuVar5 = (undefined **)((long)ppuVar5 + 0x10);\n  }\n  puVar8 = *(undefined1 **)((long)ppuVar5 + 0x18);\n  if (puVar8 == (undefined1 *)0x0) {\n    uVar2 = dcgettext(0,\"\\n%s online help: <%s>\\n\",5);\n    __printf_chk(1,uVar2,\"GNU coreutils\",\"https://www.gnu.org/software/coreutils/\");\n    pcVar3 = setlocale(5,(char *)0x0);\n    if (pcVar3 != (char *)0x0) {\n      iVar1 = strncmp(pcVar3,\"en_\",3);\n      if (iVar1 != 0) {\n        puVar8 = &DAT_00109087;\n        goto LAB_0010459e;\n      }\n    }\n    uVar2 = dcgettext(0,\"Full documentation at: <%s%s>\\n\",5);\n    puVar8 = &DAT_00109087;\n    __printf_chk(1,uVar2,\"https://www.gnu.org/software/coreutils/\",&DAT_00109087);\n    pcVar3 = \" invocation\";\n  }\n  else {\n    uVar2 = dcgettext(0,\"\\n%s online help: <%s>\\n\",5);\n    __printf_chk(1,uVar2,\"GNU coreutils\",\"https://www.gnu.org/software/coreutils/\");\n    pcVar3 = setlocale(5,(char *)0x0);\n    if (pcVar3 != (char *)0x0) {\n      iVar1 = strncmp(pcVar3,\"en_\",3);\n      if (iVar1 != 0) {\nLAB_0010459e:\n        uVar2 = dcgettext(0,\"Report %s translation bugs to <https://translationproject.org/team/>\\n\"\n                          ,5);\n        __printf_chk(1,uVar2,&DAT_00109087);\n      }\n    }\n    uVar2 = dcgettext(0,\"Full documentation at: <%s%s>\\n\",5);\n    pcVar3 = \" invocation\";\n    __printf_chk(1,uVar2,\"https://www.gnu.org/software/coreutils/\",&DAT_00109087);\n    if (puVar8 != &DAT_00109087) {\n      pcVar3 = \"\";\n    }\n  }\n  uVar2 = dcgettext(0,\"or available locally via: info \\'(coreutils) %s%s\\'\\n\",5);\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    __printf_chk(1,uVar2,puVar8,pcVar3);\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "001024a0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t __ctype_get_mb_cur_max(void)\n\n{\n  size_t sVar1;\n  \n  sVar1 = (*(code *)PTR___ctype_get_mb_cur_max_0010de68)();\n  return sVar1;\n}\n\n", 
    "001026e0": "\nvoid __cxa_atexit(void)\n\n{\n  (*(code *)PTR___cxa_atexit_0010df88)();\n  return;\n}\n\n", 
    "001038f0": "\nundefined8 get_line(FILE *param_1,long *param_2,int param_3)\n\n{\n  int iVar1;\n  long lVar2;\n  long lVar3;\n  undefined8 uVar4;\n  int *piVar5;\n  long lVar6;\n  \n  lVar2 = *param_2;\n  lVar6 = (long)(param_3 + -1);\n  lVar3 = lVar2;\n  if (*(long *)(prevline + lVar6 * 8) == lVar2) {\n    lVar3 = *(long *)(spareline + lVar6 * 8);\n    *(long *)(spareline + lVar6 * 8) = lVar2;\n    *param_2 = lVar3;\n  }\n  if (lVar3 == 0) {\n    lVar3 = init_linep(param_2);\n  }\n  else {\n    reset_line_isra_0(lVar3 + 0x18);\n  }\n  lVar2 = readlinebuffer_delim(lVar3,param_1,(int)eolchar);\n  if (lVar2 != 0) {\n    *(long *)(line_no + lVar6 * 8) = *(long *)(line_no + lVar6 * 8) + 1;\n    xfields(lVar3);\n    if (*(long *)(prevline + lVar6 * 8) != 0) {\n      check_order(*(long *)(prevline + lVar6 * 8),lVar3,param_3);\n    }\n    *(long *)(prevline + lVar6 * 8) = lVar3;\n    return 1;\n  }\n  iVar1 = ferror_unlocked(param_1);\n  if (iVar1 == 0) {\n    freeline(lVar3);\n    return 0;\n  }\n  uVar4 = dcgettext(0,\"read error\",5);\n  piVar5 = __errno_location();\n                    /* WARNING: Subroutine does not return */\n  error(1,*piVar5,uVar4);\n}\n\n", 
    "001025c0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * memcpy(void *__dest,void *__src,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = (void *)(*(code *)PTR_memcpy_0010def8)();\n  return pvVar1;\n}\n\n", 
    "001074b0": "\nvoid version_etc_ar(void)\n\n{\n  long lVar1;\n  long *in_R8;\n  long lVar2;\n  \n  lVar2 = 0;\n  lVar1 = *in_R8;\n  while (lVar1 != 0) {\n    lVar2 = lVar2 + 1;\n    lVar1 = in_R8[lVar2];\n  }\n  version_etc_arn();\n  return;\n}\n\n", 
    "00104b40": "\nbool hard_locale(int param_1)\n\n{\n  byte *pbVar1;\n  long lVar2;\n  byte *pbVar3;\n  bool bVar4;\n  bool bVar5;\n  byte bVar6;\n  \n  bVar6 = 0;\n  pbVar1 = (byte *)setlocale(param_1,(char *)0x0);\n  bVar4 = true;\n  if (pbVar1 != (byte *)0x0) {\n    bVar4 = *pbVar1 < 0x43;\n    bVar5 = *pbVar1 == 0x43;\n    if (bVar5) {\n      bVar4 = false;\n      bVar5 = pbVar1[1] == 0;\n      if (bVar5) {\n        return false;\n      }\n    }\n    lVar2 = 6;\n    pbVar3 = (byte *)\"POSIX\";\n    do {\n      if (lVar2 == 0) break;\n      lVar2 = lVar2 + -1;\n      bVar4 = *pbVar1 < *pbVar3;\n      bVar5 = *pbVar1 == *pbVar3;\n      pbVar1 = pbVar1 + (ulong)bVar6 * -2 + 1;\n      pbVar3 = pbVar3 + (ulong)bVar6 * -2 + 1;\n    } while (bVar5);\n    bVar4 = (!bVar4 && !bVar5) != bVar4;\n  }\n  return bVar4;\n}\n\n", 
    "001076f0": "\nvoid xcharalloc(void)\n\n{\n  xmalloc();\n  return;\n}\n\n", 
    "001030f0": "\nvoid initseq(undefined8 *param_1)\n\n{\n  *param_1 = 0;\n  param_1[1] = 0;\n  param_1[2] = 0;\n  return;\n}\n\n", 
    "00102630": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * strpbrk(char *__s,char *__accept)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_strpbrk_0010df30)();\n  return pcVar1;\n}\n\n", 
    "00102510": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\n__off_t lseek(int __fd,__off_t __offset,int __whence)\n\n{\n  __off_t _Var1;\n  \n  _Var1 = (*(code *)PTR_lseek_0010dea0)();\n  return _Var1;\n}\n\n", 
    "00107a90": "\nbool bkm_scale(ulong *param_1,int param_2)\n\n{\n  ulong uVar1;\n  bool bVar2;\n  \n  uVar1 = SUB168(ZEXT816((ulong)(long)param_2) * ZEXT816(*param_1),0);\n  bVar2 = SUB168(ZEXT816((ulong)(long)param_2) * ZEXT816(*param_1) >> 0x40,0) != 0;\n  if (bVar2) {\n    uVar1 = 0xffffffffffffffff;\n  }\n  *param_1 = uVar1;\n  return bVar2;\n}\n\n"
}