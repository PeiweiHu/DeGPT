{
    "00104ba0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fflush(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_fflush_00123e88)();\n  return iVar1;\n}\n\n", 
    "00104de0": "\nvoid __sprintf_chk(void)\n\n{\n  (*(code *)PTR___sprintf_chk_00123fa8)();\n  return;\n}\n\n", 
    "001153f0": "\nvoid same_name(undefined8 param_1,undefined8 param_2)\n\n{\n  same_nameat(0xffffff9c,param_1,0xffffff9c,param_2);\n  return;\n}\n\n", 
    "00104cc0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nuintmax_t strtoumax(char *__nptr,char **__endptr,int __base)\n\n{\n  uintmax_t uVar1;\n  \n  uVar1 = (*(code *)PTR_strtoumax_00123f18)();\n  return uVar1;\n}\n\n", 
    "001151b0": "\nvoid quotearg_n_custom(void)\n\n{\n  quotearg_n_custom_mem();\n  return;\n}\n\n", 
    "0010fd00": "\nint default_block_size(void)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = getenv(\"POSIXLY_CORRECT\");\n  return (-(uint)(pcVar1 == (char *)0x0) & 0x200) + 0x200;\n}\n\n", 
    "001260a8": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint setenv(char *__name,char *__value,int __replace)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* setenv@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001262e8": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint unsetenv(char *__name)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* unsetenv@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001261c8": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\n__sighandler_t signal(int __sig,__sighandler_t __handler)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* signal@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00108490": "\nvoid cmp_name_isra_0(undefined8 param_1,undefined8 param_2,code *UNRECOVERED_JUMPTABLE)\n\n{\n                    /* WARNING: Could not recover jumptable at 0x00108490. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*UNRECOVERED_JUMPTABLE)();\n  return;\n}\n\n", 
    "001260a0": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint clock_gettime(clockid_t __clock_id,timespec *__tp)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* clock_gettime@@GLIBC_2.17 */\n  halt_baddata();\n}\n\n", 
    "001088b0": "\nvoid xstrcoll_version(undefined8 *param_1,undefined8 *param_2)\n\n{\n  cmp_version_isra_0(*param_1,*param_2);\n  return;\n}\n\n", 
    "001109a0": "\n__gid_t * getgidbyname(char *param_1)\n\n{\n  char cVar1;\n  __gid_t *p_Var2;\n  int iVar3;\n  group *pgVar4;\n  size_t sVar5;\n  __gid_t *p_Var6;\n  long lVar7;\n  \n  if (group_alist != (__gid_t *)0x0) {\n    cVar1 = *param_1;\n    p_Var6 = group_alist;\n    do {\n      if ((*(char *)(p_Var6 + 4) == cVar1) &&\n         (iVar3 = strcmp((char *)(p_Var6 + 4),param_1), iVar3 == 0)) {\n        return p_Var6;\n      }\n      p_Var6 = *(__gid_t **)(p_Var6 + 2);\n    } while (p_Var6 != (__gid_t *)0x0);\n  }\n  if (nogroup_alist != (__gid_t *)0x0) {\n    cVar1 = *param_1;\n    lVar7 = (long)nogroup_alist;\n    do {\n      if ((*(char *)(lVar7 + 0x10) == cVar1) &&\n         (iVar3 = strcmp((char *)(lVar7 + 0x10),param_1), iVar3 == 0)) {\n        return (__gid_t *)0x0;\n      }\n      lVar7 = *(long *)(lVar7 + 8);\n    } while (lVar7 != 0);\n  }\n  pgVar4 = getgrnam(param_1);\n  sVar5 = strlen(param_1);\n  p_Var6 = (__gid_t *)xmalloc(sVar5 + 0x18 & 0xfffffffffffffff8);\n  strcpy((char *)(p_Var6 + 4),param_1);\n  if (pgVar4 != (group *)0x0) {\n    *p_Var6 = pgVar4->gr_gid;\n    p_Var2 = p_Var6;\n    *(__gid_t **)(p_Var6 + 2) = group_alist;\n    group_alist = p_Var2;\n    return p_Var6;\n  }\n  *(__gid_t **)(p_Var6 + 2) = nogroup_alist;\n  nogroup_alist = p_Var6;\n  return (__gid_t *)0x0;\n}\n\n", 
    "001262e0": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nuintmax_t strtoumax(char *__nptr,char **__endptr,int __base)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strtoumax@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001089d0": "\nundefined8 strcmp_df_extension(long param_1,long param_2)\n\n{\n  char cVar1;\n  char cVar2;\n  undefined8 uVar3;\n  \n  cVar1 = is_directory_isra_0(*(undefined4 *)(param_1 + 0xa8));\n  cVar2 = is_directory_isra_0(*(undefined4 *)(param_2 + 0xa8));\n  if ((cVar2 == '\\x01') || (cVar1 == '\\0')) {\n    if ((cVar1 == '\\x01') || (uVar3 = 1, cVar2 == '\\0')) {\n      uVar3 = cmp_extension_isra_0(param_1);\n      return uVar3;\n    }\n  }\n  else {\n    uVar3 = 0xffffffff;\n  }\n  return uVar3;\n}\n\n", 
    "001261c0": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid lgetfilecon(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n  halt_baddata();\n}\n\n", 
    "0010d590": "\nint c_strncasecmp(undefined *param_1,undefined *param_2,long param_3)\n\n{\n  undefined *puVar1;\n  byte bVar2;\n  byte bVar3;\n  \n  if ((param_1 == param_2) || (param_3 == 0)) {\n    return 0;\n  }\n  puVar1 = param_1 + param_3 + -1;\n  do {\n    bVar2 = c_tolower(*param_1);\n    bVar3 = c_tolower(*param_2);\n    if ((param_1 == puVar1) || (bVar2 == 0)) break;\n    param_1 = param_1 + 1;\n    param_2 = param_2 + 1;\n  } while (bVar2 == bVar3);\n  return (uint)bVar2 - (uint)bVar3;\n}\n\n", 
    "00114bf0": "\nvoid set_custom_quoting(undefined1 *param_1,long param_2,long param_3)\n\n{\n  if ((undefined4 *)param_1 == (undefined4 *)0x0) {\n    param_1 = default_quoting_options;\n  }\n  *(undefined4 *)param_1 = 10;\n  if ((param_2 != 0) && (param_3 != 0)) {\n    *(long *)((long)param_1 + 0x28) = param_2;\n    *(long *)((long)param_1 + 0x30) = param_3;\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "00115ce0": "\nvoid xstrdup(char *param_1)\n\n{\n  size_t sVar1;\n  \n  sVar1 = strlen(param_1);\n  xmemdup(param_1,sVar1 + 1);\n  return;\n}\n\n", 
    "0010d470": "\nbool c_isgraph(int param_1)\n\n{\n  return param_1 - 0x21U < 0x5e;\n}\n\n", 
    "00107c80": "\nundefined8 xstrcoll_df_atime(long param_1,long param_2)\n\n{\n  char cVar1;\n  char cVar2;\n  undefined8 uVar3;\n  \n  cVar1 = is_directory_isra_0(*(undefined4 *)(param_1 + 0xa8));\n  cVar2 = is_directory_isra_0(*(undefined4 *)(param_2 + 0xa8));\n  if ((cVar2 == '\\x01') || (cVar1 == '\\0')) {\n    if ((cVar1 == '\\x01') || (uVar3 = 1, cVar2 == '\\0')) {\n      uVar3 = cmp_atime(param_1);\n      return uVar3;\n    }\n  }\n  else {\n    uVar3 = 0xffffffff;\n  }\n  return uVar3;\n}\n\n", 
    "00104cb0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fseeko(FILE *__stream,__off_t __off,int __whence)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_fseeko_00123f10)();\n  return iVar1;\n}\n\n", 
    "00105ec0": "\nundefined8 getenv_quoting_style(void)\n\n{\n  int iVar1;\n  char *pcVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  undefined8 uStack_18;\n  \n  pcVar2 = getenv(\"QUOTING_STYLE\");\n  if (pcVar2 == (char *)0x0) {\n    return uStack_18;\n  }\n  iVar1 = argmatch(pcVar2,quoting_style_args,quoting_style_vals,4);\n  if (-1 < iVar1) {\n    uVar3 = set_quoting_style(0,*(undefined4 *)(quoting_style_vals + (long)iVar1 * 4));\n    return uVar3;\n  }\n  uVar3 = quote(pcVar2);\n  uVar4 = dcgettext(0,\"ignoring invalid value of environment variable QUOTING_STYLE: %s\",5);\n  uVar3 = error(0,0,uVar4,uVar3,uStack_18);\n  return uVar3;\n}\n\n", 
    "00108b50": "\nvoid xstrcoll_extension(undefined8 param_1,undefined8 param_2)\n\n{\n  cmp_extension_isra_0(param_1,param_2,xstrcoll);\n  return;\n}\n\n", 
    "00104dd0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nushort ** __ctype_b_loc(void)\n\n{\n  ushort **ppuVar1;\n  \n  ppuVar1 = (ushort **)(*(code *)PTR___ctype_b_loc_00123fa0)();\n  return ppuVar1;\n}\n\n", 
    "0010bb90": "\nvoid initialize_exit_failure_constprop_0(void)\n\n{\n  exit_failure = 2;\n  return;\n}\n\n", 
    "001151c0": "\nvoid quotearg_custom(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  quotearg_n_custom(0,param_1,param_2,param_3);\n  return;\n}\n\n", 
    "00110f90": "\nvoid * ambsalign(undefined8 param_1,ulong *param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  ulong __size;\n  ulong uVar1;\n  void *__ptr;\n  ulong uVar2;\n  void *__ptr_00;\n  \n  uVar1 = *param_2;\n  uVar2 = uVar1;\n  __ptr_00 = (void *)0x0;\n  while( true ) {\n    __size = uVar2 + 1;\n    __ptr = realloc(__ptr_00,__size);\n    if (__ptr == (void *)0x0) {\n      free(__ptr_00);\n      return (void *)0x0;\n    }\n    *param_2 = uVar1;\n    uVar2 = mbsalign(param_1,__ptr,__size,param_2,param_3,param_4);\n    if (uVar2 == 0xffffffffffffffff) break;\n    __ptr_00 = __ptr;\n    if (uVar2 < __size) {\n      return __ptr;\n    }\n  }\n  free(__ptr);\n  return (void *)0x0;\n}\n\n", 
    "00108000": "\nundefined8 xstrcoll_df_mtime(long param_1,long param_2)\n\n{\n  char cVar1;\n  char cVar2;\n  undefined8 uVar3;\n  \n  cVar1 = is_directory_isra_0(*(undefined4 *)(param_1 + 0xa8));\n  cVar2 = is_directory_isra_0(*(undefined4 *)(param_2 + 0xa8));\n  if ((cVar2 == '\\x01') || (cVar1 == '\\0')) {\n    if ((cVar1 == '\\x01') || (uVar3 = 1, cVar2 == '\\0')) {\n      uVar3 = cmp_mtime(param_1);\n      return uVar3;\n    }\n  }\n  else {\n    uVar3 = 0xffffffff;\n  }\n  return uVar3;\n}\n\n", 
    "001261d8": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\npasswd * getpwnam(char *__name)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* getpwnam@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001260b8": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fclose(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fclose@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00115910": "\nvoid version_etc_va(void)\n\n{\n  uint uVar1;\n  long *plVar2;\n  long lVar3;\n  uint *in_R8;\n  long lVar4;\n  long in_FS_OFFSET;\n  long local_68 [11];\n  long local_10;\n  \n  lVar4 = 0;\n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  do {\n    uVar1 = *in_R8;\n    if (uVar1 < 0x30) {\n      *in_R8 = uVar1 + 8;\n      lVar3 = *(long *)((ulong)uVar1 + *(long *)(in_R8 + 4));\n      local_68[lVar4] = lVar3;\n    }\n    else {\n      plVar2 = *(long **)(in_R8 + 2);\n      *(long **)(in_R8 + 2) = plVar2 + 1;\n      lVar3 = *plVar2;\n      local_68[lVar4] = lVar3;\n    }\n  } while ((lVar3 != 0) && (lVar4 = lVar4 + 1, lVar4 != 10));\n  version_etc_arn();\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "001261d0": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint dirfd(DIR *__dirp)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* dirfd@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001078d0": "\nvoid cmp_atime(undefined8 *param_1,undefined8 *param_2,code *UNRECOVERED_JUMPTABLE)\n\n{\n  int iVar1;\n  undefined auVar2 [16];\n  undefined auVar3 [16];\n  \n  auVar2 = get_stat_ctime_isra_0(param_1[0xc],param_1[0xd]);\n  auVar3 = get_stat_ctime_isra_0(param_2[0xc],param_2[0xd]);\n  iVar1 = timespec_cmp(SUB168(auVar3,0),SUB168(auVar3 >> 0x40,0),SUB168(auVar2,0),\n                       SUB168(auVar2 >> 0x40,0));\n  if (iVar1 == 0) {\n                    /* WARNING: Could not recover jumptable at 0x00107920. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n    (*UNRECOVERED_JUMPTABLE)(*param_1,*param_2);\n    return;\n  }\n  return;\n}\n\n", 
    "001260b0": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid textdomain(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* textdomain@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001056f0": "\nulong dev_ino_compare(long *param_1,long *param_2)\n\n{\n  if (*param_1 != *param_2) {\n    return 0;\n  }\n  return param_2[1] & 0xffffffffffffff00U | (ulong)(param_1[1] == param_2[1]);\n}\n\n", 
    "0010d480": "\nbool c_islower(int param_1)\n\n{\n  return param_1 - 0x61U < 0x1a;\n}\n\n", 
    "001055d0": "\nbool dot_or_dotdot(char *param_1)\n\n{\n  if (*param_1 != '.') {\n    return false;\n  }\n  return param_1[(ulong)(param_1[1] == '.') + 1] == '\\0' ||\n         param_1[(ulong)(param_1[1] == '.') + 1] == '/';\n}\n\n", 
    "001262f8": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nulong strtoul(char *__nptr,char **__endptr,int __base)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strtoul@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00116cc0": "\nlong _obstack_memory_used(long param_1)\n\n{\n  long *plVar1;\n  long lVar2;\n  \n  lVar2 = 0;\n  for (plVar1 = *(long **)(param_1 + 8); plVar1 != (long *)0x0; plVar1 = (long *)plVar1[1]) {\n    lVar2 = lVar2 + (*plVar1 - (long)plVar1);\n  }\n  return lVar2;\n}\n\n", 
    "0010f300": "\nvoid hash_free(long **param_1)\n\n{\n  void *pvVar1;\n  void *__ptr;\n  long *plVar2;\n  long *plVar3;\n  long *plVar4;\n  long lVar5;\n  \n  plVar4 = *param_1;\n  plVar2 = param_1[1];\n  if ((param_1[8] != (long *)0x0) && (param_1[4] != (long *)0x0)) {\n    if (plVar2 <= plVar4) goto LAB_0010f3ac;\n    do {\n      while (lVar5 = *plVar4, plVar3 = plVar4, lVar5 == 0) {\n        plVar4 = plVar4 + 2;\n        if (plVar2 <= plVar4) goto LAB_0010f36f;\n      }\n      while( true ) {\n        (*(code *)param_1[8])(lVar5);\n        plVar3 = (long *)plVar3[1];\n        if (plVar3 == (long *)0x0) break;\n        lVar5 = *plVar3;\n      }\n      plVar2 = param_1[1];\n      plVar4 = plVar4 + 2;\n    } while (plVar4 < plVar2);\nLAB_0010f36f:\n    plVar4 = *param_1;\n  }\n  if (plVar4 < plVar2) {\n    do {\n      __ptr = (void *)plVar4[1];\n      while (__ptr != (void *)0x0) {\n        pvVar1 = *(void **)((long)__ptr + 8);\n        free(__ptr);\n        __ptr = pvVar1;\n      }\n      plVar4 = plVar4 + 2;\n    } while (plVar4 <= param_1[1] && param_1[1] != plVar4);\n  }\nLAB_0010f3ac:\n  plVar4 = param_1[9];\n  while (plVar4 != (long *)0x0) {\n    plVar2 = (long *)plVar4[1];\n    free(plVar4);\n    plVar4 = plVar2;\n  }\n  free(*param_1);\n  (*(code *)PTR_free_00123fb0)(param_1);\n  return;\n}\n\n", 
    "00107a30": "\nvoid rev_xstrcoll_ctime(undefined8 param_1,undefined8 param_2)\n\n{\n  cmp_ctime(param_2,param_1,xstrcoll);\n  return;\n}\n\n", 
    "00110c30": "\nulong wc_truncate(wchar_t *param_1,ulong param_2)\n\n{\n  int iVar1;\n  ulong uVar2;\n  wchar_t __c;\n  ulong uVar3;\n  \n  __c = *param_1;\n  if (__c == L'\\0') {\n    uVar3 = 0;\n  }\n  else {\n    uVar3 = 0;\n    do {\n      iVar1 = wcwidth(__c);\n      if (iVar1 == -1) {\n        *param_1 = L'\ufffd';\n        uVar2 = uVar3 + 1;\n      }\n      else {\n        uVar2 = (long)iVar1 + uVar3;\n      }\n      if (param_2 < uVar2) break;\n      __c = param_1[1];\n      param_1 = param_1 + 1;\n      uVar3 = uVar2;\n    } while (__c != L'\\0');\n  }\n  *param_1 = L'\\0';\n  return uVar3;\n}\n\n", 
    "0010d360": "\nlong argmatch_to_argument(void *param_1,long *param_2,void *param_3,size_t param_4)\n\n{\n  int iVar1;\n  long lVar2;\n  \n  lVar2 = *param_2;\n  if (lVar2 != 0) {\n    param_2 = param_2 + 1;\n    do {\n      iVar1 = memcmp(param_1,param_3,param_4);\n      if (iVar1 == 0) {\n        return lVar2;\n      }\n      lVar2 = *param_2;\n      param_3 = (void *)((long)param_3 + param_4);\n      param_2 = param_2 + 1;\n    } while (lVar2 != 0);\n  }\n  return lVar2;\n}\n\n", 
    "001262f0": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nuint gnu_dev_minor(ulonglong __dev)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* gnu_dev_minor@@GLIBC_2.3.3 */\n  halt_baddata();\n}\n\n", 
    "001130d0": "\nundefined8 strcaseeq7(long param_1,undefined8 param_2,byte param_3,char param_4)\n\n{\n  char cVar1;\n  byte bVar2;\n  undefined8 uVar3;\n  \n  cVar1 = c_isupper((int)(char)param_3);\n  bVar2 = *(byte *)(param_1 + 7);\n  if (cVar1 != '\\0') {\n    bVar2 = bVar2 & 0xdf;\n  }\n  if (param_3 != bVar2) {\n    return 0;\n  }\n  if (param_3 == 0) {\n    return 1;\n  }\n  uVar3 = strcaseeq8(param_1,param_2,(int)param_4);\n  return uVar3;\n}\n\n", 
    "001131f0": "\nundefined8\nstrcaseeq5(long param_1,undefined8 param_2,byte param_3,char param_4,char param_5,char param_6)\n\n{\n  char cVar1;\n  byte bVar2;\n  undefined8 uVar3;\n  \n  cVar1 = c_isupper((int)(char)param_3);\n  bVar2 = *(byte *)(param_1 + 5);\n  if (cVar1 != '\\0') {\n    bVar2 = bVar2 & 0xdf;\n  }\n  if (param_3 != bVar2) {\n    return 0;\n  }\n  if (param_3 == 0) {\n    return 1;\n  }\n  uVar3 = strcaseeq6(param_1,param_2,(int)param_4,(int)param_5,(int)param_6);\n  return uVar3;\n}\n\n", 
    "00104bc0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint __fxstat(int __ver,int __fildes,stat *__stat_buf)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR___fxstat_00123e98)();\n  return iVar1;\n}\n\n", 
    "00105dd0": "\nundefined  [16] dev_ino_pop(void)\n\n{\n  long lVar1;\n  \n  lVar1 = dev_ino_obstack._24_8_;\n  if (0xf < (ulong)(dev_ino_obstack._24_8_ - dev_ino_obstack._16_8_)) {\n    dev_ino_obstack._24_8_ = dev_ino_obstack._24_8_ + -0x10;\n    return *(undefined (*) [16])(lVar1 + -0x10);\n  }\n                    /* WARNING: Subroutine does not return */\n  __assert_fail(\"dev_ino_size <= obstack_object_size (&dev_ino_obstack)\",\"src/ls.c\",0x403,\n                \"dev_ino_pop\");\n}\n\n", 
    "00104aa0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\n__sighandler_t signal(int __sig,__sighandler_t __handler)\n\n{\n  __sighandler_t p_Var1;\n  \n  p_Var1 = (__sighandler_t)(*(code *)PTR_signal_00123e08)();\n  return p_Var1;\n}\n\n", 
    "00104ce0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nuint gnu_dev_minor(ulonglong __dev)\n\n{\n  uint uVar1;\n  \n  uVar1 = (*(code *)PTR_gnu_dev_minor_00123f28)();\n  return uVar1;\n}\n\n", 
    "00111520": "\nlong memcpy_lowcase(long param_1,long param_2,long param_3)\n\n{\n  __int32_t **pp_Var1;\n  \n  if (param_3 != 0) {\n    param_3 = param_3 + -1;\n    pp_Var1 = __ctype_tolower_loc();\n    do {\n      *(char *)(param_1 + param_3) = (char)(*pp_Var1)[*(byte *)(param_2 + param_3)];\n      param_3 = param_3 + -1;\n    } while (param_3 != -1);\n  }\n  return param_1;\n}\n\n", 
    "001262c8": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * memmove(void *__dest,void *__src,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* memmove@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001261a8": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fputs_unlocked(char *__s,FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fputs_unlocked@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00108390": "\nundefined8 rev_xstrcoll_df_size(undefined8 *param_1,undefined8 *param_2)\n\n{\n  char cVar1;\n  char cVar2;\n  undefined8 uVar3;\n  undefined8 *puVar4;\n  \n  puVar4 = param_2;\n  cVar1 = is_directory_isra_0(*(undefined4 *)(param_1 + 0x15));\n  cVar2 = is_directory_isra_0(*(undefined4 *)(param_2 + 0x15));\n  if ((cVar2 == '\\x01') || (cVar1 == '\\0')) {\n    if ((cVar1 == '\\x01') || (uVar3 = 1, cVar2 == '\\0')) {\n      uVar3 = cmp_size_isra_0(*puVar4,puVar4[9],*param_1,param_1[9],xstrcoll);\n      return uVar3;\n    }\n  }\n  else {\n    uVar3 = 0xffffffff;\n  }\n  return uVar3;\n}\n\n", 
    "001262c0": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * mempcpy(void *__dest,void *__src,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* mempcpy@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00116db0": "\nbool change_env(long param_1)\n\n{\n  int iVar1;\n  long lVar2;\n  \n  lVar2 = param_1 + 9;\n  if (*(char *)(param_1 + 8) == '\\0') {\n    lVar2 = 0;\n  }\n  iVar1 = setenv_TZ(lVar2);\n  if (iVar1 == 0) {\n    tzset();\n  }\n  return iVar1 == 0;\n}\n\n", 
    "001261a0": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint _setjmp(__jmp_buf_tag *__env)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* _setjmp@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001087b0": "\nundefined8 rev_xstrcoll_df_version(undefined8 *param_1,undefined8 *param_2)\n\n{\n  char cVar1;\n  char cVar2;\n  undefined8 uVar3;\n  \n  cVar1 = is_directory_isra_0(*(undefined4 *)(param_1 + 0x15));\n  cVar2 = is_directory_isra_0(*(undefined4 *)(param_2 + 0x15));\n  if ((cVar2 == '\\x01') || (cVar1 == '\\0')) {\n    if ((cVar1 == '\\x01') || (uVar3 = 1, cVar2 == '\\0')) {\n      uVar3 = cmp_version_isra_0(*param_2,*param_1);\n      return uVar3;\n    }\n  }\n  else {\n    uVar3 = 0xffffffff;\n  }\n  return uVar3;\n}\n\n", 
    "00114bd0": "\nundefined4 set_quoting_flags(undefined1 *param_1,undefined4 param_2)\n\n{\n  undefined4 uVar1;\n  \n  if (param_1 == (undefined1 *)0x0) {\n    param_1 = default_quoting_options;\n  }\n  uVar1 = *(undefined4 *)(param_1 + 4);\n  *(undefined4 *)(param_1 + 4) = param_2;\n  return uVar1;\n}\n\n", 
    "00104900": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint __lxstat(int __ver,char *__filename,stat *__stat_buf)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR___lxstat_00123d38)();\n  return iVar1;\n}\n\n", 
    "0010d570": "\nint c_toupper(int param_1)\n\n{\n  if (param_1 - 0x61U < 0x1a) {\n    param_1 = param_1 + -0x20;\n  }\n  return param_1;\n}\n\n", 
    "00107a60": "\nvoid cmp_mtime(undefined8 *param_1,undefined8 *param_2,code *UNRECOVERED_JUMPTABLE)\n\n{\n  int iVar1;\n  undefined auVar2 [16];\n  undefined auVar3 [16];\n  \n  auVar2 = get_stat_ctime_isra_0(param_1[0xe],param_1[0xf]);\n  auVar3 = get_stat_ctime_isra_0(param_2[0xe],param_2[0xf]);\n  iVar1 = timespec_cmp(SUB168(auVar3,0),SUB168(auVar3 >> 0x40,0),SUB168(auVar2,0),\n                       SUB168(auVar2 >> 0x40,0));\n  if (iVar1 == 0) {\n                    /* WARNING: Could not recover jumptable at 0x00107ab0. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n    (*UNRECOVERED_JUMPTABLE)(*param_1,*param_2);\n    return;\n  }\n  return;\n}\n\n", 
    "00106a90": "\nulong needs_quoting(char *param_1)\n\n{\n  size_t sVar1;\n  ulong uVar2;\n  size_t sVar3;\n  long in_FS_OFFSET;\n  char local_22 [2];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  sVar1 = quotearg_buffer(local_22,2,param_1,0xffffffffffffffff,filename_quoting_options);\n  if (*param_1 == local_22[0]) {\n    sVar3 = strlen(param_1);\n    uVar2 = sVar3 & 0xffffffffffffff00 | (ulong)(sVar3 != sVar1);\n  }\n  else {\n    uVar2 = 1;\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00104df5": "\nvoid decode_switches_cold(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "00104cd0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint unsetenv(char *__name)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_unsetenv_00123f20)();\n  return iVar1;\n}\n\n", 
    "00104bb0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * nl_langinfo(nl_item __item)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_nl_langinfo_00123e90)();\n  return pcVar1;\n}\n\n", 
    "001164d0": "\nuint xstrtoumax(byte *param_1,byte **param_2,uint param_3,uintmax_t *param_4,char *param_5)\n\n{\n  byte bVar1;\n  uint uVar2;\n  int *piVar3;\n  ushort **ppuVar4;\n  byte *pbVar5;\n  uintmax_t uVar6;\n  char *pcVar7;\n  int iVar8;\n  undefined8 uVar9;\n  uint uVar10;\n  byte bVar11;\n  long in_FS_OFFSET;\n  byte *local_50;\n  uintmax_t local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (0x24 < param_3) {\n                    /* WARNING: Subroutine does not return */\n    __assert_fail(\"0 <= strtol_base && strtol_base <= 36\",\"lib/xstrtol.c\",0x60,\"xstrtoumax\");\n  }\n  if (param_2 == (byte **)0x0) {\n    param_2 = &local_50;\n  }\n  piVar3 = __errno_location();\n  *piVar3 = 0;\n  bVar11 = *param_1;\n  ppuVar4 = __ctype_b_loc();\n  pbVar5 = param_1;\n  while ((*(byte *)((long)*ppuVar4 + (ulong)bVar11 * 2 + 1) & 0x20) != 0) {\n    bVar11 = pbVar5[1];\n    pbVar5 = pbVar5 + 1;\n  }\n  if (bVar11 != 0x2d) {\n    uVar6 = strtoumax((char *)param_1,(char **)param_2,param_3);\n    pbVar5 = *param_2;\n    local_48 = uVar6;\n    if (pbVar5 != param_1) {\n      if (*piVar3 == 0) {\n        uVar10 = 0;\n      }\n      else {\n        uVar10 = 1;\n        if (*piVar3 != 0x22) goto LAB_001165cb;\n      }\n      if ((param_5 != (char *)0x0) && (bVar11 = *pbVar5, bVar11 != 0)) {\n        iVar8 = (int)(char)bVar11;\nLAB_0011660c:\n        pcVar7 = strchr(param_5,iVar8);\n        if (pcVar7 == (char *)0x0) {\nswitchD_00116660_caseD_43:\n          uVar10 = uVar10 | 2;\n          *param_4 = local_48;\n          goto LAB_00116592;\n        }\n        switch(bVar11) {\n        case 0x45:\n        case 0x47:\n        case 0x4b:\n        case 0x4d:\n        case 0x50:\n        case 0x54:\n        case 0x59:\n        case 0x5a:\n        case 0x67:\n        case 0x6b:\n        case 0x6d:\n        case 0x74:\n          pcVar7 = strchr(param_5,0x30);\n          if (pcVar7 == (char *)0x0) goto switchD_00116636_caseD_46;\n          bVar1 = pbVar5[1];\n          if (bVar1 == 0x44) {\n            iVar8 = 2;\n            uVar9 = 1000;\n          }\n          else if (bVar1 == 0x69) {\n            uVar9 = 0x400;\n            iVar8 = (pbVar5[2] == 0x42) + 1 + (uint)(pbVar5[2] == 0x42);\n          }\n          else {\n            iVar8 = (bVar1 == 0x42) + 1;\n            uVar9 = 0x400;\n            if (bVar1 == 0x42) {\n              uVar9 = 1000;\n            }\n          }\n          break;\n        default:\nswitchD_00116636_caseD_46:\n          iVar8 = 1;\n          uVar9 = 0x400;\n        }\n        switch(bVar11) {\n        case 0x42:\n          uVar2 = bkm_scale(&local_48,0x400);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n          break;\n        default:\n          goto switchD_00116660_caseD_43;\n        case 0x45:\n          uVar2 = bkm_scale_by_power(&local_48,uVar9,6);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n          break;\n        case 0x47:\n        case 0x67:\n          uVar2 = bkm_scale_by_power(&local_48,uVar9,3);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n          break;\n        case 0x4b:\n        case 0x6b:\n          uVar2 = bkm_scale_by_power(&local_48,uVar9,1);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n          break;\n        case 0x4d:\n        case 0x6d:\n          uVar2 = bkm_scale_by_power(&local_48,uVar9,2);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n          break;\n        case 0x50:\n          uVar2 = bkm_scale_by_power(&local_48,uVar9,5);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n          break;\n        case 0x54:\n        case 0x74:\n          uVar2 = bkm_scale_by_power(&local_48,uVar9,4);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n          break;\n        case 0x59:\n          uVar2 = bkm_scale_by_power(&local_48,uVar9,8);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n          break;\n        case 0x5a:\n          uVar2 = bkm_scale_by_power(&local_48,uVar9,7);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n          break;\n        case 0x62:\n          uVar2 = bkm_scale(&local_48,0x200);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n          break;\n        case 99:\n          break;\n        case 0x77:\n          uVar2 = bkm_scale(&local_48,2);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n        }\n        uVar6 = local_48;\n        *param_2 = pbVar5 + iVar8;\n        if (pbVar5[iVar8] != 0) {\n          uVar10 = uVar10 | 2;\n        }\n      }\n      *param_4 = uVar6;\n      goto LAB_00116592;\n    }\n    if ((param_5 != (char *)0x0) && (bVar11 = *param_1, bVar11 != 0)) {\n      iVar8 = (int)(char)bVar11;\n      pcVar7 = strchr(param_5,iVar8);\n      if (pcVar7 != (char *)0x0) {\n        local_48 = 1;\n        uVar10 = 0;\n        goto LAB_0011660c;\n      }\n    }\n  }\nLAB_001165cb:\n  uVar10 = 4;\nLAB_00116592:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar10;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "001175c0": "\nint rpl_fseeko(FILE *param_1,__off_t param_2,int param_3)\n\n{\n  int iVar1;\n  __off_t _Var2;\n  \n  if (((param_1->_IO_read_end == param_1->_IO_read_ptr) &&\n      (param_1->_IO_write_ptr == param_1->_IO_write_base)) &&\n     (param_1->_IO_save_base == (char *)0x0)) {\n    iVar1 = fileno(param_1);\n    _Var2 = lseek(iVar1,param_2,param_3);\n    if (_Var2 == -1) {\n      iVar1 = -1;\n    }\n    else {\n      param_1->_flags = param_1->_flags & 0xffffffef;\n      param_1->_offset = _Var2;\n      iVar1 = 0;\n    }\n    return iVar1;\n  }\n  iVar1 = fseeko(param_1,param_2,param_3);\n  return iVar1;\n}\n\n", 
    "00104df0": "\nvoid print_long_format_cold(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "001176e0": "\nint stat(char *__file,stat *__buf)\n\n{\n  int iVar1;\n  \n  iVar1 = __xstat(1,__file,__buf);\n  return iVar1;\n}\n\n", 
    "001261b8": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * calloc(size_t __nmemb,size_t __size)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* calloc@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001262d8": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fseeko(FILE *__stream,__off_t __off,int __whence)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fseeko@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00108260": "\nvoid rev_strcmp_size(undefined8 *param_1,undefined8 *param_2)\n\n{\n  cmp_size_isra_0(*param_2,param_2[9],*param_1,param_1[9],PTR_strcmp_00123fc8);\n  return;\n}\n\n", 
    "001261b0": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint ferror_unlocked(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* ferror_unlocked@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001087a0": "\nint cmp_version_isra_0(char *param_1,char *param_2)\n\n{\n  char cVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  long lVar6;\n  size_t sVar7;\n  size_t __n;\n  long in_FS_OFFSET;\n  char *pcStack_40;\n  char *pcStack_38;\n  long lStack_30;\n  \n  lStack_30 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar3 = strcmp(param_1,param_2);\n  if (iVar3 == 0) goto LAB_0010e5e9;\n  cVar1 = *param_1;\n  if (cVar1 == '\\0') {\nLAB_0010e6e8:\n    iVar3 = -1;\n    goto LAB_0010e5e9;\n  }\n  cVar2 = *param_2;\n  if (cVar2 == '\\0') {\nLAB_0010e5e3:\n    iVar3 = 1;\n    goto LAB_0010e5e9;\n  }\n  if ((cVar1 == '.') && (param_1[1] == '\\0')) goto LAB_0010e6e8;\n  if ((*param_2 == '.') && (param_2[1] == '\\0')) goto LAB_0010e5e3;\n  if (((*param_1 == '.') && (param_1[1] == '.')) && (param_1[2] == '\\0')) goto LAB_0010e6e8;\n  if (((*param_2 == '.') && (param_2[1] == '.')) && (param_2[2] == '\\0')) goto LAB_0010e5e3;\n  if ((cVar2 != '.') && (cVar1 == '.')) goto LAB_0010e6e8;\n  if ((cVar1 != '.') && (cVar2 == '.')) goto LAB_0010e5e3;\n  if ((cVar1 == '.') && (cVar2 == '.')) {\n    param_1 = param_1 + 1;\n    param_2 = param_2 + 1;\n  }\n  pcStack_40 = param_1;\n  pcStack_38 = param_2;\n  lVar5 = match_suffix(&pcStack_40);\n  lVar6 = match_suffix(&pcStack_38);\n  if (lVar5 == 0) {\n    __n = (long)pcStack_40 - (long)param_1;\n    if (lVar6 != 0) goto LAB_0010e696;\nLAB_0010e705:\n    sVar7 = (long)pcStack_38 - (long)param_2;\n  }\n  else {\n    __n = lVar5 - (long)param_1;\n    if (lVar6 == 0) {\n      sVar7 = (long)pcStack_38 - (long)param_2;\n    }\n    else {\nLAB_0010e696:\n      sVar7 = lVar6 - (long)param_2;\n    }\n    if ((__n == sVar7) && (iVar4 = strncmp(param_1,param_2,__n), iVar4 == 0)) {\n      __n = (long)pcStack_40 - (long)param_1;\n      goto LAB_0010e705;\n    }\n  }\n  iVar4 = verrevcmp(param_1,__n,param_2,sVar7);\n  if (iVar4 != 0) {\n    iVar3 = iVar4;\n  }\nLAB_0010e5e9:\n  if (lStack_30 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return iVar3;\n}\n\n", 
    "001088c0": "\nvoid cmp_extension_isra_0(char **param_1,char **param_2,code *UNRECOVERED_JUMPTABLE)\n\n{\n  int iVar1;\n  char *pcVar2;\n  char *pcVar3;\n  \n  pcVar2 = strrchr(*param_1,0x2e);\n  pcVar3 = strrchr(*param_2,0x2e);\n  if (pcVar3 == (char *)0x0) {\n    pcVar3 = \"\";\n  }\n  if (pcVar2 == (char *)0x0) {\n    pcVar2 = \"\";\n  }\n  iVar1 = (*UNRECOVERED_JUMPTABLE)(pcVar2,pcVar3);\n  if (iVar1 == 0) {\n                    /* WARNING: Could not recover jumptable at 0x00108927. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n    (*UNRECOVERED_JUMPTABLE)(*param_1,*param_2);\n    return;\n  }\n  return;\n}\n\n", 
    "001262d0": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid error(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* error@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001054d0": "\nvoid _start(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 unaff_retaddr;\n  undefined auStack_8 [8];\n  \n  (*(code *)PTR___libc_start_main_00123fc0)\n            (main,unaff_retaddr,&stack0x00000008,__libc_csu_init,__libc_csu_fini,param_3,auStack_8);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n", 
    "00115bb0": "\nvoid x2nrealloc(long param_1,ulong *param_2,ulong param_3)\n\n{\n  undefined auVar1 [16];\n  ulong uVar2;\n  ulong uVar3;\n  \n  uVar3 = *param_2;\n  if (param_1 == 0) {\n    if (uVar3 == 0) {\n      uVar3 = (ulong)(0x80 < param_3) +\n              SUB168((ZEXT816(0) << 0x40 | ZEXT816(0x80)) / ZEXT816(param_3),0);\n    }\n    uVar2 = (ulong)(SUB168(ZEXT816(uVar3) * ZEXT816(param_3) >> 0x40,0) != 0);\n    if ((SUB168(ZEXT816(uVar3) * ZEXT816(param_3),0) < 0) || (uVar2 != 0)) goto LAB_00115c0b;\n  }\n  else {\n    auVar1 = ZEXT816(0) << 0x40 | ZEXT816(0x5555555555555554);\n    uVar2 = SUB168(auVar1 % ZEXT816(param_3),0);\n    if (SUB168(auVar1 / ZEXT816(param_3),0) <= uVar3) {\nLAB_00115c0b:\n                    /* WARNING: Subroutine does not return */\n      xalloc_die(param_1,uVar3,uVar2);\n    }\n    uVar3 = (uVar3 >> 1) + 1 + uVar3;\n  }\n  *param_2 = uVar3;\n  xrealloc(param_1,uVar3 * param_3);\n  return;\n}\n\n", 
    "0010d460": "\nbool c_isdigit(int param_1)\n\n{\n  return param_1 - 0x30U < 10;\n}\n\n", 
    "00107a50": "\nvoid xstrcoll_ctime(undefined8 param_1,undefined8 param_2)\n\n{\n  cmp_ctime(param_1,param_2,xstrcoll);\n  return;\n}\n\n", 
    "00104da0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint iswprint(wint_t __wc)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_iswprint_00123f88)();\n  return iVar1;\n}\n\n", 
    "001176b0": "\nvoid __libc_csu_fini(void)\n\n{\n  return;\n}\n\n", 
    "00105fb0": "\nundefined8 set_line_length(undefined8 param_1)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  long in_FS_OFFSET;\n  undefined8 local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = xstrtoumax(param_1,0,0,&local_18,&DAT_0011991e);\n  if (iVar1 == 0) {\n    line_length = local_18;\n    uVar2 = 1;\n  }\n  else if (iVar1 == 1) {\n    line_length = 0xffffffffffffffff;\n    uVar2 = 1;\n  }\n  else {\n    uVar2 = 0;\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "001164a0": "\nuint bkm_scale_by_power(undefined8 param_1,uint param_2,int param_3)\n\n{\n  uint uVar1;\n  uint uVar2;\n  ulong uVar3;\n  \n  uVar3 = (ulong)param_2;\n  param_3 = param_3 + -1;\n  uVar2 = 0;\n  do {\n    uVar1 = bkm_scale(param_1,uVar3 & 0xffffffff);\n    param_3 = param_3 + -1;\n    uVar2 = uVar2 | uVar1;\n  } while (param_3 != -1);\n  return uVar2;\n}\n\n", 
    "00108210": "\nvoid strcmp_size(undefined8 *param_1,undefined8 *param_2)\n\n{\n  cmp_size_isra_0(*param_1,param_1[9],*param_2,param_2[9],PTR_strcmp_00123fc8);\n  return;\n}\n\n", 
    "00106030": "\nundefined8 abmon_init(long param_1)\n\n{\n  bool bVar1;\n  char *__s;\n  char *pcVar2;\n  ulong uVar3;\n  undefined8 uVar4;\n  ulong uVar5;\n  long lVar6;\n  ulong uVar7;\n  int __item;\n  long in_FS_OFFSET;\n  ulong local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  uVar7 = 0xc;\n  do {\n    __item = 0x2000e;\n    uVar5 = 0;\n    lVar6 = param_1;\n    do {\n      local_48 = uVar7;\n      __s = nl_langinfo(__item);\n      pcVar2 = strchr(__s,0x25);\n      if ((pcVar2 != (char *)0x0) || (uVar3 = mbsalign(__s,lVar6,0x80,&local_48,0,0), 0x7f < uVar3))\n      {\n        uVar4 = 0;\n        goto LAB_001060e2;\n      }\n      if (uVar5 < local_48) {\n        uVar5 = local_48;\n      }\n      __item = __item + 1;\n      lVar6 = lVar6 + 0x80;\n    } while (__item != 0x2001a);\n    bVar1 = uVar7 <= uVar5;\n    uVar7 = uVar5;\n    if (bVar1) {\n      uVar4 = 1;\nLAB_001060e2:\n      if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n        __stack_chk_fail();\n      }\n      return uVar4;\n    }\n  } while( true );\n}\n\n", 
    "0010de40": "\nchar * last_component(char *param_1)\n\n{\n  bool bVar1;\n  char *pcVar2;\n  char cVar3;\n  \n  cVar3 = *param_1;\n  while (cVar3 == '/') {\n    pcVar2 = param_1 + 1;\n    param_1 = param_1 + 1;\n    cVar3 = *pcVar2;\n  }\n  if (cVar3 != '\\0') {\n    bVar1 = false;\n    pcVar2 = param_1;\n    do {\n      while (cVar3 != '/') {\n        if (bVar1) {\n          bVar1 = false;\n          param_1 = pcVar2;\n        }\n        cVar3 = pcVar2[1];\n        pcVar2 = pcVar2 + 1;\n        if (cVar3 == '\\0') {\n          return param_1;\n        }\n      }\n      cVar3 = pcVar2[1];\n      pcVar2 = pcVar2 + 1;\n      bVar1 = true;\n    } while (cVar3 != '\\0');\n  }\n  return param_1;\n}\n\n", 
    "001262a8": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __printf_chk(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __printf_chk@@GLIBC_2.3.4 */\n  halt_baddata();\n}\n\n", 
    "001069f0": "\nchar * make_link_name(char *param_1,char *param_2)\n\n{\n  size_t __n;\n  size_t sVar1;\n  char *pcVar2;\n  char *__dest;\n  \n  if (param_2 == (char *)0x0) {\n    pcVar2 = (char *)0x0;\n  }\n  else {\n    if ((*param_2 == '/') || (__n = dir_len(), __n == 0)) {\n      pcVar2 = (char *)xstrdup(param_2);\n      return pcVar2;\n    }\n    sVar1 = strlen(param_2);\n    pcVar2 = (char *)xmalloc(__n + 2 + sVar1);\n    if (param_1[__n - 1] != '/') {\n      __n = __n + 1;\n    }\n    __dest = stpncpy(pcVar2,param_1,__n);\n    strcpy(__dest,param_2);\n  }\n  return pcVar2;\n}\n\n", 
    "00107a00": "\nvoid rev_strcmp_ctime(undefined8 param_1,undefined8 param_2)\n\n{\n  cmp_ctime(param_2,param_1,PTR_strcmp_00123fc8);\n  return;\n}\n\n", 
    "001046f0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid free(void *__ptr)\n\n{\n  (*(code *)PTR_free_00123fb0)();\n  return;\n}\n\n", 
    "001262a0": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * setlocale(int __category,char *__locale)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* setlocale@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00107b20": "\nuint is_directory_isra_0(int param_1,undefined8 param_2,uint param_3)\n\n{\n  uint in_EAX;\n  \n  return in_EAX & 0xffffff00 | (uint)(param_1 == 3) | param_3 & 0xffffff00 | (uint)(param_1 == 9);\n}\n\n", 
    "0010d550": "\nint c_tolower(int param_1)\n\n{\n  if (param_1 - 0x41U < 0x1a) {\n    param_1 = param_1 + 0x20;\n  }\n  return param_1;\n}\n\n", 
    "0010f850": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nlong hash_delete(long param_1,undefined8 param_2)\n\n{\n  void *pvVar1;\n  void *__ptr;\n  char cVar2;\n  long lVar3;\n  ulong uVar4;\n  ulong uVar5;\n  float *pfVar6;\n  long in_FS_OFFSET;\n  float fVar7;\n  float fVar8;\n  long *local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  lVar3 = hash_find_entry(param_1,param_2,&local_28,1);\n  if ((lVar3 == 0) || (*(long *)(param_1 + 0x20) = *(long *)(param_1 + 0x20) + -1, *local_28 != 0))\n  goto LAB_0010f893;\n  uVar4 = *(long *)(param_1 + 0x18) - 1;\n  *(ulong *)(param_1 + 0x18) = uVar4;\n  if ((long)uVar4 < 0) {\n    uVar5 = *(ulong *)(param_1 + 0x10);\n    fVar7 = (float)(uVar4 >> 1 | (ulong)((uint)uVar4 & 1));\n    pfVar6 = *(float **)(param_1 + 0x28);\n    fVar7 = fVar7 + fVar7;\n    if ((long)uVar5 < 0) goto LAB_0010f9ca;\nLAB_0010f8e4:\n    fVar8 = (float)uVar5;\n  }\n  else {\n    pfVar6 = *(float **)(param_1 + 0x28);\n    fVar7 = (float)uVar4;\n    uVar5 = *(ulong *)(param_1 + 0x10);\n    if (-1 < (long)uVar5) goto LAB_0010f8e4;\nLAB_0010f9ca:\n    fVar8 = (float)(uVar5 >> 1 | (ulong)((uint)uVar5 & 1));\n    fVar8 = fVar8 + fVar8;\n  }\n  if (fVar7 < fVar8 * *pfVar6) {\n    check_tuning_isra_0(param_1 + 0x28);\n    uVar4 = *(ulong *)(param_1 + 0x10);\n    pfVar6 = *(float **)(param_1 + 0x28);\n    if ((long)uVar4 < 0) {\n      fVar7 = (float)(uVar4 >> 1 | (ulong)((uint)uVar4 & 1));\n      fVar7 = fVar7 + fVar7;\n    }\n    else {\n      fVar7 = (float)uVar4;\n    }\n    uVar4 = *(ulong *)(param_1 + 0x18);\n    if ((long)uVar4 < 0) {\n      fVar8 = (float)(uVar4 >> 1 | (ulong)((uint)uVar4 & 1));\n      fVar8 = fVar8 + fVar8;\n    }\n    else {\n      fVar8 = (float)uVar4;\n    }\n    if (fVar8 < *pfVar6 * fVar7) {\n      fVar7 = fVar7 * pfVar6[1];\n      if (*(char *)(pfVar6 + 4) == '\\0') {\n        fVar7 = fVar7 * pfVar6[2];\n      }\n      if (_DAT_0011bf6c <= fVar7) {\n        uVar4 = (long)(fVar7 - _DAT_0011bf6c) ^ 0x8000000000000000;\n      }\n      else {\n        uVar4 = (ulong)fVar7;\n      }\n      cVar2 = hash_rehash(param_1,uVar4);\n      if (cVar2 == '\\0') {\n        __ptr = *(void **)(param_1 + 0x48);\n        while (__ptr != (void *)0x0) {\n          pvVar1 = *(void **)((long)__ptr + 8);\n          free(__ptr);\n          __ptr = pvVar1;\n        }\n        *(undefined8 *)(param_1 + 0x48) = 0;\n      }\n    }\n  }\nLAB_0010f893:\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return lVar3;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00107d60": "\nundefined8 strcmp_df_ctime(long param_1,long param_2)\n\n{\n  char cVar1;\n  char cVar2;\n  undefined8 uVar3;\n  \n  cVar1 = is_directory_isra_0(*(undefined4 *)(param_1 + 0xa8));\n  cVar2 = is_directory_isra_0(*(undefined4 *)(param_2 + 0xa8));\n  if ((cVar2 == '\\x01') || (cVar1 == '\\0')) {\n    if ((cVar1 == '\\x01') || (uVar3 = 1, cVar2 == '\\0')) {\n      uVar3 = cmp_ctime(param_1);\n      return uVar3;\n    }\n  }\n  else {\n    uVar3 = 0xffffffff;\n  }\n  return uVar3;\n}\n\n", 
    "00104a90": "\nvoid lgetfilecon(void)\n\n{\n  (*(code *)PTR_lgetfilecon_00123e00)();\n  return;\n}\n\n", 
    "0010e760": "\nvoid gettime(timespec *param_1)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  timeval local_28;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = clock_gettime(0,param_1);\n  if (iVar1 != 0) {\n    gettimeofday(&local_28,(__timezone_ptr_t)0x0);\n    param_1->tv_sec = local_28.tv_sec;\n    param_1->tv_nsec = local_28.tv_usec * 1000;\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "001176c0": "\nint atexit(__func *__func)\n\n{\n  int iVar1;\n  \n  iVar1 = __cxa_atexit(__func,0,__dso_handle);\n  return iVar1;\n}\n\n", 
    "00108c30": "\nvoid set_normal_color(void)\n\n{\n  char cVar1;\n  \n  if (print_with_color == '\\0') {\n    return;\n  }\n  cVar1 = is_colored(4);\n  if (cVar1 == '\\0') {\n    return;\n  }\n  put_indicator_isra_0(color_indicator);\n  put_indicator_isra_0(0x1240a0);\n  put_indicator_isra_0(0x124070);\n  return;\n}\n\n", 
    "0010ef40": "\nlong hash_get_first(long **param_1)\n\n{\n  long lVar1;\n  long *plVar2;\n  \n  if (param_1[4] == (long *)0x0) {\n    return 0;\n  }\n  plVar2 = *param_1;\n  if (param_1[1] <= plVar2) {\n    lVar1 = hash_get_first_cold();\n    return lVar1;\n  }\n  do {\n    if (*plVar2 != 0) {\n      return *plVar2;\n    }\n    plVar2 = plVar2 + 2;\n  } while (plVar2 < param_1[1]);\n  lVar1 = hash_get_first_cold();\n  return lVar1;\n}\n\n", 
    "001262b8": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t strftime(char *__s,size_t __maxsize,char *__format,tm *__tp)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strftime@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010df70": "\nulong seen_file(long param_1,undefined8 param_2,undefined8 *param_3)\n\n{\n  ulong uVar1;\n  long in_FS_OFFSET;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  uVar1 = 0;\n  if (param_1 != 0) {\n    local_20 = param_3[1];\n    local_18 = *param_3;\n    local_28 = param_2;\n    uVar1 = hash_lookup(param_1,&local_28);\n    uVar1 = uVar1 & 0xffffffffffffff00 | (ulong)(uVar1 != 0);\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar1;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00116a90": "\nvoid print_and_abort(void)\n\n{\n  undefined8 uVar1;\n  \n  uVar1 = dcgettext(0,\"memory exhausted\",5);\n  __fprintf_chk(stderr,1,\"%s\\n\",uVar1);\n                    /* WARNING: Subroutine does not return */\n  exit(exit_failure);\n}\n\n", 
    "00115cb0": "\nvoid xmemdup(void *param_1,size_t param_2)\n\n{\n  void *__dest;\n  \n  __dest = (void *)xmalloc(param_2);\n  memcpy(__dest,param_1,param_2);\n  return;\n}\n\n", 
    "001262b0": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\ntime_t timegm(tm *__tp)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* timegm@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00107b10": "\nvoid xstrcoll_mtime(undefined8 param_1,undefined8 param_2)\n\n{\n  cmp_mtime(param_1,param_2,xstrcoll);\n  return;\n}\n\n", 
    "00116fe0": "\nvoid tzfree(long *param_1)\n\n{\n  long *plVar1;\n  \n  if (param_1 == (long *)0x1) {\n    return;\n  }\n  if (param_1 != (long *)0x0) {\n    do {\n      plVar1 = (long *)*param_1;\n      free(param_1);\n      param_1 = plVar1;\n    } while (plVar1 != (long *)0x0);\n  }\n  return;\n}\n\n", 
    "0010d440": "\nulong c_iscntrl(uint param_1)\n\n{\n  ulong in_RAX;\n  \n  if ((int)param_1 < 0x20) {\n    return (ulong)(~param_1 >> 0x1f);\n  }\n  return in_RAX & 0xffffffffffffff00 | (ulong)(param_1 == 0x7f);\n}\n\n", 
    "00104a80": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * calloc(size_t __nmemb,size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = (void *)(*(code *)PTR_calloc_00123df8)();\n  return pvVar1;\n}\n\n", 
    "00107f90": "\nundefined8 rev_xstrcoll_df_mtime(long param_1,long param_2)\n\n{\n  char cVar1;\n  char cVar2;\n  long lVar3;\n  undefined8 uVar4;\n  \n  lVar3 = param_2;\n  cVar1 = is_directory_isra_0(*(undefined4 *)(param_1 + 0xa8));\n  cVar2 = is_directory_isra_0(*(undefined4 *)(param_2 + 0xa8));\n  if ((cVar2 == '\\x01') || (cVar1 == '\\0')) {\n    if ((cVar1 == '\\x01') || (uVar4 = 1, cVar2 == '\\0')) {\n      uVar4 = cmp_mtime(lVar3,param_1,xstrcoll);\n      return uVar4;\n    }\n  }\n  else {\n    uVar4 = 0xffffffff;\n  }\n  return uVar4;\n}\n\n", 
    "0010e890": "\nulong next_prime(ulong param_1)\n\n{\n  char cVar1;\n  ulong uVar2;\n  \n  uVar2 = 10;\n  if (9 < param_1) {\n    uVar2 = param_1;\n  }\n  uVar2 = uVar2 | 1;\n  while ((uVar2 != 0xffffffffffffffff && (cVar1 = is_prime(uVar2), cVar1 == '\\0'))) {\n    uVar2 = uVar2 + 2;\n  }\n  return uVar2;\n}\n\n", 
    "00104dc0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\n__int32_t ** __ctype_tolower_loc(void)\n\n{\n  __int32_t **pp_Var1;\n  \n  pp_Var1 = (__int32_t **)(*(code *)PTR___ctype_tolower_loc_00123f98)();\n  return pp_Var1;\n}\n\n", 
    "00104ca0": "\nvoid error(void)\n\n{\n  (*(code *)PTR_error_00123f08)();\n  return;\n}\n\n", 
    "00110750": "\n__uid_t * getuser(__uid_t param_1)\n\n{\n  __uid_t *p_Var1;\n  passwd *ppVar2;\n  size_t sVar3;\n  __uid_t *p_Var4;\n  ulong uVar5;\n  char *__s;\n  \n  p_Var4 = user_alist;\n  if (user_alist != (__uid_t *)0x0) {\n    do {\n      if (*p_Var4 == param_1) goto LAB_0011077d;\n      p_Var4 = *(__uid_t **)(p_Var4 + 2);\n    } while (p_Var4 != (__uid_t *)0x0);\n  }\n  __s = \"\";\n  ppVar2 = getpwuid(param_1);\n  uVar5 = 0x18;\n  if (ppVar2 != (passwd *)0x0) {\n    __s = ppVar2->pw_name;\n    sVar3 = strlen(__s);\n    uVar5 = sVar3 + 0x18 & 0xfffffffffffffff8;\n  }\n  p_Var4 = (__uid_t *)xmalloc(uVar5);\n  *p_Var4 = param_1;\n  strcpy((char *)(p_Var4 + 4),__s);\n  p_Var1 = p_Var4;\n  *(__uid_t **)(p_Var4 + 2) = user_alist;\n  user_alist = p_Var1;\nLAB_0011077d:\n  p_Var1 = (__uid_t *)0x0;\n  if (*(char *)(p_Var4 + 4) != '\\0') {\n    p_Var1 = p_Var4 + 4;\n  }\n  return p_Var1;\n}\n\n", 
    "00108230": "\nvoid rev_xstrcoll_size(undefined8 *param_1,undefined8 *param_2)\n\n{\n  cmp_size_isra_0(*param_2,param_2[9],*param_1,param_1[9],xstrcoll);\n  return;\n}\n\n", 
    "00108590": "\nundefined8 strcmp_df_name(undefined8 *param_1,undefined8 *param_2)\n\n{\n  char cVar1;\n  char cVar2;\n  undefined8 uVar3;\n  \n  cVar1 = is_directory_isra_0(*(undefined4 *)(param_1 + 0x15));\n  cVar2 = is_directory_isra_0(*(undefined4 *)(param_2 + 0x15));\n  if ((cVar2 == '\\x01') || (cVar1 == '\\0')) {\n    if ((cVar1 == '\\x01') || (uVar3 = 1, cVar2 == '\\0')) {\n      uVar3 = cmp_name_isra_0(*param_1,*param_2,PTR_strcmp_00123fc8);\n      return uVar3;\n    }\n  }\n  else {\n    uVar3 = 0xffffffff;\n  }\n  return uVar3;\n}\n\n", 
    "001089b0": "\nvoid rev_strcmp_extension(undefined8 param_1,undefined8 param_2)\n\n{\n  cmp_extension_isra_0(param_2,param_1,PTR_strcmp_00123fc8);\n  return;\n}\n\n", 
    "00114cb0": "\nundefined8\nquotearg_alloc_mem(undefined8 param_1,undefined8 param_2,long *param_3,undefined1 *param_4)\n\n{\n  int iVar1;\n  int *piVar2;\n  long lVar3;\n  undefined8 uVar4;\n  uint uVar5;\n  \n  if ((undefined4 *)param_4 == (undefined4 *)0x0) {\n    param_4 = default_quoting_options;\n  }\n  piVar2 = __errno_location();\n  iVar1 = *piVar2;\n  uVar5 = (uint)(param_3 == (long *)0x0) | *(uint *)((long)param_4 + 4);\n  lVar3 = quotearg_buffer_restyled\n                    (0,0,param_1,param_2,*(undefined4 *)param_4,uVar5,\n                     (undefined4 *)((long)param_4 + 8),*(undefined8 *)((long)param_4 + 0x28),\n                     *(undefined8 *)((long)param_4 + 0x30));\n  uVar4 = xcharalloc(lVar3 + 1);\n  quotearg_buffer_restyled\n            (uVar4,lVar3 + 1,param_1,param_2,*(undefined4 *)param_4,uVar5,\n             (undefined4 *)((long)param_4 + 8),*(undefined8 *)((long)param_4 + 0x28),\n             *(undefined8 *)((long)param_4 + 0x30));\n  *piVar2 = iVar1;\n  if (param_3 != (long *)0x0) {\n    *param_3 = lVar3;\n  }\n  return uVar4;\n}\n\n", 
    "00115fe0": "\nuint xstrtoul(byte *param_1,byte **param_2,uint param_3,ulong *param_4,char *param_5)\n\n{\n  byte bVar1;\n  uint uVar2;\n  int *piVar3;\n  ushort **ppuVar4;\n  byte *pbVar5;\n  ulong uVar6;\n  char *pcVar7;\n  int iVar8;\n  undefined8 uVar9;\n  uint uVar10;\n  byte bVar11;\n  long in_FS_OFFSET;\n  byte *local_50;\n  ulong local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (0x24 < param_3) {\n                    /* WARNING: Subroutine does not return */\n    __assert_fail(\"0 <= strtol_base && strtol_base <= 36\",\"lib/xstrtol.c\",0x60,\"xstrtoul\");\n  }\n  if (param_2 == (byte **)0x0) {\n    param_2 = &local_50;\n  }\n  piVar3 = __errno_location();\n  *piVar3 = 0;\n  bVar11 = *param_1;\n  ppuVar4 = __ctype_b_loc();\n  pbVar5 = param_1;\n  while ((*(byte *)((long)*ppuVar4 + (ulong)bVar11 * 2 + 1) & 0x20) != 0) {\n    bVar11 = pbVar5[1];\n    pbVar5 = pbVar5 + 1;\n  }\n  if (bVar11 != 0x2d) {\n    uVar6 = strtoul((char *)param_1,(char **)param_2,param_3);\n    pbVar5 = *param_2;\n    local_48 = uVar6;\n    if (pbVar5 != param_1) {\n      if (*piVar3 == 0) {\n        uVar10 = 0;\n      }\n      else {\n        uVar10 = 1;\n        if (*piVar3 != 0x22) goto LAB_001160db;\n      }\n      if ((param_5 != (char *)0x0) && (bVar11 = *pbVar5, bVar11 != 0)) {\n        iVar8 = (int)(char)bVar11;\nLAB_0011611c:\n        pcVar7 = strchr(param_5,iVar8);\n        if (pcVar7 == (char *)0x0) {\nswitchD_00116170_caseD_43:\n          uVar10 = uVar10 | 2;\n          *param_4 = local_48;\n          goto LAB_001160a2;\n        }\n        switch(bVar11) {\n        case 0x45:\n        case 0x47:\n        case 0x4b:\n        case 0x4d:\n        case 0x50:\n        case 0x54:\n        case 0x59:\n        case 0x5a:\n        case 0x67:\n        case 0x6b:\n        case 0x6d:\n        case 0x74:\n          pcVar7 = strchr(param_5,0x30);\n          if (pcVar7 == (char *)0x0) goto switchD_00116146_caseD_46;\n          bVar1 = pbVar5[1];\n          if (bVar1 == 0x44) {\n            iVar8 = 2;\n            uVar9 = 1000;\n          }\n          else if (bVar1 == 0x69) {\n            uVar9 = 0x400;\n            iVar8 = (pbVar5[2] == 0x42) + 1 + (uint)(pbVar5[2] == 0x42);\n          }\n          else {\n            iVar8 = (bVar1 == 0x42) + 1;\n            uVar9 = 0x400;\n            if (bVar1 == 0x42) {\n              uVar9 = 1000;\n            }\n          }\n          break;\n        default:\nswitchD_00116146_caseD_46:\n          iVar8 = 1;\n          uVar9 = 0x400;\n        }\n        switch(bVar11) {\n        case 0x42:\n          uVar2 = bkm_scale(&local_48,0x400);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n          break;\n        default:\n          goto switchD_00116170_caseD_43;\n        case 0x45:\n          uVar2 = bkm_scale_by_power(&local_48,uVar9,6);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n          break;\n        case 0x47:\n        case 0x67:\n          uVar2 = bkm_scale_by_power(&local_48,uVar9,3);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n          break;\n        case 0x4b:\n        case 0x6b:\n          uVar2 = bkm_scale_by_power(&local_48,uVar9,1);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n          break;\n        case 0x4d:\n        case 0x6d:\n          uVar2 = bkm_scale_by_power(&local_48,uVar9,2);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n          break;\n        case 0x50:\n          uVar2 = bkm_scale_by_power(&local_48,uVar9,5);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n          break;\n        case 0x54:\n        case 0x74:\n          uVar2 = bkm_scale_by_power(&local_48,uVar9,4);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n          break;\n        case 0x59:\n          uVar2 = bkm_scale_by_power(&local_48,uVar9,8);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n          break;\n        case 0x5a:\n          uVar2 = bkm_scale_by_power(&local_48,uVar9,7);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n          break;\n        case 0x62:\n          uVar2 = bkm_scale(&local_48,0x200);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n          break;\n        case 99:\n          break;\n        case 0x77:\n          uVar2 = bkm_scale(&local_48,2);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n        }\n        uVar6 = local_48;\n        *param_2 = pbVar5 + iVar8;\n        if (pbVar5[iVar8] != 0) {\n          uVar10 = uVar10 | 2;\n        }\n      }\n      *param_4 = uVar6;\n      goto LAB_001160a2;\n    }\n    if ((param_5 != (char *)0x0) && (bVar11 = *param_1, bVar11 != 0)) {\n      iVar8 = (int)(char)bVar11;\n      pcVar7 = strchr(param_5,iVar8);\n      if (pcVar7 != (char *)0x0) {\n        local_48 = 1;\n        uVar10 = 0;\n        goto LAB_0011611c;\n      }\n    }\n  }\nLAB_001160db:\n  uVar10 = 4;\nLAB_001160a2:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar10;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "001055c0": "\nundefined4 to_uchar(undefined4 param_1)\n\n{\n  return param_1;\n}\n\n", 
    "001078c0": "\nundefined  [16] get_stat_ctime_isra_0(undefined8 param_1,undefined8 param_2)\n\n{\n  return CONCAT88(param_2,param_1);\n}\n\n", 
    "001056e0": "\nulong dev_ino_hash(ulong *param_1,ulong param_2)\n\n{\n  return *param_1 % param_2;\n}\n\n", 
    "00107a20": "\nvoid strcmp_ctime(undefined8 param_1,undefined8 param_2)\n\n{\n  cmp_ctime(param_1,param_2,PTR_strcmp_00123fc8);\n  return;\n}\n\n", 
    "0010a380": "\nlong print_name_with_quoting(undefined8 *param_1,byte param_2,undefined8 param_3,ulong param_4)\n\n{\n  ulong uVar1;\n  char cVar2;\n  undefined8 uVar3;\n  long lVar4;\n  \n  uVar3 = param_1[1];\n  if (param_2 == 0) {\n    uVar3 = *param_1;\n  }\n  if ((print_with_color == '\\0') ||\n     ((lVar4 = get_color_indicator(param_1,param_2), lVar4 == 0 &&\n      (cVar2 = is_colored(4), cVar2 == '\\0')))) {\n    lVar4 = quote_name(uVar3,filename_quoting_options,*(undefined4 *)((long)param_1 + 0xc4),0,\n                       param_2 ^ 1,param_3,param_1[2]);\n    process_signals();\n  }\n  else {\n    lVar4 = quote_name(uVar3,filename_quoting_options,*(undefined4 *)((long)param_1 + 0xc4));\n    process_signals();\n    prep_non_filename_text();\n    if ((line_length != 0) &&\n       (uVar1 = lVar4 + -1 + param_4, param_4 / line_length != uVar1 / line_length)) {\n      put_indicator_isra_0(0x1241d0,0x1241d8,uVar1 % line_length);\n    }\n  }\n  return lVar4;\n}\n\n", 
    "0010d410": "\nbool c_isascii(uint param_1)\n\n{\n  return param_1 < 0x80;\n}\n\n", 
    "00104db0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint sigaddset(sigset_t *__set,int __signo)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_sigaddset_00123f90)();\n  return iVar1;\n}\n\n", 
    "001055b0": "\nvoid frame_dummy(void)\n\n{\n  register_tm_clones();\n  return;\n}\n\n", 
    "00107b30": "\nundefined8 rev_strcmp_df_atime(long param_1,long param_2)\n\n{\n  char cVar1;\n  char cVar2;\n  long lVar3;\n  undefined8 uVar4;\n  \n  lVar3 = param_2;\n  cVar1 = is_directory_isra_0(*(undefined4 *)(param_1 + 0xa8));\n  cVar2 = is_directory_isra_0(*(undefined4 *)(param_2 + 0xa8));\n  if ((cVar2 == '\\x01') || (cVar1 == '\\0')) {\n    if ((cVar1 == '\\x01') || (uVar4 = 1, cVar2 == '\\0')) {\n      uVar4 = cmp_atime(lVar3,param_1,PTR_strcmp_00123fc8);\n      return uVar4;\n    }\n  }\n  else {\n    uVar4 = 0xffffffff;\n  }\n  return uVar4;\n}\n\n", 
    "0010a030": "\nlong quote_name(char *param_1,undefined8 param_2,undefined4 param_3,long param_4,char param_5,\n               long param_6,long param_7)\n\n{\n  size_t sVar1;\n  void *__ptr;\n  char *__ptr_00;\n  char *pcVar2;\n  long *plVar3;\n  long lVar4;\n  size_t sVar5;\n  char cVar6;\n  char cVar7;\n  long in_FS_OFFSET;\n  byte local_2051;\n  char *local_2050;\n  char local_2048 [8200];\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_2050 = local_2048;\n  sVar1 = quote_name_buf_constprop_0(&local_2050,param_1,param_2,param_3,0);\n  if ((local_2051 != 0) && (param_5 != '\\0')) {\n    putchar_unlocked(0x20);\n    dired_pos = dired_pos + 1;\n  }\n  if (param_4 != 0) {\n    print_color_indicator(param_4);\n  }\n  cVar7 = cwd_some_quoted;\n  sVar5 = sVar1;\n  if (param_7 == 0) {\n    lVar4 = 0;\n    cVar7 = '\\0';\n  }\n  else {\n    cVar6 = align_variable_outer_quotes;\n    if ((align_variable_outer_quotes == '\\0') || (cVar6 = cwd_some_quoted, cwd_some_quoted == '\\0'))\n    {\n      lVar4 = 0;\n      cVar7 = cVar6;\n    }\n    else if (local_2051 == 0) {\n      putchar_unlocked((int)*local_2050);\n      sVar5 = sVar1 - 2;\n      lVar4 = 1;\n    }\n    else {\n      lVar4 = 0;\n      cVar7 = '\\0';\n    }\n    __ptr = (void *)file_escape(hostname,0);\n    __ptr_00 = (char *)file_escape(param_7,1);\n    pcVar2 = \"\";\n    if (*__ptr_00 != '/') {\n      pcVar2 = \"/\";\n    }\n    __printf_chk(1,&DAT_00119904,__ptr,pcVar2);\n    free(__ptr);\n    free(__ptr_00);\n  }\n  if (param_6 == 0) {\n    fwrite_unlocked(local_2050 + lVar4,1,sVar5,stdout);\n    dired_pos = dired_pos + sVar1;\n  }\n  else {\n    if (dired != '\\0') {\n      plVar3 = *(long **)(param_6 + 0x18);\n      if ((ulong)(*(long *)(param_6 + 0x20) - (long)plVar3) < 8) {\n        _obstack_newchunk(param_6,8);\n        plVar3 = *(long **)(param_6 + 0x18);\n      }\n      *plVar3 = dired_pos;\n      *(long *)(param_6 + 0x18) = *(long *)(param_6 + 0x18) + 8;\n    }\n    fwrite_unlocked(local_2050 + lVar4,1,sVar5,stdout);\n    dired_pos = dired_pos + sVar1;\n    if (dired != '\\0') {\n      plVar3 = *(long **)(param_6 + 0x18);\n      if ((ulong)(*(long *)(param_6 + 0x20) - (long)plVar3) < 8) {\n        _obstack_newchunk(param_6,8);\n        plVar3 = *(long **)(param_6 + 0x18);\n      }\n      *plVar3 = dired_pos;\n      *(long *)(param_6 + 0x18) = *(long *)(param_6 + 0x18) + 8;\n    }\n  }\n  if ((param_7 != 0) && (fwrite_unlocked(&DAT_00119918,1,6,stdout), cVar7 != '\\0')) {\n    putchar_unlocked((int)local_2050[sVar1 - 1]);\n  }\n  if ((local_2050 != param_1) && (local_2050 != local_2048)) {\n    free(local_2050);\n  }\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_2051 + sVar1;\n}\n\n", 
    "00106c80": "\nvoid format_group_width(undefined4 param_1)\n\n{\n  undefined8 uVar1;\n  \n  if (numeric_ids != '\\0') {\n    format_user_or_group_width(0,param_1);\n    return;\n  }\n  uVar1 = getgroup();\n  format_user_or_group_width(uVar1,param_1);\n  return;\n}\n\n", 
    "0010d420": "\nuint c_isblank(int param_1,undefined8 param_2,uint param_3)\n\n{\n  uint in_EAX;\n  \n  return in_EAX & 0xffffff00 | (uint)(param_1 == 0x20) | param_3 & 0xffffff00 | (uint)(param_1 == 9)\n  ;\n}\n\n", 
    "00126088": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nlconv * localeconv(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* localeconv@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00108410": "\nundefined8 rev_strcmp_df_size(undefined8 *param_1,undefined8 *param_2)\n\n{\n  char cVar1;\n  char cVar2;\n  undefined8 uVar3;\n  undefined8 *puVar4;\n  \n  puVar4 = param_2;\n  cVar1 = is_directory_isra_0(*(undefined4 *)(param_1 + 0x15));\n  cVar2 = is_directory_isra_0(*(undefined4 *)(param_2 + 0x15));\n  if ((cVar2 == '\\x01') || (cVar1 == '\\0')) {\n    if ((cVar1 == '\\x01') || (uVar3 = 1, cVar2 == '\\0')) {\n      uVar3 = cmp_size_isra_0(*puVar4,puVar4[9],*param_1,param_1[9],PTR_strcmp_00123fc8);\n      return uVar3;\n    }\n  }\n  else {\n    uVar3 = 0xffffffff;\n  }\n  return uVar3;\n}\n\n", 
    "00106110": "\nvoid abformat_init(void)\n\n{\n  long lVar1;\n  char cVar2;\n  uint uVar3;\n  ulong uVar4;\n  char *__s;\n  undefined *puVar5;\n  long in_FS_OFFSET;\n  long local_670;\n  ulong local_658 [2];\n  undefined local_648 [1536];\n  undefined local_48 [8];\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  uVar4 = first_percent_b(long_time_format._0_8_);\n  local_658[0] = uVar4;\n  local_658[1] = first_percent_b(long_time_format._8_8_);\n  if ((uVar4 | local_658[1]) != 0) {\n    cVar2 = abmon_init(local_648);\n    if (cVar2 != '\\0') {\n      local_670 = 0;\n      while( true ) {\n        uVar4 = local_658[local_670];\n        lVar1 = *(long *)(long_time_format + local_670 * 8);\n        __s = abformat + local_670 * 0x600;\n        puVar5 = local_648;\n        do {\n          if (uVar4 == 0) {\n            uVar3 = snprintf(__s,0x80,\"%s\",lVar1);\n          }\n          else {\n            if (0x80 < (long)(uVar4 - lVar1)) goto LAB_00106248;\n            uVar3 = __snprintf_chk(__s,0x80,1,0xffffffffffffffff,\"%.*s%s%s\",\n                                   uVar4 - lVar1 & 0xffffffff,lVar1,puVar5,uVar4 + 2);\n          }\n          if (0x7f < uVar3) goto LAB_00106248;\n          puVar5 = puVar5 + 0x80;\n          __s = __s + 0x80;\n        } while (puVar5 != local_48);\n        if (local_670 == 1) break;\n        local_670 = 1;\n      }\n      use_abformat = 1;\n    }\n  }\nLAB_00106248:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00108770": "\nundefined1 * format_inode_isra_0(undefined8 param_1,undefined8 param_2,long *param_3,char *param_4)\n\n{\n  undefined1 *puVar1;\n  \n  if (*param_4 == '\\0') {\n    return &DAT_001198cf;\n  }\n  if (*param_3 == 0) {\n    return &DAT_001198cf;\n  }\n  puVar1 = (undefined1 *)umaxtostr(*param_3,param_1);\n  return puVar1;\n}\n\n", 
    "00106470": "\nvoid parse_ls_color(void)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  char cVar3;\n  int iVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  undefined8 uVar7;\n  void *pvVar8;\n  long lVar9;\n  void *pvVar10;\n  long in_FS_OFFSET;\n  byte *local_58;\n  void *local_50;\n  ushort local_43;\n  undefined local_41;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_58 = (byte *)getenv(\"LS_COLORS\");\n  if ((local_58 == (byte *)0x0) || (*local_58 == 0)) {\n    pcVar5 = getenv(\"COLORTERM\");\n    if (((pcVar5 == (char *)0x0) || (*pcVar5 == '\\0')) && (cVar3 = known_term_type(), cVar3 == '\\0')\n       ) {\n      print_with_color = 0;\n    }\n  }\n  else {\n    local_43 = 0x3f3f;\n    local_41 = 0;\n    color_buf = (void *)xstrdup(local_58);\n    local_50 = color_buf;\n    do {\n      while( true ) {\n        while (bVar1 = *local_58, bVar1 == 0x2a) {\n          pvVar8 = (void *)xmalloc(0x28);\n          local_58 = local_58 + 1;\n          pvVar10 = pvVar8;\n          *(void **)((long)pvVar8 + 0x20) = color_ext_list;\n          color_ext_list = pvVar10;\n          *(void **)((long)pvVar8 + 8) = local_50;\n          cVar3 = get_funky_string(&local_50,&local_58,1);\n          pbVar2 = local_58;\n          if ((cVar3 == '\\0') || (pbVar2 = local_58 + 1, *local_58 != 0x3d)) goto LAB_00106603;\n          *(void **)((long)pvVar8 + 0x18) = local_50;\n          local_58 = local_58 + 1;\n          cVar3 = get_funky_string();\n          pbVar2 = local_58;\n          if (cVar3 == '\\0') goto LAB_00106603;\n        }\n        if (bVar1 != 0x3a) break;\n        local_58 = local_58 + 1;\n      }\n      if (bVar1 == 0) goto LAB_00106651;\n      local_43 = local_43 & 0xff00 | (ushort)*local_58;\n      pbVar2 = local_58 + 1;\n      if (local_58[1] == 0) goto LAB_00106603;\n      local_43 = CONCAT11(local_58[1],*local_58);\n      pbVar2 = local_58 + 3;\n      if (local_58[2] != 0x3d) goto LAB_00106603;\n      lVar9 = 0;\n      pcVar5 = \"lc\";\n      local_58 = local_58 + 3;\n      while (iVar4 = strcmp((char *)&local_43,pcVar5), iVar4 != 0) {\n        lVar9 = lVar9 + 1;\n        pcVar5 = *(char **)(indicator_name + lVar9 * 8);\n        if (pcVar5 == (char *)0x0) goto LAB_001065d4;\n      }\n      *(void **)(color_indicator + (long)(int)lVar9 * 0x10 + 8) = local_50;\n      cVar3 = get_funky_string(&local_50,&local_58,0);\n    } while (cVar3 != '\\0');\nLAB_001065d4:\n    uVar6 = quote(&local_43);\n    uVar7 = dcgettext(0,\"unrecognized prefix: %s\",5);\n    error(0,0,uVar7,uVar6);\n    pbVar2 = local_58;\nLAB_00106603:\n    local_58 = pbVar2;\n    uVar6 = dcgettext(0,\"unparsable value for LS_COLORS environment variable\",5);\n    error(0,0,uVar6);\n    free(color_buf);\n    pvVar10 = color_ext_list;\n    while (pvVar10 != (void *)0x0) {\n      pvVar8 = *(void **)((long)pvVar10 + 0x20);\n      free(pvVar10);\n      pvVar10 = pvVar8;\n    }\n    print_with_color = 0;\nLAB_00106651:\n    if ((color_indicator._112_8_ == 6) &&\n       (iVar4 = strncmp(color_indicator._120_8_,\"target\",6), iVar4 == 0)) {\n      color_symlink_as_referent = 1;\n    }\n  }\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n", 
    "00126080": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint wcswidth(wchar_t *__s,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* wcswidth@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001048f0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t strlen(char *__s)\n\n{\n  size_t sVar1;\n  \n  sVar1 = (*(code *)PTR_strlen_00123d30)();\n  return sVar1;\n}\n\n", 
    "00114db0": "\nvoid quotearg_free(void)\n\n{\n  void **ppvVar1;\n  void *__ptr;\n  undefined *__ptr_00;\n  void **ppvVar2;\n  \n  __ptr_00 = slotvec;\n  if (1 < nslots) {\n    ppvVar2 = (void **)(slotvec + 0x18);\n    ppvVar1 = (void **)(slotvec + (ulong)(nslots - 2) * 0x10 + 0x28);\n    do {\n      __ptr = *ppvVar2;\n      ppvVar2 = ppvVar2 + 2;\n      free(__ptr);\n    } while (ppvVar2 != ppvVar1);\n  }\n  if (*(undefined1 **)(__ptr_00 + 8) != slot0) {\n    free(*(undefined1 **)(__ptr_00 + 8));\n    slotvec0._8_8_ = slot0;\n    slotvec0._0_8_ = 0x100;\n  }\n  if (__ptr_00 != slotvec0) {\n    free(__ptr_00);\n    slotvec = slotvec0;\n  }\n  nslots = 1;\n  return;\n}\n\n", 
    "00115ea0": "\nchar * xgethostname(void)\n\n{\n  uint uVar1;\n  long lVar2;\n  int iVar3;\n  uint *puVar4;\n  char *__name;\n  char *pcVar5;\n  long in_FS_OFFSET;\n  long local_38;\n  long local_30;\n  \n  __name = (char *)0x0;\n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  local_38 = 0x22;\n  puVar4 = (uint *)__errno_location();\n  do {\n    while( true ) {\n      __name = (char *)x2realloc(__name,&local_38);\n      lVar2 = local_38 + -2;\n      __name[lVar2] = '\\0';\n      *puVar4 = 0;\n      iVar3 = gethostname(__name,local_38 - 1);\n      if (iVar3 != 0) break;\n      pcVar5 = __name;\n      if (__name[lVar2] == '\\0') goto LAB_00115f17;\n    }\n    uVar1 = *puVar4;\n  } while ((uVar1 < 0x25) && ((0x1000401001U >> ((ulong)uVar1 & 0x3f) & 1) != 0));\n  pcVar5 = (char *)0x0;\n  free(__name);\n  *puVar4 = uVar1;\nLAB_00115f17:\n  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return pcVar5;\n}\n\n", 
    "001047d0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * strcpy(char *__dest,char *__src)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_strcpy_00123ca0)();\n  return pcVar1;\n}\n\n", 
    "00106b10": "\nundefined * file_escape(char *param_1,char param_2)\n\n{\n  char cVar1;\n  undefined *puVar2;\n  byte bVar3;\n  size_t sVar4;\n  undefined *puVar5;\n  undefined extraout_DL;\n  \n  sVar4 = strlen(param_1);\n  puVar5 = (undefined *)xnmalloc(3,sVar4 + 1);\n  cVar1 = *param_1;\n  puVar2 = puVar5;\n  do {\n    while( true ) {\n      if (cVar1 == '\\0') {\n        *puVar2 = 0;\n        return puVar5;\n      }\n      param_1 = param_1 + 1;\n      if ((cVar1 != '/') || (param_2 == '\\0')) break;\n      *puVar2 = 0x2f;\nLAB_00106b57:\n      cVar1 = *param_1;\n      puVar2 = puVar2 + 1;\n    }\n    bVar3 = to_uchar((int)cVar1);\n    if (RFC3986[bVar3] != '\\0') {\n      *puVar2 = extraout_DL;\n      goto LAB_00106b57;\n    }\n    __sprintf_chk(puVar2,1,0xffffffffffffffff,\"%%%02x\",bVar3);\n    cVar1 = *param_1;\n    puVar2 = puVar2 + 3;\n  } while( true );\n}\n\n", 
    "00107e40": "\nundefined8 xstrcoll_df_ctime(long param_1,long param_2)\n\n{\n  char cVar1;\n  char cVar2;\n  undefined8 uVar3;\n  \n  cVar1 = is_directory_isra_0(*(undefined4 *)(param_1 + 0xa8));\n  cVar2 = is_directory_isra_0(*(undefined4 *)(param_2 + 0xa8));\n  if ((cVar2 == '\\x01') || (cVar1 == '\\0')) {\n    if ((cVar1 == '\\x01') || (uVar3 = 1, cVar2 == '\\0')) {\n      uVar3 = cmp_ctime(param_1);\n      return uVar3;\n    }\n  }\n  else {\n    uVar3 = 0xffffffff;\n  }\n  return uVar3;\n}\n\n", 
    "00104b70": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\ndirent * readdir(DIR *__dirp)\n\n{\n  dirent *pdVar1;\n  \n  pdVar1 = (dirent *)(*(code *)PTR_readdir_00123e70)();\n  return pdVar1;\n}\n\n", 
    "00115070": "\nvoid quotearg_n_style_colon(undefined4 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  long in_FS_OFFSET;\n  undefined8 local_98;\n  undefined8 uStack_90;\n  undefined8 local_88;\n  undefined8 uStack_80;\n  undefined8 local_78;\n  undefined8 uStack_70;\n  undefined8 local_68;\n  undefined8 local_58;\n  undefined8 uStack_50;\n  undefined8 local_48;\n  undefined8 uStack_40;\n  undefined8 local_38;\n  undefined8 uStack_30;\n  undefined8 local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  quoting_options_from_style(&local_98);\n  puVar1 = &local_58;\n  local_58 = local_98;\n  uStack_50 = uStack_90;\n  local_48 = local_88;\n  uStack_40 = uStack_80;\n  local_38 = local_78;\n  uStack_30 = uStack_70;\n  local_28 = local_68;\n  set_char_quoting(puVar1,0x3a,1);\n  quotearg_n_options(param_1,param_3,0xffffffffffffffff,puVar1);\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00104a50": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint _setjmp(__jmp_buf_tag *__env)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR__setjmp_00123de0)();\n  return iVar1;\n}\n\n", 
    "00117490": "\nchar * locale_charset(void)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = nl_langinfo(0xe);\n  if (pcVar1 != (char *)0x0) {\n    if (*pcVar1 == '\\0') {\n      pcVar1 = \"ASCII\";\n    }\n    return pcVar1;\n  }\n  return \"ASCII\";\n}\n\n", 
    "00117130": "\ntm * localtime_rz(long param_1,time_t *param_2,tm *param_3)\n\n{\n  char cVar1;\n  long lVar2;\n  tm *ptVar3;\n  \n  if (param_1 == 0) {\n    ptVar3 = gmtime_r(param_2,param_3);\n    return ptVar3;\n  }\n  lVar2 = set_tz();\n  if (lVar2 != 0) {\n    ptVar3 = localtime_r(param_2,param_3);\n    if ((ptVar3 != (tm *)0x0) && (cVar1 = save_abbr(param_1,param_3), cVar1 != '\\0')) {\n      cVar1 = revert_tz(lVar2);\n      if (cVar1 == '\\0') {\n        return (tm *)0x0;\n      }\n      return param_3;\n    }\n    revert_tz(lVar2);\n  }\n  return (tm *)0x0;\n}\n\n", 
    "00104c90": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * memmove(void *__dest,void *__src,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = (void *)(*(code *)PTR_memmove_00123f00)();\n  return pvVar1;\n}\n\n", 
    "0010d510": "\nbool c_isupper(int param_1)\n\n{\n  return param_1 - 0x41U < 0x1a;\n}\n\n", 
    "001168f0": "\nuint rpl_lgetfilecon(undefined8 param_1,byte **param_2)\n\n{\n  uint uVar1;\n  int *piVar2;\n  long lVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  bool bVar6;\n  bool bVar7;\n  byte bVar8;\n  \n  bVar8 = 0;\n  uVar1 = lgetfilecon();\n  if (uVar1 == 0) {\n    piVar2 = __errno_location();\n    *piVar2 = 0x5f;\n    return 0xffffffff;\n  }\n  bVar6 = uVar1 < 10;\n  bVar7 = uVar1 == 10;\n  if (bVar7) {\n    lVar3 = 10;\n    pbVar4 = *param_2;\n    pbVar5 = (byte *)\"unlabeled\";\n    do {\n      if (lVar3 == 0) break;\n      lVar3 = lVar3 + -1;\n      bVar6 = *pbVar4 < *pbVar5;\n      bVar7 = *pbVar4 == *pbVar5;\n      pbVar4 = pbVar4 + (ulong)bVar8 * -2 + 1;\n      pbVar5 = pbVar5 + (ulong)bVar8 * -2 + 1;\n    } while (bVar7);\n    if ((!bVar6 && !bVar7) == bVar6) {\n      freecon(*param_2);\n      *param_2 = (byte *)0x0;\n      piVar2 = __errno_location();\n      *piVar2 = 0x3d;\n      return 0xffffffff;\n    }\n  }\n  return uVar1;\n}\n\n", 
    "00126098": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nssize_t readlink(char *__path,char *__buf,size_t __len)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* readlink@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010f0d0": "\nulong hash_string(byte *param_1,ulong param_2)\n\n{\n  byte bVar1;\n  ulong uVar2;\n  \n  uVar2 = 0;\n  bVar1 = *param_1;\n  while (bVar1 != 0) {\n    param_1 = param_1 + 1;\n    uVar2 = (uVar2 * 0x1f + (ulong)bVar1) % param_2;\n    bVar1 = *param_1;\n  }\n  return uVar2;\n}\n\n", 
    "001154a0": "\nundefined8\nversion_etc_arn(FILE *param_1,long param_2,undefined8 param_3,undefined8 param_4,undefined8 *param_5\n               ,undefined8 param_6)\n\n{\n  undefined8 uVar1;\n  char *pcVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  undefined8 uVar5;\n  undefined8 uVar6;\n  undefined8 local_60;\n  undefined8 local_58;\n  undefined8 local_50;\n  undefined8 local_48;\n  \n  if (param_2 == 0) {\n    __fprintf_chk(param_1,1,\"%s %s\\n\",param_3,param_4);\n  }\n  else {\n    __fprintf_chk(param_1,1,\"%s (%s) %s\\n\",param_2,param_3,param_4);\n  }\n  uVar1 = dcgettext(0,&DAT_0011c9a3,5);\n  __fprintf_chk(param_1,1,\"Copyright %s %d Free Software Foundation, Inc.\",uVar1,0x7e2);\n  pcVar2 = (char *)dcgettext(0,\n                             \"\\nLicense GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>.\\nThis is free software: you are free to change and redistribute it.\\nThere is NO WARRANTY, to the extent permitted by law.\\n\\n\"\n                             ,5);\n  fputs_unlocked(pcVar2,param_1);\n  switch(param_6) {\n  case 0:\n                    /* WARNING: Subroutine does not return */\n    abort();\n  case 1:\n    uVar1 = *param_5;\n    uVar4 = dcgettext(0,\"Written by %s.\\n\",5);\n    uVar1 = __fprintf_chk(param_1,1,uVar4,uVar1);\n    return uVar1;\n  case 2:\n    uVar1 = param_5[1];\n    uVar4 = *param_5;\n    uVar5 = dcgettext(0,\"Written by %s and %s.\\n\",5);\n    uVar1 = __fprintf_chk(param_1,1,uVar5,uVar4,uVar1);\n    return uVar1;\n  case 3:\n    uVar1 = param_5[2];\n    uVar4 = param_5[1];\n    uVar5 = *param_5;\n    uVar6 = dcgettext(0,\"Written by %s, %s, and %s.\\n\",5);\n    uVar1 = __fprintf_chk(param_1,1,uVar6,uVar5,uVar4,uVar1);\n    return uVar1;\n  case 4:\n    uVar1 = param_5[3];\n    uVar4 = param_5[2];\n    uVar5 = param_5[1];\n    uVar6 = *param_5;\n    uVar3 = dcgettext(0,\"Written by %s, %s, %s,\\nand %s.\\n\",5);\n    goto LAB_00115769;\n  case 5:\n    uVar1 = param_5[3];\n    uVar4 = param_5[2];\n    uVar5 = param_5[1];\n    uVar6 = *param_5;\n    uVar3 = dcgettext(0,\"Written by %s, %s, %s,\\n%s, and %s.\\n\",5);\nLAB_00115769:\n    __fprintf_chk(param_1,1,uVar3,uVar6,uVar5,uVar4);\n    return uVar1;\n  case 6:\n    local_58 = param_5[5];\n    local_60 = param_5[4];\n    uVar1 = param_5[3];\n    uVar4 = param_5[2];\n    uVar5 = param_5[1];\n    uVar6 = *param_5;\n    uVar3 = dcgettext(0,\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\",5);\n    goto LAB_0011580b;\n  case 7:\n    local_58 = param_5[5];\n    local_60 = param_5[4];\n    uVar1 = param_5[3];\n    uVar4 = param_5[2];\n    uVar5 = param_5[1];\n    uVar6 = *param_5;\n    uVar3 = dcgettext(0,\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\",5);\nLAB_0011580b:\n    uVar1 = __fprintf_chk(param_1,1,uVar3,uVar6,uVar5,uVar4,uVar1,local_60,local_58);\n    return uVar1;\n  case 8:\n    local_48 = param_5[7];\n    local_50 = param_5[6];\n    local_58 = param_5[5];\n    local_60 = param_5[4];\n    uVar1 = param_5[3];\n    uVar4 = param_5[2];\n    uVar5 = param_5[1];\n    uVar6 = *param_5;\n    uVar3 = dcgettext(0,\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\",5);\n    goto LAB_001155bd;\n  case 9:\n    local_48 = param_5[7];\n    pcVar2 = \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\";\n    local_50 = param_5[6];\n    local_58 = param_5[5];\n    local_60 = param_5[4];\n    uVar1 = param_5[3];\n    uVar4 = param_5[2];\n    uVar5 = param_5[1];\n    uVar6 = *param_5;\n    break;\n  default:\n    local_48 = param_5[7];\n    pcVar2 = \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\";\n    local_50 = param_5[6];\n    local_58 = param_5[5];\n    local_60 = param_5[4];\n    uVar1 = param_5[3];\n    uVar4 = param_5[2];\n    uVar5 = param_5[1];\n    uVar6 = *param_5;\n  }\n  uVar3 = dcgettext(0,pcVar2,5);\nLAB_001155bd:\n  uVar1 = __fprintf_chk(param_1,1,uVar3,uVar6,uVar5,uVar4,uVar1,local_60,local_58,local_50,local_48)\n  ;\n  return uVar1;\n}\n\n", 
    "00108520": "\nundefined8 xstrcoll_df_name(undefined8 *param_1,undefined8 *param_2)\n\n{\n  char cVar1;\n  char cVar2;\n  undefined8 uVar3;\n  \n  cVar1 = is_directory_isra_0(*(undefined4 *)(param_1 + 0x15));\n  cVar2 = is_directory_isra_0(*(undefined4 *)(param_2 + 0x15));\n  if ((cVar2 == '\\x01') || (cVar1 == '\\0')) {\n    if ((cVar1 == '\\x01') || (uVar3 = 1, cVar2 == '\\0')) {\n      uVar3 = cmp_name_isra_0(*param_1,*param_2,xstrcoll);\n      return uVar3;\n    }\n  }\n  else {\n    uVar3 = 0xffffffff;\n  }\n  return uVar3;\n}\n\n", 
    "00126090": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t mbstowcs(wchar_t *__pwcs,char *__s,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* mbstowcs@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00107790": "\nvoid format_user_or_group(char *param_1,undefined8 param_2,int param_3)\n\n{\n  int iVar1;\n  size_t sVar2;\n  long lVar3;\n  \n  if (param_1 == (char *)0x0) {\n    lVar3 = (long)param_3;\n    __printf_chk(1,\"%*lu \",param_3,param_2);\n  }\n  else {\n    iVar1 = gnu_mbswidth(param_1,0);\n    param_3 = param_3 - iVar1;\n    if (param_3 < 0) {\n      param_3 = 0;\n    }\n    fputs_unlocked(param_1,stdout);\n    sVar2 = strlen(param_1);\n    lVar3 = (long)param_3 + sVar2;\n    do {\n      param_3 = param_3 + -1;\n      putchar_unlocked(0x20);\n    } while (param_3 != -1);\n  }\n  dired_pos = lVar3 + 1 + dired_pos;\n  return;\n}\n\n", 
    "001069a0": "\nvoid get_link_name(undefined8 param_1,long param_2,undefined param_3)\n\n{\n  long lVar1;\n  undefined8 uVar2;\n  \n  lVar1 = areadlink_with_size(param_1,*(undefined8 *)(param_2 + 0x48));\n  *(long *)(param_2 + 8) = lVar1;\n  if (lVar1 != 0) {\n    return;\n  }\n  uVar2 = dcgettext(0,\"cannot read symbolic link %s\",5);\n  file_failure(param_3,uVar2,param_1);\n  return;\n}\n\n", 
    "001059d0": "\nvoid initialize_ordering_vector(void)\n\n{\n  long *plVar1;\n  long *plVar2;\n  long lVar3;\n  \n  if (cwd_n_used != 0) {\n    plVar1 = sorted_file + cwd_n_used;\n    plVar2 = sorted_file;\n    lVar3 = cwd_file;\n    do {\n      *plVar2 = lVar3;\n      plVar2 = plVar2 + 1;\n      lVar3 = lVar3 + 200;\n    } while (plVar2 != plVar1);\n  }\n  return;\n}\n\n", 
    "001047c0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid _exit(int __status)\n\n{\n  (*(code *)PTR__exit_00123c98)();\n  return;\n}\n\n", 
    "001048e0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t __ctype_get_mb_cur_max(void)\n\n{\n  size_t sVar1;\n  \n  sVar1 = (*(code *)PTR___ctype_get_mb_cur_max_00123d28)();\n  return sVar1;\n}\n\n", 
    "0010fad0": "\nulong triple_compare_ino_str(char **param_1,char **param_2)\n\n{\n  int iVar1;\n  undefined4 extraout_var;\n  \n  if ((param_1[1] == param_2[1]) && (param_1[2] == param_2[2])) {\n    iVar1 = strcmp(*param_1,*param_2);\n    return CONCAT44(extraout_var,iVar1) & 0xffffffffffffff00 | (ulong)(iVar1 == 0);\n  }\n  return 0;\n}\n\n", 
    "00105a10": "\nbyte get_type_indicator(char param_1,uint param_2,int param_3)\n\n{\n  byte bVar1;\n  bool bVar2;\n  \n  if (param_1 == '\\0') {\n    if (param_3 == 5) {\n      return 0;\n    }\n    bVar2 = param_3 == 3 || param_3 == 9;\n  }\n  else {\n    if ((param_2 & 0xf000) == 0x8000) {\n      if (indicator_style != 3) {\n        return 0;\n      }\n      return ~-((param_2 & 0x49) == 0) & 0x2a;\n    }\n    bVar2 = (param_2 & 0xf000) == 0x4000;\n  }\n  bVar1 = 0x2f;\n  if ((bVar2) || (bVar1 = 0, indicator_style == 1)) {\n    return bVar1;\n  }\n  if (param_1 == '\\0') {\n    if (param_3 == 6) {\n      return 0x40;\n    }\n    if (param_3 == 1) {\n      return 0x7c;\n    }\n    bVar2 = param_3 == 7;\n  }\n  else {\n    param_2 = param_2 & 0xf000;\n    if (param_2 == 0xa000) {\n      return 0x40;\n    }\n    if (param_2 == 0x1000) {\n      return 0x7c;\n    }\n    bVar2 = param_2 == 0xc000;\n  }\n  return -bVar2 & 0x3d;\n}\n\n", 
    "00104a40": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint memcmp(void *__s1,void *__s2,size_t __n)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_memcmp_00123dd8)();\n  return iVar1;\n}\n\n", 
    "00104c80": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * mempcpy(void *__dest,void *__src,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = (void *)(*(code *)PTR_mempcpy_00123ef8)();\n  return pvVar1;\n}\n\n", 
    "00104b60": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint __xstat(int __ver,char *__filename,stat *__stat_buf)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR___xstat_00123e68)();\n  return iVar1;\n}\n\n", 
    "00117020": "\nlong set_tz(long param_1)\n\n{\n  char cVar1;\n  int iVar2;\n  char *__s2;\n  long lVar3;\n  int *piVar4;\n  long lVar5;\n  \n  __s2 = (char *)getenv_TZ();\n  if (__s2 == (char *)0x0) {\n    if (*(char *)(param_1 + 8) == '\\0') {\n      return 1;\n    }\n  }\n  else if (*(char *)(param_1 + 8) != '\\0') {\n    iVar2 = strcmp((char *)(param_1 + 9),__s2);\n    if (iVar2 == 0) {\n      return 1;\n    }\n  }\n  lVar3 = tzalloc(__s2);\n  lVar5 = lVar3;\n  if (lVar3 != 0) {\n    cVar1 = change_env(param_1);\n    if (cVar1 == '\\0') {\n      piVar4 = __errno_location();\n      lVar5 = 0;\n      iVar2 = *piVar4;\n      tzfree(lVar3);\n      *piVar4 = iVar2;\n    }\n  }\n  return lVar5;\n}\n\n", 
    "0010a490": "\nlong print_file_name_and_frills(long param_1,undefined8 param_2)\n\n{\n  byte bVar1;\n  long lVar2;\n  undefined8 uVar3;\n  undefined1 *puVar4;\n  undefined4 uVar5;\n  long in_FS_OFFSET;\n  undefined auStack_2b8 [664];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  set_normal_color();\n  if (print_inode != '\\0') {\n    uVar3 = format_inode_isra_0(auStack_2b8,0x28c,param_1 + 0x20,param_1 + 0xb8);\n    uVar5 = 0;\n    if (format != 4) {\n      uVar5 = inode_number_width;\n    }\n    __printf_chk(1,&DAT_0011992f,uVar5,uVar3);\n  }\n  if (print_block_size != '\\0') {\n    puVar4 = &DAT_001198cf;\n    if (*(char *)(param_1 + 0xb8) != '\\0') {\n      puVar4 = (undefined1 *)\n               human_readable(*(undefined8 *)(param_1 + 0x58),auStack_2b8,human_output_opts,0x200,\n                              output_block_size);\n    }\n    uVar5 = 0;\n    if (format != 4) {\n      uVar5 = block_size_width;\n    }\n    __printf_chk(1,&DAT_0011992f,uVar5,puVar4);\n  }\n  if (print_scontext != '\\0') {\n    uVar5 = 0;\n    if (format != 4) {\n      uVar5 = scontext_width;\n    }\n    __printf_chk(1,&DAT_0011992f,uVar5,*(undefined8 *)(param_1 + 0xb0));\n  }\n  lVar2 = print_name_with_quoting(param_1,0,0,param_2);\n  if (indicator_style != 0) {\n    bVar1 = print_type_indicator\n                      (*(undefined *)(param_1 + 0xb8),*(undefined4 *)(param_1 + 0x30),\n                       *(undefined4 *)(param_1 + 0xa8));\n    lVar2 = lVar2 + (ulong)bVar1;\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return lVar2;\n}\n\n", 
    "0010d520": "\nulong c_isxdigit(int param_1)\n\n{\n  ulong uVar1;\n  \n  if (param_1 - 0x30U < 0x37) {\n    uVar1 = 1L << ((byte)(param_1 - 0x30U) & 0x3f);\n    return uVar1 & 0xffffffffffffff00 | (ulong)((uVar1 & 0x7e0000007e03ff) != 0);\n  }\n  return 0;\n}\n\n", 
    "001158f0": "\nvoid version_etc_ar(void)\n\n{\n  long lVar1;\n  long *in_R8;\n  long lVar2;\n  \n  lVar2 = 0;\n  lVar1 = *in_R8;\n  while (lVar1 != 0) {\n    lVar2 = lVar2 + 1;\n    lVar1 = in_R8[lVar2];\n  }\n  version_etc_arn();\n  return;\n}\n\n", 
    "001169e0": "\nvoid call_freefun(long param_1,undefined8 param_2)\n\n{\n  if ((*(byte *)(param_1 + 0x50) & 1) != 0) {\n                    /* WARNING: Could not recover jumptable at 0x001169ee. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n    (**(code **)(param_1 + 0x40))(*(undefined8 *)(param_1 + 0x48));\n    return;\n  }\n                    /* WARNING: Could not recover jumptable at 0x001169f3. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (**(code **)(param_1 + 0x40))(param_2);\n  return;\n}\n\n", 
    "0010d610": "\nundefined4 seen_triple(long *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined4 uVar1;\n  long lVar2;\n  \n  lVar2 = *param_1;\n  if (lVar2 == 0) {\n    lVar2 = hash_initialize(7,0,triple_hash,triple_compare_ino_str,triple_free);\n    *param_1 = lVar2;\n    if (lVar2 == 0) {\n                    /* WARNING: Subroutine does not return */\n      xalloc_die(0);\n    }\n  }\n  uVar1 = seen_file(lVar2,param_2,param_3);\n  if ((char)uVar1 == '\\0') {\n    record_file(*param_1,param_2,param_3);\n  }\n  return uVar1;\n}\n\n", 
    "0010e820": "\nulong is_prime(ulong param_1)\n\n{\n  ulong uVar1;\n  ulong uVar2;\n  ulong uVar3;\n  ulong uVar4;\n  long lVar5;\n  \n  uVar1 = param_1 - (param_1 / 3 +\n                    (SUB168(ZEXT816(param_1) * ZEXT816(0xaaaaaaaaaaaaaaab) >> 0x40,0) &\n                    0xfffffffffffffffe));\n  uVar3 = uVar1;\n  if ((9 < param_1) && (uVar1 != 0)) {\n    lVar5 = 0x10;\n    uVar4 = 9;\n    uVar2 = 3;\n    do {\n      uVar2 = uVar2 + 2;\n      uVar4 = uVar4 + lVar5;\n      uVar1 = param_1 / uVar2;\n      uVar3 = param_1 % uVar2;\n      if (param_1 <= uVar4) break;\n      lVar5 = lVar5 + 8;\n    } while (uVar3 != 0);\n  }\n  return uVar1 & 0xffffffffffffff00 | (ulong)(uVar3 != 0);\n}\n\n", 
    "00108310": "\nundefined8 strcmp_df_size(undefined8 *param_1,undefined8 *param_2)\n\n{\n  char cVar1;\n  char cVar2;\n  undefined8 uVar3;\n  \n  cVar1 = is_directory_isra_0(*(undefined4 *)(param_1 + 0x15));\n  cVar2 = is_directory_isra_0(*(undefined4 *)(param_2 + 0x15));\n  if ((cVar2 == '\\x01') || (cVar1 == '\\0')) {\n    if ((cVar1 == '\\x01') || (uVar3 = 1, cVar2 == '\\0')) {\n      uVar3 = cmp_size_isra_0(*param_1,param_1[9],*param_2,param_2[9],PTR_strcmp_00123fc8);\n      return uVar3;\n    }\n  }\n  else {\n    uVar3 = 0xffffffff;\n  }\n  return uVar3;\n}\n\n", 
    "00126188": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint closedir(DIR *__dirp)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* closedir@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00126068": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint isatty(int __fd)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* isatty@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00107460": "\nvoid dired_dump_obstack(char *param_1,long param_2)\n\n{\n  undefined8 uVar1;\n  ulong uVar2;\n  undefined8 *puVar3;\n  undefined8 *puVar4;\n  \n  puVar4 = *(undefined8 **)(param_2 + 0x18);\n  puVar3 = *(undefined8 **)(param_2 + 0x10);\n  if (7 < (ulong)((long)puVar4 - (long)puVar3)) {\n    if (puVar4 == puVar3) {\n      *(byte *)(param_2 + 0x50) = *(byte *)(param_2 + 0x50) | 2;\n    }\n    uVar2 = (long)puVar4 + *(ulong *)(param_2 + 0x30) & ~*(ulong *)(param_2 + 0x30);\n    if (*(ulong *)(param_2 + 0x20) - *(long *)(param_2 + 8) < uVar2 - *(long *)(param_2 + 8)) {\n      uVar2 = *(ulong *)(param_2 + 0x20);\n    }\n    puVar4 = (undefined8 *)(((long)puVar4 - (long)puVar3 & 0xfffffffffffffff8U) + (long)puVar3);\n    *(ulong *)(param_2 + 0x18) = uVar2;\n    *(ulong *)(param_2 + 0x10) = uVar2;\n    fputs_unlocked(param_1,stdout);\n    do {\n      uVar1 = *puVar3;\n      puVar3 = puVar3 + 1;\n      __printf_chk(1,&DAT_0011983e,uVar1);\n    } while (puVar3 != puVar4);\n    putchar_unlocked(10);\n    return;\n  }\n  return;\n}\n\n", 
    "00108670": "\nundefined8 rev_strcmp_df_name(undefined8 *param_1,undefined8 *param_2)\n\n{\n  char cVar1;\n  char cVar2;\n  undefined8 *puVar3;\n  undefined8 uVar4;\n  \n  puVar3 = param_2;\n  cVar1 = is_directory_isra_0(*(undefined4 *)(param_1 + 0x15));\n  cVar2 = is_directory_isra_0(*(undefined4 *)(param_2 + 0x15));\n  if ((cVar2 == '\\x01') || (cVar1 == '\\0')) {\n    if ((cVar1 == '\\x01') || (uVar4 = 1, cVar2 == '\\0')) {\n      uVar4 = cmp_name_isra_0(*puVar3,*param_1,PTR_strcmp_00123fc8);\n      return uVar4;\n    }\n  }\n  else {\n    uVar4 = 0xffffffff;\n  }\n  return uVar4;\n}\n\n", 
    "00115a50": "\nvoid emit_bug_reporting_address(void)\n\n{\n  FILE *__stream;\n  undefined8 uVar1;\n  char *__s;\n  \n  uVar1 = dcgettext(0,\"\\nReport bugs to: %s\\n\",5);\n  __printf_chk(1,uVar1,\"bug-coreutils@gnu.org\");\n  uVar1 = dcgettext(0,\"%s home page: <%s>\\n\",5);\n  __printf_chk(1,uVar1,\"GNU coreutils\",\"https://www.gnu.org/software/coreutils/\");\n  __stream = stdout;\n  __s = (char *)dcgettext(0,\"General help using GNU software: <https://www.gnu.org/gethelp/>\\n\",5);\n  fputs_unlocked(__s,__stream);\n  return;\n}\n\n", 
    "00106370": "\nundefined8 file_ignored(char *param_1)\n\n{\n  char cVar1;\n  undefined8 uVar2;\n  \n  if (ignore_mode != 2) {\n    if (*param_1 == '.') {\n      if ((ignore_mode == 0) || (param_1[(ulong)(param_1[1] == '.') + 1] == '\\0')) {\n        return 1;\n      }\n    }\n    else if ((ignore_mode == 0) && (cVar1 = patterns_match(hide_patterns,param_1), cVar1 != '\\0')) {\n      return 1;\n    }\n  }\n  uVar2 = patterns_match(ignore_patterns,param_1);\n  return uVar2;\n}\n\n", 
    "00116d80": "\nvoid setenv_TZ(char *param_1)\n\n{\n  if (param_1 != (char *)0x0) {\n    setenv(\"TZ\",param_1,1);\n    return;\n  }\n  unsetenv(\"TZ\");\n  return;\n}\n\n", 
    "00114ea0": "\nvoid quotearg_n_style(undefined4 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  long in_FS_OFFSET;\n  undefined auStack_58 [56];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  quoting_options_from_style(auStack_58);\n  quotearg_n_options(param_1,param_3,0xffffffffffffffff,auStack_58);\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00126180": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t strspn(char *__s,char *__accept)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strspn@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00126060": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __fpending(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __fpending@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001047f0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint isatty(int __fd)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_isatty_00123cb0)();\n  return iVar1;\n}\n\n", 
    "00105b60": "\nvoid init_column_info(void)\n\n{\n  undefined8 *puVar1;\n  long lVar2;\n  long lVar3;\n  long lVar4;\n  undefined8 *puVar5;\n  ulong uVar6;\n  ulong uVar7;\n  ulong uVar8;\n  ulong uVar9;\n  ulong uVar10;\n  ulong uVar11;\n  undefined auVar12 [16];\n  \n  uVar8 = max_idx;\n  if (cwd_n_used <= max_idx) {\n    uVar8 = cwd_n_used;\n  }\n  uVar9 = column_info_alloc_11538;\n  if (column_info_alloc_11538 < uVar8) {\n    if (uVar8 < max_idx >> 1) {\n      uVar9 = uVar8 * 2;\n      auVar12 = xnrealloc(column_info,uVar8,0x30);\n    }\n    else {\n      auVar12 = xnrealloc(column_info,max_idx,0x18);\n      uVar9 = max_idx;\n    }\n    uVar7 = SUB168(auVar12 >> 0x40,0);\n    column_info = SUB168(auVar12,0);\n    uVar10 = uVar9 - column_info_alloc_11538;\n    uVar6 = column_info_alloc_11538 + 1 + uVar9;\n    uVar11 = uVar10 * uVar6;\n    if ((CARRY8(column_info_alloc_11538 + 1,uVar9) != false) ||\n       (uVar7 = uVar11 % uVar10, uVar11 / uVar10 != uVar6)) {\n                    /* WARNING: Subroutine does not return */\n      xalloc_die(uVar11,uVar10,uVar7);\n    }\n    lVar3 = xnmalloc(uVar11 >> 1);\n    lVar2 = column_info;\n    if (column_info_alloc_11538 < uVar9) {\n      lVar4 = column_info_alloc_11538 * 8 + 8;\n      do {\n        *(long *)(lVar2 + -8 + lVar4 * 3) = lVar3;\n        lVar3 = lVar3 + lVar4;\n        lVar4 = lVar4 + 8;\n      } while (lVar4 != uVar9 * 8 + 8);\n    }\n  }\n  column_info_alloc_11538 = uVar9;\n  lVar2 = column_info;\n  if (uVar8 != 0) {\n    lVar4 = 0;\n    lVar3 = 3;\n    do {\n      puVar5 = *(undefined8 **)(lVar2 + -8 + lVar3 * 8);\n      *(undefined *)(lVar2 + -0x18 + lVar3 * 8) = 1;\n      lVar4 = lVar4 + 8;\n      *(long *)(lVar2 + -0x10 + lVar3 * 8) = lVar3;\n      puVar1 = (undefined8 *)(lVar4 + (long)puVar5);\n      do {\n        *puVar5 = 3;\n        puVar5 = puVar5 + 1;\n      } while (puVar5 != puVar1);\n      lVar3 = lVar3 + 3;\n    } while (uVar8 * 3 + 3 != lVar3);\n  }\n  return;\n}\n\n", 
    "00104b90": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint putc_unlocked(int __c,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_putc_unlocked_00123e80)();\n  return iVar1;\n}\n\n", 
    "00115050": "\nvoid quotearg_colon(undefined8 param_1)\n\n{\n  quotearg_char(param_1,0x3a);\n  return;\n}\n\n", 
    "00117350": "\nuint rotr8(uint param_1,byte param_2)\n\n{\n  return param_1 & 0xffffff00 |\n         (uint)(byte)((byte)param_1 >> (param_2 & 7) | (byte)param_1 << 8 - (param_2 & 7));\n}\n\n", 
    "00104a70": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint ferror_unlocked(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_ferror_unlocked_00123df0)();\n  return iVar1;\n}\n\n", 
    "0010faa0": "\nundefined8 triple_compare(undefined8 *param_1,undefined8 *param_2)\n\n{\n  undefined8 uVar1;\n  \n  if ((param_1[1] == param_2[1]) && (param_1[2] == param_2[2])) {\n    uVar1 = same_name(*param_1,*param_2);\n    return uVar1;\n  }\n  return 0;\n}\n\n", 
    "00126198": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint memcmp(void *__s1,void *__s2,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* memcmp@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001168d0": "\nuint rpl_getfilecon(undefined8 param_1,byte **param_2)\n\n{\n  uint uVar1;\n  int *piVar2;\n  long lVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  bool bVar6;\n  bool bVar7;\n  byte bVar8;\n  \n  bVar8 = 0;\n  uVar1 = getfilecon();\n  if (uVar1 == 0) {\n    piVar2 = __errno_location();\n    *piVar2 = 0x5f;\n    return 0xffffffff;\n  }\n  bVar6 = uVar1 < 10;\n  bVar7 = uVar1 == 10;\n  if (bVar7) {\n    lVar3 = 10;\n    pbVar4 = *param_2;\n    pbVar5 = (byte *)\"unlabeled\";\n    do {\n      if (lVar3 == 0) break;\n      lVar3 = lVar3 + -1;\n      bVar6 = *pbVar4 < *pbVar5;\n      bVar7 = *pbVar4 == *pbVar5;\n      pbVar4 = pbVar4 + (ulong)bVar8 * -2 + 1;\n      pbVar5 = pbVar5 + (ulong)bVar8 * -2 + 1;\n    } while (bVar7);\n    if ((!bVar6 && !bVar7) == bVar6) {\n      freecon(*param_2);\n      *param_2 = (byte *)0x0;\n      piVar2 = __errno_location();\n      *piVar2 = 0x3d;\n      return 0xffffffff;\n    }\n  }\n  return uVar1;\n}\n\n", 
    "001132a0": "\nundefined8\nstrcaseeq4(long param_1,undefined8 param_2,byte param_3,char param_4,char param_5,char param_6,\n          char param_7)\n\n{\n  char cVar1;\n  byte bVar2;\n  undefined8 uVar3;\n  \n  cVar1 = c_isupper((int)(char)param_3);\n  bVar2 = *(byte *)(param_1 + 4);\n  if (cVar1 != '\\0') {\n    bVar2 = bVar2 & 0xdf;\n  }\n  if (param_3 != bVar2) {\n    return 0;\n  }\n  if (param_3 == 0) {\n    return 1;\n  }\n  uVar3 = strcaseeq5(param_1,param_2,(int)param_4,(int)param_5,(int)param_6,(int)param_7);\n  return uVar3;\n}\n\n", 
    "00107210": "\nvoid signal_setup(char param_1)\n\n{\n  int iVar1;\n  int *piVar2;\n  int iVar3;\n  int *piVar4;\n  long in_FS_OFFSET;\n  undefined local_d8 [12];\n  undefined4 uStack_cc;\n  undefined4 uStack_c8;\n  undefined4 uStack_c4;\n  undefined4 local_c0;\n  undefined4 uStack_bc;\n  undefined4 uStack_b8;\n  undefined4 uStack_b4;\n  undefined4 local_b0;\n  undefined4 uStack_ac;\n  undefined4 uStack_a8;\n  undefined4 uStack_a4;\n  undefined4 local_a0;\n  undefined4 uStack_9c;\n  undefined4 uStack_98;\n  undefined4 uStack_94;\n  undefined4 local_90;\n  undefined4 uStack_8c;\n  undefined4 uStack_88;\n  undefined4 uStack_84;\n  undefined4 local_80;\n  undefined4 uStack_7c;\n  undefined4 uStack_78;\n  undefined4 uStack_74;\n  undefined4 local_70;\n  undefined4 uStack_6c;\n  undefined4 uStack_68;\n  undefined4 uStack_64;\n  undefined4 local_60;\n  undefined4 uStack_5c;\n  undefined4 uStack_58;\n  undefined4 uStack_54;\n  int local_50;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_1 == '\\0') {\n    piVar2 = (int *)(sig_10319 + 4);\n    iVar3 = 0x14;\n    while( true ) {\n      iVar1 = sigismember((sigset_t *)caught_signals,iVar3);\n      if (iVar1 != 0) {\n        signal(iVar3,(__sighandler_t)0x0);\n      }\n      if (piVar2 == (int *)&DAT_00118650) break;\n      iVar3 = *piVar2;\n      piVar2 = piVar2 + 1;\n    }\n  }\n  else {\n    piVar4 = (int *)(sig_10319 + 4);\n    iVar3 = 0x14;\n    sigemptyset((sigset_t *)caught_signals);\n    piVar2 = (int *)(sig_10319 + 4);\n    while( true ) {\n      sigaction(iVar3,(sigaction *)0x0,(sigaction *)local_d8);\n      if (local_d8._0_8_ != (__sighandler_t)0x1) {\n        sigaddset((sigset_t *)caught_signals,iVar3);\n      }\n      if (piVar2 == (int *)&DAT_00118650) break;\n      iVar3 = *piVar2;\n      piVar2 = piVar2 + 1;\n    }\n    local_50 = 0x10000000;\n    iVar3 = 0x14;\n    local_d8._8_4_ = caught_signals._0_4_;\n    uStack_cc = caught_signals._4_4_;\n    uStack_c8 = caught_signals._8_4_;\n    uStack_c4 = caught_signals._12_4_;\n    local_c0 = caught_signals._16_4_;\n    uStack_bc = caught_signals._20_4_;\n    uStack_b8 = caught_signals._24_4_;\n    uStack_b4 = caught_signals._28_4_;\n    local_b0 = caught_signals._32_4_;\n    uStack_ac = caught_signals._36_4_;\n    uStack_a8 = caught_signals._40_4_;\n    uStack_a4 = caught_signals._44_4_;\n    local_a0 = caught_signals._48_4_;\n    uStack_9c = caught_signals._52_4_;\n    uStack_98 = caught_signals._56_4_;\n    uStack_94 = caught_signals._60_4_;\n    local_90 = caught_signals._64_4_;\n    uStack_8c = caught_signals._68_4_;\n    uStack_88 = caught_signals._72_4_;\n    uStack_84 = caught_signals._76_4_;\n    local_80 = caught_signals._80_4_;\n    uStack_7c = caught_signals._84_4_;\n    uStack_78 = caught_signals._88_4_;\n    uStack_74 = caught_signals._92_4_;\n    local_70 = caught_signals._96_4_;\n    uStack_6c = caught_signals._100_4_;\n    uStack_68 = caught_signals._104_4_;\n    uStack_64 = caught_signals._108_4_;\n    local_60 = caught_signals._112_4_;\n    uStack_5c = caught_signals._116_4_;\n    uStack_58 = caught_signals._120_4_;\n    uStack_54 = caught_signals._124_4_;\n    while( true ) {\n      iVar1 = sigismember((sigset_t *)caught_signals,iVar3);\n      if (iVar1 != 0) {\n        local_d8._0_8_ = sighandler;\n        if (iVar3 == 0x14) {\n          local_d8._0_8_ = stophandler;\n        }\n        sigaction(iVar3,(sigaction *)local_d8,(sigaction *)0x0);\n      }\n      if (piVar4 == (int *)&DAT_00118650) break;\n      iVar3 = *piVar4;\n      piVar4 = piVar4 + 1;\n    }\n  }\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00126078": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint iswcntrl(wint_t __wc)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* iswcntrl@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001134e0": "\nundefined8\nstrcaseeq1(long param_1,undefined8 param_2,byte param_3,char param_4,char param_5,char param_6,\n          char param_7)\n\n{\n  char cVar1;\n  byte bVar2;\n  undefined8 uVar3;\n  \n  cVar1 = c_isupper((int)(char)param_3);\n  bVar2 = *(byte *)(param_1 + 1);\n  if (cVar1 != '\\0') {\n    bVar2 = bVar2 & 0xdf;\n  }\n  if (param_3 != bVar2) {\n    return 0;\n  }\n  if (param_3 == 0) {\n    return 1;\n  }\n  uVar3 = strcaseeq2(param_1,param_2,(int)param_4,(int)param_5,(int)param_6,(int)param_7);\n  return uVar3;\n}\n\n", 
    "00115b80": "\nvoid xnrealloc(undefined8 param_1,ulong param_2,ulong param_3)\n\n{\n  if ((-1 < SUB168(ZEXT816(param_2) * ZEXT816(param_3),0)) &&\n     (SUB168(ZEXT816(param_2) * ZEXT816(param_3) >> 0x40,0) == 0)) {\n    xrealloc();\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  xalloc_die();\n}\n\n", 
    "00126190": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __libc_start_main(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __libc_start_main@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00108e10": "\n/* WARNING: Could not reconcile some variable overlaps */\n\nundefined8 gobble_file_constprop_0(char *param_1,int param_2,byte param_3,stat *param_4)\n\n{\n  undefined8 *puVar1;\n  ulonglong uVar2;\n  stat *psVar3;\n  undefined uVar4;\n  byte bVar5;\n  char cVar6;\n  int iVar7;\n  uint uVar8;\n  undefined8 uVar9;\n  size_t sVar10;\n  char *pcVar11;\n  size_t sVar12;\n  int *piVar13;\n  undefined8 uVar14;\n  undefined4 uVar15;\n  ulong uVar16;\n  long lVar17;\n  int extraout_EDX;\n  stat **ppsVar18;\n  stat **ppsVar19;\n  stat **ppsVar20;\n  stat **ppsVar21;\n  byte *pbVar22;\n  undefined8 *puVar23;\n  byte *pbVar24;\n  stat *psVar25;\n  uint uVar26;\n  long in_FS_OFFSET;\n  bool bVar27;\n  bool bVar28;\n  byte bVar29;\n  stat *local_398;\n  stat *local_390;\n  stat local_388;\n  undefined local_2f8 [32];\n  undefined local_2d8 [664];\n  long local_40;\n  \n  bVar29 = 0;\n  ppsVar21 = &local_398;\n  ppsVar20 = &local_398;\n  ppsVar18 = &local_398;\n  ppsVar19 = &local_398;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (cwd_n_used == cwd_n_alloc) {\n    local_390 = param_4;\n    cwd_file = xnrealloc(cwd_file,cwd_n_used,400);\n    cwd_n_alloc = cwd_n_alloc << 1;\n    param_4 = local_390;\n  }\n  puVar1 = (undefined8 *)(cwd_file + cwd_n_used * 200);\n  puVar1[0x18] = 0;\n  *puVar1 = 0;\n  puVar23 = (undefined8 *)((ulong)(puVar1 + 1) & 0xfffffffffffffff8);\n  for (uVar16 = (ulong)(((int)puVar1 - (int)(undefined8 *)((ulong)(puVar1 + 1) & 0xfffffffffffffff8)\n                        ) + 200U >> 3); uVar16 != 0; uVar16 = uVar16 - 1) {\n    *puVar23 = 0;\n    puVar23 = puVar23 + (ulong)bVar29 * -2 + 1;\n  }\n  puVar1[4] = 0;\n  *(int *)(puVar1 + 0x15) = param_2;\n  bVar27 = cwd_some_quoted == '\\0';\n  *(undefined4 *)((long)puVar1 + 0xc4) = 0xffffffff;\n  if ((bVar27) && (align_variable_outer_quotes != '\\0')) {\n    local_390 = param_4;\n    bVar5 = needs_quoting(param_1);\n    *(uint *)((long)puVar1 + 0xc4) = (uint)bVar5;\n    param_4 = local_390;\n    if (bVar5 != 0) {\n      cwd_some_quoted = '\\x01';\n    }\n  }\n  pcVar11 = param_1;\n  local_390._0_1_ = print_hyperlink;\n  if (param_3 == 0) {\n    if (print_hyperlink != 0) {\n      if ((*param_1 != '/') && (ppsVar21 = &local_398, *(char *)&param_4->st_dev != '\\0'))\n      goto LAB_0010913b;\n      goto LAB_00109606;\n    }\n    if (format_needs_stat != '\\0') {\nLAB_00109120:\n      ppsVar18 = &local_398;\n      if (*param_1 != '/') {\nLAB_0010912e:\n        ppsVar18 = &local_398;\n        if (*(char *)&param_4->st_dev != '\\0') goto LAB_0010913b;\n      }\n      goto LAB_00108eef;\n    }\n    if ((param_2 == 3) && (print_with_color != '\\0')) {\n      local_390 = (stat *)((ulong)local_390 & 0xffffffffffffff00);\n      local_398 = param_4;\n      cVar6 = is_colored(0x13);\n      param_4 = local_398;\n      if (cVar6 == '\\0') {\n        cVar6 = is_colored(0x12);\n        param_4 = local_398;\n        if (cVar6 == '\\0') {\n          cVar6 = is_colored(0x14);\n          param_4 = local_398;\n          if (cVar6 == '\\0') goto LAB_0010902f;\n        }\n      }\n      goto LAB_00109120;\n    }\nLAB_0010902f:\n    if (print_inode != '\\0') {\n      if ((param_2 != 6) && (param_2 != 0)) goto LAB_00109120;\nLAB_001098e4:\n      if (dereference != 5) {\n        if (((color_symlink_as_referent == '\\0') && (check_symlink_color == '\\0')) &&\n           (print_inode == '\\0')) {\n          if (format_needs_type == '\\0') goto LAB_00109960;\n          if (param_2 != 0) goto LAB_00109074;\n        }\n        goto LAB_00109120;\n      }\n      if (*param_1 != '/') goto LAB_0010912e;\n      goto LAB_00109349;\n    }\n    if (format_needs_type == '\\0') {\nLAB_00109960:\n      uVar9 = 0;\n    }\n    else {\n      if ((param_2 == 6) || (param_2 == 0)) goto LAB_001098e4;\n      if (format_needs_type == '\\0') goto LAB_00109960;\nLAB_00109074:\n      uVar9 = 0;\n      ppsVar18 = &local_398;\n      if (param_2 == 5) {\n        if (indicator_style != 3) {\n          local_398 = param_4;\n          local_390 = (stat *)((ulong)local_390 & 0xffffffffffffff00 | (ulong)(byte)local_390);\n          ppsVar18 = &local_398;\n          if (print_with_color == '\\0') goto LAB_00108fd2;\n          cVar6 = is_colored(0xe);\n          param_4 = local_398;\n          if (cVar6 == '\\0') {\n            cVar6 = is_colored(0x10);\n            param_4 = local_398;\n            if (cVar6 == '\\0') {\n              cVar6 = is_colored(0x11);\n              param_4 = local_398;\n              if (cVar6 == '\\0') {\n                cVar6 = is_colored(0x15);\n                ppsVar18 = &local_398;\n                param_4 = local_398;\n                if (cVar6 == '\\0') goto LAB_00108fd2;\n              }\n            }\n          }\n        }\n        goto LAB_00109120;\n      }\n    }\n  }\n  else {\n    ppsVar18 = &local_398;\n    if ((*param_1 != '/') && (ppsVar18 = &local_398, *(char *)&param_4->st_dev != '\\0')) {\nLAB_0010913b:\n      local_398 = (stat *)((ulong)local_398 & 0xffffffffffffff00 | (ulong)(byte)local_390);\n      local_390 = param_4;\n      sVar12 = strlen(param_1);\n      sVar10 = strlen((char *)local_390);\n      psVar3 = local_390;\n      psVar25 = local_398;\n      uVar16 = sVar12 + 0x19 + sVar10;\n      for (; ppsVar19 != (stat **)((long)&local_398 - (uVar16 & 0xfffffffffffff000));\n          ppsVar19 = (stat **)((long)ppsVar19 + -0x1000)) {\n        *(undefined8 *)((long)ppsVar19 + -8) = *(undefined8 *)((long)ppsVar19 + -8);\n      }\n      uVar16 = (ulong)((uint)uVar16 & 0xff0);\n      lVar17 = -uVar16;\n      ppsVar18 = (stat **)((long)ppsVar19 + lVar17);\n      if (uVar16 != 0) {\n        *(undefined8 *)((long)ppsVar19 + -8) = *(undefined8 *)((long)ppsVar19 + -8);\n      }\n      local_390 = (stat *)((ulong)local_390 & 0xffffffffffffff00 | (ulong)psVar25 & 0xff);\n      pcVar11 = (char *)((ulong)((long)ppsVar19 + lVar17 + 0xf) & 0xfffffffffffffff0);\n      *(undefined8 *)((long)ppsVar19 + lVar17 + -8) = 0x10979f;\n      attach(pcVar11,psVar3,param_1);\n    }\n    ppsVar21 = ppsVar18;\n    if ((byte)local_390 != 0) {\nLAB_00109606:\n      *(undefined8 *)((long)ppsVar21 + -8) = 0x109613;\n      lVar17 = canonicalize_filename_mode(pcVar11,2);\n      puVar1[2] = lVar17;\n      ppsVar18 = ppsVar21;\n      if (lVar17 == 0) {\n        *(undefined8 *)((long)ppsVar21 + -8) = 0x109633;\n        uVar9 = dcgettext(0,\"error canonicalizing %s\",5);\n        *(undefined8 *)((long)ppsVar21 + -8) = 0x109642;\n        file_failure(param_3,uVar9,pcVar11);\n      }\n    }\nLAB_00108eef:\n    psVar25 = (stat *)(puVar1 + 3);\n    if (dereference < 5) {\n      if ((dereference < 3) || (param_3 == 0)) {\nLAB_00108f0b:\n        local_390 = psVar25;\n        *(undefined8 *)((long)ppsVar18 + -8) = 0x108f1d;\n        iVar7 = lstat(pcVar11,psVar25);\n        uVar16 = 0;\n        goto joined_r0x00109369;\n      }\n      local_398 = (stat *)((ulong)local_398 & 0xffffffff00000000 | (ulong)dereference);\n      local_390 = psVar25;\n      *(undefined8 *)((long)ppsVar18 + -8) = 0x1095b1;\n      iVar7 = stat(pcVar11,psVar25);\n      if ((int)local_398 != 3) {\n        if (-1 < iVar7) {\n          psVar25 = local_390;\n          if ((*(uint *)(puVar1 + 6) & 0xf000) != 0x4000) goto LAB_00108f0b;\n          goto LAB_001095e0;\n        }\n        *(undefined8 *)((long)ppsVar18 + -8) = 0x109945;\n        piVar13 = __errno_location();\n        psVar25 = local_390;\n        if (*piVar13 == 2) goto LAB_00108f0b;\nLAB_00109970:\n        *(undefined8 *)((long)ppsVar18 + -8) = 0x109983;\n        uVar9 = dcgettext(0,\"cannot access %s\",5);\n        uVar14 = 0;\n        *(undefined8 *)((long)ppsVar18 + -8) = 0x109996;\n        file_failure(1,uVar9,pcVar11);\n        goto LAB_00108fe5;\n      }\nLAB_001095e0:\n      if (iVar7 != 0) goto LAB_00109970;\n      uVar16 = (ulong)param_3;\n    }\n    else {\n      ppsVar20 = ppsVar18;\n      if (dereference != 5) goto LAB_00108f0b;\nLAB_00109349:\n      local_390 = (stat *)(puVar1 + 3);\n      *(undefined8 *)((long)ppsVar20 + -8) = 0x10935b;\n      iVar7 = stat(pcVar11,(stat *)(puVar1 + 3));\n      uVar16 = 1;\n      ppsVar18 = ppsVar20;\njoined_r0x00109369:\n      if (iVar7 != 0) {\n        *(undefined8 *)((long)ppsVar18 + -8) = 0x109382;\n        uVar9 = dcgettext(0,\"cannot access %s\",5);\n        uVar14 = 0;\n        *(undefined8 *)((long)ppsVar18 + -8) = 0x109394;\n        file_failure(param_3,uVar9,pcVar11);\n        uVar9 = 0;\n        if (param_3 != 0) goto LAB_00108fe5;\n        goto LAB_00108fd2;\n      }\n    }\n    *(undefined *)(puVar1 + 0x17) = 1;\n    if (((param_2 == 5) || ((*(uint *)(puVar1 + 6) & 0xf000) == 0x8000)) &&\n       (print_with_color != '\\0')) {\n      local_398 = (stat *)((ulong)local_398 & 0xffffffffffffff00 | uVar16);\n      *(undefined8 *)((long)ppsVar18 + -8) = 0x109554;\n      cVar6 = is_colored(0x15);\n      psVar25 = local_390;\n      uVar16 = (ulong)local_398 & 0xff;\n      if (cVar6 != '\\0') {\n        local_390 = (stat *)((ulong)local_390 & 0xffffffffffffff00 | (ulong)local_398 & 0xff);\n        *(undefined8 *)((long)ppsVar18 + -8) = 0x109578;\n        uVar4 = has_capability_cache_isra_0(psVar25);\n        uVar16 = (ulong)local_390 & 0xff;\n        *(undefined *)(puVar1 + 0x18) = uVar4;\n      }\n    }\n    if ((format == 0) || (print_scontext != '\\0')) {\n      *(undefined8 *)((long)ppsVar18 + -8) = 0x1093b3;\n      uVar8 = getfilecon_cache(pcVar11,puVar1,uVar16);\n      uVar26 = uVar8 >> 0x1f;\n      if ((int)uVar8 < 0) {\n        puVar1[0x16] = &UNKNOWN_SECURITY_CONTEXT;\n        *(undefined8 *)((long)ppsVar18 + -8) = 0x1097c3;\n        piVar13 = __errno_location();\n        iVar7 = *piVar13;\n        *(undefined8 *)((long)ppsVar18 + -8) = 0x1097cc;\n        cVar6 = is_ENOTSUP(iVar7);\n        if ((extraout_EDX != 0x3d) && (cVar6 == '\\0')) goto LAB_00109830;\n        if (format == 0) {\n          local_390._0_1_ = false;\n          goto LAB_001098a2;\n        }\n        *(undefined4 *)((long)puVar1 + 0xbc) = 0;\n        goto LAB_00108f6f;\n      }\n      *(undefined8 *)((long)ppsVar18 + -8) = 0x1093c7;\n      cVar6 = is_smack_enabled();\n      pbVar24 = (byte *)puVar1[0x16];\n      bVar27 = false;\n      bVar28 = cVar6 == '\\0';\n      if (bVar28) {\n        lVar17 = 10;\n        pbVar22 = (byte *)\"unlabeled\";\n        do {\n          if (lVar17 == 0) break;\n          lVar17 = lVar17 + -1;\n          bVar27 = *pbVar22 < *pbVar24;\n          bVar28 = *pbVar22 == *pbVar24;\n          pbVar22 = pbVar22 + (ulong)bVar29 * -2 + 1;\n          pbVar24 = pbVar24 + (ulong)bVar29 * -2 + 1;\n        } while (bVar28);\n        local_390._0_1_ = (!bVar27 && !bVar28) != bVar27;\n      }\n      else {\n        iVar7 = 0x5f - (uint)*pbVar24;\n        if (iVar7 == 0) {\n          iVar7 = -(uint)pbVar24[1];\n        }\n        local_390._0_1_ = iVar7 != 0;\n      }\n      if (format == 0) {\nLAB_001098a2:\n        local_390 = (stat *)((ulong)local_390 & 0xffffffffffffff00 | (ulong)(byte)local_390);\n        *(undefined8 *)((long)ppsVar18 + -8) = 0x1098b3;\n        uVar8 = file_has_acl_cache(pcVar11,puVar1);\n        uVar26 = uVar8 >> 0x1f;\n        bVar27 = 0 < (int)uVar8;\n        bVar29 = bVar27 | (byte)local_390;\n      }\n      else {\n        bVar27 = false;\n        bVar29 = (byte)local_390;\n      }\n      if (bVar29 == 0) {\nLAB_00109830:\n        uVar15 = 0;\n      }\n      else {\n        uVar15 = 1;\n        any_has_acl = (bVar27 ^ 1U) & (byte)local_390;\n        if (any_has_acl == 0) {\n          uVar15 = 2;\n          any_has_acl = bVar29;\n        }\n      }\n      *(undefined4 *)((long)puVar1 + 0xbc) = uVar15;\n      if (uVar26 != 0) {\n        *(undefined8 *)((long)ppsVar18 + -8) = 0x10943c;\n        uVar9 = quotearg_n_style_colon(0,3,pcVar11);\n        *(undefined8 *)((long)ppsVar18 + -8) = 0x109444;\n        piVar13 = __errno_location();\n        iVar7 = *piVar13;\n        *(undefined8 *)((long)ppsVar18 + -8) = 0x109459;\n        error(0,iVar7,&DAT_0011beac,uVar9);\n      }\n      uVar8 = *(uint *)(puVar1 + 6) & 0xf000;\n      if (uVar8 == 0xa000) {\n        if (format != 0) goto LAB_00109750;\n        goto LAB_0010947c;\n      }\nLAB_00108f82:\n      if (uVar8 == 0x4000) {\n        if ((param_3 == 0) || (immediate_dirs != '\\0')) {\n          *(undefined4 *)(puVar1 + 0x15) = 3;\n        }\n        else {\n          *(undefined4 *)(puVar1 + 0x15) = 9;\n        }\n      }\n      else {\n        *(undefined4 *)(puVar1 + 0x15) = 5;\n      }\n    }\n    else {\nLAB_00108f6f:\n      uVar8 = *(uint *)(puVar1 + 6) & 0xf000;\n      if (uVar8 != 0xa000) goto LAB_00108f82;\nLAB_00109750:\n      if (check_symlink_color != '\\0') {\nLAB_0010947c:\n        *(undefined8 *)((long)ppsVar18 + -8) = 0x10948b;\n        get_link_name(pcVar11,puVar1,param_3);\n        uVar9 = puVar1[1];\n        *(undefined8 *)((long)ppsVar18 + -8) = 0x109497;\n        pcVar11 = (char *)make_link_name(pcVar11,uVar9);\n        if (pcVar11 != (char *)0x0) {\n          if (*(int *)((long)puVar1 + 0xc4) == 0) {\n            uVar9 = puVar1[1];\n            *(undefined8 *)((long)ppsVar18 + -8) = 0x109a29;\n            cVar6 = needs_quoting(uVar9);\n            if (cVar6 != '\\0') {\n              *(undefined4 *)((long)puVar1 + 0xc4) = 0xffffffff;\n            }\n          }\n          if ((1 < indicator_style) || (check_symlink_color != '\\0')) {\n            *(undefined8 *)((long)ppsVar18 + -8) = 0x1094d0;\n            iVar7 = stat(pcVar11,&local_388);\n            if ((iVar7 == 0) &&\n               (((*(undefined *)((long)puVar1 + 0xb9) = 1, param_3 == 0 || (format == 0)) ||\n                ((local_388.st_mode & 0xf000) != 0x4000)))) {\n              *(__mode_t *)((long)puVar1 + 0xac) = local_388.st_mode;\n            }\n          }\n        }\n        *(undefined8 *)((long)ppsVar18 + -8) = 0x109516;\n        free(pcVar11);\n        uVar8 = *(uint *)(puVar1 + 6) & 0xf000;\n        if (uVar8 != 0xa000) goto LAB_00108f82;\n      }\n      *(undefined4 *)(puVar1 + 0x15) = 6;\n    }\n    uVar9 = puVar1[0xb];\n    if ((format == 0) || (print_block_size != '\\0')) {\n      *(undefined8 *)((long)ppsVar18 + -8) = 0x1091d1;\n      uVar14 = human_readable(uVar9,local_2d8,human_output_opts,0x200,output_block_size);\n      *(undefined8 *)((long)ppsVar18 + -8) = 0x1091db;\n      iVar7 = gnu_mbswidth(uVar14,0);\n      if (block_size_width < iVar7) {\n        block_size_width = iVar7;\n      }\n      if (format != 0) goto LAB_00108fb6;\n      if (print_owner != '\\0') {\n        uVar15 = *(undefined4 *)((long)puVar1 + 0x34);\n        *(undefined8 *)((long)ppsVar18 + -8) = 0x109868;\n        iVar7 = format_user_width(uVar15);\n        if (owner_width < iVar7) {\n          owner_width = iVar7;\n        }\n      }\n      if (print_group != '\\0') {\n        uVar15 = *(undefined4 *)(puVar1 + 7);\n        *(undefined8 *)((long)ppsVar18 + -8) = 0x109848;\n        iVar7 = format_group_width(uVar15);\n        if (group_width < iVar7) {\n          group_width = iVar7;\n        }\n      }\n      if (print_author != '\\0') {\n        uVar15 = *(undefined4 *)((long)puVar1 + 0x34);\n        *(undefined8 *)((long)ppsVar18 + -8) = 0x109888;\n        iVar7 = format_user_width(uVar15);\n        if (author_width < iVar7) {\n          author_width = iVar7;\n        }\n      }\n      if (print_scontext != '\\0') goto LAB_00109227;\nLAB_0010923f:\n      if (format != 0) goto LAB_00108fc3;\n      uVar14 = puVar1[5];\n      *(undefined8 *)((long)ppsVar18 + -8) = 0x10925d;\n      pcVar11 = (char *)umaxtostr(uVar14,local_2f8);\n      *(undefined8 *)((long)ppsVar18 + -8) = 0x109265;\n      sVar12 = strlen(pcVar11);\n      if (nlink_width < (int)sVar12) {\n        nlink_width = (int)sVar12;\n      }\n      if ((*(uint *)(puVar1 + 6) & 0xb000) == 0x2000) {\n        uVar2 = puVar1[8];\n        *(undefined8 *)((long)ppsVar18 + -8) = 0x109296;\n        uVar8 = gnu_dev_major(uVar2);\n        *(undefined8 *)((long)ppsVar18 + -8) = 0x1092a0;\n        pcVar11 = (char *)umaxtostr(uVar8,local_2d8);\n        *(undefined8 *)((long)ppsVar18 + -8) = 0x1092a8;\n        sVar12 = strlen(pcVar11);\n        if (major_device_number_width < (int)sVar12) {\n          major_device_number_width = (int)sVar12;\n        }\n        uVar2 = puVar1[8];\n        *(undefined8 *)((long)ppsVar18 + -8) = 0x1092bf;\n        uVar8 = gnu_dev_minor(uVar2);\n        *(undefined8 *)((long)ppsVar18 + -8) = 0x1092c9;\n        pcVar11 = (char *)umaxtostr(uVar8,local_2d8);\n        *(undefined8 *)((long)ppsVar18 + -8) = 0x1092d1;\n        sVar12 = strlen(pcVar11);\n        if (minor_device_number_width < (int)sVar12) {\n          minor_device_number_width = (int)sVar12;\n        }\n        iVar7 = minor_device_number_width + 2 + major_device_number_width;\n        if (iVar7 <= file_size_width) goto LAB_00108fc3;\n      }\n      else {\n        uVar14 = puVar1[9];\n        *(undefined8 *)((long)ppsVar18 + -8) = 0x109711;\n        uVar14 = unsigned_file_size(uVar14);\n        *(undefined8 *)((long)ppsVar18 + -8) = 0x109732;\n        uVar14 = human_readable(uVar14,local_2d8,file_human_output_opts,1,file_output_block_size);\n        *(undefined8 *)((long)ppsVar18 + -8) = 0x10973c;\n        iVar7 = gnu_mbswidth(uVar14,0);\n        if (iVar7 <= file_size_width) goto LAB_00108fc3;\n      }\n    }\n    else {\nLAB_00108fb6:\n      if (print_scontext != '\\0') {\nLAB_00109227:\n        pcVar11 = (char *)puVar1[0x16];\n        *(undefined8 *)((long)ppsVar18 + -8) = 0x109233;\n        sVar12 = strlen(pcVar11);\n        if (scontext_width < (int)sVar12) {\n          scontext_width = (int)sVar12;\n        }\n        goto LAB_0010923f;\n      }\nLAB_00108fc3:\n      iVar7 = file_size_width;\n    }\n    file_size_width = iVar7;\n    if (print_inode != '\\0') {\n      uVar14 = puVar1[4];\n      *(undefined8 *)((long)ppsVar18 + -8) = 0x109320;\n      pcVar11 = (char *)umaxtostr(uVar14,local_2d8);\n      *(undefined8 *)((long)ppsVar18 + -8) = 0x109328;\n      sVar12 = strlen(pcVar11);\n      if (inode_number_width < (int)sVar12) {\n        inode_number_width = (int)sVar12;\n      }\n    }\n  }\nLAB_00108fd2:\n  uVar14 = uVar9;\n  *(undefined8 *)((long)ppsVar18 + -8) = 0x108fda;\n  uVar9 = xstrdup(param_1);\n  cwd_n_used = cwd_n_used + 1;\n  *puVar1 = uVar9;\nLAB_00108fe5:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar14;\n  }\n                    /* WARNING: Subroutine does not return */\n  *(undefined8 *)((long)ppsVar18 + -8) = 0x109a5c;\n  __stack_chk_fail();\n}\n\n", 
    "0010cf40": "\nchar * areadlink_with_size(char *param_1,ulong param_2)\n\n{\n  char *__buf;\n  ulong uVar1;\n  int *piVar2;\n  size_t __size;\n  \n  __size = param_2 + 1;\n  if (0x400 < param_2) {\n    __size = 0x401;\n  }\n  do {\n    __buf = (char *)malloc(__size);\n    while( true ) {\n      if (__buf == (char *)0x0) {\n        return (char *)0x0;\n      }\n      uVar1 = readlink(param_1,__buf,__size);\n      if (((long)uVar1 < 0) && (piVar2 = __errno_location(), *piVar2 != 0x22)) {\n        free(__buf);\n        return (char *)0x0;\n      }\n      if (uVar1 < __size) {\n        __buf[uVar1] = '\\0';\n        return __buf;\n      }\n      free(__buf);\n      if (0x3fffffffffffffff < __size) break;\n      __size = __size * 2;\n      __buf = (char *)malloc(__size);\n    }\n    if (0x7ffffffffffffffe < __size) {\n      piVar2 = __errno_location();\n      *piVar2 = 0xc;\n      return (char *)0x0;\n    }\n    __size = 0x7fffffffffffffff;\n  } while( true );\n}\n\n", 
    "00126070": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint sigaction(int __sig,sigaction *__act,sigaction *__oact)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* sigaction@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00110720": "\nundefined8 human_options(undefined8 param_1,undefined8 param_2,long *param_3)\n\n{\n  undefined8 uVar1;\n  long lVar2;\n  \n  uVar1 = humblock(param_1,param_3,param_2);\n  if (*param_3 != 0) {\n    return uVar1;\n  }\n  lVar2 = default_block_size();\n  *param_3 = lVar2;\n  return 4;\n}\n\n", 
    "001047e0": "\nvoid __fpending(void)\n\n{\n  (*(code *)PTR___fpending_00123ca8)();\n  return;\n}\n\n", 
    "00115fb0": "\nuint bkm_scale_by_power(undefined8 param_1,uint param_2,int param_3)\n\n{\n  uint uVar1;\n  uint uVar2;\n  ulong uVar3;\n  \n  uVar3 = (ulong)param_2;\n  param_3 = param_3 + -1;\n  uVar2 = 0;\n  do {\n    uVar1 = bkm_scale(param_1,uVar3 & 0xffffffff);\n    param_3 = param_3 + -1;\n    uVar2 = uVar2 | uVar1;\n  } while (param_3 != -1);\n  return uVar2;\n}\n\n", 
    "00114da0": "\nvoid quotearg_alloc(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  quotearg_alloc_mem(param_1,param_2,0,param_3);\n  return;\n}\n\n", 
    "00107c10": "\nundefined8 rev_xstrcoll_df_atime(long param_1,long param_2)\n\n{\n  char cVar1;\n  char cVar2;\n  long lVar3;\n  undefined8 uVar4;\n  \n  lVar3 = param_2;\n  cVar1 = is_directory_isra_0(*(undefined4 *)(param_1 + 0xa8));\n  cVar2 = is_directory_isra_0(*(undefined4 *)(param_2 + 0xa8));\n  if ((cVar2 == '\\x01') || (cVar1 == '\\0')) {\n    if ((cVar1 == '\\x01') || (uVar4 = 1, cVar2 == '\\0')) {\n      uVar4 = cmp_atime(lVar3,param_1,xstrcoll);\n      return uVar4;\n    }\n  }\n  else {\n    uVar4 = 0xffffffff;\n  }\n  return uVar4;\n}\n\n", 
    "00104a60": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fputs_unlocked(char *__s,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_fputs_unlocked_00123de8)();\n  return iVar1;\n}\n\n", 
    "00115060": "\nvoid quotearg_colon_mem(undefined8 param_1,undefined8 param_2)\n\n{\n  quotearg_char_mem(param_1,param_2,0x3a);\n  return;\n}\n\n", 
    "00104b80": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint wcwidth(wchar_t __c)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_wcwidth_00123e78)();\n  return iVar1;\n}\n\n", 
    "00117360": "\nint c_strcasecmp(undefined *param_1,undefined *param_2)\n\n{\n  byte bVar1;\n  byte bVar2;\n  int iVar3;\n  \n  iVar3 = 0;\n  if (param_1 != param_2) {\n    do {\n      bVar1 = c_tolower(*param_1);\n      bVar2 = c_tolower(*param_2);\n      if (bVar1 == 0) break;\n      param_1 = param_1 + 1;\n      param_2 = param_2 + 1;\n    } while (bVar1 == bVar2);\n    iVar3 = (uint)bVar1 - (uint)bVar2;\n  }\n  return iVar3;\n}\n\n", 
    "0010b200": "\nvoid print_many_per_line(void)\n\n{\n  long lVar1;\n  undefined8 uVar2;\n  ulong uVar3;\n  long lVar4;\n  long lVar5;\n  ulong uVar6;\n  long lVar7;\n  long lVar8;\n  ulong local_40;\n  \n  uVar3 = calculate_columns(1);\n  local_40 = 0;\n  lVar1 = column_info + uVar3 * 0x18;\n  uVar3 = (ulong)(cwd_n_used % uVar3 != 0) + cwd_n_used / uVar3;\n  if (uVar3 != 0) {\n    do {\n      lVar7 = 0;\n      uVar6 = local_40;\n      lVar8 = 0;\n      while( true ) {\n        uVar2 = *(undefined8 *)(sorted_file + uVar6 * 8);\n        lVar4 = length_of_file_name_and_frills();\n        lVar5 = *(long *)(*(long *)(lVar1 + -8) + lVar7);\n        lVar7 = lVar7 + 8;\n        print_file_name_and_frills(uVar2,lVar8);\n        uVar6 = uVar6 + uVar3;\n        if (cwd_n_used <= uVar6) break;\n        lVar5 = lVar5 + lVar8;\n        indent(lVar8 + lVar4,lVar5);\n        lVar8 = lVar5;\n      }\n      putchar_unlocked(10);\n      local_40 = local_40 + 1;\n    } while (uVar3 != local_40);\n  }\n  return;\n}\n\n", 
    "00107400": "\nchar * timetostr(ulong param_1,long param_2)\n\n{\n  ulong uVar1;\n  char *pcVar2;\n  char *pcVar3;\n  \n  *(undefined *)(param_2 + 0x14) = 0;\n  pcVar2 = (char *)(param_2 + 0x14);\n  if ((long)param_1 < 0) {\n    do {\n      pcVar3 = pcVar2;\n      uVar1 = (long)param_1 / 10;\n      pcVar3[-1] = ((char)uVar1 * '\\n' + '0') - (char)param_1;\n      param_1 = uVar1;\n      pcVar2 = pcVar3 + -1;\n    } while (uVar1 != 0);\n    pcVar3[-2] = '-';\n    return pcVar3 + -2;\n  }\n  do {\n    pcVar2 = pcVar2 + -1;\n    uVar1 = param_1 / 10;\n    *pcVar2 = (char)param_1 + (char)uVar1 * -10 + '0';\n    param_1 = uVar1;\n  } while (uVar1 != 0);\n  return pcVar2;\n}\n\n", 
    "00126168": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * memset(void *__s,int __c,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* memset@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00106310": "\nundefined8 patterns_match(char **param_1,char *param_2)\n\n{\n  int iVar1;\n  \n  if (param_1 == (char **)0x0) {\n    return 0;\n  }\n  do {\n    iVar1 = fnmatch(*param_1,param_2,4);\n    if (iVar1 == 0) {\n      return 1;\n    }\n    param_1 = (char **)param_1[1];\n  } while (param_1 != (char **)0x0);\n  return 0;\n}\n\n", 
    "001135d0": "\nundefined8\nstrcaseeq0_constprop_0\n          (byte *param_1,undefined8 param_2,byte param_3,char param_4,char param_5,char param_6,\n          char param_7,char param_8,char param_9)\n\n{\n  char cVar1;\n  byte bVar2;\n  undefined8 uVar3;\n  \n  cVar1 = c_isupper((int)(char)param_3);\n  bVar2 = *param_1;\n  if (cVar1 != '\\0') {\n    bVar2 = bVar2 & 0xdf;\n  }\n  uVar3 = 0;\n  if (bVar2 == param_3) {\n    uVar3 = strcaseeq1(param_1,param_2,(int)param_4,(int)param_5,(int)param_6,(int)param_7,\n                       (int)param_8,(int)param_9,0,0);\n  }\n  return uVar3;\n}\n\n", 
    "00116d60": "\nvoid extend_abbrs(void *param_1,void *param_2,size_t param_3)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = memcpy(param_1,param_2,param_3);\n  *(undefined *)((long)pvVar1 + param_3) = 0;\n  return;\n}\n\n", 
    "00126048": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\ntm * localtime_r(time_t *__timer,tm *__tp)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* localtime_r@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00116a00": "\nundefined8\n_obstack_begin_worker\n          (long *param_1,long param_2,long param_3,undefined8 param_4,undefined8 param_5,\n          undefined8 param_6)\n\n{\n  long *plVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  long lVar5;\n  \n  if (param_3 == 0) {\n    lVar5 = 0xf;\n    param_3 = 0x10;\n  }\n  else {\n    lVar5 = param_3 + -1;\n  }\n  param_1[6] = lVar5;\n  if (param_2 == 0) {\n    param_2 = 0xfe0;\n  }\n  *param_1 = param_2;\n  plVar1 = (long *)call_chunkfun(param_1);\n  param_1[1] = (long)plVar1;\n  if (plVar1 != (long *)0x0) {\n    uVar4 = -param_3 & (long)plVar1 + lVar5 + 0x10;\n    lVar5 = *param_1;\n    param_1[2] = uVar4;\n    param_1[3] = uVar4;\n    *plVar1 = lVar5 + (long)plVar1;\n    param_1[4] = lVar5 + (long)plVar1;\n    plVar1[1] = 0;\n    *(byte *)(param_1 + 10) = *(byte *)(param_1 + 10) & 0xf9;\n    return 1;\n  }\n  uVar2 = (*(code *)obstack_alloc_failed_handler)();\n  uVar3 = dcgettext(0,\"memory exhausted\",5);\n  __fprintf_chk(stderr,1,\"%s\\n\",uVar3,param_5,param_6,uVar2);\n                    /* WARNING: Subroutine does not return */\n  exit(exit_failure);\n}\n\n", 
    "00116b20": "\nulong * _obstack_newchunk(ulong **param_1,ulong param_2)\n\n{\n  ulong *puVar1;\n  ulong **ppuVar2;\n  ulong *puVar3;\n  ulong *puVar4;\n  ulong **ppuVar5;\n  ulong __n;\n  \n  __n = (long)param_1[3] - (long)param_1[2];\n  puVar1 = param_1[1];\n  puVar4 = (ulong *)(param_2 + __n + (long)param_1[6]);\n  puVar3 = (ulong *)((long)puVar4 + (__n >> 3) + 100);\n  if (puVar4 <= *param_1) {\n    puVar4 = *param_1;\n  }\n  if (puVar3 <= puVar4) {\n    puVar3 = puVar4;\n  }\n  ppuVar5 = param_1;\n  if ((CARRY8(param_2,__n) == false) && (CARRY8(param_2 + __n,(ulong)param_1[6]) == false)) {\n    puVar4 = puVar3;\n    ppuVar2 = (ulong **)call_chunkfun();\n    if (ppuVar2 != (ulong **)0x0) {\n      param_1[1] = (ulong *)ppuVar2;\n      ppuVar2[1] = puVar1;\n      param_1[4] = (ulong *)((long)ppuVar2 + (long)puVar3);\n      *ppuVar2 = (ulong *)((long)ppuVar2 + (long)puVar3);\n      puVar4 = (ulong *)((long)(ppuVar2 + 2) + (long)param_1[6] & ~(ulong)param_1[6]);\n      puVar3 = (ulong *)memcpy(puVar4,param_1[2],__n);\n      if ((*(byte *)(param_1 + 10) & 2) == 0) {\n        puVar3 = (ulong *)(~(ulong)param_1[6] & (long)(puVar1 + 2) + (long)param_1[6]);\n        if (param_1[2] == puVar3) {\n          ppuVar2[1] = (ulong *)puVar1[1];\n          puVar3 = (ulong *)call_freefun(param_1,puVar1);\n        }\n      }\n      *(byte *)(param_1 + 10) = *(byte *)(param_1 + 10) & 0xfd;\n      param_1[2] = puVar4;\n      param_1[3] = (ulong *)(__n + (long)puVar4);\n      return puVar3;\n    }\n  }\n  (*(code *)obstack_alloc_failed_handler)();\n  puVar3 = ppuVar5[1];\n  if (puVar3 != (ulong *)0x0) {\n    while ((puVar4 <= puVar3 || ((ulong *)*puVar3 < puVar4))) {\n      puVar3 = (ulong *)puVar3[1];\n      if (puVar3 == (ulong *)0x0) {\n        return (ulong *)0x0;\n      }\n    }\n    return (ulong *)0x1;\n  }\n  return puVar3;\n}\n\n", 
    "00126288": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nuint gnu_dev_major(ulonglong __dev)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* gnu_dev_major@@GLIBC_2.3.3 */\n  halt_baddata();\n}\n\n", 
    "00106790": "\nvoid clear_files(void)\n\n{\n  long lVar1;\n  ulong uVar2;\n  \n  if (cwd_n_used != 0) {\n    uVar2 = 0;\n    do {\n      lVar1 = uVar2 * 8;\n      uVar2 = uVar2 + 1;\n      free_ent(*(undefined8 *)(sorted_file + lVar1));\n    } while (uVar2 < cwd_n_used);\n  }\n  cwd_n_used = 0;\n  cwd_some_quoted = 0;\n  any_has_acl = 0;\n  inode_number_width = 0;\n  block_size_width = 0;\n  nlink_width = 0;\n  owner_width = 0;\n  group_width = 0;\n  author_width = 0;\n  scontext_width = 0;\n  major_device_number_width = 0;\n  minor_device_number_width = 0;\n  file_size_width = 0;\n  return;\n}\n\n", 
    "00115c70": "\nvoid xcalloc(size_t param_1,ulong param_2)\n\n{\n  void *pvVar1;\n  \n  if ((-1 < SUB168(ZEXT816(param_1) * ZEXT816(param_2),0)) &&\n     (SUB168(ZEXT816(param_1) * ZEXT816(param_2) >> 0x40,0) == 0)) {\n    pvVar1 = calloc(param_1,param_2);\n    if (pvVar1 != (void *)0x0) {\n      return;\n    }\n  }\n                    /* WARNING: Subroutine does not return */\n  xalloc_die();\n}\n\n", 
    "001048b0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\npasswd * getpwuid(__uid_t __uid)\n\n{\n  passwd *ppVar1;\n  \n  ppVar1 = (passwd *)(*(code *)PTR_getpwuid_00123d10)();\n  return ppVar1;\n}\n\n", 
    "001059a0": "\nundefined8 unsigned_file_size(undefined8 param_1)\n\n{\n  return param_1;\n}\n\n", 
    "00126160": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fnmatch(char *__pattern,char *__name,int __flags)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fnmatch@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001049d0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid __assert_fail(char *__assertion,char *__file,uint __line,char *__function)\n\n{\n  (*(code *)PTR___assert_fail_00123da0)();\n  return;\n}\n\n", 
    "00114fa0": "\nvoid quotearg_char_mem(undefined8 param_1,undefined8 param_2,char param_3,undefined8 param_4)\n\n{\n  undefined8 *puVar1;\n  long in_FS_OFFSET;\n  undefined8 local_48;\n  undefined8 uStack_40;\n  undefined8 local_38;\n  undefined8 uStack_30;\n  undefined8 local_28;\n  undefined8 uStack_20;\n  undefined8 local_18;\n  long local_10;\n  \n  puVar1 = &local_48;\n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_48 = default_quoting_options._0_8_;\n  uStack_40 = default_quoting_options._8_8_;\n  local_38 = default_quoting_options._16_8_;\n  uStack_30 = default_quoting_options._24_8_;\n  local_28 = default_quoting_options._32_8_;\n  uStack_20 = default_quoting_options._40_8_;\n  local_18 = default_quoting_options._48_8_;\n  set_char_quoting(&local_48,(int)param_3,1,param_4,param_1,param_2);\n  quotearg_n_options(0,param_1,param_2,puVar1);\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00126040": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid _ITM_deregisterTMCloneTable(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n  halt_baddata();\n}\n\n", 
    "00126280": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t fwrite_unlocked(void *__ptr,size_t __size,size_t __n,FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fwrite_unlocked@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00105b00": "\nvoid attach(char *param_1,char *param_2,char *param_3)\n\n{\n  char cVar1;\n  char cVar2;\n  char *pcVar3;\n  char *pcVar4;\n  char *pcVar5;\n  \n  cVar2 = *param_2;\n  cVar1 = cVar2;\n  if (cVar2 == '.') {\n    cVar1 = param_2[1];\n  }\n  pcVar4 = param_2;\n  if (cVar1 == '\\0') goto LAB_00105b4a;\n  do {\n    pcVar5 = param_1;\n    pcVar3 = pcVar4;\n    pcVar4 = pcVar3 + 1;\n    param_1 = pcVar5 + 1;\n    *pcVar5 = cVar2;\n    cVar2 = *pcVar4;\n  } while (cVar2 != '\\0');\n  if (pcVar4 <= param_2) goto LAB_00105b4a;\n  if (*pcVar3 == '/') goto LAB_00105b4a;\n  *param_1 = '/';\n  param_1 = pcVar5 + 2;\n  cVar2 = *param_3;\n  while (cVar2 != '\\0') {\n    *param_1 = cVar2;\n    param_1 = param_1 + 1;\n    param_3 = param_3 + 1;\nLAB_00105b4a:\n    cVar2 = *param_3;\n  }\n  *param_1 = '\\0';\n  return;\n}\n\n", 
    "00107f20": "\nundefined8 strcmp_df_mtime(long param_1,long param_2)\n\n{\n  char cVar1;\n  char cVar2;\n  undefined8 uVar3;\n  \n  cVar1 = is_directory_isra_0(*(undefined4 *)(param_1 + 0xa8));\n  cVar2 = is_directory_isra_0(*(undefined4 *)(param_2 + 0xa8));\n  if ((cVar2 == '\\x01') || (cVar1 == '\\0')) {\n    if ((cVar1 == '\\x01') || (uVar3 = 1, cVar2 == '\\0')) {\n      uVar3 = cmp_mtime(param_1);\n      return uVar3;\n    }\n  }\n  else {\n    uVar3 = 0xffffffff;\n  }\n  return uVar3;\n}\n\n", 
    "0010ecf0": "\nulong hash_get_max_bucket_length(long **param_1)\n\n{\n  long lVar1;\n  long *plVar2;\n  ulong uVar3;\n  ulong uVar4;\n  \n  plVar2 = *param_1;\n  uVar4 = 0;\n  do {\n    if (param_1[1] <= plVar2) {\n      return uVar4;\n    }\n    while (*plVar2 != 0) {\n      uVar3 = 1;\n      for (lVar1 = plVar2[1]; lVar1 != 0; lVar1 = *(long *)(lVar1 + 8)) {\n        uVar3 = uVar3 + 1;\n      }\n      if (uVar4 < uVar3) {\n        uVar4 = uVar3;\n      }\n      plVar2 = plVar2 + 2;\n      if (param_1[1] <= plVar2) {\n        return uVar4;\n      }\n    }\n    plVar2 = plVar2 + 2;\n  } while( true );\n}\n\n", 
    "00105d40": "\nulong indent(ulong param_1,ulong param_2)\n\n{\n  uint uVar1;\n  ulong in_RAX;\n  ulong uVar2;\n  \n  if (param_2 <= param_1) {\n    return in_RAX;\n  }\n  do {\n    while ((uVar2 = param_1 + 1, tabsize != 0 && (uVar2 / tabsize < param_2 / tabsize))) {\n      putchar_unlocked(9);\n      uVar2 = param_1 / tabsize;\n      param_1 = (param_1 + tabsize) - param_1 % tabsize;\n      if (param_2 <= param_1) {\n        return uVar2;\n      }\n    }\n    uVar1 = putchar_unlocked(0x20);\n    param_1 = uVar2;\n  } while (uVar2 < param_2);\n  return (ulong)uVar1;\n}\n\n", 
    "00104b30": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid tzset(void)\n\n{\n  (*(code *)PTR_tzset_00123e50)();\n  return;\n}\n\n", 
    "00115030": "\nvoid quotearg_char(undefined8 param_1,char param_2)\n\n{\n  quotearg_char_mem(param_1,0xffffffffffffffff,(int)param_2);\n  return;\n}\n\n", 
    "00117330": "\nuint rotr16(uint param_1,byte param_2)\n\n{\n  return param_1 & 0xffff0000 |\n         (uint)(ushort)((ushort)param_1 >> (param_2 & 0xf) |\n                       (ushort)param_1 << 0x10 - (param_2 & 0xf));\n}\n\n", 
    "00104a10": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * getcwd(char *__buf,size_t __size)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_getcwd_00123dc0)();\n  return pcVar1;\n}\n\n", 
    "00117450": "\nulong hash_pjw(char *param_1,ulong param_2)\n\n{\n  char cVar1;\n  ulong uVar2;\n  \n  cVar1 = *param_1;\n  if (cVar1 != '\\0') {\n    uVar2 = 0;\n    do {\n      param_1 = param_1 + 1;\n      uVar2 = (uVar2 << 9 | uVar2 >> 0x37) + (long)cVar1;\n      cVar1 = *param_1;\n    } while (cVar1 != '\\0');\n    return uVar2 % param_2;\n  }\n  return 0;\n}\n\n", 
    "00104d70": "\nvoid __fprintf_chk(void)\n\n{\n  (*(code *)PTR___fprintf_chk_00123f70)();\n  return;\n}\n\n", 
    "00112ef0": "\nvoid nstrftime(void)\n\n{\n  long lVar1;\n  long in_FS_OFFSET;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  __strftime_internal();\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00104c50": "\nvoid __printf_chk(void)\n\n{\n  (*(code *)PTR___printf_chk_00123ee0)();\n  return;\n}\n\n", 
    "00105f80": "\nvoid emit_size_note(void)\n\n{\n  char *__s;\n  FILE *__stream;\n  \n  __stream = stdout;\n  __s = (char *)dcgettext(0,\n                          \"\\nThe SIZE argument is an integer and optional unit (example: 10K is 10*1024).\\nUnits are K,M,G,T,P,E,Z,Y (powers of 1024) or KB,MB,... (powers of 1000).\\n\"\n                          ,5);\n  fputs_unlocked(__s,__stream);\n  return;\n}\n\n", 
    "00126038": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint strncmp(char *__s1,char *__s2,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strncmp@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001169c0": "\nvoid call_chunkfun(long param_1,undefined8 param_2)\n\n{\n  if ((*(byte *)(param_1 + 0x50) & 1) != 0) {\n                    /* WARNING: Could not recover jumptable at 0x001169ce. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n    (**(code **)(param_1 + 0x38))(*(undefined8 *)(param_1 + 0x48));\n    return;\n  }\n                    /* WARNING: Could not recover jumptable at 0x001169d3. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (**(code **)(param_1 + 0x38))(param_2);\n  return;\n}\n\n", 
    "00108600": "\nundefined8 rev_xstrcoll_df_name(undefined8 *param_1,undefined8 *param_2)\n\n{\n  char cVar1;\n  char cVar2;\n  undefined8 *puVar3;\n  undefined8 uVar4;\n  \n  puVar3 = param_2;\n  cVar1 = is_directory_isra_0(*(undefined4 *)(param_1 + 0x15));\n  cVar2 = is_directory_isra_0(*(undefined4 *)(param_2 + 0x15));\n  if ((cVar2 == '\\x01') || (cVar1 == '\\0')) {\n    if ((cVar1 == '\\x01') || (uVar4 = 1, cVar2 == '\\0')) {\n      uVar4 = cmp_name_isra_0(*puVar3,*param_1,xstrcoll);\n      return uVar4;\n    }\n  }\n  else {\n    uVar4 = 0xffffffff;\n  }\n  return uVar4;\n}\n\n", 
    "0010f3f0": "\nundefined4 hash_rehash(void **param_1,undefined8 param_2)\n\n{\n  void *pvVar1;\n  char cVar2;\n  undefined4 uVar3;\n  void *__nmemb;\n  long in_FS_OFFSET;\n  void *local_88;\n  void *local_80;\n  void *local_78;\n  void *local_70;\n  undefined8 local_68;\n  void *local_60;\n  void *local_58;\n  void *local_50;\n  void *local_48;\n  void *local_40;\n  long local_30;\n  \n  pvVar1 = param_1[5];\n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  __nmemb = (void *)compute_bucket_size_isra_0\n                              (*(undefined4 *)((long)pvVar1 + 8),param_2,\n                               *(undefined *)((long)pvVar1 + 0x10));\n  if (__nmemb != (void *)0x0) {\n    if (param_1[2] == __nmemb) {\n      uVar3 = 1;\n      goto LAB_0010f4fc;\n    }\n    local_88 = calloc((size_t)__nmemb,0x10);\n    if (local_88 != (void *)0x0) {\n      local_80 = (void *)((long)__nmemb * 0x10 + (long)local_88);\n      local_58 = param_1[6];\n      local_50 = param_1[7];\n      local_48 = param_1[8];\n      local_70 = (void *)0x0;\n      local_40 = param_1[9];\n      local_68 = 0;\n      local_78 = __nmemb;\n      local_60 = pvVar1;\n      uVar3 = transfer_entries(&local_88,param_1,0);\n      if ((char)uVar3 == '\\0') {\n        param_1[9] = local_40;\n        cVar2 = transfer_entries(param_1,&local_88,1);\n        if (cVar2 != '\\0') {\n          cVar2 = transfer_entries(param_1,&local_88,0);\n          if (cVar2 != '\\0') {\n            free(local_88);\n            goto LAB_0010f4fc;\n          }\n        }\n                    /* WARNING: Subroutine does not return */\n        abort();\n      }\n      free(*param_1);\n      *param_1 = local_88;\n      param_1[1] = local_80;\n      param_1[2] = local_78;\n      param_1[3] = local_70;\n      param_1[9] = local_40;\n      goto LAB_0010f4fc;\n    }\n  }\n  uVar3 = 0;\nLAB_0010f4fc:\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar3;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00107510": "\nvoid emit_ancillary_info(char *param_1)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  char *pcVar3;\n  undefined8 *puVar4;\n  char *pcVar5;\n  long in_FS_OFFSET;\n  bool bVar6;\n  undefined8 local_a8;\n  char *local_a0;\n  char *local_98 [4];\n  char *local_78;\n  char *local_70;\n  char *local_68;\n  char *local_60;\n  undefined *local_58;\n  char *local_50;\n  undefined8 local_48;\n  undefined8 local_40;\n  long local_30;\n  \n  pcVar5 = (char *)((long)&DAT_00119cff + 1);\n  puVar4 = &local_a8;\n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  local_a8 = 0x119d00;\n  local_a0 = \"test invocation\";\n  local_98[0] = \"coreutils\";\n  local_98[1] = \"Multi-call invocation\";\n  local_98[2] = \"sha224sum\";\n  local_78 = \"sha256sum\";\n  local_98[3] = \"sha2 utilities\";\n  local_70 = \"sha2 utilities\";\n  local_68 = \"sha384sum\";\n  local_60 = \"sha2 utilities\";\n  local_58 = &DAT_00119896;\n  local_50 = \"sha2 utilities\";\n  local_48 = 0;\n  local_40 = 0;\n  do {\n    iVar1 = strcmp(param_1,pcVar5);\n    if (iVar1 == 0) break;\n    pcVar5 = *(char **)((long)puVar4 + 0x10);\n    puVar4 = (undefined8 *)((long)puVar4 + 0x10);\n  } while (pcVar5 != (char *)0x0);\n  pcVar5 = *(char **)((long)puVar4 + 8);\n  if (pcVar5 == (char *)0x0) {\n    uVar2 = dcgettext(0,\"\\n%s online help: <%s>\\n\",5);\n    __printf_chk(1,uVar2,\"GNU coreutils\",\"https://www.gnu.org/software/coreutils/\");\n    pcVar5 = setlocale(5,(char *)0x0);\n    if ((pcVar5 == (char *)0x0) || (iVar1 = strncmp(pcVar5,\"en_\",3), pcVar5 = param_1, iVar1 == 0))\n    {\n      uVar2 = dcgettext(0,\"Full documentation at: <%s%s>\\n\",5);\n      pcVar3 = \" invocation\";\n      __printf_chk(1,uVar2,\"https://www.gnu.org/software/coreutils/\",param_1);\n      goto LAB_0010768c;\n    }\nLAB_00107723:\n    uVar2 = dcgettext(0,\"Report %s translation bugs to <https://translationproject.org/team/>\\n\",5);\n    __printf_chk(1,uVar2,param_1);\n  }\n  else {\n    uVar2 = dcgettext(0,\"\\n%s online help: <%s>\\n\",5);\n    __printf_chk(1,uVar2,\"GNU coreutils\",\"https://www.gnu.org/software/coreutils/\");\n    pcVar3 = setlocale(5,(char *)0x0);\n    if ((pcVar3 != (char *)0x0) && (iVar1 = strncmp(pcVar3,\"en_\",3), iVar1 != 0)) goto LAB_00107723;\n  }\n  uVar2 = dcgettext(0,\"Full documentation at: <%s%s>\\n\",5);\n  pcVar3 = \" invocation\";\n  __printf_chk(1,uVar2,\"https://www.gnu.org/software/coreutils/\",param_1);\n  bVar6 = param_1 != pcVar5;\n  param_1 = pcVar5;\n  if (bVar6) {\n    pcVar3 = \"\";\n  }\nLAB_0010768c:\n  uVar2 = dcgettext(0,\"or available locally via: info \\'(coreutils) %s%s\\'\\n\",5);\n  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  __printf_chk(1,uVar2,param_1,pcVar3);\n  return;\n}\n\n", 
    "00108840": "\nundefined8 xstrcoll_df_version(undefined8 *param_1,undefined8 *param_2)\n\n{\n  char cVar1;\n  char cVar2;\n  undefined8 uVar3;\n  \n  cVar1 = is_directory_isra_0(*(undefined4 *)(param_1 + 0x15));\n  cVar2 = is_directory_isra_0(*(undefined4 *)(param_2 + 0x15));\n  if ((cVar2 == '\\x01') || (cVar1 == '\\0')) {\n    if ((cVar1 == '\\x01') || (uVar3 = 1, cVar2 == '\\0')) {\n      uVar3 = cmp_version_isra_0(*param_1,*param_2);\n      return uVar3;\n    }\n  }\n  else {\n    uVar3 = 0xffffffff;\n  }\n  return uVar3;\n}\n\n", 
    "0010e930": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined8 check_tuning_isra_0(float **param_1)\n\n{\n  float fVar1;\n  float *pfVar2;\n  float fVar3;\n  \n  pfVar2 = *param_1;\n  if (pfVar2 == (float *)default_tuning) {\n    return 1;\n  }\n  fVar1 = pfVar2[2];\n  if ((((_DAT_0011bf54 < fVar1) && (fVar1 < DAT_0011bf58)) && (_DAT_0011bf5c < pfVar2[3])) &&\n     (_DAT_0011bf60 <= *pfVar2)) {\n    fVar3 = *pfVar2 + _DAT_0011bf54;\n    if (((fVar3 < pfVar2[1]) && (pfVar2[1] <= DAT_0011bf64)) && (fVar3 < fVar1)) {\n      return 1;\n    }\n  }\n  *param_1 = (float *)default_tuning;\n  return 0;\n}\n\n", 
    "00126058": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * strcpy(char *__dest,char *__src)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strcpy@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00116c50": "\nvoid _obstack_free(long param_1,ulong *param_2)\n\n{\n  ulong *puVar1;\n  ulong *puVar2;\n  \n  puVar1 = *(ulong **)(param_1 + 8);\n  while( true ) {\n    if (puVar1 == (ulong *)0x0) {\n      if (param_2 == (ulong *)0x0) {\n        return;\n      }\n                    /* WARNING: Subroutine does not return */\n      abort();\n    }\n    if ((puVar1 < param_2) && (puVar2 = (ulong *)*puVar1, param_2 <= puVar2)) break;\n    puVar1 = (ulong *)puVar1[1];\n    call_freefun(param_1);\n    *(byte *)(param_1 + 0x50) = *(byte *)(param_1 + 0x50) | 2;\n  }\n  *(ulong **)(param_1 + 0x18) = param_2;\n  *(ulong **)(param_1 + 0x10) = param_2;\n  *(ulong **)(param_1 + 0x20) = puVar2;\n  *(ulong **)(param_1 + 8) = puVar1;\n  return;\n}\n\n", 
    "00104000": "\nint _init(EVP_PKEY_CTX *ctx)\n\n{\n  undefined *puVar1;\n  \n  puVar1 = PTR___gmon_start___00123fd0;\n  if (PTR___gmon_start___00123fd0 != (undefined *)0x0) {\n    puVar1 = (undefined *)(*(code *)PTR___gmon_start___00123fd0)();\n  }\n  return (int)puVar1;\n}\n\n", 
    "00105570": "\nvoid __do_global_dtors_aux(void)\n\n{\n  if (completed_8061 == '\\0') {\n    if (PTR___cxa_finalize_00123fe8 != (undefined *)0x0) {\n      __cxa_finalize(__dso_handle);\n    }\n    deregister_tm_clones();\n    completed_8061 = 1;\n    return;\n  }\n  return;\n}\n\n", 
    "00107870": "\nvoid format_user(ulong param_1,int param_2,char param_3)\n\n{\n  int iVar1;\n  size_t sVar2;\n  long lVar3;\n  char *__s;\n  \n  __s = \"?\";\n  param_1 = param_1 & 0xffffffff;\n  if ((param_3 != '\\0') && (__s = (char *)0x0, numeric_ids == '\\0')) {\n    __s = (char *)getuser();\n  }\n  if (__s == (char *)0x0) {\n    lVar3 = (long)param_2;\n    __printf_chk(1,\"%*lu \",param_2,param_1);\n  }\n  else {\n    iVar1 = gnu_mbswidth(__s,0);\n    param_2 = param_2 - iVar1;\n    if (param_2 < 0) {\n      param_2 = 0;\n    }\n    fputs_unlocked(__s,stdout);\n    sVar2 = strlen(__s);\n    lVar3 = (long)param_2 + sVar2;\n    do {\n      param_2 = param_2 + -1;\n      putchar_unlocked(0x20);\n    } while (param_2 != -1);\n  }\n  dired_pos = lVar3 + 1 + dired_pos;\n  return;\n}\n\n", 
    "00126298": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * stpncpy(char *__dest,char *__src,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* stpncpy@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00107990": "\nvoid cmp_ctime(undefined8 *param_1,undefined8 *param_2,code *UNRECOVERED_JUMPTABLE)\n\n{\n  int iVar1;\n  undefined auVar2 [16];\n  undefined auVar3 [16];\n  \n  auVar2 = get_stat_ctime_isra_0(param_1[0x10],param_1[0x11]);\n  auVar3 = get_stat_ctime_isra_0(param_2[0x10],param_2[0x11]);\n  iVar1 = timespec_cmp(SUB168(auVar3,0),SUB168(auVar3 >> 0x40,0),SUB168(auVar2,0),\n                       SUB168(auVar2 >> 0x40,0));\n  if (iVar1 == 0) {\n                    /* WARNING: Could not recover jumptable at 0x001079ec. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n    (*UNRECOVERED_JUMPTABLE)(*param_1,*param_2);\n    return;\n  }\n  return;\n}\n\n", 
    "00126178": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * getcwd(char *__buf,size_t __size)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* getcwd@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00114b90": "\nuint set_char_quoting(undefined1 *param_1,byte param_2,uint param_3)\n\n{\n  uint uVar1;\n  uint uVar2;\n  \n  if (param_1 == (undefined1 *)0x0) {\n    param_1 = default_quoting_options;\n  }\n  uVar1 = *(uint *)(param_1 + (ulong)(param_2 >> 5) * 4 + 8);\n  uVar2 = uVar1 >> (param_2 & 0x1f);\n  *(uint *)(param_1 + (ulong)(param_2 >> 5) * 4 + 8) =\n       ((param_3 ^ uVar2) & 1) << (param_2 & 0x1f) ^ uVar1;\n  return uVar2 & 1;\n}\n\n", 
    "00116d70": "\nvoid getenv_TZ(void)\n\n{\n  getenv(\"TZ\");\n  return;\n}\n\n", 
    "00116e90": "\nundefined8 save_abbr(long *param_1,char *param_2)\n\n{\n  char *__s2;\n  long *plVar1;\n  int iVar2;\n  size_t sVar3;\n  ulong uVar4;\n  int *piVar5;\n  long lVar6;\n  char *__s1;\n  \n  __s2 = *(char **)(param_2 + 0x30);\n  if (__s2 == (char *)0x0) {\n    return 1;\n  }\n  if ((__s2 < param_2) || (param_2 + 0x38 <= __s2)) {\n    __s1 = (char *)((long)param_1 + 9);\n    if (*__s2 != '\\0') {\n      do {\n        iVar2 = strcmp(__s1,__s2);\n        while( true ) {\n          if (iVar2 == 0) goto LAB_00116f28;\n          if ((*__s1 == '\\0') &&\n             (((char *)((long)param_1 + 9) != __s1 || (*(char *)(param_1 + 1) == '\\0')))) {\n            sVar3 = strlen(__s2);\n            uVar4 = (long)__s1 - (long)(char *)((long)param_1 + 9);\n            if (~uVar4 < sVar3 + 1) {\n              piVar5 = __errno_location();\n              *piVar5 = 0xc;\n              return 0;\n            }\n            if (uVar4 + sVar3 + 1 < 0x77) {\n              extend_abbrs(__s1,__s2);\n            }\n            else {\n              lVar6 = tzalloc(__s2);\n              *param_1 = lVar6;\n              if (lVar6 == 0) {\n                return 0;\n              }\n              *(undefined *)(lVar6 + 8) = 0;\n              __s1 = (char *)(lVar6 + 9);\n            }\n            goto LAB_00116f28;\n          }\n          sVar3 = strlen(__s1);\n          __s1 = __s1 + sVar3 + 1;\n          if ((*__s1 != '\\0') || (plVar1 = (long *)*param_1, plVar1 == (long *)0x0)) break;\n          __s1 = (char *)((long)plVar1 + 9);\n          iVar2 = strcmp(__s1,__s2);\n          param_1 = plVar1;\n        }\n      } while( true );\n    }\n    __s1 = \"\";\nLAB_00116f28:\n    *(char **)(param_2 + 0x30) = __s1;\n  }\n  return 1;\n}\n\n", 
    "001049c0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint gettimeofday(timeval *__tv,__timezone_ptr_t __tz)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_gettimeofday_00123d98)();\n  return iVar1;\n}\n\n", 
    "00126050": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid _exit(int __status)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* _exit@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00126290": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * realloc(void *__ptr,size_t __size)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* realloc@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010ae60": "\nlong quote_name_width(undefined *param_1,undefined8 param_2,undefined4 param_3)\n\n{\n  long in_FS_OFFSET;\n  byte local_2039;\n  undefined *local_2038;\n  long local_2030;\n  undefined local_2028 [8200];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_2038 = local_2028;\n  quote_name_buf_constprop_0(&local_2038,param_1,param_2,param_3,&local_2030,&local_2039);\n  if ((local_2038 != local_2028) && (local_2038 != param_1)) {\n    free(local_2038);\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return (ulong)local_2039 + local_2030;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "001048a0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nDIR * opendir(char *__name)\n\n{\n  DIR *pDVar1;\n  \n  pDVar1 = (DIR *)(*(code *)PTR_opendir_00123d08)();\n  return pDVar1;\n}\n\n", 
    "00126170": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint ioctl(int __fd,ulong __request,...)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* ioctl@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00106d00": "\nvoid sort_files(void)\n\n{\n  ulong uVar1;\n  int iVar2;\n  int iVar3;\n  int iVar4;\n  \n  uVar1 = cwd_n_used;\n  if (sorted_file_alloc < (cwd_n_used >> 1) + cwd_n_used) {\n    free(sorted_file);\n    sorted_file = (void *)xnmalloc(uVar1,0x18);\n    sorted_file_alloc = cwd_n_used * 3;\n  }\n  initialize_ordering_vector();\n  if (sort_type != -1) {\n    iVar2 = _setjmp((__jmp_buf_tag *)failed_strcoll);\n    iVar4 = sort_type;\n    if (iVar2 != 0) {\n      if (sort_type == 3) {\n                    /* WARNING: Subroutine does not return */\n        __assert_fail(\"sort_type != sort_version\",\"src/ls.c\",0xee8,\"sort_files\");\n      }\n      initialize_ordering_vector();\n      iVar2 = 1;\n    }\n    iVar3 = 0;\n    if (iVar4 == 4) {\n      iVar3 = time_type;\n    }\n    mpsort(sorted_file,cwd_n_used,\n           *(undefined8 *)\n            (sort_functions +\n            ((ulong)directories_first +\n            ((ulong)sort_reverse + ((long)iVar2 + (ulong)(uint)(iVar3 + iVar4) * 2) * 2) * 2) * 8));\n  }\n  return;\n}\n\n", 
    "00104a00": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint ioctl(int __fd,ulong __request,...)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_ioctl_00123db8)();\n  return iVar1;\n}\n\n", 
    "00106e20": "\nvoid basename_is_dot_or_dotdot(void)\n\n{\n  undefined8 uVar1;\n  \n  uVar1 = last_component();\n  dot_or_dotdot(uVar1);\n  return;\n}\n\n", 
    "00105e50": "\nbool is_colored(uint param_1)\n\n{\n  long lVar1;\n  byte *pbVar2;\n  int iVar3;\n  bool bVar4;\n  \n  bVar4 = false;\n  lVar1 = *(long *)(color_indicator + (ulong)param_1 * 0x10);\n  if (lVar1 != 0) {\n    pbVar2 = *(byte **)(color_indicator + (ulong)param_1 * 0x10 + 8);\n    if (lVar1 == 1) {\n      return *pbVar2 != 0x30;\n    }\n    bVar4 = true;\n    if (lVar1 == 2) {\n      iVar3 = *pbVar2 - 0x30;\n      if (iVar3 == 0) {\n        iVar3 = pbVar2[1] - 0x30;\n      }\n      return iVar3 != 0;\n    }\n  }\n  return bVar4;\n}\n\n", 
    "00104c40": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * setlocale(int __category,char *__locale)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_setlocale_00123ed8)();\n  return pcVar1;\n}\n\n", 
    "00104b20": "\nvoid getfilecon(void)\n\n{\n  (*(code *)PTR_getfilecon_00123e48)();\n  return;\n}\n\n", 
    "00117340": "\nuint rotl8(uint param_1,byte param_2)\n\n{\n  return param_1 & 0xffffff00 |\n         (uint)(byte)((byte)param_1 << (param_2 & 7) | (byte)param_1 >> 8 - (param_2 & 7));\n}\n\n", 
    "00104d60": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t fwrite(void *__ptr,size_t __size,size_t __n,FILE *__s)\n\n{\n  size_t sVar1;\n  \n  sVar1 = (*(code *)PTR_fwrite_00123f68)();\n  return sVar1;\n}\n\n", 
    "00116370": "\nvoid xstrtol_error(uint param_1,int param_2,undefined param_3,long param_4,undefined8 param_5,\n                  undefined4 param_6)\n\n{\n  undefined8 uVar1;\n  char *pcVar2;\n  undefined *puVar3;\n  undefined *puVar4;\n  long in_FS_OFFSET;\n  undefined local_32;\n  undefined local_31;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_1 < 4) {\n    if (param_1 < 2) {\n      if (param_1 != 1) {\n        xstrtol_error_cold();\n        return;\n      }\n      pcVar2 = \"%s%s argument \\'%s\\' too large\";\n    }\n    else {\n      pcVar2 = \"invalid suffix in %s%s argument \\'%s\\'\";\n    }\n  }\n  else {\n    if (param_1 != 4) {\n                    /* WARNING: Subroutine does not return */\n      abort();\n    }\n    pcVar2 = \"invalid %s%s argument \\'%s\\'\";\n  }\n  if (param_2 < 0) {\n    puVar4 = &local_32;\n    local_31 = 0;\n    puVar3 = &DAT_0011cf3d + -(long)param_2;\n    local_32 = param_3;\n  }\n  else {\n    puVar3 = &DAT_0011cf3d;\n    puVar4 = *(undefined **)(param_4 + (long)param_2 * 0x20);\n  }\n  uVar1 = dcgettext(0,pcVar2,5);\n  error(param_6,0,uVar1,puVar3,puVar4,param_5);\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00117580": "\nvoid rpl_fflush(FILE *param_1)\n\n{\n  int iVar1;\n  \n  if (param_1 != (FILE *)0x0) {\n    iVar1 = __freading();\n    if (iVar1 != 0) {\n      clear_ungetc_buffer_preserving_position(param_1);\n      fflush(param_1);\n      return;\n    }\n  }\n  fflush(param_1);\n  return;\n}\n\n", 
    "00116b00": "\nvoid _obstack_begin_1(long param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n                     undefined8 param_5,undefined8 param_6)\n\n{\n  *(byte *)(param_1 + 0x50) = *(byte *)(param_1 + 0x50) | 1;\n  *(undefined8 *)(param_1 + 0x38) = param_4;\n  *(undefined8 *)(param_1 + 0x40) = param_5;\n  *(undefined8 *)(param_1 + 0x48) = param_6;\n  _obstack_begin_worker();\n  return;\n}\n\n", 
    "00126140": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\ntm * gmtime_r(time_t *__timer,tm *__tp)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* gmtime_r@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010b510": "\nvoid print_current_files(void)\n\n{\n  long lVar1;\n  ulong uVar2;\n  \n  switch(format) {\n  case 0:\n    uVar2 = 0;\n    if (cwd_n_used != 0) {\n      do {\n        set_normal_color();\n        lVar1 = uVar2 * 8;\n        uVar2 = uVar2 + 1;\n        print_long_format(*(undefined8 *)(sorted_file + lVar1));\n        putchar_unlocked(10);\n        dired_pos = dired_pos + 1;\n      } while (uVar2 < cwd_n_used);\n      return;\n    }\n    break;\n  case 1:\n    uVar2 = 0;\n    if (cwd_n_used != 0) {\n      do {\n        lVar1 = uVar2 * 8;\n        uVar2 = uVar2 + 1;\n        print_file_name_and_frills(*(undefined8 *)(sorted_file + lVar1),0);\n        putchar_unlocked(10);\n      } while (uVar2 < cwd_n_used);\n    }\n    break;\n  case 2:\n    if (line_length != 0) {\n      print_many_per_line();\n      return;\n    }\n    goto LAB_0010b600;\n  case 3:\n    if (line_length != 0) {\n      print_horizontal();\n      return;\n    }\nLAB_0010b600:\n    print_with_separator(0x20);\n    return;\n  case 4:\n    print_with_separator(0x2c);\n    return;\n  default:\n    return;\n  }\n  return;\n}\n\n", 
    "00126020": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint raise(int __sig)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* raise@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010d1e0": "\nvoid argmatch_valid(long *param_1,void *param_2,size_t param_3)\n\n{\n  long lVar1;\n  FILE *__stream;\n  int iVar2;\n  char *__s;\n  undefined8 uVar3;\n  long lVar4;\n  void *__s1;\n  \n  __stream = stderr;\n  __s1 = (void *)0x0;\n  __s = (char *)dcgettext(0,\"Valid arguments are:\",5);\n  fputs_unlocked(__s,__stream);\n  lVar4 = 0;\n  lVar1 = *param_1;\n  while (lVar1 != 0) {\n    if ((lVar4 == 0) || (iVar2 = memcmp(__s1,param_2,param_3), iVar2 != 0)) {\n      uVar3 = quote(lVar1);\n      __fprintf_chk(stderr,1,\"\\n  - %s\",uVar3);\n      __s1 = param_2;\n    }\n    else {\n      uVar3 = quote(lVar1);\n      __fprintf_chk(stderr,1,&DAT_0011beaa,uVar3);\n    }\n    lVar4 = lVar4 + 1;\n    param_2 = (void *)((long)param_2 + param_3);\n    lVar1 = param_1[lVar4];\n  }\n  putc_unlocked(10,stderr);\n  return;\n}\n\n", 
    "00115c50": "\nvoid xzalloc(size_t param_1)\n\n{\n  void *__s;\n  \n  __s = (void *)xmalloc();\n  memset(__s,0,param_1);\n  return;\n}\n\n", 
    "00126388": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint strcmp(char *__s1,char *__s2)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strcmp@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00126268": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint strcoll(char *__s1,char *__s2)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strcoll@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010e900": "\nlong safe_hasher(long *param_1,undefined8 param_2)\n\n{\n  ulong uVar1;\n  \n  uVar1 = (*(code *)param_1[6])(param_2,param_1[2]);\n  if (uVar1 <= (ulong)param_1[2] && param_1[2] != uVar1) {\n    return uVar1 * 0x10 + *param_1;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "00115b30": "\nvoid xcharalloc(void)\n\n{\n  xmalloc();\n  return;\n}\n\n", 
    "00126380": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid free(void *__ptr)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* free@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001047b0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\ntm * localtime_r(time_t *__timer,tm *__tp)\n\n{\n  tm *ptVar1;\n  \n  ptVar1 = (tm *)(*(code *)PTR_localtime_r_00123c90)();\n  return ptVar1;\n}\n\n", 
    "00126260": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint __fxstat(int __ver,int __fildes,stat *__stat_buf)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __fxstat@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001048d0": "\nvoid dcgettext(void)\n\n{\n  (*(code *)PTR_dcgettext_00123d20)();\n  return;\n}\n\n", 
    "001049f0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * memset(void *__s,int __c,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = (void *)(*(code *)PTR_memset_00123db0)();\n  return pvVar1;\n}\n\n", 
    "00110ab0": "\nchar * imaxtostr(ulong param_1,long param_2)\n\n{\n  ulong uVar1;\n  char *pcVar2;\n  char *pcVar3;\n  \n  *(undefined *)(param_2 + 0x14) = 0;\n  pcVar2 = (char *)(param_2 + 0x14);\n  if ((long)param_1 < 0) {\n    do {\n      pcVar3 = pcVar2;\n      uVar1 = (long)param_1 / 10;\n      pcVar3[-1] = ((char)uVar1 * '\\n' + '0') - (char)param_1;\n      param_1 = uVar1;\n      pcVar2 = pcVar3 + -1;\n    } while (uVar1 != 0);\n    pcVar3[-2] = '-';\n    return pcVar3 + -2;\n  }\n  do {\n    pcVar2 = pcVar2 + -1;\n    uVar1 = param_1 / 10;\n    *pcVar2 = (char)param_1 + (char)uVar1 * -10 + '0';\n    param_1 = uVar1;\n  } while (uVar1 != 0);\n  return pcVar2;\n}\n\n", 
    "00104b50": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\n__pid_t tcgetpgrp(int __fd)\n\n{\n  __pid_t _Var1;\n  \n  _Var1 = (*(code *)PTR_tcgetpgrp_00123e60)();\n  return _Var1;\n}\n\n", 
    "00117310": "\nvoid rotr_sz(void)\n\n{\n  rotr64();\n  return;\n}\n\n", 
    "00104a30": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint closedir(DIR *__dirp)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_closedir_00123dd0)();\n  return iVar1;\n}\n\n", 
    "00117430": "\nvoid dir_name(void)\n\n{\n  long lVar1;\n  \n  lVar1 = mdir_name();\n  if (lVar1 != 0) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  xalloc_die();\n}\n\n", 
    "00104d90": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint mbsinit(mbstate_t *__ps)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_mbsinit_00123f80)();\n  return iVar1;\n}\n\n", 
    "00126018": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __snprintf_chk(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __snprintf_chk@@GLIBC_2.3.4 */\n  halt_baddata();\n}\n\n", 
    "00104c70": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t strftime(char *__s,size_t __maxsize,char *__format,tm *__tp)\n\n{\n  size_t sVar1;\n  \n  sVar1 = (*(code *)PTR_strftime_00123ef0)();\n  return sVar1;\n}\n\n", 
    "00126258": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * nl_langinfo(nl_item __item)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* nl_langinfo@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00126138": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid fgetfilecon(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n  halt_baddata();\n}\n\n", 
    "0010ecd0": "\nundefined8 hash_get_n_buckets_used(long param_1)\n\n{\n  return *(undefined8 *)(param_1 + 0x18);\n}\n\n", 
    "00113070": "\nundefined8 strcaseeq8(long param_1,undefined8 param_2,byte param_3)\n\n{\n  char cVar1;\n  byte bVar2;\n  undefined8 uVar3;\n  \n  cVar1 = c_isupper((int)(char)param_3);\n  bVar2 = *(byte *)(param_1 + 8);\n  if (cVar1 != '\\0') {\n    bVar2 = bVar2 & 0xdf;\n  }\n  if (param_3 != bVar2) {\n    return 0;\n  }\n  if (param_3 == 0) {\n    return 1;\n  }\n  uVar3 = strcaseeq9(param_1,param_2);\n  return uVar3;\n}\n\n", 
    "00126030": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint * __errno_location(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __errno_location@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00108500": "\nvoid rev_strcmp_name(undefined8 *param_1,undefined8 *param_2)\n\n{\n  cmp_name_isra_0(*param_2,*param_1,PTR_strcmp_00123fc8);\n  return;\n}\n\n", 
    "00104020": "\nvoid FUN_00104020(void)\n\n{\n                    /* WARNING: Treating indirect jump as call */\n  (*(code *)PTR_00123c48)();\n  return;\n}\n\n", 
    "00107410": "\nulong visit_dir(ulong param_1,ulong param_2)\n\n{\n  undefined8 uVar1;\n  ulong *__ptr;\n  ulong *puVar2;\n  \n  __ptr = (ulong *)xmalloc(0x10);\n  uVar1 = active_dir_set;\n  *__ptr = param_2;\n  __ptr[1] = param_1;\n  puVar2 = (ulong *)hash_insert(uVar1,__ptr);\n  if (puVar2 != (ulong *)0x0) {\n    if (__ptr != puVar2) {\n      free(__ptr);\n    }\n    return param_2 & 0xffffff00 | (ulong)(__ptr != puVar2);\n  }\n                    /* WARNING: Subroutine does not return */\n  xalloc_die();\n}\n\n", 
    "00115b40": "\nvoid * xrealloc(void *param_1,size_t param_2)\n\n{\n  void *pvVar1;\n  \n  if ((param_2 == 0) && (param_1 != (void *)0x0)) {\n    free(param_1);\n    return (void *)0x0;\n  }\n  pvVar1 = realloc(param_1,param_2);\n  if ((pvVar1 == (void *)0x0) && (param_2 != 0)) {\n                    /* WARNING: Subroutine does not return */\n    xalloc_die();\n  }\n  return pvVar1;\n}\n\n", 
    "00126278": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __freading(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __freading@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00126158": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid __assert_fail(char *__assertion,char *__file,uint __line,char *__function)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __assert_fail@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00126398": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * malloc(size_t __size)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* malloc@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00114b70": "\nvoid set_quoting_style(undefined1 *param_1,undefined4 param_2)\n\n{\n  if ((undefined4 *)param_1 == (undefined4 *)0x0) {\n    param_1 = default_quoting_options;\n  }\n  *(undefined4 *)param_1 = param_2;\n  return;\n}\n\n", 
    "001047a0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint strncmp(char *__s1,char *__s2,size_t __n)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_strncmp_00123c88)();\n  return iVar1;\n}\n\n", 
    "00126270": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\ntime_t mktime(tm *__tp)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* mktime@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001048c0": "\nvoid bindtextdomain(void)\n\n{\n  (*(code *)PTR_bindtextdomain_00123d18)();\n  return;\n}\n\n", 
    "00126150": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint gettimeofday(timeval *__tv,__timezone_ptr_t __tz)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* gettimeofday@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001059b0": "\nundefined8 errno_unsupported(int param_1)\n\n{\n  undefined8 uVar1;\n  \n  if ((param_1 - 0x16U & 0xffffffef) != 0) {\n    uVar1 = is_ENOTSUP();\n    return uVar1;\n  }\n  return 1;\n}\n\n", 
    "00126390": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __cxa_finalize(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __cxa_finalize@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001049e0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fnmatch(char *__pattern,char *__name,int __flags)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_fnmatch_00123da8)();\n  return iVar1;\n}\n\n", 
    "00109ad0": "\nulong long_time_expected_width(void)\n\n{\n  long lVar1;\n  ulong uVar2;\n  long in_FS_OFFSET;\n  undefined8 local_460;\n  undefined local_458 [64];\n  undefined local_418 [1016];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  uVar2 = (ulong)width_11153;\n  if (-1 < (int)width_11153) goto LAB_00109af7;\n  local_460 = 0;\n  lVar1 = localtime_rz(localtz,&local_460,local_458);\n  if (lVar1 == 0) {\nLAB_00109b68:\n    uVar2 = (ulong)width_11153;\n  }\n  else {\n    lVar1 = align_nstrftime_constprop_0(local_418,0,local_458,localtz,0);\n    if (lVar1 == 0) goto LAB_00109b68;\n    uVar2 = mbsnwidth(local_418,lVar1,0);\n    width_11153 = (uint)uVar2;\n  }\n  if ((int)uVar2 < 0) {\n    width_11153 = 0;\n    uVar2 = 0;\n  }\nLAB_00109af7:\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00104a20": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t strspn(char *__s,char *__accept)\n\n{\n  size_t sVar1;\n  \n  sVar1 = (*(code *)PTR_strspn_00123dc8)();\n  return sVar1;\n}\n\n", 
    "00106e40": "\nulong * get_color_indicator(char **param_1,char param_2)\n\n{\n  byte bVar1;\n  char cVar2;\n  int iVar3;\n  long lVar4;\n  ulong *puVar5;\n  size_t sVar6;\n  ulong uVar7;\n  uint uVar8;\n  char *__s;\n  uint uVar9;\n  \n  bVar1 = *(byte *)((long)param_1 + 0xb9);\n  if (param_2 == '\\0') {\n    __s = *param_1;\n    if ((color_symlink_as_referent == '\\0') || (bVar1 == 0)) {\n      uVar8 = *(uint *)(param_1 + 6);\n    }\n    else {\n      uVar8 = *(uint *)((long)param_1 + 0xac);\n    }\n    uVar7 = (ulong)uVar8;\n    uVar8 = (uint)bVar1;\nLAB_00106f0f:\n    cVar2 = *(char *)(param_1 + 0x17);\n    uVar9 = uVar8;\n    if (cVar2 != '\\0') goto LAB_00106e7c;\nLAB_00106f1f:\n    uVar8 = uVar9;\n    uVar9 = *(uint *)(filetype_indicator_11457 + (ulong)*(uint *)(param_1 + 0x15) * 4);\n    uVar7 = (ulong)uVar9;\n    cVar2 = uVar9 == 7;\n    if (uVar9 == 5) goto LAB_00107040;\n  }\n  else {\n    __s = param_1[1];\n    uVar7 = (ulong)*(uint *)((long)param_1 + 0xac);\n    if (bVar1 == 0) {\n      cVar2 = is_colored(0xc);\n      uVar8 = 0xffffffff;\n      if (cVar2 != '\\0') {\n        lVar4 = 0xc0;\n        goto LAB_00106f77;\n      }\n      goto LAB_00106f0f;\n    }\n    cVar2 = *(char *)(param_1 + 0x17);\n    uVar8 = 0;\n    uVar9 = 0;\n    if (cVar2 == '\\0') goto LAB_00106f1f;\nLAB_00106e7c:\n    uVar9 = (uint)uVar7 & 0xf000;\n    if (uVar9 == 0x8000) {\n      if (((uVar7 & 0x800) != 0) && (cVar2 = is_colored(0x10), cVar2 != '\\0')) {\n        lVar4 = 0x100;\n        goto LAB_00106f77;\n      }\n      uVar8 = (uint)uVar7;\n      if (((uVar7 & 0x400) != 0) && (cVar2 = is_colored(0x11), cVar2 != '\\0')) {\n        lVar4 = 0x110;\n        goto LAB_00106f77;\n      }\n      cVar2 = is_colored(0x15);\n      if ((cVar2 != '\\0') && (*(char *)(param_1 + 0x18) != '\\0')) {\n        lVar4 = 0x150;\n        goto LAB_00106f77;\n      }\n      if (((uVar8 & 0x49) != 0) && (cVar2 = is_colored(0xe), cVar2 != '\\0')) {\n        lVar4 = 0xe0;\n        goto LAB_00106f77;\n      }\n      if (((char *)0x1 < param_1[5]) && (cVar2 = is_colored(0x16), cVar2 != '\\0')) {\n        lVar4 = 0x160;\n        goto LAB_00106f77;\n      }\nLAB_00107040:\n      sVar6 = strlen(__s);\n      for (puVar5 = color_ext_list; puVar5 != (ulong *)0x0; puVar5 = (ulong *)puVar5[4]) {\n        if ((*puVar5 <= sVar6) &&\n           (iVar3 = c_strncasecmp(__s + (sVar6 - *puVar5),puVar5[1]), iVar3 == 0)) {\n          puVar5 = puVar5 + 2;\n          goto LAB_00106f81;\n        }\n      }\n      lVar4 = 0x50;\n      goto LAB_00106f77;\n    }\n    if (uVar9 == 0x4000) {\n      if (((uint)uVar7 & 0x202) == 0x202) {\n        cVar2 = is_colored(0x14);\n        lVar4 = 0x140;\n        if (cVar2 != '\\0') goto LAB_00106f77;\n      }\n      uVar8 = (uint)uVar7;\n      if ((uVar7 & 2) != 0) {\n        cVar2 = is_colored(0x13);\n        lVar4 = 0x130;\n        if (cVar2 != '\\0') goto LAB_00106f77;\n      }\n      lVar4 = 0x60;\n      if ((uVar8 & 0x200) != 0) {\n        cVar2 = is_colored(0x12);\n        lVar4 = (-(ulong)(cVar2 == '\\0') & 0xffffffffffffff40) + 0x120;\n      }\n      goto LAB_00106f77;\n    }\n    if (uVar9 != 0xa000) {\n      lVar4 = 0x80;\n      if ((((uVar9 != 0x1000) && (lVar4 = 0x90, uVar9 != 0xc000)) && (lVar4 = 0xa0, uVar9 != 0x6000)\n          ) && (lVar4 = 0xd0, uVar9 == 0x2000)) {\n        lVar4 = 0xb0;\n      }\n      goto LAB_00106f77;\n    }\n    uVar7 = 7;\n  }\n  if ((uVar8 == 0) && (cVar2 != '\\0')) {\n    lVar4 = 0xd0;\n    if (color_symlink_as_referent == '\\0') {\n      cVar2 = is_colored(0xd);\n      lVar4 = (-(ulong)(cVar2 == '\\0') & 0xffffffffffffffa0) + 0xd0;\n    }\n  }\n  else {\n    lVar4 = uVar7 << 4;\n  }\nLAB_00106f77:\n  puVar5 = (ulong *)(color_indicator + lVar4);\nLAB_00106f81:\n  if (puVar5[1] == 0) {\n    puVar5 = (ulong *)0x0;\n  }\n  return puVar5;\n}\n\n", 
    "00117560": "\nvoid clear_ungetc_buffer_preserving_position(uint *param_1)\n\n{\n  if ((*param_1 & 0x100) == 0) {\n    return;\n  }\n  rpl_fseeko(param_1,0,1);\n  return;\n}\n\n", 
    "00104c60": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\ntime_t timegm(tm *__tp)\n\n{\n  time_t tVar1;\n  \n  tVar1 = (*(code *)PTR_timegm_00123ee8)();\n  return tVar1;\n}\n\n", 
    "00104b40": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fileno(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_fileno_00123e58)();\n  return iVar1;\n}\n\n", 
    "00110be0": "\nundefined8 wc_ensure_printable(wint_t *param_1)\n\n{\n  wint_t *pwVar1;\n  wint_t __wc;\n  int iVar2;\n  undefined8 uVar3;\n  \n  uVar3 = 0;\n  __wc = *param_1;\n  while (__wc != 0) {\n    iVar2 = iswprint(__wc);\n    if (iVar2 == 0) {\n      *param_1 = 0xfffd;\n      uVar3 = 1;\n    }\n    pwVar1 = param_1 + 1;\n    param_1 = param_1 + 1;\n    __wc = *pwVar1;\n  }\n  return uVar3;\n}\n\n", 
    "00117320": "\nuint rotl16(uint param_1,byte param_2)\n\n{\n  return param_1 & 0xffff0000 |\n         (uint)(ushort)((ushort)param_1 << (param_2 & 0xf) |\n                       (ushort)param_1 >> 0x10 - (param_2 & 0xf));\n}\n\n", 
    "00104d80": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fflush_unlocked(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_fflush_unlocked_00123f78)();\n  return iVar1;\n}\n\n", 
    "00126148": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\n__off_t lseek(int __fd,__off_t __offset,int __whence)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* lseek@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00116470": "\nbool bkm_scale(ulong *param_1,int param_2)\n\n{\n  ulong uVar1;\n  bool bVar2;\n  \n  uVar1 = SUB168(ZEXT816((ulong)(long)param_2) * ZEXT816(*param_1),0);\n  bVar2 = SUB168(ZEXT816((ulong)(long)param_2) * ZEXT816(*param_1) >> 0x40,0) != 0;\n  if (bVar2) {\n    uVar1 = 0xffffffffffffffff;\n  }\n  *param_1 = uVar1;\n  return bVar2;\n}\n\n", 
    "00126028": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid abort(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* abort@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010ece0": "\nundefined8 hash_get_n_entries(long param_1)\n\n{\n  return *(undefined8 *)(param_1 + 0x20);\n}\n\n", 
    "0010b610": "\nvoid print_dir(char *param_1,char *param_2,undefined param_3)\n\n{\n  char cVar1;\n  byte bVar2;\n  int iVar3;\n  int *piVar4;\n  DIR *__dirp;\n  long lVar5;\n  dirent *pdVar6;\n  undefined8 uVar7;\n  void *__ptr;\n  char *pcVar8;\n  size_t sVar9;\n  undefined8 uVar10;\n  undefined4 uVar11;\n  long lVar12;\n  long in_FS_OFFSET;\n  stat local_368;\n  undefined local_2d8 [664];\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  piVar4 = __errno_location();\n  *piVar4 = 0;\n  __dirp = opendir(param_1);\n  if (__dirp == (DIR *)0x0) {\n    uVar7 = dcgettext(0,\"cannot open directory %s\",5);\n    file_failure(param_3,uVar7,param_1);\n    goto LAB_0010b858;\n  }\n  if (active_dir_set != 0) {\n    iVar3 = dirfd(__dirp);\n    if (iVar3 < 0) {\n      iVar3 = stat(param_1,&local_368);\n    }\n    else {\n      iVar3 = fstat(iVar3,&local_368);\n    }\n    if (iVar3 < 0) {\n      uVar7 = dcgettext(0,\"cannot determine device and inode of %s\",5);\n      file_failure(param_3,uVar7,param_1);\n      closedir(__dirp);\n      goto LAB_0010b858;\n    }\n    cVar1 = visit_dir(local_368.st_dev,local_368.st_ino);\n    if (cVar1 != '\\0') {\n      uVar7 = quotearg_n_style_colon(0,3,param_1);\n      uVar10 = dcgettext(0,\"%s: not listing already-listed directory\",5);\n      error(0,0,uVar10,uVar7);\n      closedir(__dirp);\n      set_exit_status(1);\n      goto LAB_0010b858;\n    }\n    dev_ino_push(local_368.st_dev,local_368.st_ino);\n  }\n  clear_files();\n  if (recursive == '\\0') {\n    if (print_dir_name == '\\0') goto LAB_0010b767;\n    if (first_10638 == '\\0') goto LAB_0010b8a2;\nLAB_0010b6da:\n    if (dired == '\\0') goto LAB_0010b6ee;\nLAB_0010b8c8:\n    first_10638 = '\\0';\n    fwrite_unlocked(&DAT_00119927,1,2,stdout);\n    dired_pos = dired_pos + 2;\n  }\n  else {\n    if (first_10638 != '\\0') goto LAB_0010b6da;\nLAB_0010b8a2:\n    putchar_unlocked(10);\n    dired_pos = dired_pos + 1;\n    if (dired != '\\0') goto LAB_0010b8c8;\nLAB_0010b6ee:\n    first_10638 = '\\0';\n  }\n  __ptr = (void *)0x0;\n  if ((print_hyperlink != '\\0') &&\n     (__ptr = (void *)canonicalize_filename_mode(param_1,2), __ptr == (void *)0x0)) {\n    uVar7 = dcgettext(0,\"error canonicalizing %s\",5);\n    file_failure(param_3,uVar7,param_1);\n  }\n  if (param_2 == (char *)0x0) {\n    param_2 = param_1;\n  }\n  quote_name(param_2,dirname_quoting_options,0xffffffff,0,1,subdired_obstack,__ptr);\n  free(__ptr);\n  fwrite_unlocked(\":\\n\",1,2,stdout);\n  dired_pos = dired_pos + 2;\nLAB_0010b767:\n  lVar12 = 0;\n  do {\n    *piVar4 = 0;\n    pdVar6 = readdir(__dirp);\n    if (pdVar6 == (dirent *)0x0) {\n      if (*piVar4 == 0) break;\n      uVar7 = dcgettext(0,\"reading directory %s\",5);\n      file_failure(param_3,uVar7,param_1);\n      if (*piVar4 != 0x4b) break;\n    }\n    else {\n      cVar1 = file_ignored(pdVar6->d_name);\n      if (cVar1 == '\\0') {\n        uVar11 = 0;\n        bVar2 = pdVar6->d_type - 1;\n        if (bVar2 < 0xe) {\n          uVar11 = *(undefined4 *)(CSWTCH_796 + (ulong)bVar2 * 4);\n        }\n        lVar5 = gobble_file_constprop_0(pdVar6->d_name,uVar11,0,param_1);\n        lVar12 = lVar12 + lVar5;\n        if ((((format == 1) && (sort_type == -1)) && (print_block_size == '\\0')) &&\n           (recursive == '\\0')) {\n          sort_files();\n          print_current_files();\n          clear_files();\n        }\n      }\n    }\n    process_signals();\n  } while( true );\n  iVar3 = closedir(__dirp);\n  if (iVar3 != 0) {\n    uVar7 = dcgettext(0,\"closing directory %s\",5);\n    file_failure(param_3,uVar7,param_1);\n  }\n  sort_files();\n  if (recursive != '\\0') {\n    extract_dirs_from_files(param_1,0);\n  }\n  if ((format == 0) || (print_block_size != '\\0')) {\n    if (dired != '\\0') {\n      fwrite_unlocked(&DAT_00119927,1,2,stdout);\n      dired_pos = dired_pos + 2;\n    }\n    pcVar8 = (char *)dcgettext(0,\"total\",5);\n    fputs_unlocked(pcVar8,stdout);\n    sVar9 = strlen(pcVar8);\n    dired_pos = dired_pos + sVar9;\n    putchar_unlocked(0x20);\n    dired_pos = dired_pos + 1;\n    pcVar8 = (char *)human_readable(lVar12,local_2d8,human_output_opts,0x200,output_block_size);\n    fputs_unlocked(pcVar8,stdout);\n    sVar9 = strlen(pcVar8);\n    dired_pos = dired_pos + sVar9;\n    putchar_unlocked(10);\n    dired_pos = dired_pos + 1;\n  }\n  if (cwd_n_used != 0) {\n    print_current_files();\n  }\nLAB_0010b858:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00126120": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint __fxstatat(int __ver,int __fildes,char *__filename,stat *__stat_buf,int __flag)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __fxstatat@@GLIBC_2.4 */\n  halt_baddata();\n}\n\n", 
    "00126000": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\n__int32_t ** __ctype_toupper_loc(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __ctype_toupper_loc@@GLIBC_2.3 */\n  halt_baddata();\n}\n\n", 
    "00126360": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint sigaddset(sigset_t *__set,int __signo)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* sigaddset@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0011775c": "\nvoid _fini(void)\n\n{\n  return;\n}\n\n", 
    "00126240": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint wcwidth(wchar_t __c)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* wcwidth@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00107960": "\nvoid rev_xstrcoll_atime(undefined8 param_1,undefined8 param_2)\n\n{\n  cmp_atime(param_2,param_1,xstrcoll);\n  return;\n}\n\n", 
    "00115e70": "\nchar * xgetcwd(void)\n\n{\n  char *pcVar1;\n  int *piVar2;\n  \n  pcVar1 = getcwd((char *)0x0,0);\n  if (pcVar1 == (char *)0x0) {\n    piVar2 = __errno_location();\n    if (*piVar2 == 0xc) {\n                    /* WARNING: Subroutine does not return */\n      xalloc_die();\n    }\n  }\n  return pcVar1;\n}\n\n", 
    "001114d0": "\nvoid mpsort(long param_1,long param_2,undefined8 param_3)\n\n{\n  mpsort_with_tmp(param_1,param_2,param_1 + param_2 * 8,param_3);\n  return;\n}\n\n", 
    "0010d2e0": "\nlong __xargmatch_internal\n               (undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n               undefined8 param_5,code *param_6)\n\n{\n  long lVar1;\n  \n  lVar1 = argmatch(param_2,param_3,param_4,param_5);\n  if (lVar1 < 0) {\n    argmatch_invalid(param_1,param_2,lVar1);\n    argmatch_valid(param_3,param_4,param_5);\n    (*param_6)();\n    lVar1 = -1;\n  }\n  return lVar1;\n}\n\n", 
    "00107af0": "\nvoid rev_xstrcoll_mtime(undefined8 param_1,undefined8 param_2)\n\n{\n  cmp_mtime(param_2,param_1,xstrcoll);\n  return;\n}\n\n", 
    "00105d00": "\nuint print_type_indicator(undefined param_1)\n\n{\n  char cVar1;\n  uint uVar2;\n  \n  uVar2 = get_type_indicator(param_1);\n  cVar1 = (char)uVar2;\n  if (cVar1 == '\\0') {\n    return uVar2 & 0xffffff00;\n  }\n  uVar2 = putchar_unlocked((int)cVar1);\n  dired_pos = dired_pos + 1;\n  return uVar2 & 0xffffff00 | (uint)(cVar1 != '\\0');\n}\n\n", 
    "00104d30": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint gethostname(char *__name,size_t __len)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_gethostname_00123f50)();\n  return iVar1;\n}\n\n", 
    "00105e20": "\nvoid add_ignore_pattern(undefined8 param_1)\n\n{\n  undefined8 *puVar1;\n  \n  puVar1 = (undefined8 *)xmalloc(0x10);\n  *puVar1 = param_1;\n  puVar1[1] = ignore_patterns;\n  ignore_patterns = puVar1;\n  return;\n}\n\n", 
    "00104c10": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nuint gnu_dev_major(ulonglong __dev)\n\n{\n  uint uVar1;\n  \n  uVar1 = (*(code *)PTR_gnu_dev_major_00123ec0)();\n  return uVar1;\n}\n\n", 
    "00113050": "\nbool strcaseeq9(long param_1,long param_2)\n\n{\n  int iVar1;\n  \n  iVar1 = c_strcasecmp(param_1 + 9,param_2 + 9);\n  return iVar1 == 0;\n}\n\n", 
    "00115470": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\ndouble timespectod(long param_1,long param_2)\n\n{\n  return (double)param_2 / _DAT_0011c988 + (double)param_1;\n}\n\n", 
    "00115230": "\nvoid quote(undefined8 param_1)\n\n{\n  quote_n(0,param_1);\n  return;\n}\n\n", 
    "00115110": "\nvoid quotearg_n_custom_mem\n               (undefined4 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n               undefined8 param_5)\n\n{\n  long in_FS_OFFSET;\n  undefined8 local_68;\n  undefined8 uStack_60;\n  undefined8 local_58;\n  undefined8 uStack_50;\n  undefined8 local_48;\n  undefined8 uStack_40;\n  undefined8 local_38;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  local_68 = default_quoting_options._0_8_;\n  uStack_60 = default_quoting_options._8_8_;\n  local_38 = default_quoting_options._48_8_;\n  local_58 = default_quoting_options._16_8_;\n  uStack_50 = default_quoting_options._24_8_;\n  local_48 = default_quoting_options._32_8_;\n  uStack_40 = default_quoting_options._40_8_;\n  set_custom_quoting(&local_68);\n  quotearg_n_options(param_1,param_4,param_5,&local_68);\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00126238": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\ndirent * readdir(DIR *__dirp)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* readdir@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00126118": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\ngroup * getgrgid(__gid_t __gid)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* getgrgid@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00126358": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint iswprint(wint_t __wc)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* iswprint@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010dce0": "\nvoid close_stdout(void)\n\n{\n  int iVar1;\n  int *piVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  \n  iVar1 = close_stream(stdout);\n  if (iVar1 != 0) {\n    piVar2 = __errno_location();\n    if ((ignore_EPIPE == '\\0') || (*piVar2 != 0x20)) {\n      uVar3 = dcgettext(0,\"write error\",5);\n      if (file_name == 0) {\n        error(0,*piVar2,&DAT_0011beac,uVar3);\n      }\n      else {\n        uVar4 = quotearg_colon();\n        error(0,*piVar2,\"%s: %s\",uVar4,uVar3);\n      }\n      goto LAB_0010dd68;\n    }\n  }\n  iVar1 = close_stream(stderr);\n  if (iVar1 == 0) {\n    return;\n  }\nLAB_0010dd68:\n                    /* WARNING: Subroutine does not return */\n  _exit(exit_failure);\n}\n\n", 
    "00126010": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint sigprocmask(int __how,sigset_t *__set,sigset_t *__oset)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* sigprocmask@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00116c10": "\nulong * _obstack_allocated_p(long param_1,ulong *param_2)\n\n{\n  ulong *puVar1;\n  \n  puVar1 = *(ulong **)(param_1 + 8);\n  if (puVar1 == (ulong *)0x0) {\n    return puVar1;\n  }\n  while ((param_2 <= puVar1 || ((ulong *)*puVar1 < param_2))) {\n    puVar1 = (ulong *)puVar1[1];\n    if (puVar1 == (ulong *)0x0) {\n      return (ulong *)0x0;\n    }\n  }\n  return (ulong *)0x1;\n}\n\n", 
    "00105530": "\n/* WARNING: Removing unreachable block (ram,0x00105554) */\n/* WARNING: Removing unreachable block (ram,0x00105560) */\n\nvoid register_tm_clones(void)\n\n{\n  return;\n}\n\n", 
    "00126250": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fflush(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fflush@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00107950": "\nvoid strcmp_atime(undefined8 param_1,undefined8 param_2)\n\n{\n  cmp_atime(param_1,param_2,PTR_strcmp_00123fc8);\n  return;\n}\n\n", 
    "00110900": "\n__gid_t * getgroup(__gid_t param_1)\n\n{\n  __gid_t *p_Var1;\n  group *pgVar2;\n  size_t sVar3;\n  __gid_t *p_Var4;\n  ulong uVar5;\n  char *__s;\n  \n  p_Var4 = group_alist;\n  if (group_alist != (__gid_t *)0x0) {\n    do {\n      if (*p_Var4 == param_1) goto LAB_0011092d;\n      p_Var4 = *(__gid_t **)(p_Var4 + 2);\n    } while (p_Var4 != (__gid_t *)0x0);\n  }\n  __s = \"\";\n  pgVar2 = getgrgid(param_1);\n  uVar5 = 0x18;\n  if (pgVar2 != (group *)0x0) {\n    __s = pgVar2->gr_name;\n    sVar3 = strlen(__s);\n    uVar5 = sVar3 + 0x18 & 0xfffffffffffffff8;\n  }\n  p_Var4 = (__gid_t *)xmalloc(uVar5);\n  *p_Var4 = param_1;\n  strcpy((char *)(p_Var4 + 4),__s);\n  p_Var1 = p_Var4;\n  *(__gid_t **)(p_Var4 + 2) = group_alist;\n  group_alist = p_Var1;\nLAB_0011092d:\n  p_Var1 = (__gid_t *)0x0;\n  if (*(char *)(p_Var4 + 4) != '\\0') {\n    p_Var1 = p_Var4 + 4;\n  }\n  return p_Var1;\n}\n\n", 
    "00126130": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * strrchr(char *__s,int __c)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strrchr@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001114e0": "\nint iso_week_days(int param_1,int param_2)\n\n{\n  int iVar1;\n  \n  iVar1 = (param_1 - param_2) + 0x17e;\n  return (param_1 - iVar1) + 3 + (iVar1 / 7) * 7;\n}\n\n", 
    "00114b50": "\nundefined4 get_quoting_style(undefined1 *param_1)\n\n{\n  if ((undefined4 *)param_1 == (undefined4 *)0x0) {\n    param_1 = default_quoting_options;\n  }\n  return *(undefined4 *)param_1;\n}\n\n", 
    "00126378": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __sprintf_chk(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __sprintf_chk@@GLIBC_2.3.4 */\n  halt_baddata();\n}\n\n", 
    "00115c40": "\nvoid x2realloc(undefined8 param_1,undefined8 param_2)\n\n{\n  x2nrealloc(param_1,param_2,1);\n  return;\n}\n\n", 
    "00110bb0": "\nvoid mbs_align_pad(undefined *param_1,undefined *param_2,long param_3)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  \n  puVar1 = param_1;\n  if ((param_1 < param_2) && (puVar2 = param_1, param_3 != 0)) {\n    do {\n      puVar1 = puVar2 + 1;\n      *puVar2 = 0x20;\n      if (param_1 + (param_3 - (long)puVar1) == (undefined *)0x0) break;\n      puVar2 = puVar1;\n    } while (puVar1 < param_2);\n  }\n  *puVar1 = 0;\n  return;\n}\n\n", 
    "00107ae0": "\nvoid strcmp_mtime(undefined8 param_1,undefined8 param_2)\n\n{\n  cmp_mtime(param_1,param_2,PTR_strcmp_00123fc8);\n  return;\n}\n\n", 
    "00126370": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nushort ** __ctype_b_loc(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __ctype_b_loc@@GLIBC_2.3 */\n  halt_baddata();\n}\n\n", 
    "00104c00": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t fwrite_unlocked(void *__ptr,size_t __size,size_t __n,FILE *__stream)\n\n{\n  size_t sVar1;\n  \n  sVar1 = (*(code *)PTR_fwrite_unlocked_00123eb8)();\n  return sVar1;\n}\n\n", 
    "00117300": "\nvoid rotl_sz(void)\n\n{\n  rotl64();\n  return;\n}\n\n", 
    "00104e40": "\n/* WARNING: Could not reconcile some variable overlaps */\n\nundefined4 main(int param_1,undefined8 *param_2)\n\n{\n  undefined8 *puVar1;\n  undefined *puVar2;\n  undefined *puVar3;\n  byte bVar4;\n  char cVar5;\n  int iVar6;\n  uint uVar7;\n  char *pcVar8;\n  void *__ptr;\n  long lVar9;\n  long lVar10;\n  long *plVar11;\n  long in_FS_OFFSET;\n  undefined auVar12 [16];\n  undefined local_48 [24];\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  set_program_name(*param_2);\n  setlocale(6,\"\");\n  bindtextdomain(\"coreutils\",\"/usr/local/share/locale\");\n  textdomain(\"coreutils\");\n  initialize_exit_failure_constprop_0();\n  atexit(close_stdout);\n  exit_status = 0;\n  print_dir_name = 1;\n  pending_dirs = (long *)0x0;\n  current_time._0_8_ = 0x8000000000000000;\n  current_time._8_8_ = 0xffffffffffffffff;\n  iVar6 = decode_switches(param_1,param_2);\n  lVar10 = (long)iVar6;\n  if (((print_with_color != '\\0') && (parse_ls_color(), print_with_color != '\\0')) &&\n     (((cVar5 = is_colored(0xd), cVar5 != '\\0' ||\n       ((cVar5 = is_colored(0xe), cVar5 != '\\0' && (color_symlink_as_referent != '\\0')))) ||\n      ((cVar5 = is_colored(0xc), cVar5 != '\\0' && (format == 0)))))) {\n    check_symlink_color = 1;\n  }\n  if (((dereference == 1) && (dereference = 2, immediate_dirs == '\\0')) && (indicator_style != 3)) {\n    dereference = (-(uint)(format == 0) & 0xfffffffe) + 4;\n  }\n  if (recursive != '\\0') {\n    active_dir_set = hash_initialize(0x1e,0,dev_ino_hash,dev_ino_compare,dev_ino_free);\n    if (active_dir_set == 0) {\n                    /* WARNING: Subroutine does not return */\n      xalloc_die();\n    }\n    _obstack_begin(dev_ino_obstack,0,0,PTR_malloc_00123fd8,PTR_free_00123fb0);\n  }\n  pcVar8 = getenv(\"TZ\");\n  localtz = tzalloc(pcVar8);\n  puVar3 = PTR_malloc_00123fd8;\n  puVar2 = PTR_free_00123fb0;\n  if ((((sort_type - 2U & 0xfffffffd) == 0) || (format == 0)) ||\n     ((print_scontext != '\\0' || (print_block_size != '\\0')))) {\n    format_needs_stat = 1;\n    bVar4 = 0;\n  }\n  else {\n    format_needs_stat = 0;\n    bVar4 = 1;\n    if (((recursive == '\\0') && (print_with_color == '\\0')) && (indicator_style == 0)) {\n      bVar4 = directories_first;\n    }\n  }\n  format_needs_type = bVar4 & 1;\n  if (dired != '\\0') {\n    _obstack_begin(dired_obstack,0,0,PTR_malloc_00123fd8,PTR_free_00123fb0);\n    _obstack_begin(subdired_obstack,0,0,puVar3,puVar2);\n  }\n  if (print_hyperlink != '\\0') {\n    file_escape_init();\n    hostname = (undefined *)xgethostname();\n    if (hostname == (undefined *)0x0) {\n      hostname = &DAT_0011991e;\n    }\n  }\n  cwd_n_alloc = 100;\n  cwd_file = xnmalloc(100,200);\n  cwd_n_used = 0;\n  clear_files();\n  if (param_1 - iVar6 < 1) {\n    if (immediate_dirs == '\\0') {\n      queue_directory(&DAT_00119af9,0,1);\n    }\n    else {\n      gobble_file_constprop_0(&DAT_00119af9,3,1,&DAT_0011991e);\n    }\n    if (cwd_n_used != 0) goto LAB_00105314;\nLAB_001052bc:\n    auVar12 = CONCAT88(local_48._8_8_,local_48._0_8_);\n    if (pending_dirs != (long *)0x0) {\n      plVar11 = pending_dirs;\n      local_48._0_16_ = CONCAT88(local_48._8_8_,local_48._0_8_);\n      if (pending_dirs[3] != 0) goto LAB_00105088;\n      print_dir_name = 0;\n      local_48._0_16_ = auVar12;\n      goto LAB_00105088;\n    }\n  }\n  else {\n    do {\n      puVar1 = param_2 + lVar10;\n      lVar10 = lVar10 + 1;\n      gobble_file_constprop_0(*puVar1,0,1,&DAT_0011991e);\n    } while ((int)lVar10 < param_1);\n    if (cwd_n_used == 0) {\nLAB_00105039:\n      if (param_1 - iVar6 < 2) goto LAB_001052bc;\n    }\n    else {\nLAB_00105314:\n      sort_files();\n      if (immediate_dirs == '\\0') {\n        extract_dirs_from_files(0,1);\n      }\n      if (cwd_n_used == 0) goto LAB_00105039;\n      print_current_files();\n      auVar12 = CONCAT88(local_48._8_8_,local_48._0_8_);\n      if (pending_dirs == (long *)0x0) goto LAB_001050f0;\n      putchar_unlocked(10);\n      dired_pos = dired_pos + 1;\n    }\n    while (plVar11 = pending_dirs, auVar12 = local_48._0_16_, pending_dirs != (long *)0x0) {\nLAB_00105088:\n      while( true ) {\n        lVar10 = active_dir_set;\n        pending_dirs = (long *)plVar11[3];\n        if ((active_dir_set != 0) && (*plVar11 == 0)) break;\n        print_dir(*plVar11,plVar11[1],*(undefined *)(plVar11 + 2));\n        free_pending_ent(plVar11);\n        print_dir_name = 1;\n        plVar11 = pending_dirs;\n        auVar12 = local_48._0_16_;\n        if (pending_dirs == (long *)0x0) goto LAB_001050f0;\n      }\n      auVar12 = dev_ino_pop();\n      local_48._0_16_ = auVar12;\n      __ptr = (void *)hash_delete(lVar10,local_48);\n      if (__ptr == (void *)0x0) {\n                    /* WARNING: Subroutine does not return */\n        __assert_fail(\"found\",\"src/ls.c\",0x63c,(char *)&__PRETTY_FUNCTION___10346);\n      }\n      dev_ino_free(__ptr);\n      free_pending_ent(plVar11);\n    }\n  }\nLAB_001050f0:\n  local_48._0_16_ = auVar12;\n  if ((print_with_color != '\\0') && (used_color != '\\0')) {\n    if ((color_indicator._0_8_ != 2) ||\n       (((*color_indicator._8_8_ != 0x5b1b || (color_indicator._16_8_ != 1)) ||\n        (*color_indicator._24_8_ != 'm')))) {\n      restore_default_color();\n      auVar12 = local_48._0_16_;\n    }\n    local_48._0_16_ = auVar12;\n    fflush_unlocked(stdout);\n    signal_restore();\n    for (iVar6 = stop_signal_count; iVar6 != 0; iVar6 = iVar6 + -1) {\n      raise(0x13);\n    }\n    if (interrupt_signal != 0) {\n      raise(interrupt_signal);\n    }\n  }\n  if (dired != '\\0') {\n    dired_dump_obstack(\"//DIRED//\",dired_obstack);\n    dired_dump_obstack(\"//SUBDIRED//\",subdired_obstack);\n    uVar7 = get_quoting_style(filename_quoting_options);\n    __printf_chk(1,\"//DIRED-OPTIONS// --quoting-style=%s\\n\",\n                 *(undefined8 *)(quoting_style_args + (ulong)uVar7 * 8));\n  }\n  lVar10 = active_dir_set;\n  if (active_dir_set != 0) {\n    lVar9 = hash_get_n_entries(active_dir_set);\n    if (lVar9 != 0) {\n                    /* WARNING: Subroutine does not return */\n      __assert_fail(\"hash_get_n_entries (active_dir_set) == 0\",\"src/ls.c\",0x670,\n                    (char *)&__PRETTY_FUNCTION___10346);\n    }\n    hash_free(lVar10);\n  }\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return exit_status;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00104d20": "\nvoid freecon(void)\n\n{\n  (*(code *)PTR_freecon_00123f48)();\n  return;\n}\n\n", 
    "00108ae0": "\nundefined8 xstrcoll_df_extension(long param_1,long param_2)\n\n{\n  char cVar1;\n  char cVar2;\n  undefined8 uVar3;\n  \n  cVar1 = is_directory_isra_0(*(undefined4 *)(param_1 + 0xa8));\n  cVar2 = is_directory_isra_0(*(undefined4 *)(param_2 + 0xa8));\n  if ((cVar2 == '\\x01') || (cVar1 == '\\0')) {\n    if ((cVar1 == '\\x01') || (uVar3 = 1, cVar2 == '\\0')) {\n      uVar3 = cmp_extension_isra_0(param_1);\n      return uVar3;\n    }\n  }\n  else {\n    uVar3 = 0xffffffff;\n  }\n  return uVar3;\n}\n\n", 
    "00115240": "\nbool same_nameat(int param_1,undefined8 param_2,int param_3,undefined8 param_4)\n\n{\n  int iVar1;\n  void *__s1;\n  void *__s2;\n  size_t __n;\n  size_t sVar2;\n  char *pcVar3;\n  int *piVar4;\n  bool bVar5;\n  long in_FS_OFFSET;\n  stat local_168;\n  stat local_d8;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  __s1 = (void *)last_component(param_2);\n  __s2 = (void *)last_component(param_4);\n  __n = base_len(__s1);\n  sVar2 = base_len(__s2);\n  bVar5 = false;\n  if (__n == sVar2) {\n    iVar1 = memcmp(__s1,__s2,__n);\n    if (iVar1 == 0) {\n      pcVar3 = (char *)dir_name(param_2);\n      iVar1 = fstatat(param_1,pcVar3,&local_168,0x100);\n      if (iVar1 != 0) {\n        piVar4 = __errno_location();\n        error(1,*piVar4,&DAT_0011beac,pcVar3);\n      }\n      free(pcVar3);\n      pcVar3 = (char *)dir_name(param_4);\n      iVar1 = fstatat(param_3,pcVar3,&local_d8,0x100);\n      if (iVar1 != 0) {\n        piVar4 = __errno_location();\n        error(1,*piVar4,&DAT_0011beac,pcVar3);\n      }\n      bVar5 = local_168.st_ino == local_d8.st_ino && local_168.st_dev == local_d8.st_dev;\n      free(pcVar3);\n    }\n    else {\n      bVar5 = false;\n    }\n  }\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return bVar5;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00116450": "\nvoid xstrtol_fatal(undefined8 param_1,undefined8 param_2,char param_3,undefined8 param_4,\n                  undefined8 param_5)\n\n{\n  xstrtol_error(param_1,param_2,(int)param_3,param_4,param_5,exit_failure);\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "00126128": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint snprintf(char *__s,size_t __maxlen,char *__format,...)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* snprintf@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00126008": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * getenv(char *__name)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* getenv@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001081c0": "\nulong cmp_size_isra_0(undefined8 param_1,long param_2,undefined8 param_3,long param_4,\n                     code *UNRECOVERED_JUMPTABLE)\n\n{\n  ulong uVar1;\n  \n  if (param_4 < param_2) {\n    return 0xffffffff;\n  }\n  if (param_4 == param_2) {\n                    /* WARNING: Could not recover jumptable at 0x001081cd. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n    uVar1 = (*UNRECOVERED_JUMPTABLE)(param_1,param_3);\n    return uVar1;\n  }\n  return (ulong)(param_2 < param_4);\n}\n\n", 
    "00126368": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\n__int32_t ** __ctype_tolower_loc(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __ctype_tolower_loc@@GLIBC_2.3 */\n  halt_baddata();\n}\n\n", 
    "00126248": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint putc_unlocked(int __c,FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* putc_unlocked@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010ecc0": "\nundefined8 hash_get_n_buckets(long param_1)\n\n{\n  return *(undefined8 *)(param_1 + 0x10);\n}\n\n", 
    "00104e2c": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid _obstack_free_cold(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "00126340": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid _ITM_registerTMCloneTable(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n  halt_baddata();\n}\n\n", 
    "00126220": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fileno(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fileno@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00114e80": "\nvoid quotearg(undefined8 param_1)\n\n{\n  quotearg_n(0,param_1);\n  return;\n}\n\n", 
    "00105680": "\nvoid file_escape_init(void)\n\n{\n  char cVar1;\n  int iVar2;\n  ulong uVar3;\n  bool bVar4;\n  \n  uVar3 = 0;\n  do {\n    iVar2 = (int)uVar3;\n    cVar1 = c_isalnum(uVar3 & 0xffffffff);\n    bVar4 = true;\n    if (cVar1 == '\\0') {\n      if ((iVar2 - 0x2dU < 2) || (iVar2 == 0x7e)) {\n        bVar4 = true;\n      }\n      else {\n        bVar4 = iVar2 == 0x5f;\n      }\n    }\n    RFC3986[uVar3] = RFC3986[uVar3] | bVar4;\n    uVar3 = uVar3 + 1;\n  } while (uVar3 != 0x100);\n  return;\n}\n\n", 
    "00107980": "\nvoid xstrcoll_atime(undefined8 param_1,undefined8 param_2)\n\n{\n  cmp_atime(param_1,param_2,xstrcoll);\n  return;\n}\n\n", 
    "00126100": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid getopt_long(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* getopt_long@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010fa80": "\nulong triple_hash_no_name(long param_1,ulong param_2)\n\n{\n  return *(ulong *)(param_1 + 8) % param_2;\n}\n\n", 
    "001049b0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\n__off_t lseek(int __fd,__off_t __offset,int __whence)\n\n{\n  __off_t _Var1;\n  \n  _Var1 = (*(code *)PTR_lseek_00123d90)();\n  return _Var1;\n}\n\n", 
    "00115210": "\nvoid quote_mem(undefined8 param_1,undefined8 param_2)\n\n{\n  quote_n_mem(0,param_1,param_2);\n  return;\n}\n\n", 
    "00104b10": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint putchar_unlocked(int __c)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_putchar_unlocked_00123e40)();\n  return iVar1;\n}\n\n", 
    "00104d50": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid exit(int __status)\n\n{\n  (*(code *)PTR_exit_00123f60)();\n  return;\n}\n\n", 
    "00104c30": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * stpncpy(char *__dest,char *__src,size_t __n)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_stpncpy_00123ed0)();\n  return pcVar1;\n}\n\n", 
    "00108bd0": "\nvoid prep_non_filename_text(void)\n\n{\n  if (color_indicator._40_8_ != 0) {\n    put_indicator_isra_0(0x124080);\n    return;\n  }\n  put_indicator_isra_0(color_indicator);\n  put_indicator_isra_0(0x124090);\n  put_indicator_isra_0(0x124070);\n  return;\n}\n\n", 
    "00115450": "\nulong timespec_sign(ulong param_1,ulong param_2)\n\n{\n  ulong uVar1;\n  \n  uVar1 = 0xffffffff;\n  if (-1 < (long)param_1) {\n    uVar1 = (ulong)((param_1 | param_2) != 0);\n  }\n  return uVar1;\n}\n\n", 
    "0010af00": "\nlong length_of_file_name_and_frills(undefined8 *param_1)\n\n{\n  char cVar1;\n  long lVar2;\n  size_t sVar3;\n  char *pcVar4;\n  long lVar5;\n  long in_FS_OFFSET;\n  undefined auStack_2b8 [664];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  if (print_inode == '\\0') {\n    lVar5 = 0;\nLAB_0010afda:\n    if (print_block_size != '\\0') {\n      if (format != 4) goto LAB_0010af51;\n      lVar2 = 2;\n      if (*(char *)(param_1 + 0x17) != '\\0') {\n        pcVar4 = (char *)human_readable(param_1[0xb],auStack_2b8,human_output_opts,0x200,\n                                        output_block_size);\n        sVar3 = strlen(pcVar4);\n        lVar2 = sVar3 + 1;\n      }\nLAB_0010af5c:\n      lVar5 = lVar5 + lVar2;\n    }\n    if (print_scontext == '\\0') goto LAB_0010af6c;\n    if (format != 4) goto LAB_0010b041;\n    sVar3 = strlen((char *)param_1[0x16]);\n  }\n  else {\n    if (format == 4) {\n      pcVar4 = (char *)umaxtostr(param_1[4],auStack_2b8);\n      sVar3 = strlen(pcVar4);\n      lVar5 = sVar3 + 1;\n      goto LAB_0010afda;\n    }\n    lVar5 = (long)inode_number_width + 1;\n    if (print_block_size != '\\0') {\nLAB_0010af51:\n      lVar2 = (long)block_size_width + 1;\n      goto LAB_0010af5c;\n    }\n    if (print_scontext == '\\0') goto LAB_0010af6c;\nLAB_0010b041:\n    sVar3 = (size_t)scontext_width;\n  }\n  lVar5 = lVar5 + sVar3 + 1;\nLAB_0010af6c:\n  lVar2 = quote_name_width(*param_1,filename_quoting_options,*(undefined4 *)((long)param_1 + 0xc4));\n  lVar5 = lVar5 + lVar2;\n  if (indicator_style != 0) {\n    cVar1 = get_type_indicator(*(undefined *)(param_1 + 0x17),*(undefined4 *)(param_1 + 6),\n                               *(undefined4 *)(param_1 + 0x15));\n    lVar5 = lVar5 + (ulong)(cVar1 != '\\0');\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return lVar5;\n}\n\n", 
    "0010fea0": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined8 * human_readable(ulong param_1,char *param_2,uint param_3,ulong param_4,ulong param_5)\n\n{\n  char *pcVar1;\n  undefined auVar2 [16];\n  undefined auVar3 [16];\n  float fVar4;\n  float fVar5;\n  char cVar6;\n  uint uVar7;\n  uint uVar8;\n  uint uVar9;\n  lconv *plVar10;\n  size_t sVar11;\n  size_t sVar12;\n  undefined8 *puVar13;\n  ulong uVar14;\n  ulong uVar15;\n  long lVar16;\n  uint uVar17;\n  uint uVar18;\n  uint uVar19;\n  uint uVar20;\n  undefined8 *puVar21;\n  ulong uVar22;\n  uint uVar23;\n  char *__s;\n  undefined8 *puVar24;\n  ulong uVar25;\n  bool bVar26;\n  undefined8 in_ST0;\n  undefined8 *local_78;\n  uint local_68;\n  \n  uVar7 = param_3 & 3;\n  uVar8 = param_3 & 0x20;\n  plVar10 = localeconv();\n  puVar21 = (undefined8 *)plVar10->decimal_point;\n  uVar20 = (-(uint)(uVar8 == 0) & 0xffffffe8) + 0x400;\n  sVar11 = strlen((char *)puVar21);\n  bVar26 = 0xf < sVar11 - 1;\n  if (bVar26) {\n    puVar21 = (undefined8 *)&DAT_00119af9;\n  }\n  pcVar1 = plVar10->grouping;\n  __s = plVar10->thousands_sep;\n  if (bVar26) {\n    sVar11 = 1;\n  }\n  sVar12 = strlen(__s);\n  if (0x10 < sVar12) {\n    __s = \"\";\n  }\n  local_78 = (undefined8 *)(param_2 + 0x287);\n  uVar19 = (uint)sVar11;\n  if (param_4 < param_5) {\n    if (param_4 != 0) {\n      auVar3 = ZEXT816(param_5) / ZEXT816(param_4);\n      if (param_5 % param_4 == 0) {\n        uVar22 = SUB168(ZEXT816(param_1) / (auVar3 & (undefined  [16])0xffffffffffffffff),0);\n        auVar2 = ZEXT816((ulong)(SUB168(ZEXT816(param_1) %\n                                        (auVar3 & (undefined  [16])0xffffffffffffffff),0) * 10));\n        uVar25 = SUB168(auVar2 % (auVar3 & (undefined  [16])0xffffffffffffffff),0) * 2;\n        uVar9 = SUB164(auVar2 / (auVar3 & (undefined  [16])0xffffffffffffffff),0);\n        uVar15 = (ulong)uVar9;\n        if (uVar25 < SUB168(auVar3,0)) {\n          uVar17 = (uint)(uVar25 != 0);\n        }\n        else {\n          uVar17 = (SUB168(auVar3,0) < uVar25) + 2;\n        }\n        goto joined_r0x00110216;\n      }\n    }\nLAB_0010ff8c:\n    fVar4 = (float)param_4;\n    if ((long)param_4 < 0) {\n      fVar4 = fVar4 + _DAT_0011bf68;\n    }\n    if ((long)param_5 < 0) {\n      fVar4 = fVar4 / ((float)param_5 + _DAT_0011bf68);\n      if ((long)param_1 < 0) goto LAB_001100c0;\nLAB_0010ffc9:\n      fVar4 = (float)param_1 * fVar4;\n      if ((param_3 & 0x10) != 0) goto LAB_0010ffd5;\nLAB_00110108:\n      adjust_value(uVar7);\n      __sprintf_chk(param_2,1,0xffffffffffffffff,\"%.0Lf\");\n      sVar12 = strlen(param_2);\n      uVar23 = 0xffffffff;\n      sVar11 = sVar12;\n    }\n    else {\n      fVar4 = fVar4 / (float)param_5;\n      if (-1 < (long)param_1) goto LAB_0010ffc9;\nLAB_001100c0:\n      fVar4 = ((float)param_1 + _DAT_0011bf68) * fVar4;\n      if ((param_3 & 0x10) == 0) goto LAB_00110108;\nLAB_0010ffd5:\n      uVar23 = 0;\n      fVar5 = (float)uVar20;\n      do {\n        uVar23 = uVar23 + 1;\n        fVar5 = fVar5 * (float)uVar20;\n        if (fVar4 < fVar5) break;\n      } while (uVar23 != 8);\n      adjust_value(uVar7);\n      __sprintf_chk(param_2,1,0xffffffffffffffff,\"%.1Lf\");\n      sVar12 = strlen(param_2);\n      if ((sVar11 + 2 + (ulong)(uVar8 == 0) < sVar12) ||\n         (((param_3 & 8) != 0 && (param_2[sVar12 - 1] == '0')))) {\n        adjust_value(uVar7,in_ST0);\n        __sprintf_chk(param_2,1,0xffffffffffffffff,\"%.0Lf\");\n        sVar12 = strlen(param_2);\n        sVar11 = sVar12;\n      }\n      else {\n        sVar11 = sVar12 - (sVar11 + 1);\n      }\n    }\n    puVar13 = (undefined8 *)memmove((void *)((long)local_78 - sVar12),param_2,sVar12);\n    puVar24 = (undefined8 *)(sVar11 + (long)puVar13);\n  }\n  else {\n    if ((param_4 % param_5 != 0) ||\n       (uVar22 = param_1 * SUB168(ZEXT816(param_4) / ZEXT816(param_5),0),\n       SUB168(ZEXT816(uVar22) /\n              (ZEXT816(param_4) / ZEXT816(param_5) & (undefined  [16])0xffffffffffffffff),0) !=\n       param_1)) goto LAB_0010ff8c;\n    uVar17 = 0;\n    uVar15 = 0;\n    uVar9 = 0;\njoined_r0x00110216:\n    local_68 = param_3 & 0x10;\n    puVar13 = local_78;\n    if ((param_3 & 0x10) == 0) {\n      uVar23 = 0xffffffff;\nLAB_0011022b:\n      if (uVar7 != 1) goto LAB_0011023a;\n      puVar24 = local_78;\n      if (5 < (int)(uVar9 + (((uint)uVar22 & 1) + uVar17 != 0))) goto LAB_0011024a;\nLAB_00110278:\n      do {\n        puVar13 = (undefined8 *)((long)puVar13 + -1);\n        *(char *)puVar13 = (char)uVar22 + (char)(uVar22 / 10) * -10 + '0';\n        bVar26 = 9 < uVar22;\n        uVar22 = uVar22 / 10;\n      } while (bVar26);\n    }\n    else {\n      uVar9 = (uint)uVar15;\n      uVar25 = (ulong)uVar20;\n      uVar23 = 0;\n      if (uVar22 < uVar25) goto LAB_0011022b;\n      while( true ) {\n        uVar14 = uVar22 / uVar25;\n        uVar9 = (int)uVar15 + (int)(uVar22 % uVar25) * 10;\n        uVar15 = (ulong)uVar9 / (ulong)uVar20;\n        uVar18 = ((int)uVar17 >> 1) + (uVar9 % uVar20) * 2;\n        uVar9 = (uint)uVar15;\n        uVar17 = uVar17 + uVar18;\n        if (uVar18 < uVar20) {\n          uVar17 = (uint)(uVar17 != 0);\n        }\n        else {\n          uVar17 = (uVar20 < uVar17) + 2;\n        }\n        uVar23 = uVar23 + 1;\n        uVar22 = uVar14;\n        if (uVar14 < uVar25) break;\n        if (uVar23 == 8) goto LAB_0011022b;\n      }\n      if (9 < uVar14) goto LAB_0011022b;\n      if (uVar7 == 1) {\n        bVar26 = 2 < (uVar9 & 1) + uVar17;\n      }\n      else {\n        bVar26 = uVar17 != 0 && uVar7 == 0;\n      }\n      if (bVar26) {\n        cVar6 = (char)uVar15 + '1';\n        if (uVar9 == 9) {\n          uVar22 = uVar14 + 1;\n          if (uVar14 != 9) {\n            uVar17 = 0;\n            goto LAB_0011053f;\n          }\n          goto LAB_00110583;\n        }\n      }\n      else if (uVar9 == 0) {\nLAB_0011053f:\n        if ((param_3 & 8) != 0) goto LAB_00110585;\n        cVar6 = '0';\n      }\n      else {\n        cVar6 = (char)uVar15 + '0';\n      }\n      param_2[0x286] = cVar6;\n      uVar15 = sVar11 & 0xffffffff;\n      puVar13 = (undefined8 *)(param_2 + (0x286 - sVar11));\n      if (uVar19 < 8) {\n        if ((sVar11 & 4) == 0) {\n          if (((int)uVar15 != 0) &&\n             (*(undefined *)puVar13 = *(undefined *)puVar21, (sVar11 & 2) != 0)) {\n            *(undefined2 *)((long)puVar13 + (uVar15 - 2)) =\n                 *(undefined2 *)((long)puVar21 + (uVar15 - 2));\n          }\n        }\n        else {\n          *(undefined4 *)puVar13 = *(undefined4 *)puVar21;\n          *(undefined4 *)((long)puVar13 + (uVar15 - 4)) =\n               *(undefined4 *)((long)puVar21 + (uVar15 - 4));\n        }\n      }\n      else {\n        *puVar13 = *puVar21;\n        *(undefined8 *)((long)puVar13 + ((sVar11 & 0xffffffff) - 8)) =\n             *(undefined8 *)((long)puVar21 + ((sVar11 & 0xffffffff) - 8));\n        lVar16 = (long)puVar13 - ((ulong)(puVar13 + 1) & 0xfffffffffffffff8);\n        uVar9 = (int)lVar16 + uVar19 & 0xfffffff8;\n        if (7 < uVar9) {\n          uVar17 = 0;\n          do {\n            uVar15 = (ulong)uVar17;\n            uVar17 = uVar17 + 8;\n            *(undefined8 *)(((ulong)(puVar13 + 1) & 0xfffffffffffffff8) + uVar15) =\n                 *(undefined8 *)((long)puVar21 + (uVar15 - lVar16));\n          } while (uVar17 < uVar9);\n        }\n      }\nLAB_00110583:\n      uVar17 = 0;\nLAB_00110585:\n      puVar24 = puVar13;\n      if (uVar7 == 1) goto LAB_00110278;\n      uVar9 = 0;\nLAB_0011023a:\n      puVar24 = puVar13;\n      if ((uVar7 != 0) || ((int)(uVar17 + uVar9) < 1)) goto LAB_00110278;\nLAB_0011024a:\n      uVar22 = uVar22 + 1;\n      puVar13 = puVar24;\n      if (((local_68 == 0) || (uVar20 != uVar22)) || (uVar23 == 8)) goto LAB_00110278;\n      uVar23 = uVar23 + 1;\n      if ((param_3 & 8) == 0) {\n        *(undefined *)((long)puVar24 + -1) = 0x30;\n        puVar24 = (undefined8 *)((long)puVar24 + ~sVar11);\n        uVar22 = sVar11 & 0xffffffff;\n        if (uVar19 < 8) {\n          if ((sVar11 & 4) == 0) {\n            if (((int)uVar22 != 0) &&\n               (*(undefined *)puVar24 = *(undefined *)puVar21, (sVar11 & 2) != 0)) {\n              *(undefined2 *)((long)puVar24 + (uVar22 - 2)) =\n                   *(undefined2 *)((long)puVar21 + (uVar22 - 2));\n            }\n          }\n          else {\n            *(undefined4 *)puVar24 = *(undefined4 *)puVar21;\n            *(undefined4 *)((long)puVar24 + (uVar22 - 4)) =\n                 *(undefined4 *)((long)puVar21 + (uVar22 - 4));\n          }\n        }\n        else {\n          *puVar24 = *puVar21;\n          *(undefined8 *)((long)puVar24 + ((sVar11 & 0xffffffff) - 8)) =\n               *(undefined8 *)((long)puVar21 + ((sVar11 & 0xffffffff) - 8));\n          lVar16 = (long)puVar24 - ((ulong)(puVar24 + 1) & 0xfffffffffffffff8);\n          uVar7 = (int)lVar16 + uVar19 & 0xfffffff8;\n          if (7 < uVar7) {\n            uVar19 = 0;\n            do {\n              uVar22 = (ulong)uVar19;\n              uVar19 = uVar19 + 8;\n              *(undefined8 *)(((ulong)(puVar24 + 1) & 0xfffffffffffffff8) + uVar22) =\n                   *(undefined8 *)((long)puVar21 + (uVar22 - lVar16));\n            } while (uVar19 < uVar7);\n          }\n        }\n      }\n      *(undefined *)((long)puVar24 + -1) = 0x31;\n      puVar13 = (undefined8 *)((long)puVar24 + -1);\n    }\n  }\n  if ((param_3 & 4) != 0) {\n    puVar13 = (undefined8 *)group_number(puVar13,(long)puVar24 - (long)puVar13,pcVar1,__s);\n  }\n  puVar21 = local_78;\n  if ((param_3 & 0x80) == 0) goto LAB_0011019f;\n  if (uVar23 == 0xffffffff) {\n    if (param_5 < 2) {\n      uVar23 = 0;\n      goto LAB_0011018c;\n    }\n    uVar23 = 1;\n    uVar22 = 1;\n    do {\n      uVar22 = uVar22 * uVar20;\n      if (param_5 <= uVar22) break;\n      uVar23 = uVar23 + 1;\n    } while (uVar23 != 8);\n    if ((param_3 & 0x40) != 0) goto LAB_00110401;\nLAB_0011041f:\n    puVar21 = (undefined8 *)((long)local_78 + 1);\n    if ((uVar23 == 1) && (uVar8 == 0)) {\n      *(undefined *)local_78 = 0x6b;\n      goto joined_r0x001104f5;\n    }\n    *(undefined1 *)local_78 = power_letter[(int)uVar23];\n    if ((param_3 & 0x100) == 0) goto LAB_0011019f;\n    if (uVar8 != 0) {\n      *(undefined *)((long)local_78 + 1) = 0x69;\n      puVar21 = (undefined8 *)((long)local_78 + 2);\n    }\n  }\n  else {\nLAB_0011018c:\n    if ((param_3 & 0x100 | uVar23) == 0) goto LAB_0011019f;\n    if ((param_3 & 0x40) != 0) {\nLAB_00110401:\n      local_78 = (undefined8 *)(param_2 + 0x288);\n      param_2[0x287] = ' ';\n    }\n    puVar21 = local_78;\n    if (uVar23 != 0) goto LAB_0011041f;\njoined_r0x001104f5:\n    if ((param_3 & 0x100) == 0) goto LAB_0011019f;\n  }\n  *(undefined *)puVar21 = 0x42;\n  puVar21 = (undefined8 *)((long)puVar21 + 1);\nLAB_0011019f:\n  local_78 = puVar21;\n  *(undefined *)local_78 = 0;\n  return puVar13;\n}\n\n", 
    "001137b0": "\nulong quotearg_buffer_restyled\n                (undefined *param_1,ulong param_2,char *param_3,ulong param_4,int param_5,\n                uint param_6,long param_7,char *param_8,uint *param_9)\n\n{\n  byte *__s1;\n  bool bVar1;\n  bool bVar2;\n  bool bVar3;\n  bool bVar4;\n  bool bVar5;\n  bool bVar6;\n  int iVar7;\n  size_t sVar8;\n  ushort **ppuVar9;\n  long lVar10;\n  char cVar11;\n  uint uVar12;\n  ulong uVar13;\n  byte bVar14;\n  ulong uVar15;\n  char *pcVar16;\n  ulong uVar17;\n  ulong uVar18;\n  ulong uVar19;\n  long in_FS_OFFSET;\n  bool bVar20;\n  bool bVar21;\n  bool bVar22;\n  bool bVar23;\n  bool bVar24;\n  size_t local_c8;\n  uint *local_98;\n  ulong local_90;\n  uint *local_78;\n  char *local_70;\n  bool local_64;\n  wint_t local_4c;\n  mbstate_t local_48;\n  long local_40;\n  \n  local_70 = param_8;\n  local_78 = param_9;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  sVar8 = __ctype_get_mb_cur_max();\n  uVar12 = param_6 & 2;\n  bVar20 = uVar12 != 0;\n  switch(param_5) {\n  case 0:\n    bVar6 = true;\n    bVar2 = false;\n    uVar18 = 0;\n    local_64 = false;\n    local_90 = 0;\n    bVar20 = false;\n    bVar1 = false;\n    local_c8 = 0;\n    local_98 = (uint *)0x0;\n    break;\n  case 2:\n    if (uVar12 == 0) {\n      bVar1 = false;\nLAB_00113c37:\n      if (param_2 == 0) {\n        local_90 = 0;\n        bVar2 = false;\n        bVar6 = true;\n        local_64 = false;\n        goto LAB_00113c59;\n      }\n      bVar2 = false;\n      local_64 = false;\n      bVar6 = true;\n      uVar13 = 0;\n      local_90 = param_2;\n      goto LAB_001141f6;\n    }\n    bVar2 = false;\n    uVar18 = 0;\n    bVar6 = true;\n    local_64 = false;\n    local_90 = 0;\n    bVar20 = true;\n    bVar1 = false;\n    local_c8 = 1;\n    local_98 = (uint *)0x11cf3b;\n    break;\n  case 3:\n    bVar1 = true;\n    goto LAB_00113baf;\n  case 4:\n    if (uVar12 == 0) {\n      bVar1 = true;\n      goto LAB_00113c37;\n    }\n  case 1:\n    bVar1 = false;\nLAB_00113baf:\n    bVar6 = true;\n    local_64 = false;\n    bVar20 = true;\n    local_90 = 0;\n    bVar2 = false;\n    uVar18 = 0;\n    param_5 = 2;\n    local_c8 = 1;\n    local_98 = (uint *)0x11cf3b;\n    break;\n  case 5:\n    if (uVar12 == 0) {\n      if (param_2 != 0) {\n        *param_1 = 0x22;\n      }\n      bVar6 = true;\n      local_64 = false;\n      local_90 = 0;\n      bVar2 = false;\n      bVar20 = false;\n      uVar18 = 1;\n      bVar1 = true;\n      local_c8 = 1;\n      local_98 = &UINT_0011c240;\n    }\n    else {\n      bVar2 = false;\n      uVar18 = 0;\n      bVar6 = true;\n      local_64 = false;\n      local_90 = 0;\n      bVar20 = true;\n      bVar1 = true;\n      local_c8 = 1;\n      local_98 = &UINT_0011c240;\n    }\n    break;\n  case 6:\n    bVar2 = false;\n    uVar18 = 0;\n    bVar6 = true;\n    local_64 = false;\n    param_5 = 5;\n    local_90 = 0;\n    bVar20 = true;\n    bVar1 = true;\n    local_c8 = 1;\n    local_98 = &UINT_0011c240;\n    break;\n  case 7:\n    bVar6 = true;\n    bVar2 = false;\n    uVar18 = 0;\n    local_64 = false;\n    local_90 = 0;\n    bVar20 = false;\n    bVar1 = true;\n    local_c8 = 0;\n    local_98 = (uint *)0x0;\n    break;\n  case 8:\n  case 9:\n  case 10:\n    if (param_5 != 10) {\n      local_70 = (char *)gettext_quote(0x11c25f,param_5);\n      local_78 = (uint *)gettext_quote(\"\\'\");\n    }\n    uVar18 = 0;\n    if (uVar12 == 0) {\n      cVar11 = *local_70;\n      while (cVar11 != '\\0') {\n        if (uVar18 < param_2) {\n          param_1[uVar18] = cVar11;\n        }\n        uVar18 = uVar18 + 1;\n        cVar11 = local_70[uVar18];\n      }\n    }\n    bVar2 = false;\n    local_c8 = strlen((char *)local_78);\n    local_98 = local_78;\n    bVar6 = true;\n    local_64 = false;\n    local_90 = 0;\n    bVar1 = true;\n    break;\n  default:\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  do {\n    uVar13 = 0;\n    bVar4 = local_64;\nLAB_00113900:\n    bVar21 = param_4 != uVar13;\n    if (param_4 == 0xffffffffffffffff) {\n      bVar21 = param_3[uVar13] != '\\0';\n    }\n    bVar24 = bVar1;\n    if (bVar21) {\n      bVar23 = (bool)(param_5 != 2 & bVar1);\n      __s1 = (byte *)(param_3 + uVar13);\n      uVar17 = uVar13;\n      bVar3 = bVar2;\n      bVar5 = bVar23;\n      if (!bVar23) {\n        uVar15 = (ulong)*__s1;\n        switch(uVar15) {\n        case 0:\n          if (bVar1) goto switchD_00114160_caseD_0;\n          bVar5 = false;\n          uVar15 = 0;\n          if ((param_6 & 1) != 0) goto code_r0x001140fb;\n          goto LAB_00113eeb;\n        default:\nswitchD_00114010_caseD_1:\n          bVar22 = bVar1;\n          if (sVar8 != 1) {\n            local_48 = (mbstate_t)0x0;\n            if (param_4 == 0xffffffffffffffff) {\n              param_4 = strlen(param_3);\n            }\n            uVar17 = 0;\n            do {\n              uVar19 = uVar13 + uVar17;\n              lVar10 = rpl_mbrtowc(&local_4c,param_3 + uVar19,param_4 - uVar19,&local_48);\n              if (lVar10 == 0) break;\n              if (lVar10 == -1) {\n                bVar21 = false;\n                goto LAB_001143e8;\n              }\n              if (lVar10 == -2) goto joined_r0x001147fa;\n              if (((param_5 == 2) && (bVar20)) && (lVar10 != 1)) {\n                pcVar16 = param_3 + uVar19 + 1;\n                do {\n                  if (((byte)(*pcVar16 + 0xa5U) < 0x22) &&\n                     ((1L << (*pcVar16 + 0xa5U & 0x3f) & 0x20000002bU) != 0)) {\n                    param_5 = 2;\n                    goto LAB_00113dd0;\n                  }\n                  pcVar16 = pcVar16 + 1;\n                } while (param_3 + uVar19 + lVar10 != pcVar16);\n              }\n              iVar7 = iswprint(local_4c);\n              if (iVar7 == 0) {\n                bVar21 = false;\n              }\n              uVar17 = uVar17 + lVar10;\n              iVar7 = mbsinit(&local_48);\n            } while (iVar7 == 0);\n            bVar22 = (bool)((bVar21 ^ 1U) & bVar1);\n            goto LAB_001143e8;\n          }\n          ppuVar9 = __ctype_b_loc();\n          uVar17 = 1;\n          bVar22 = ((*ppuVar9)[uVar15] & 0x4000) == 0;\n          bVar21 = !bVar22;\n          bVar22 = (bool)(bVar22 & bVar1);\n          goto LAB_00113b71;\n        case 7:\n          uVar15 = 7;\n          bVar14 = 0x61;\n          break;\n        case 8:\n          uVar15 = 8;\n          bVar14 = 0x62;\n          break;\n        case 9:\n          uVar15 = 9;\n          bVar14 = 0x74;\n          goto LAB_001140b8;\n        case 10:\n          uVar15 = 10;\n          bVar14 = 0x6e;\n          goto LAB_001140b8;\n        case 0xb:\n          uVar15 = 0xb;\n          bVar14 = 0x76;\n          break;\n        case 0xc:\n          uVar15 = 0xc;\n          bVar14 = 0x66;\n          break;\n        case 0xd:\n          uVar15 = 0xd;\n          bVar14 = 0x72;\nLAB_001140b8:\n          bVar23 = (bool)(param_5 == 2 & bVar20);\n          if (bVar23) goto LAB_00113dc7;\n          break;\n        case 0x20:\n          uVar15 = 0x20;\n          goto LAB_00113db4;\n        case 0x21:\n        case 0x22:\n        case 0x24:\n        case 0x26:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x3b:\n        case 0x3c:\n        case 0x3d:\n        case 0x3e:\n        case 0x5b:\n        case 0x5e:\n        case 0x60:\n        case 0x7c:\n          bVar21 = false;\nLAB_00113db4:\n          bVar22 = param_5 == 2;\n          bVar23 = bVar21;\n          if ((!bVar20) || (!bVar22)) goto LAB_00113ad8;\n          goto LAB_00113dc7;\n        case 0x23:\n        case 0x7e:\nLAB_00113dab:\n          bVar22 = param_5 == 2;\n          if (uVar13 == 0) goto LAB_00113db4;\n          goto LAB_00113ad5;\n        case 0x25:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x2f:\n        case 0x30:\n        case 0x31:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x41:\n        case 0x42:\n        case 0x43:\n        case 0x44:\n        case 0x45:\n        case 0x46:\n        case 0x47:\n        case 0x48:\n        case 0x49:\n        case 0x4a:\n        case 0x4b:\n        case 0x4c:\n        case 0x4d:\n        case 0x4e:\n        case 0x4f:\n        case 0x50:\n        case 0x51:\n        case 0x52:\n        case 0x53:\n        case 0x54:\n        case 0x55:\n        case 0x56:\n        case 0x57:\n        case 0x58:\n        case 0x59:\n        case 0x5a:\n        case 0x5d:\n        case 0x5f:\n        case 0x61:\n        case 0x62:\n        case 99:\n        case 100:\n        case 0x65:\n        case 0x66:\n        case 0x67:\n        case 0x68:\n        case 0x69:\n        case 0x6a:\n        case 0x6b:\n        case 0x6c:\n        case 0x6d:\n        case 0x6e:\n        case 0x6f:\n        case 0x70:\n        case 0x71:\n        case 0x72:\n        case 0x73:\n        case 0x74:\n        case 0x75:\n        case 0x76:\n        case 0x77:\n        case 0x78:\n        case 0x79:\n        case 0x7a:\n          goto switchD_00114010_caseD_25;\n        case 0x27:\nswitchD_00114010_caseD_27:\n          bVar4 = bVar21;\n          if (param_5 != 2) {\n            bVar22 = false;\n            uVar15 = 0x27;\n            bVar23 = bVar21;\n            goto LAB_00113ad8;\n          }\n          if (!bVar20) {\n            if ((param_2 == 0) || (uVar13 = 0, uVar15 = param_2, local_90 != 0)) {\n              if (uVar18 < param_2) {\n                param_1[uVar18] = 0x27;\n              }\n              if (uVar18 + 1 < param_2) {\n                param_1[uVar18 + 1] = 0x5c;\n              }\n              uVar13 = param_2;\n              uVar15 = local_90;\n              if (uVar18 + 2 < param_2) {\n                param_1[uVar18 + 2] = 0x27;\n              }\n            }\n            bVar14 = 0x27;\n            uVar18 = uVar18 + 3;\n            param_2 = uVar13;\n            local_90 = uVar15;\n            bVar3 = false;\n            bVar22 = false;\n            goto joined_r0x00113afb;\n          }\n          goto LAB_00113dd0;\n        case 0x3f:\nswitchD_00114010_caseD_3f:\n          if (param_5 != 2) {\n            if ((((param_5 == 5) && ((param_6 & 4) != 0)) && (uVar17 = uVar13 + 2, uVar17 < param_4)\n                ) && (param_3[uVar13 + 1] == '?')) {\n              uVar15 = (ulong)(byte)param_3[uVar17];\n              switch(param_3[uVar17]) {\n              case '!':\n              case '\\'':\n              case '(':\n              case ')':\n              case '-':\n              case '/':\n              case '<':\n              case '=':\n              case '>':\n                goto switchD_0011475e_caseD_21;\n              default:\n                break;\n              }\n            }\n            bVar22 = false;\n            uVar15 = 0x3f;\n            bVar23 = false;\n            goto LAB_00113ad8;\n          }\n          if (!bVar20) {\n            bVar14 = 0x3f;\n            bVar22 = false;\n            bVar21 = false;\n            goto joined_r0x00113afb;\n          }\n          goto LAB_00113dd0;\n        case 0x5c:\n          if (param_5 != 2) goto switchD_00113a08_caseD_5c;\n          if (!bVar20) {\nLAB_00114048:\n            uVar13 = uVar13 + 1;\n            bVar21 = false;\n            bVar14 = 0x5c;\n            goto LAB_00114060;\n          }\n          goto LAB_00113dd0;\n        case 0x7b:\n        case 0x7d:\nswitchD_00114010_caseD_7b:\n          bVar23 = param_4 != 1;\n          if (param_4 == 0xffffffffffffffff) {\n            bVar23 = param_3[1] != '\\0';\n          }\n          bVar22 = param_5 == 2;\n          if (!bVar23) goto LAB_00113dab;\nLAB_00113ad5:\n          bVar23 = false;\n          goto LAB_00113ad8;\n        }\nLAB_00113ee0:\n        bVar5 = bVar23;\n        if (!bVar1) {\nLAB_00113eeb:\n          bVar14 = (byte)uVar15;\n          bVar23 = false;\n          bVar21 = false;\n          bVar22 = false;\n          if (!bVar20) goto LAB_00113af8;\n          goto LAB_00113a20;\n        }\nLAB_00113f20:\n        bVar21 = false;\n        goto joined_r0x00113f31;\n      }\n      if (local_c8 != 0) {\n        if ((param_4 == 0xffffffffffffffff) && (1 < local_c8)) {\n          param_4 = strlen(param_3);\n        }\n        if ((param_4 < uVar13 + local_c8) || (iVar7 = memcmp(__s1,local_98,local_c8), iVar7 != 0))\n        goto LAB_00114140;\n        if (!bVar20) {\n          uVar15 = (ulong)*__s1;\n          switch(uVar15) {\n          case 0:\n            goto switchD_00113a08_caseD_0;\n          default:\n            goto switchD_00114010_caseD_1;\n          case 7:\n            goto switchD_00114160_caseD_7;\n          case 8:\n            goto switchD_00114160_caseD_8;\n          case 9:\n            goto switchD_00113a08_caseD_9;\n          case 10:\n            goto switchD_00114160_caseD_a;\n          case 0xb:\n            goto switchD_00114160_caseD_b;\n          case 0xc:\n            goto switchD_00114160_caseD_c;\n          case 0xd:\n            goto switchD_00114160_caseD_d;\n          case 0x20:\n            goto LAB_00114189;\n          case 0x21:\n          case 0x22:\n          case 0x24:\n          case 0x26:\n          case 0x28:\n          case 0x29:\n          case 0x2a:\n          case 0x3b:\n          case 0x3c:\n          case 0x3d:\n          case 0x3e:\n          case 0x5b:\n          case 0x5e:\n          case 0x60:\n          case 0x7c:\n            goto switchD_00113a08_caseD_21;\n          case 0x23:\n          case 0x7e:\n            goto LAB_00114171;\n          case 0x25:\n          case 0x2b:\n          case 0x2c:\n          case 0x2d:\n          case 0x2e:\n          case 0x2f:\n          case 0x30:\n          case 0x31:\n          case 0x32:\n          case 0x33:\n          case 0x34:\n          case 0x35:\n          case 0x36:\n          case 0x37:\n          case 0x38:\n          case 0x39:\n          case 0x3a:\n          case 0x41:\n          case 0x42:\n          case 0x43:\n          case 0x44:\n          case 0x45:\n          case 0x46:\n          case 0x47:\n          case 0x48:\n          case 0x49:\n          case 0x4a:\n          case 0x4b:\n          case 0x4c:\n          case 0x4d:\n          case 0x4e:\n          case 0x4f:\n          case 0x50:\n          case 0x51:\n          case 0x52:\n          case 0x53:\n          case 0x54:\n          case 0x55:\n          case 0x56:\n          case 0x57:\n          case 0x58:\n          case 0x59:\n          case 0x5a:\n          case 0x5d:\n          case 0x5f:\n          case 0x61:\n          case 0x62:\n          case 99:\n          case 100:\n          case 0x65:\n          case 0x66:\n          case 0x67:\n          case 0x68:\n          case 0x69:\n          case 0x6a:\n          case 0x6b:\n          case 0x6c:\n          case 0x6d:\n          case 0x6e:\n          case 0x6f:\n          case 0x70:\n          case 0x71:\n          case 0x72:\n          case 0x73:\n          case 0x74:\n          case 0x75:\n          case 0x76:\n          case 0x77:\n          case 0x78:\n          case 0x79:\n          case 0x7a:\n            goto LAB_00113a18;\n          case 0x27:\n            goto switchD_00114010_caseD_27;\n          case 0x3f:\n            goto switchD_00114010_caseD_3f;\n          case 0x5c:\n            goto switchD_00113a08_caseD_5c;\n          case 0x7b:\n          case 0x7d:\n            goto switchD_00114010_caseD_7b;\n          }\n        }\n        goto LAB_00113dde;\n      }\nLAB_00114140:\n      uVar15 = (ulong)*__s1;\n      switch(uVar15) {\n      case 0:\nswitchD_00114160_caseD_0:\n        if (!bVar20) {\n          bVar5 = false;\nswitchD_00113a08_caseD_0:\n          bVar24 = param_5 == 2;\n          bVar3 = (bool)((bVar2 ^ 1U) & bVar24);\n          if (bVar3) {\n            if (uVar18 < param_2) {\n              param_1[uVar18] = 0x27;\n            }\n            if (uVar18 + 1 < param_2) {\n              param_1[uVar18 + 1] = 0x24;\n            }\n            if (uVar18 + 2 < param_2) {\n              param_1[uVar18 + 2] = 0x27;\n            }\n            uVar15 = uVar18 + 3;\n            bVar2 = bVar3;\n            if (param_2 <= uVar18 + 3) {\n              bVar14 = 0x30;\n              uVar18 = uVar18 + 4;\n              bVar22 = bVar3;\n              bVar21 = false;\n              goto joined_r0x00113afb;\n            }\nLAB_0011459b:\n            param_1[uVar15] = 0x5c;\n            uVar18 = uVar15;\n          }\n          else {\n            uVar15 = uVar18;\n            if (uVar18 < param_2) goto LAB_0011459b;\n          }\n          uVar19 = uVar18 + 1;\n          bVar22 = bVar21;\n          if (param_5 != 2) {\n            uVar15 = 0x30;\n            if ((uVar13 + 1 < param_4) && ((byte)(param_3[uVar13 + 1] - 0x30U) < 10)) {\n              if (uVar19 < param_2) {\n                param_1[uVar19] = 0x30;\n              }\n              if (uVar18 + 2 < param_2) {\n                param_1[uVar18 + 2] = 0x30;\n              }\n              uVar19 = uVar18 + 3;\n              uVar15 = 0x30;\n            }\n            goto LAB_001145d8;\n          }\n          bVar14 = 0x30;\n          uVar18 = uVar19;\n          bVar3 = bVar2;\n          bVar21 = false;\n          goto joined_r0x00113afb;\n        }\n        bVar24 = param_5 == 2;\n        goto LAB_00113dd0;\n      default:\n        bVar23 = false;\n        goto switchD_00114010_caseD_1;\n      case 7:\nswitchD_00114160_caseD_7:\n        bVar14 = 0x61;\n        break;\n      case 8:\nswitchD_00114160_caseD_8:\n        bVar14 = 0x62;\n        break;\n      case 9:\n        bVar23 = false;\nswitchD_00113a08_caseD_9:\n        uVar15 = 9;\n        bVar14 = 0x74;\n        goto LAB_00113ee0;\n      case 10:\nswitchD_00114160_caseD_a:\n        bVar14 = 0x6e;\n        goto LAB_00113f20;\n      case 0xb:\nswitchD_00114160_caseD_b:\n        bVar14 = 0x76;\n        goto LAB_00113f20;\n      case 0xc:\nswitchD_00114160_caseD_c:\n        bVar14 = 0x66;\n        break;\n      case 0xd:\nswitchD_00114160_caseD_d:\n        bVar14 = 0x72;\n        goto LAB_00113f20;\n      case 0x20:\n        bVar5 = false;\nLAB_00114189:\n        uVar15 = 0x20;\n        goto LAB_00113a18;\n      case 0x21:\n      case 0x22:\n      case 0x24:\n      case 0x26:\n      case 0x28:\n      case 0x29:\n      case 0x2a:\n      case 0x3b:\n      case 0x3c:\n      case 0x3d:\n      case 0x3e:\n      case 0x5b:\n      case 0x5e:\n      case 0x60:\n      case 0x7c:\n        bVar5 = false;\nswitchD_00113a08_caseD_21:\n        bVar22 = false;\n        goto LAB_00113ad5;\n      case 0x23:\n      case 0x7e:\n        bVar5 = false;\nLAB_00114171:\n        if (uVar13 == 0) {\n          bVar22 = false;\n          goto LAB_00113ad8;\n        }\n        bVar23 = false;\n        bVar22 = false;\n        goto LAB_00113a20;\n      case 0x25:\n      case 0x2b:\n      case 0x2c:\n      case 0x2d:\n      case 0x2e:\n      case 0x2f:\n      case 0x30:\n      case 0x31:\n      case 0x32:\n      case 0x33:\n      case 0x34:\n      case 0x35:\n      case 0x36:\n      case 0x37:\n      case 0x38:\n      case 0x39:\n      case 0x3a:\n      case 0x41:\n      case 0x42:\n      case 0x43:\n      case 0x44:\n      case 0x45:\n      case 0x46:\n      case 0x47:\n      case 0x48:\n      case 0x49:\n      case 0x4a:\n      case 0x4b:\n      case 0x4c:\n      case 0x4d:\n      case 0x4e:\n      case 0x4f:\n      case 0x50:\n      case 0x51:\n      case 0x52:\n      case 0x53:\n      case 0x54:\n      case 0x55:\n      case 0x56:\n      case 0x57:\n      case 0x58:\n      case 0x59:\n      case 0x5a:\n      case 0x5d:\n      case 0x5f:\n      case 0x61:\n      case 0x62:\n      case 99:\n      case 100:\n      case 0x65:\n      case 0x66:\n      case 0x67:\n      case 0x68:\n      case 0x69:\n      case 0x6a:\n      case 0x6b:\n      case 0x6c:\n      case 0x6d:\n      case 0x6e:\n      case 0x6f:\n      case 0x70:\n      case 0x71:\n      case 0x72:\n      case 0x73:\n      case 0x74:\n      case 0x75:\n      case 0x76:\n      case 0x77:\n      case 0x78:\n      case 0x79:\n      case 0x7a:\n        bVar5 = false;\nLAB_00113a18:\n        bVar22 = false;\n        goto LAB_00113a20;\n      case 0x27:\n        bVar5 = false;\n        goto switchD_00114010_caseD_27;\n      case 0x3f:\n        bVar5 = false;\n        goto switchD_00114010_caseD_3f;\n      case 0x5c:\n        bVar23 = false;\nswitchD_00113a08_caseD_5c:\n        if (((bool)(bVar1 & bVar20)) && (local_c8 != 0)) goto LAB_00114048;\n        uVar15 = 0x5c;\n        bVar14 = 0x5c;\n        goto LAB_00113ee0;\n      case 0x7b:\n      case 0x7d:\n        bVar5 = false;\n        goto switchD_00114010_caseD_7b;\n      }\n      if (bVar20) goto LAB_00113f40;\n      bVar21 = false;\n      goto LAB_00113a96;\n    }\n    if ((uVar18 == 0) && ((bool)(bVar20 & param_5 == 2))) {\nLAB_00113dc7:\n      param_5 = 2;\nLAB_00113dd0:\n      if (bVar24) {\n        param_5 = 4;\n      }\nLAB_00113dde:\n      uVar13 = quotearg_buffer_restyled\n                         (param_1,param_2,param_3,param_4,param_5,param_6 & 0xfffffffd,0,local_70,\n                          local_78);\n      goto LAB_00113e18;\n    }\n    bVar21 = (bool)(param_5 == 2 & (bVar20 ^ 1U));\n    bVar20 = (bool)(bVar20 ^ 1U);\n    if ((!bVar21) || (bVar20 = bVar21, !bVar4)) {\nLAB_00114865:\n      uVar13 = uVar18;\n      if (((local_98 != (uint *)0x0) && (bVar20)) && (cVar11 = *(char *)local_98, cVar11 != '\\0')) {\n        do {\n          if (uVar13 < param_2) {\n            param_1[uVar13] = cVar11;\n          }\n          uVar13 = uVar13 + 1;\n          cVar11 = *(char *)((long)local_98 + (uVar13 - uVar18));\n        } while (cVar11 != '\\0');\n      }\n      if (uVar13 < param_2) {\n        param_1[uVar13] = 0;\n      }\nLAB_00113e18:\n      if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n        return uVar13;\n      }\n                    /* WARNING: Subroutine does not return */\n      __stack_chk_fail();\n    }\n    if (bVar6) {\n      uVar13 = quotearg_buffer_restyled\n                         (param_1,local_90,param_3,param_4,5,param_6,param_7,local_70,local_78);\n      goto LAB_00113e18;\n    }\n    local_64 = param_2 == 0 && local_90 != 0;\n    uVar13 = local_90;\n    bVar20 = bVar4;\n    if (param_2 != 0 || local_90 == 0) goto LAB_00114865;\nLAB_001141f6:\n    *param_1 = 0x27;\n    param_2 = local_90;\n    local_90 = uVar13;\nLAB_00113c59:\n    bVar20 = false;\n    uVar18 = 1;\n    param_5 = 2;\n    local_c8 = 1;\n    local_98 = (uint *)0x11cf3b;\n  } while( true );\ncode_r0x001140fb:\n  uVar13 = uVar13 + 1;\n  goto LAB_00113900;\nswitchD_0011475e_caseD_21:\n  if (!bVar20) {\n    if (uVar18 < param_2) {\n      param_1[uVar18] = 0x3f;\n    }\n    if (uVar18 + 1 < param_2) {\n      param_1[uVar18 + 1] = 0x22;\n    }\n    if (uVar18 + 2 < param_2) {\n      param_1[uVar18 + 2] = 0x22;\n    }\n    if (uVar18 + 3 < param_2) {\n      param_1[uVar18 + 3] = 0x3f;\n    }\n    uVar19 = uVar18 + 4;\n    bVar24 = false;\n    bVar22 = false;\nLAB_001145d8:\n    bVar14 = (byte)uVar15;\n    bVar23 = false;\n    bVar21 = false;\n    uVar13 = uVar17;\n    uVar18 = uVar19;\n    bVar3 = bVar2;\n    if ((bool)(bVar1 ^ 1U | bVar24)) goto joined_r0x00113afb;\n    goto LAB_00113a20;\n  }\n  goto LAB_00113dde;\njoined_r0x001147fa:\n  while ((uVar19 < param_4 && (param_3[uVar19] != '\\0'))) {\n    uVar17 = uVar17 + 1;\n    uVar19 = uVar13 + uVar17;\n  }\n  bVar21 = false;\nLAB_001143e8:\n  if (1 < uVar17) {\nLAB_001143f2:\n    bVar24 = false;\n    uVar17 = uVar17 + uVar13;\n    uVar19 = uVar13;\n    do {\n      bVar14 = (byte)uVar15;\n      if (bVar22) {\n        bVar24 = param_5 == 2;\n        if (bVar20) goto LAB_00113dd0;\n        bVar24 = (bool)(bVar24 & (bVar3 ^ 1U));\n        if (bVar24) {\n          if (uVar18 < param_2) {\n            param_1[uVar18] = 0x27;\n          }\n          if (uVar18 + 1 < param_2) {\n            param_1[uVar18 + 1] = 0x24;\n          }\n          if (uVar18 + 2 < param_2) {\n            param_1[uVar18 + 2] = 0x27;\n          }\n          uVar18 = uVar18 + 3;\n          bVar3 = bVar24;\n        }\n        if (uVar18 < param_2) {\n          param_1[uVar18] = 0x5c;\n        }\n        if (uVar18 + 1 < param_2) {\n          param_1[uVar18 + 1] = (char)(uVar15 >> 6) + '0';\n        }\n        if (uVar18 + 2 < param_2) {\n          param_1[uVar18 + 2] = ((byte)(uVar15 >> 3) & 7) + 0x30;\n        }\n        uVar13 = uVar19 + 1;\n        uVar18 = uVar18 + 3;\n        bVar14 = (bVar14 & 7) + 0x30;\n        bVar24 = bVar22;\n        if (uVar17 <= uVar13) goto LAB_00113aa8;\n      }\n      else {\n        bVar2 = (bool)((bVar24 ^ 1U) & bVar3);\n        if (bVar23) {\n          if (uVar18 < param_2) {\n            param_1[uVar18] = 0x5c;\n          }\n          uVar18 = uVar18 + 1;\n        }\n        uVar13 = uVar19 + 1;\n        if (uVar17 <= uVar13) goto LAB_00114060;\n        if (bVar2) {\n          if (uVar18 < param_2) {\n            param_1[uVar18] = 0x27;\n          }\n          if (uVar18 + 1 < param_2) {\n            param_1[uVar18 + 1] = 0x27;\n          }\n          uVar18 = uVar18 + 2;\n          bVar23 = false;\n          bVar3 = false;\n        }\n        else {\n          bVar23 = false;\n        }\n      }\n      uVar19 = uVar19 + 1;\n      if (uVar18 < param_2) {\n        param_1[uVar18] = bVar14;\n      }\n      uVar15 = (ulong)(byte)param_3[uVar19];\n      uVar18 = uVar18 + 1;\n    } while( true );\n  }\nLAB_00113b71:\n  bVar5 = bVar23;\n  if (bVar22) {\n    bVar21 = false;\n    bVar22 = bVar1;\n    goto LAB_001143f2;\n  }\nswitchD_00114010_caseD_25:\n  bVar22 = param_5 == 2;\n  bVar23 = bVar21;\nLAB_00113ad8:\n  bVar14 = (byte)uVar15;\n  bVar22 = (bool)(bVar22 | bVar1 ^ 1U);\n  if ((!bVar22) || (bVar22 = false, bVar21 = bVar23, bVar20)) {\nLAB_00113a20:\n    bVar14 = (byte)uVar15;\n    uVar17 = uVar13;\n    bVar3 = bVar2;\n    bVar21 = bVar23;\n    if ((param_7 == 0) || ((*(uint *)(param_7 + (uVar15 >> 5) * 4) >> (bVar14 & 0x1f) & 1) == 0))\n    goto joined_r0x00113afb;\n  }\n  else {\nLAB_00113af8:\n    uVar17 = uVar13;\n    bVar22 = false;\njoined_r0x00113afb:\n    uVar13 = uVar17;\n    bVar2 = bVar3;\n    if (!bVar5) {\n      uVar13 = uVar17 + 1;\n      bVar2 = (bool)((bVar22 ^ 1U) & bVar3);\nLAB_00114060:\n      if (bVar2) {\n        if (uVar18 < param_2) {\n          param_1[uVar18] = 0x27;\n        }\n        if (uVar18 + 1 < param_2) {\n          param_1[uVar18 + 1] = 0x27;\n        }\n        uVar18 = uVar18 + 2;\n        bVar3 = false;\n      }\n      goto LAB_00113aa8;\n    }\n  }\njoined_r0x00113f31:\n  if (bVar20) {\nLAB_00113f40:\n    bVar24 = (bool)(bVar1 & param_5 == 2);\n    goto LAB_00113dd0;\n  }\n  bVar24 = (bool)((bVar2 ^ 1U) & param_5 == 2);\n  if (bVar24) {\n    if (uVar18 < param_2) {\n      param_1[uVar18] = 0x27;\n    }\n    if (uVar18 + 1 < param_2) {\n      param_1[uVar18 + 1] = 0x24;\n    }\n    if (uVar18 + 2 < param_2) {\n      param_1[uVar18 + 2] = 0x27;\n    }\n    uVar18 = uVar18 + 3;\n    bVar2 = bVar24;\n  }\nLAB_00113a96:\n  if (uVar18 < param_2) {\n    param_1[uVar18] = 0x5c;\n  }\n  uVar18 = uVar18 + 1;\n  uVar13 = uVar13 + 1;\n  bVar3 = bVar2;\nLAB_00113aa8:\n  bVar2 = bVar3;\n  if (uVar18 < param_2) {\n    param_1[uVar18] = bVar14;\n  }\n  uVar18 = uVar18 + 1;\n  if (!bVar21) {\n    bVar6 = false;\n  }\n  goto LAB_00113900;\n}\n\n", 
    "00126338": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __fprintf_chk(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __fprintf_chk@@GLIBC_2.3.4 */\n  halt_baddata();\n}\n\n", 
    "001081f0": "\nvoid xstrcoll_size(undefined8 *param_1,undefined8 *param_2)\n\n{\n  cmp_size_isra_0(*param_1,param_1[9],*param_2,param_2[9],xstrcoll);\n  return;\n}\n\n", 
    "00126218": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid tzset(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* tzset@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010dcc0": "\nvoid close_stdout_set_file_name(undefined8 param_1)\n\n{\n  file_name = param_1;\n  return;\n}\n\n", 
    "00115b00": "\nvoid xnmalloc(ulong param_1,ulong param_2)\n\n{\n  if ((-1 < SUB168(ZEXT816(param_1) * ZEXT816(param_2),0)) &&\n     (SUB168(ZEXT816(param_1) * ZEXT816(param_2) >> 0x40,0) == 0)) {\n    xmalloc();\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  xalloc_die();\n}\n\n", 
    "00116d10": "\nbool equal_tm(uint *param_1,uint *param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  byte bVar1;\n  uint uVar2;\n  \n  uVar2 = *param_1 ^ *param_2 | param_1[1] ^ param_2[1] | param_1[2] ^ param_2[2] |\n          param_1[3] ^ param_2[3] | param_1[4] ^ param_2[4] | param_1[5] ^ param_2[5];\n  bVar1 = isdst_differ(param_1[8],param_2[8],param_3,param_4,uVar2);\n  return (bVar1 | uVar2) == 0;\n}\n\n", 
    "00126230": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint __xstat(int __ver,char *__filename,stat *__stat_buf)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __xstat@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00108700": "\nundefined4 has_capability_cache_isra_0(long *param_1)\n\n{\n  char cVar1;\n  undefined4 uVar2;\n  int *piVar3;\n  \n  if (*param_1 != unsupported_device_10708) {\n    uVar2 = has_capability_isra_0();\n    if ((char)uVar2 == '\\0') {\n      piVar3 = __errno_location();\n      cVar1 = errno_unsupported(*piVar3);\n      if (cVar1 != '\\0') {\n        unsupported_device_10708 = *param_1;\n      }\n    }\n    return uVar2;\n  }\n  piVar3 = __errno_location();\n  *piVar3 = 0x5f;\n  return 0;\n}\n\n", 
    "00126110": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * strchr(char *__s,int __c)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strchr@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00108820": "\nvoid rev_xstrcoll_version(undefined8 *param_1,undefined8 *param_2)\n\n{\n  cmp_version_isra_0(*param_2,*param_1);\n  return;\n}\n\n", 
    "00108940": "\nundefined8 rev_strcmp_df_extension(long param_1,long param_2)\n\n{\n  char cVar1;\n  char cVar2;\n  long lVar3;\n  undefined8 uVar4;\n  \n  lVar3 = param_2;\n  cVar1 = is_directory_isra_0(*(undefined4 *)(param_1 + 0xa8));\n  cVar2 = is_directory_isra_0(*(undefined4 *)(param_2 + 0xa8));\n  if ((cVar2 == '\\x01') || (cVar1 == '\\0')) {\n    if ((cVar1 == '\\x01') || (uVar4 = 1, cVar2 == '\\0')) {\n      uVar4 = cmp_extension_isra_0(lVar3,param_1,PTR_strcmp_00123fc8);\n      return uVar4;\n    }\n  }\n  else {\n    uVar4 = 0xffffffff;\n  }\n  return uVar4;\n}\n\n", 
    "0010a630": "\n/* WARNING: Could not reconcile some variable overlaps */\n\nvoid print_long_format(long param_1)\n\n{\n  undefined auVar1 [16];\n  int iVar2;\n  uint uVar3;\n  undefined4 uVar4;\n  int iVar5;\n  uint *puVar6;\n  undefined1 *puVar7;\n  size_t sVar8;\n  uint *puVar9;\n  long lVar10;\n  undefined8 uVar11;\n  undefined8 uVar12;\n  char cVar13;\n  uint uVar14;\n  uint *puVar15;\n  int iVar16;\n  long lVar17;\n  char *pcVar18;\n  long in_FS_OFFSET;\n  bool bVar19;\n  undefined local_1198 [16];\n  undefined local_1188 [68];\n  undefined local_1144;\n  undefined8 local_1143;\n  ushort local_113b;\n  undefined local_1139;\n  undefined local_1138 [32];\n  undefined local_1118 [656];\n  uint local_e88 [914];\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (*(char *)(param_1 + 0xb8) == '\\0') {\n    local_113b = 0x3f3f;\n    local_1144 = filetype_letter[*(uint *)(param_1 + 0xa8)];\n    local_1139 = 0;\n    local_1143 = 0x3f3f3f3f3f3f3f3f;\n    if (any_has_acl != '\\0') goto LAB_0010aa12;\nLAB_0010a68b:\n    local_113b = local_113b & 0xff;\nLAB_0010a690:\n    if (time_type == 1) goto LAB_0010aa40;\nLAB_0010a69f:\n    if (time_type == 2) {\n      local_1198 = get_stat_ctime_isra_0\n                             (*(undefined8 *)(param_1 + 0x60),*(undefined8 *)(param_1 + 0x68));\n    }\n    else {\n      if (time_type != 0) {\n        print_long_format_cold();\n        return;\n      }\n      local_1198 = get_stat_ctime_isra_0\n                             (*(undefined8 *)(param_1 + 0x70),*(undefined8 *)(param_1 + 0x78));\n    }\n  }\n  else {\n    filemodestring(param_1 + 0x18,&local_1144);\n    if (any_has_acl == '\\0') goto LAB_0010a68b;\nLAB_0010aa12:\n    if (*(int *)(param_1 + 0xbc) == 1) {\n      local_113b = CONCAT11(0x2e,(undefined)local_113b);\n      goto LAB_0010a690;\n    }\n    if (*(int *)(param_1 + 0xbc) != 2) goto LAB_0010a690;\n    local_113b = CONCAT11(0x2b,(undefined)local_113b);\n    if (time_type != 1) goto LAB_0010a69f;\nLAB_0010aa40:\n    local_1198 = get_stat_ctime_isra_0\n                           (*(undefined8 *)(param_1 + 0x80),*(undefined8 *)(param_1 + 0x88));\n  }\n  puVar15 = local_e88;\n  if (print_inode != '\\0') {\n    uVar11 = format_inode_isra_0(local_1118,0x15,param_1 + 0x20,param_1 + 0xb8);\n    __sprintf_chk(local_e88,1,0xe3b,&DAT_0011992f,inode_number_width,uVar11);\n    do {\n      puVar9 = puVar15;\n      uVar14 = *puVar9 + 0xfefefeff & ~*puVar9;\n      uVar3 = uVar14 & 0x80808080;\n      puVar15 = puVar9 + 1;\n    } while (uVar3 == 0);\n    bVar19 = (uVar14 & 0x8080) == 0;\n    if (bVar19) {\n      uVar3 = uVar3 >> 0x10;\n    }\n    if (bVar19) {\n      puVar15 = (uint *)((long)puVar9 + 6);\n    }\n    puVar15 = (uint *)((long)puVar15 + (-3 - (ulong)CARRY1((byte)uVar3,(byte)uVar3)));\n  }\n  cVar13 = *(char *)(param_1 + 0xb8);\n  if (print_block_size != '\\0') {\n    pcVar18 = \"?\";\n    if (cVar13 != '\\0') {\n      pcVar18 = (char *)human_readable(*(undefined8 *)(param_1 + 0x58),local_1118,human_output_opts,\n                                       0x200,output_block_size);\n    }\n    iVar5 = block_size_width;\n    iVar2 = gnu_mbswidth(pcVar18,0);\n    if (0 < iVar5 - iVar2) {\n      uVar3 = (iVar5 - iVar2) - 1;\n      puVar9 = puVar15;\n      do {\n        puVar6 = (uint *)((long)puVar9 + 1);\n        *(undefined *)puVar9 = 0x20;\n        puVar9 = puVar6;\n      } while ((uint *)((long)puVar15 + (ulong)uVar3 + 1) != puVar6);\n      puVar15 = (uint *)((long)puVar15 + (long)(int)uVar3 + 1);\n    }\n    do {\n      puVar9 = puVar15;\n      cVar13 = *pcVar18;\n      pcVar18 = pcVar18 + 1;\n      puVar15 = (uint *)((long)puVar9 + 1);\n      *(char *)puVar9 = cVar13;\n    } while (cVar13 != '\\0');\n    *(undefined *)puVar9 = 0x20;\n    cVar13 = *(char *)(param_1 + 0xb8);\n  }\n  puVar7 = &DAT_001198cf;\n  if (cVar13 != '\\0') {\n    puVar7 = (undefined1 *)umaxtostr(*(undefined8 *)(param_1 + 0x28),local_1118);\n  }\n  __sprintf_chk(puVar15,1,0xffffffffffffffff,\"%s %*s \",&local_1144,nlink_width,puVar7);\n  sVar8 = strlen((char *)puVar15);\n  puVar15 = (uint *)((long)puVar15 + sVar8);\n  if (dired != '\\0') {\n    fwrite_unlocked(&DAT_00119927,1,2,stdout);\n    dired_pos = dired_pos + 2;\n  }\n  if ((((print_owner != '\\0') || (print_group != '\\0')) || (print_author != '\\0')) ||\n     (print_scontext != '\\0')) {\n    fputs_unlocked((char *)local_e88,stdout);\n    dired_pos = (undefined *)((long)puVar15 + ((long)dired_pos - (long)local_e88));\n    if (print_owner != '\\0') {\n      format_user(*(undefined4 *)(param_1 + 0x34),owner_width,*(undefined *)(param_1 + 0xb8));\n    }\n    if (print_group != '\\0') {\n      format_group(*(undefined4 *)(param_1 + 0x38),group_width,*(undefined *)(param_1 + 0xb8));\n    }\n    if (print_author != '\\0') {\n      format_user(*(undefined4 *)(param_1 + 0x34),author_width,*(undefined *)(param_1 + 0xb8));\n    }\n    puVar15 = local_e88;\n    if (print_scontext != '\\0') {\n      format_user_or_group(*(undefined8 *)(param_1 + 0xb0),0,scontext_width);\n    }\n  }\n  if (*(char *)(param_1 + 0xb8) == '\\0') {\n    pcVar18 = \"?\";\nLAB_0010a826:\n    iVar5 = file_size_width;\n    iVar2 = gnu_mbswidth(pcVar18,0);\n    if (0 < iVar5 - iVar2) {\n      uVar3 = (iVar5 - iVar2) - 1;\n      puVar9 = puVar15;\n      do {\n        puVar6 = (uint *)((long)puVar9 + 1);\n        *(undefined *)puVar9 = 0x20;\n        puVar9 = puVar6;\n      } while ((uint *)((long)puVar15 + (ulong)uVar3 + 1) != puVar6);\n      puVar15 = (uint *)((long)puVar15 + (long)(int)uVar3 + 1);\n    }\n    do {\n      puVar9 = puVar15;\n      cVar13 = *pcVar18;\n      pcVar18 = pcVar18 + 1;\n      puVar15 = (uint *)((long)puVar9 + 1);\n      *(char *)puVar9 = cVar13;\n    } while (cVar13 != '\\0');\n    *(undefined *)puVar9 = 0x20;\n  }\n  else {\n    if ((*(uint *)(param_1 + 0x30) & 0xb000) != 0x2000) {\n      uVar11 = unsigned_file_size(*(undefined8 *)(param_1 + 0x48));\n      pcVar18 = (char *)human_readable(uVar11,local_1118,file_human_output_opts,1,\n                                       file_output_block_size);\n      goto LAB_0010a826;\n    }\n    iVar16 = file_size_width - (major_device_number_width + 2 + minor_device_number_width);\n    uVar3 = gnu_dev_minor(*(ulonglong *)(param_1 + 0x40));\n    uVar11 = umaxtostr(uVar3,local_1118);\n    iVar5 = minor_device_number_width;\n    uVar3 = gnu_dev_major(*(ulonglong *)(param_1 + 0x40));\n    uVar12 = umaxtostr(uVar3,local_1138);\n    iVar2 = 0;\n    if (-1 < iVar16) {\n      iVar2 = iVar16;\n    }\n    __sprintf_chk(puVar15,1,0xffffffffffffffff,&DAT_0011992a,iVar2 + major_device_number_width,\n                  uVar12,iVar5,uVar11);\n    puVar15 = (uint *)((long)puVar15 + (long)file_size_width + 1);\n  }\n  *(undefined *)puVar15 = 1;\n  puVar7 = &DAT_001198cf;\n  if (*(char *)(param_1 + 0xb8) == '\\0') {\nLAB_0010a893:\n    uVar4 = long_time_expected_width();\n    __sprintf_chk(puVar15,1,0xffffffffffffffff,&DAT_0011992f,uVar4,puVar7);\n    sVar8 = strlen((char *)puVar15);\n    lVar17 = (long)puVar15 + sVar8;\n  }\n  else {\n    lVar17 = localtime_rz(localtz,local_1198,local_1188);\n    auVar1 = local_1198;\n    if (lVar17 == 0) {\nLAB_0010ab70:\n      if (*(char *)puVar15 != '\\0') {\n        if (*(char *)(param_1 + 0xb8) == '\\0') {\n          puVar7 = &DAT_001198cf;\n        }\n        else {\n          puVar7 = (undefined1 *)timetostr(local_1198._0_8_,local_1118);\n        }\n        goto LAB_0010a893;\n      }\n    }\n    else {\n      iVar5 = timespec_cmp(current_time._0_8_,current_time._8_8_,local_1198._0_8_,local_1198._8_8_);\n      if (iVar5 < 0) {\n        gettime(current_time);\n        auVar1 = local_1198;\n      }\n      iVar5 = timespec_cmp(current_time._0_8_ + -0xf0c2ac,current_time._8_8_,SUB168(auVar1,0),\n                           SUB168(auVar1 >> 0x40,0));\n      uVar3 = 0;\n      if (iVar5 < 0) {\n        uVar3 = timespec_cmp(local_1198._0_8_,local_1198._8_8_,current_time._0_8_,current_time._8_8_\n                            );\n        uVar3 = uVar3 >> 0x1f;\n      }\n      local_1198._8_8_ = SUB168(local_1198 >> 0x40,0);\n      lVar17 = align_nstrftime_constprop_0\n                         (puVar15,uVar3,local_1188,localtz,local_1198._8_8_ & 0xffffffff);\n      if (lVar17 == 0) goto LAB_0010ab70;\n      puVar15 = (uint *)((long)puVar15 + lVar17);\n    }\n    lVar17 = (long)puVar15 + 1;\n    *(undefined2 *)puVar15 = 0x20;\n  }\n  lVar17 = lVar17 - (long)local_e88;\n  fputs_unlocked((char *)local_e88,stdout);\n  dired_pos = dired_pos + lVar17;\n  lVar10 = print_name_with_quoting(param_1,0,dired_obstack,lVar17);\n  if (*(int *)(param_1 + 0xa8) == 6) {\n    if (*(long *)(param_1 + 8) != 0) {\n      fwrite_unlocked(&DAT_00119934,1,4,stdout);\n      dired_pos = dired_pos + 4;\n      print_name_with_quoting(param_1,1,0,lVar17 + 4 + lVar10);\n      if (indicator_style != 0) {\n        print_type_indicator(1,*(undefined4 *)(param_1 + 0xac),0);\n      }\n    }\n  }\n  else if (indicator_style != 0) {\n    print_type_indicator(*(undefined *)(param_1 + 0xb8),*(undefined4 *)(param_1 + 0x30));\n  }\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00126350": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint mbsinit(mbstate_t *__ps)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* mbsinit@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00114e90": "\nvoid quotearg_mem(undefined8 param_1,undefined8 param_2)\n\n{\n  quotearg_n_mem(0,param_1,param_2);\n  return;\n}\n\n", 
    "00115f80": "\nbool bkm_scale(ulong *param_1,int param_2)\n\n{\n  ulong uVar1;\n  bool bVar2;\n  \n  uVar1 = SUB168(ZEXT816((ulong)(long)param_2) * ZEXT816(*param_1),0);\n  bVar2 = SUB168(ZEXT816((ulong)(long)param_2) * ZEXT816(*param_1) >> 0x40,0) != 0;\n  if (bVar2) {\n    uVar1 = 0xffffffffffffffff;\n  }\n  *param_1 = uVar1;\n  return bVar2;\n}\n\n", 
    "00115d40": "\nulong xnumtoumax(undefined8 param_1,undefined4 param_2,ulong param_3,ulong param_4,\n                undefined8 param_5,undefined8 param_6,int param_7)\n\n{\n  ulong uVar1;\n  int iVar2;\n  int *piVar3;\n  undefined8 uVar4;\n  long in_FS_OFFSET;\n  ulong local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar2 = xstrtoumax(param_1,0,param_2,&local_48);\n  uVar1 = local_48;\n  if (iVar2 == 0) {\n    if ((param_3 <= local_48) && (local_48 <= param_4)) goto LAB_00115dea;\n    piVar3 = __errno_location();\n    *piVar3 = (-(uint)(uVar1 < 0x40000000) & 0xffffffd7) + 0x4b;\n  }\n  else {\n    piVar3 = __errno_location();\n    if (iVar2 == 1) {\n      *piVar3 = 0x4b;\n    }\n    else if (iVar2 == 3) {\n      *piVar3 = 0;\n    }\n  }\n  uVar4 = quote(param_1);\n  iVar2 = *piVar3;\n  if (iVar2 == 0x16) {\n    iVar2 = 0;\n  }\n  if (param_7 == 0) {\n    param_7 = 1;\n  }\n  error(param_7,iVar2,\"%s: %s\",param_6,uVar4);\nLAB_00115dea:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_48;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00106880": "\nint getfilecon_cache(undefined8 param_1,long param_2,char param_3)\n\n{\n  char cVar1;\n  int iVar2;\n  int *piVar3;\n  \n  if (*(long *)(param_2 + 0x18) == unsupported_device_10696) {\n    piVar3 = __errno_location();\n    iVar2 = -1;\n    *piVar3 = 0x5f;\n  }\n  else {\n    if (param_3 == '\\0') {\n      iVar2 = rpl_lgetfilecon();\n    }\n    else {\n      iVar2 = rpl_getfilecon(param_1,param_2 + 0xb0);\n    }\n    if (iVar2 < 0) {\n      piVar3 = __errno_location();\n      cVar1 = errno_unsupported(*piVar3);\n      if (cVar1 != '\\0') {\n        unsupported_device_10696 = *(undefined8 *)(param_2 + 0x18);\n        return iVar2;\n      }\n    }\n  }\n  return iVar2;\n}\n\n", 
    "0010d3f0": "\nbool c_isalpha(int param_1)\n\n{\n  if (param_1 < 0x5b) {\n    return 0x40 < param_1;\n  }\n  return param_1 - 0x61U < 0x1a;\n}\n\n", 
    "001049a0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\ntm * gmtime_r(time_t *__timer,tm *__tp)\n\n{\n  tm *ptVar1;\n  \n  ptVar1 = (tm *)(*(code *)PTR_gmtime_r_00123d88)();\n  return ptVar1;\n}\n\n", 
    "0010e3c0": "\nint verrevcmp(long param_1,ulong param_2,long param_3,ulong param_4)\n\n{\n  char cVar1;\n  char cVar2;\n  char cVar3;\n  int iVar4;\n  int iVar5;\n  ulong uVar6;\n  long lVar7;\n  char cVar8;\n  ulong uVar9;\n  \n  uVar9 = 0;\n  uVar6 = 0;\nLAB_0010e3e4:\n  if (uVar9 < param_2) goto LAB_0010e400;\n  if (param_4 <= uVar6) {\n    return 0;\n  }\n  do {\n    if (uVar9 < param_2) {\nLAB_0010e400:\n      cVar8 = *(char *)(param_1 + uVar9);\n      cVar1 = c_isdigit((int)cVar8);\n      if (cVar1 != '\\0') goto LAB_0010e43e;\n      iVar4 = order(cVar8);\n      iVar5 = 0;\n      if (uVar6 != param_4) {\n        cVar8 = *(char *)(param_3 + uVar6);\n        goto LAB_0010e476;\n      }\n      if (iVar4 != 0) goto LAB_0010e484;\n    }\n    else {\nLAB_0010e43e:\n      cVar8 = *(char *)(param_3 + uVar6);\n      if ((param_4 <= uVar6) || (cVar1 = c_isdigit((int)cVar8), cVar1 != '\\0')) break;\n      iVar4 = 0;\n      if (uVar9 != param_2) {\n        iVar4 = order(*(undefined *)(param_1 + uVar9));\n      }\nLAB_0010e476:\n      iVar5 = order(cVar8);\n      if (iVar5 != iVar4) {\nLAB_0010e484:\n        return iVar4 - iVar5;\n      }\n    }\n    uVar9 = uVar9 + 1;\n    uVar6 = uVar6 + 1;\n  } while( true );\n  for (; cVar1 = *(char *)(param_1 + uVar9), cVar1 == '0'; uVar9 = uVar9 + 1) {\n  }\n  while (cVar8 == '0') {\n    uVar6 = uVar6 + 1;\n    cVar8 = *(char *)(param_3 + uVar6);\n  }\n  lVar7 = uVar6 - uVar9;\n  iVar4 = 0;\n  while( true ) {\n    uVar6 = uVar9 + lVar7;\n    cVar2 = c_isdigit((int)cVar1);\n    cVar3 = c_isdigit((int)cVar8);\n    if (cVar2 == '\\0') break;\n    if (cVar3 == '\\0') {\n      return 1;\n    }\n    if (iVar4 == 0) {\n      iVar4 = (int)cVar1 - (int)cVar8;\n    }\n    uVar9 = uVar9 + 1;\n    cVar1 = *(char *)(param_1 + uVar9);\n    cVar8 = *(char *)(param_3 + lVar7 + uVar9);\n  }\n  if (cVar3 != '\\0') {\n    return -1;\n  }\n  if (iVar4 != 0) {\n    return iVar4;\n  }\n  goto LAB_0010e3e4;\n}\n\n", 
    "00104c20": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * realloc(void *__ptr,size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = (void *)(*(code *)PTR_realloc_00123ec8)();\n  return pvVar1;\n}\n\n", 
    "00104b00": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\ngroup * getgrnam(char *__name)\n\n{\n  group *pgVar1;\n  \n  pgVar1 = (group *)(*(code *)PTR_getgrnam_00123e38)();\n  return pgVar1;\n}\n\n", 
    "00113160": "\nundefined8 strcaseeq6(long param_1,undefined8 param_2,byte param_3,char param_4,char param_5)\n\n{\n  char cVar1;\n  byte bVar2;\n  undefined8 uVar3;\n  \n  cVar1 = c_isupper((int)(char)param_3);\n  bVar2 = *(byte *)(param_1 + 6);\n  if (cVar1 != '\\0') {\n    bVar2 = bVar2 & 0xdf;\n  }\n  if (param_3 != bVar2) {\n    return 0;\n  }\n  if (param_3 == 0) {\n    return 1;\n  }\n  uVar3 = strcaseeq7(param_1,param_2,(int)param_4,(int)param_5);\n  return uVar3;\n}\n\n", 
    "00105f50": "\nvoid emit_mandatory_arg_note(void)\n\n{\n  char *__s;\n  FILE *__stream;\n  \n  __stream = stdout;\n  __s = (char *)dcgettext(0,\n                          \"\\nMandatory arguments to long options are mandatory for short options too.\\n\"\n                          ,5);\n  fputs_unlocked(__s,__stream);\n  return;\n}\n\n", 
    "00104d40": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint sigismember(sigset_t *__set,int __signo)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_sigismember_00123f58)();\n  return iVar1;\n}\n\n", 
    "00108ac0": "\nvoid rev_xstrcoll_extension(undefined8 param_1,undefined8 param_2)\n\n{\n  cmp_extension_isra_0(param_2,param_1,xstrcoll);\n  return;\n}\n\n", 
    "00109bb0": "\nulong quote_name_buf_constprop_0\n                (char **param_1,char *param_2,undefined8 param_3,int param_4,ulong *param_5,\n                byte *param_6)\n\n{\n  char cVar1;\n  bool bVar2;\n  byte bVar3;\n  uint uVar4;\n  int iVar5;\n  size_t sVar6;\n  size_t sVar7;\n  ulong uVar8;\n  ushort **ppuVar9;\n  long lVar10;\n  ushort *puVar11;\n  long extraout_RDX;\n  char *pcVar12;\n  undefined *extraout_RDX_00;\n  char *pcVar13;\n  ulong unaff_RBX;\n  char *pcVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  long in_FS_OFFSET;\n  char *local_80;\n  bool local_69;\n  wchar_t local_4c;\n  mbstate_t local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_80 = *param_1;\n  uVar4 = get_quoting_style(param_3);\n  local_69 = (bool)(uVar4 < 3 & qmark_funny_chars);\n  if (local_69 == false) {\n    bVar2 = false;\n    if (param_4 == 0) {\n      uVar8 = strlen(param_2);\n      local_80 = param_2;\n    }\n    else {\nLAB_00109c14:\n      sVar6 = quotearg_buffer(local_80,0x2000,param_2,0xffffffffffffffff,param_3);\n      if (0x1fff < sVar6) {\n        local_80 = (char *)xmalloc(sVar6 + 1);\n        quotearg_buffer(local_80,sVar6 + 1,param_2,0xffffffffffffffff,param_3);\n      }\n      local_69 = true;\n      if (*param_2 == *local_80) {\n        sVar7 = strlen(param_2);\n        local_69 = sVar6 != sVar7;\n      }\n      uVar8 = sVar6;\n      if (bVar2) goto LAB_00109d59;\n    }\n    if (param_5 == (ulong *)0x0) {\n      if (align_variable_outer_quotes == 0) {\n        *param_6 = 0;\n        goto LAB_00109dec;\n      }\nLAB_00109dc7:\n      bVar3 = (local_69 ^ 1U) & cwd_some_quoted;\n      goto LAB_00109dd5;\n    }\n    sVar6 = __ctype_get_mb_cur_max();\n    if (sVar6 < 2) {\n      if (local_80 < local_80 + uVar8) {\n        ppuVar9 = __ctype_b_loc();\n        unaff_RBX = 0;\n        puVar11 = *ppuVar9;\n        pcVar12 = local_80;\n        do {\n          bVar3 = to_uchar((int)*pcVar12);\n          unaff_RBX = (unaff_RBX + 1) - (ulong)((puVar11[bVar3] & 0x4000) == 0);\n          pcVar12 = (char *)(extraout_RDX + 1);\n        } while (local_80 + uVar8 != pcVar12);\n      }\n      else {\n        unaff_RBX = 0;\n      }\n    }\n    else {\n      iVar5 = mbsnwidth(local_80,uVar8,0);\n      unaff_RBX = (ulong)iVar5;\n    }\n    if (align_variable_outer_quotes != 0) goto LAB_00109dc7;\n    *param_6 = 0;\n  }\n  else {\n    if (param_4 != 0) {\n      bVar2 = true;\n      goto LAB_00109c14;\n    }\n    sVar6 = strlen(param_2);\n    if (0x1fff < sVar6) {\n      local_80 = (char *)xmalloc(sVar6 + 1);\n    }\n    memcpy(local_80,param_2,sVar6 + 1);\n    local_69 = false;\nLAB_00109d59:\n    sVar7 = __ctype_get_mb_cur_max();\n    pcVar12 = local_80 + sVar6;\n    if (sVar7 < 2) {\n      uVar8 = sVar6;\n      if (local_80 < pcVar12) {\n        ppuVar9 = __ctype_b_loc();\n        pcVar13 = local_80;\n        do {\n          bVar3 = to_uchar((int)*pcVar13);\n          if ((*(byte *)((long)*ppuVar9 + (ulong)bVar3 * 2 + 1) & 0x40) == 0) {\n            *extraout_RDX_00 = 0x3f;\n          }\n          pcVar13 = extraout_RDX_00 + 1;\n        } while (pcVar13 != pcVar12);\n      }\n    }\n    else if (local_80 < pcVar12) {\n      sVar6 = 0;\n      pcVar13 = local_80;\n      pcVar16 = local_80;\n      do {\n        cVar1 = *pcVar16;\n        if (cVar1 < '`') {\n          if ('@' < cVar1) goto LAB_00109f2c;\n          if (cVar1 < '$') {\n            if ('\\x1f' < cVar1) goto LAB_00109f2c;\n          }\n          else if ((byte)(cVar1 - 0x25U) < 0x1b) goto LAB_00109f2c;\nLAB_00109e65:\n          local_48 = (mbstate_t)0x0;\n          pcVar14 = pcVar13;\nLAB_00109e95:\n          do {\n            pcVar17 = pcVar16;\n            lVar10 = rpl_mbrtowc(&local_4c,pcVar17,(long)pcVar12 - (long)pcVar17,&local_48);\n            pcVar13 = pcVar14 + 1;\n            if (lVar10 == -1) {\n              *pcVar14 = '?';\n              pcVar16 = pcVar17 + 1;\nLAB_00109fa0:\n              sVar6 = sVar6 + 1;\n              goto LAB_00109f3c;\n            }\n            if (lVar10 == -2) {\n              *pcVar14 = '?';\n              pcVar16 = pcVar12;\n              goto LAB_00109fa0;\n            }\n            lVar15 = 1;\n            if (lVar10 != 0) {\n              lVar15 = lVar10;\n            }\n            iVar5 = wcwidth(local_4c);\n            if (iVar5 < 0) {\n              *pcVar14 = '?';\n              sVar6 = sVar6 + 1;\n              iVar5 = mbsinit(&local_48);\n              pcVar14 = pcVar13;\n              pcVar16 = pcVar17 + lVar15;\n              if (iVar5 != 0) break;\n              goto LAB_00109e95;\n            }\n            lVar10 = 0;\n            do {\n              pcVar14[lVar10] = pcVar17[lVar10];\n              lVar10 = lVar10 + 1;\n            } while (lVar15 != lVar10);\n            pcVar13 = pcVar14 + lVar15;\n            sVar6 = sVar6 + (long)iVar5;\n            iVar5 = mbsinit(&local_48);\n            pcVar14 = pcVar13;\n            pcVar16 = pcVar17 + lVar15;\n          } while (iVar5 == 0);\n          pcVar16 = pcVar17 + lVar15;\n        }\n        else {\n          if (0x1d < (byte)(cVar1 + 0x9fU)) goto LAB_00109e65;\nLAB_00109f2c:\n          *pcVar13 = cVar1;\n          pcVar16 = pcVar16 + 1;\n          sVar6 = sVar6 + 1;\n          pcVar13 = pcVar13 + 1;\n        }\nLAB_00109f3c:\n      } while (pcVar16 < pcVar12);\n      uVar8 = (long)pcVar13 - (long)local_80;\n    }\n    else {\n      sVar6 = 0;\n      uVar8 = 0;\n    }\n    unaff_RBX = sVar6;\n    bVar3 = align_variable_outer_quotes;\n    if (align_variable_outer_quotes != 0) goto LAB_00109dc7;\nLAB_00109dd5:\n    *param_6 = bVar3;\n    if (param_5 == (ulong *)0x0) goto LAB_00109dec;\n  }\n  *param_5 = unaff_RBX;\nLAB_00109dec:\n  *param_1 = local_80;\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar8;\n}\n\n", 
    "00117640": "\nvoid __libc_csu_init(EVP_PKEY_CTX *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  long lVar1;\n  \n  _init(param_1);\n  lVar1 = 0;\n  do {\n    (*(code *)(&__frame_dummy_init_array_entry)[lVar1])((ulong)param_1 & 0xffffffff,param_2,param_3)\n    ;\n    lVar1 = lVar1 + 1;\n  } while (lVar1 != 1);\n  return;\n}\n\n", 
    "00115220": "\nvoid quote_n(undefined8 param_1,undefined8 param_2)\n\n{\n  quote_n_mem(param_1,param_2,0xffffffffffffffff);\n  return;\n}\n\n", 
    "00126348": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fflush_unlocked(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fflush_unlocked@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00126228": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\n__pid_t tcgetpgrp(int __fd)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* tcgetpgrp@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010dcd0": "\nvoid close_stdout_set_ignore_EPIPE(undefined param_1)\n\n{\n  ignore_EPIPE = param_1;\n  return;\n}\n\n", 
    "0010eee0": "\nlong hash_lookup(long param_1,long param_2)\n\n{\n  char cVar1;\n  long *plVar2;\n  long lVar3;\n  \n  plVar2 = (long *)safe_hasher();\n  lVar3 = *plVar2;\n  if (lVar3 == 0) {\n    return 0;\n  }\n  while( true ) {\n    if (lVar3 == param_2) {\n      return param_2;\n    }\n    cVar1 = (**(code **)(param_1 + 0x38))(param_2);\n    if (cVar1 != '\\0') break;\n    plVar2 = (long *)plVar2[1];\n    if (plVar2 == (long *)0x0) {\n      return 0;\n    }\n    lVar3 = *plVar2;\n  }\n  return *plVar2;\n}\n\n", 
    "00126108": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t mbrtowc(wchar_t *__pwc,char *__s,size_t __n,mbstate_t *__p)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* mbrtowc@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010edc0": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid hash_print_statistics(undefined8 param_1,undefined8 param_2)\n\n{\n  undefined8 uVar1;\n  ulong uVar2;\n  ulong uVar3;\n  undefined8 uVar4;\n  double dVar5;\n  double dVar6;\n  \n  uVar1 = hash_get_n_entries();\n  uVar2 = hash_get_n_buckets();\n  uVar3 = hash_get_n_buckets_used();\n  uVar4 = hash_get_max_bucket_length();\n  __fprintf_chk(param_2,1,\"# entries:         %lu\\n\",uVar1);\n  __fprintf_chk(param_2,1,\"# buckets:         %lu\\n\",uVar2);\n  if ((long)uVar3 < 0) {\n    dVar5 = (double)(uVar3 >> 1 | (ulong)((uint)uVar3 & 1));\n    dVar5 = dVar5 + dVar5;\n  }\n  else {\n    dVar5 = (double)uVar3;\n  }\n  if ((long)uVar2 < 0) {\n    dVar6 = (double)(uVar2 >> 1 | (ulong)((uint)uVar2 & 1));\n    dVar6 = dVar6 + dVar6;\n  }\n  else {\n    dVar6 = (double)uVar2;\n  }\n  __fprintf_chk((dVar5 * _DAT_0011bf70) / dVar6,param_2,1,\"# buckets used:    %lu (%.2f%%)\\n\",uVar3)\n  ;\n  __fprintf_chk(param_2,1,\"max bucket length: %lu\\n\",uVar4);\n  return;\n}\n\n", 
    "001159a0": "\nvoid version_etc(void)\n\n{\n  long lVar1;\n  long in_FS_OFFSET;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  version_etc_va();\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00105620": "\nundefined8 is_smack_enabled(void)\n\n{\n  return 0;\n}\n\n", 
    "00105500": "\n/* WARNING: Removing unreachable block (ram,0x00105513) */\n/* WARNING: Removing unreachable block (ram,0x0010551f) */\n\nvoid deregister_tm_clones(void)\n\n{\n  return;\n}\n\n", 
    "00104770": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint raise(int __sig)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_raise_00123c70)();\n  return iVar1;\n}\n\n", 
    "00114f80": "\nvoid quotearg_style_mem(undefined4 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  quotearg_n_style_mem(0,param_1,param_2,param_3);\n  return;\n}\n\n", 
    "00126320": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint sigismember(sigset_t *__set,int __signo)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* sigismember@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00104890": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fclose(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_fclose_00123d00)();\n  return iVar1;\n}\n\n", 
    "00126200": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\ngroup * getgrnam(char *__name)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* getgrnam@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010d3c0": "\nulong c_isalnum(int param_1)\n\n{\n  ulong in_RAX;\n  ulong uVar1;\n  \n  if (param_1 < 0x5b) {\n    uVar1 = 1;\n    if (param_1 < 0x41) {\n      return (ulong)(param_1 - 0x30U < 10);\n    }\n  }\n  else {\n    uVar1 = in_RAX & 0xffffffffffffff00 | (ulong)(param_1 - 0x61U < 0x1a);\n  }\n  return uVar1;\n}\n\n", 
    "00104e18": "\nvoid quotearg_n_options_cold(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "00107cf0": "\nundefined8 rev_strcmp_df_ctime(long param_1,long param_2)\n\n{\n  char cVar1;\n  char cVar2;\n  long lVar3;\n  undefined8 uVar4;\n  \n  lVar3 = param_2;\n  cVar1 = is_directory_isra_0(*(undefined4 *)(param_1 + 0xa8));\n  cVar2 = is_directory_isra_0(*(undefined4 *)(param_2 + 0xa8));\n  if ((cVar2 == '\\x01') || (cVar1 == '\\0')) {\n    if ((cVar1 == '\\x01') || (uVar4 = 1, cVar2 == '\\0')) {\n      uVar4 = cmp_ctime(lVar3,param_1,PTR_strcmp_00123fc8);\n      return uVar4;\n    }\n  }\n  else {\n    uVar4 = 0xffffffff;\n  }\n  return uVar4;\n}\n\n", 
    "00104e13": "\nvoid quotearg_buffer_restyled_cold(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "0010f050": "\nlong hash_do_for_each(long **param_1,code *param_2,undefined8 param_3)\n\n{\n  char cVar1;\n  long *plVar2;\n  long lVar3;\n  long lVar4;\n  long *plVar5;\n  \n  plVar5 = *param_1;\n  if (param_1[1] < plVar5 || param_1[1] == plVar5) {\n    lVar4 = 0;\n  }\n  else {\n    lVar4 = 0;\n    do {\n      lVar3 = *plVar5;\n      plVar2 = plVar5;\n      if (lVar3 != 0) {\n        while( true ) {\n          cVar1 = (*param_2)(lVar3,param_3);\n          if (cVar1 == '\\0') {\n            return lVar4;\n          }\n          plVar2 = (long *)plVar2[1];\n          lVar4 = lVar4 + 1;\n          if (plVar2 == (long *)0x0) break;\n          lVar3 = *plVar2;\n        }\n      }\n      plVar5 = plVar5 + 2;\n    } while (plVar5 <= param_1[1] && param_1[1] != plVar5);\n  }\n  return lVar4;\n}\n\n", 
    "00108cd0": "\nvoid process_signals(void)\n\n{\n  int __sig;\n  long in_FS_OFFSET;\n  sigset_t sStack_a8;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  while ((interrupt_signal != 0 || (stop_signal_count != 0))) {\n    if (used_color != '\\0') {\n      restore_default_color();\n    }\n    fflush_unlocked(stdout);\n    sigprocmask(0,(sigset_t *)caught_signals,&sStack_a8);\n    __sig = interrupt_signal;\n    if (stop_signal_count == 0) {\n      signal(interrupt_signal,(__sighandler_t)0x0);\n    }\n    else {\n      stop_signal_count = stop_signal_count + -1;\n      __sig = 0x13;\n    }\n    raise(__sig);\n    sigprocmask(2,&sStack_a8,(sigset_t *)0x0);\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "0010dee0": "\nvoid record_file(long param_1,undefined8 param_2,undefined8 *param_3)\n\n{\n  undefined8 *puVar1;\n  undefined8 uVar2;\n  undefined8 *puVar3;\n  \n  if (param_1 == 0) {\n    return;\n  }\n  puVar1 = (undefined8 *)xmalloc(0x18);\n  uVar2 = xstrdup(param_2);\n  *puVar1 = uVar2;\n  puVar1[1] = param_3[1];\n  puVar1[2] = *param_3;\n  puVar3 = (undefined8 *)hash_insert(param_1,puVar1);\n  if (puVar3 != (undefined8 *)0x0) {\n    if (puVar1 != puVar3) {\n      triple_free(puVar1);\n      return;\n    }\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  xalloc_die();\n}\n\n", 
    "00126318": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint gethostname(char *__name,size_t __len)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* gethostname@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00105730": "\nvoid stophandler(void)\n\n{\n  if (interrupt_signal == 0) {\n    stop_signal_count = stop_signal_count + 1;\n  }\n  return;\n}\n\n", 
    "00114c30": "\nvoid quotearg_buffer(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n                    undefined1 *param_5)\n\n{\n  int iVar1;\n  int *piVar2;\n  \n  if ((undefined4 *)param_5 == (undefined4 *)0x0) {\n    param_5 = default_quoting_options;\n  }\n  piVar2 = __errno_location();\n  iVar1 = *piVar2;\n  quotearg_buffer_restyled\n            (param_1,param_2,param_3,param_4,*(undefined4 *)param_5,\n             *(undefined4 *)((long)param_5 + 4),(undefined4 *)((long)param_5 + 8),\n             *(undefined8 *)((long)param_5 + 0x28),*(undefined8 *)((long)param_5 + 0x30));\n  *piVar2 = iVar1;\n  return;\n}\n\n", 
    "00104760": "\nvoid __snprintf_chk(void)\n\n{\n  (*(code *)PTR___snprintf_chk_00123c68)();\n  return;\n}\n\n", 
    "00105610": "\nbool is_ENOTSUP(int param_1)\n\n{\n  return param_1 == 0x5f;\n}\n\n", 
    "00114b10": "\nvoid clone_quoting_options(undefined1 *param_1)\n\n{\n  int iVar1;\n  int *piVar2;\n  \n  piVar2 = __errno_location();\n  iVar1 = *piVar2;\n  if (param_1 == (undefined1 *)0x0) {\n    param_1 = default_quoting_options;\n  }\n  xmemdup(param_1,0x38);\n  *piVar2 = iVar1;\n  return;\n}\n\n", 
    "00115e40": "\nvoid xdectoumax(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n               undefined8 param_5,undefined8 param_6)\n\n{\n  xnumtoumax(param_1,10,param_2,param_3,param_4,param_5,param_6);\n  return;\n}\n\n", 
    "00126330": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t fwrite(void *__ptr,size_t __size,size_t __n,FILE *__s)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fwrite@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00105970": "\nvoid set_exit_status(char param_1)\n\n{\n  if (param_1 != '\\0') {\n    exit_status = 2;\n    return;\n  }\n  if (exit_status == 0) {\n    exit_status = 1;\n  }\n  return;\n}\n\n", 
    "00104880": "\nvoid textdomain(void)\n\n{\n  (*(code *)PTR_textdomain_00123cf8)();\n  return;\n}\n\n", 
    "00114e70": "\nvoid quotearg_n_mem(void)\n\n{\n  quotearg_n_options();\n  return;\n}\n\n", 
    "00126210": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid getfilecon(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n  halt_baddata();\n}\n\n", 
    "00104e09": "\nvoid hash_insert_if_absent_cold(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "00104e04": "\nvoid hash_rehash_cold(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "0010d4f0": "\nbool c_isspace(int param_1)\n\n{\n  if (param_1 < 0xe) {\n    return 8 < param_1;\n  }\n  return param_1 == 0x20;\n}\n\n", 
    "0010f7f0": "\nundefined8 hash_insert(undefined8 param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  undefined8 local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = hash_insert_if_absent(param_1,param_2,&local_18);\n  if (iVar1 == -1) {\n    param_2 = 0;\n  }\n  else if (iVar1 == 0) {\n    param_2 = local_18;\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return param_2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00115200": "\nvoid quote_n_mem(void)\n\n{\n  quotearg_n_options();\n  return;\n}\n\n", 
    "00117740": "\nint fstatat(int __fd,char *__file,stat *__buf,int __flag)\n\n{\n  int iVar1;\n  \n  iVar1 = __fxstatat(1,__fd,__file,__buf,__flag);\n  return iVar1;\n}\n\n", 
    "001071b0": "\nvoid dev_ino_push(undefined8 param_1,undefined8 param_2)\n\n{\n  undefined8 *puVar1;\n  \n  puVar1 = dev_ino_obstack._24_8_;\n  if ((ulong)(dev_ino_obstack._32_8_ - (long)dev_ino_obstack._24_8_) < 0x10) {\n    _obstack_newchunk(dev_ino_obstack,0x10);\n    puVar1 = dev_ino_obstack._24_8_;\n  }\n  dev_ino_obstack._24_8_ = puVar1 + 2;\n  puVar1[1] = param_1;\n  *puVar1 = param_2;\n  return;\n}\n\n", 
    "001084e0": "\nvoid rev_xstrcoll_name(undefined8 *param_1,undefined8 *param_2)\n\n{\n  cmp_name_isra_0(*param_2,*param_1,xstrcoll);\n  return;\n}\n\n", 
    "001073f0": "\nvoid signal_restore(void)\n\n{\n  signal_setup(0);\n  return;\n}\n\n", 
    "001115c0": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Type propagation algorithm not settling */\n/* WARNING: Could not reconcile some variable overlaps */\n\nlong __strftime_internal(char *param_1,long param_2,char *param_3,tm *param_4,char param_5,\n                        undefined8 param_6,undefined8 param_7,uint param_8)\n\n{\n  byte *pbVar1;\n  long lVar2;\n  bool bVar3;\n  int iVar4;\n  ulong uVar5;\n  char *pcVar6;\n  ulong uVar7;\n  char *pcVar8;\n  long lVar9;\n  int iVar10;\n  uint uVar11;\n  uint uVar12;\n  size_t sVar13;\n  char *pcVar14;\n  size_t __n;\n  char *pcVar15;\n  long lVar16;\n  char cVar17;\n  uint uVar18;\n  int iVar19;\n  long lVar20;\n  char cVar21;\n  int iVar22;\n  ulong __n_00;\n  char *pcVar23;\n  int iVar24;\n  uint uVar25;\n  uint uVar26;\n  char cVar27;\n  uint uVar28;\n  uint uVar29;\n  int iVar30;\n  char cVar31;\n  char *__s;\n  ulong uVar32;\n  long in_FS_OFFSET;\n  char *local_4c8;\n  undefined8 local_488;\n  undefined8 uStack_480;\n  undefined8 local_478;\n  undefined8 uStack_470;\n  undefined8 local_468;\n  long lStack_460;\n  char *local_458;\n  undefined2 local_44d;\n  char local_44b;\n  char local_44a [2];\n  char local_448;\n  undefined local_447 [21];\n  char local_432 [1010];\n  long local_40;\n  \n  __s = param_4->tm_zone;\n  uVar28 = param_4->tm_hour;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (__s == (char *)0x0) {\n    __s = \"\";\n  }\n  if ((int)uVar28 < 0xd) {\n    if (uVar28 == 0) {\n      uVar28 = 0xc;\n    }\n  }\n  else {\n    uVar28 = uVar28 - 0xc;\n  }\n  cVar27 = *param_3;\n  lVar16 = 0;\n  do {\n    if (cVar27 == '\\0') {\n      if ((param_1 != (char *)0x0) && (param_2 != 0)) {\n        *param_1 = '\\0';\n      }\nLAB_001116a3:\n      if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n        return lVar16;\n      }\n                    /* WARNING: Subroutine does not return */\n      __stack_chk_fail();\n    }\n    if (cVar27 != '%') {\n      if ((ulong)(param_2 - lVar16) < 2) goto LAB_001116a0;\n      if (param_1 != (char *)0x0) {\n        *param_1 = cVar27;\n        param_1 = param_1 + 1;\n      }\n      lVar16 = lVar16 + 1;\n      goto LAB_00111674;\n    }\n    cVar17 = '\\0';\n    iVar30 = 0;\n    cVar27 = param_5;\n    while( true ) {\n      while( true ) {\n        while( true ) {\n          while( true ) {\n            cVar21 = param_3[1];\n            uVar26 = (uint)cVar21;\n            param_3 = param_3 + 1;\n            uVar32 = (ulong)uVar26;\n            if (cVar21 != '0') break;\n            iVar30 = 0x30;\n          }\n          if ('0' < cVar21) break;\n          if (cVar21 == '#') {\n            cVar17 = '\\x01';\n          }\n          else {\n            if (cVar21 != '-') {\n              uVar29 = 0xffffffff;\n              goto LAB_0011175e;\n            }\n            iVar30 = 0x2d;\n          }\n        }\n        if (cVar21 != '^') break;\n        cVar27 = '\\x01';\n      }\n      if (cVar21 != '_') break;\n      iVar30 = 0x5f;\n    }\n    if (uVar26 - 0x30 < 10) {\n      uVar29 = 0;\n      pcVar6 = param_3;\n      do {\n        uVar26 = (uint)pcVar6[1];\n        param_3 = pcVar6 + 1;\n        uVar32 = (ulong)uVar26;\n        uVar12 = uVar26 - 0x30;\n        if ((int)uVar29 < 0xccccccd) {\n          if ((uVar29 == 0xccccccc) && ('7' < *pcVar6)) goto LAB_001118fd;\n          uVar29 = *pcVar6 + -0x30 + uVar29 * 10;\n        }\n        else {\nLAB_001118fd:\n          if (9 < uVar12) {\n            uVar29 = 0x7fffffff;\n            break;\n          }\n          uVar26 = (uint)pcVar6[2];\n          uVar29 = 0x7fffffff;\n          param_3 = pcVar6 + 2;\n          uVar32 = (ulong)uVar26;\n          uVar12 = uVar26 - 0x30;\n        }\n        pcVar6 = param_3;\n      } while (uVar12 < 10);\n    }\n    else {\n      uVar29 = 0xffffffff;\n    }\n    if ((char)uVar32 != 'E') {\nLAB_0011175e:\n      if ((byte)uVar32 == 0x4f) goto LAB_00111796;\n      uVar26 = 0;\n      if ((byte)uVar32 < 0x7b) goto LAB_0011176d;\n      goto switchD_0011177f_caseD_1;\n    }\nLAB_00111796:\n    pbVar1 = (byte *)(param_3 + 1);\n    uVar32 = (ulong)*pbVar1;\n    param_3 = param_3 + 1;\n    if (0x7a < *pbVar1) goto switchD_0011177f_caseD_1;\nLAB_0011176d:\n    cVar21 = (char)uVar32;\n    uVar5 = (long)*(int *)((uVar32 & 0xff) * 4 + 0x11c010) + 0x11c010;\n    uVar12 = uVar28;\n                    /* WARNING (jumptable): Sanity check requires truncation of jumptable */\n                    /* WARNING: Could not find normalized switch variable to match jumptable */\n    switch(uVar32 & 0xff) {\n    case 0:\n      cVar17 = param_3[-1];\n      param_3 = param_3 + -1;\nLAB_00112522:\n      uVar5 = param_2 - lVar16;\n      uVar26 = 0;\n      if (-1 < (int)uVar29) {\n        uVar26 = uVar29;\n      }\n      uVar7 = (ulong)(int)uVar26;\n      if (cVar17 != '%') break;\n      __n_00 = 1;\n      pcVar6 = param_3;\n      uVar32 = 1;\n      if (uVar7 != 0) {\n        uVar32 = uVar7;\n      }\n      goto LAB_001117e8;\n    case 0x25:\n      uVar5 = param_2 - lVar16;\n      uVar12 = 0;\n      if (-1 < (int)uVar29) {\n        uVar12 = uVar29;\n      }\n      uVar7 = (ulong)(int)uVar12;\n      uVar32 = 1;\n      if (uVar7 != 0) {\n        uVar32 = uVar7;\n      }\n      if (uVar26 != 0) {\n        __n_00 = 1;\n        pcVar6 = param_3;\n        goto LAB_001117e8;\n      }\n      if (uVar32 < uVar5) {\n        if (param_1 != (char *)0x0) {\n          pcVar6 = param_1;\n          if (1 < (int)uVar29) {\n            iVar22 = 0x30;\n            pcVar6 = param_1 + ((long)(int)uVar29 - 1U);\n            if (iVar30 != 0x30) {\n              iVar22 = 0x20;\n            }\n            memset(param_1,iVar22,(long)(int)uVar29 - 1U);\n            cVar21 = *param_3;\n          }\n          *pcVar6 = cVar21;\n          param_1 = pcVar6 + 1;\n        }\n        goto LAB_00111fe6;\n      }\n      goto LAB_001116a0;\n    case 0x3a:\n      pcVar6 = param_3 + 1;\n      uVar32 = 1;\n      cVar17 = param_3[1];\n      while (cVar17 == ':') {\n        uVar32 = uVar32 + 1;\n        pcVar6 = param_3 + uVar32;\n        cVar17 = param_3[uVar32];\n      }\n      if (cVar17 == 'z') goto LAB_0011274d;\n      break;\n    case 0x41:\n    case 0x61:\n      if (uVar26 != 0) break;\n      pcVar6 = &local_44b;\n      if (cVar17 != '\\0') {\n        cVar27 = cVar17;\n      }\n      cVar31 = '\\0';\n      uVar26 = 0;\n      goto LAB_0011195c;\n    case 0x42:\n      if (uVar26 != 0x45) {\n        if (cVar17 != '\\0') {\n          cVar27 = cVar17;\n        }\n        cVar31 = '\\0';\n        goto LAB_0011193b;\n      }\n      break;\n    case 0x43:\n      if (uVar26 != 0x45) {\n        iVar19 = param_4->tm_year;\n        bVar3 = false;\n        uVar25 = 2;\n        iVar22 = iVar19 / 100 + 0x13;\n        local_4c8._0_1_ = iVar19 < -0x76c;\n        uVar12 = iVar22 - ((uint)(0 < iVar22) & (uint)(iVar19 % 100) >> 0x1f);\n        uVar11 = 0;\n        goto LAB_00111be0;\n      }\nLAB_00112b78:\n      uVar25 = 0;\n      goto LAB_00111bf5;\n    case 0x44:\n      if (uVar26 == 0) {\n        local_4c8 = \"%m/%d/%y\";\n        goto LAB_001123f7;\n      }\n      break;\n    case 0x46:\n      if (uVar26 == 0) {\n        local_4c8 = \"%Y-%m-%d\";\n        goto LAB_001123f7;\n      }\n      break;\n    case 0x47:\n    case 0x56:\n    case 0x67:\n      if (uVar26 != 0x45) {\n        iVar22 = param_4->tm_year;\n        iVar19 = param_4->tm_yday;\n        uVar32 = (ulong)(iVar22 + -100 + (iVar22 >> 0x1f & 400U));\n        iVar4 = iso_week_days();\n        iVar24 = (int)uVar32;\n        if (iVar4 < 0) {\n          uVar12 = iVar24 - 1;\n          iVar4 = 0x16d;\n          if (((uVar12 & 3) == 0) &&\n             (iVar4 = 0x16e,\n             (uVar12 * -0x3d70a3d7 + 0x51eb850 >> 2 | uVar12 * 0x40000000) < 0x28f5c29)) {\n            iVar4 = ~-(uint)((int)uVar12 % 400 == 0) + 0x16e;\n          }\n          iVar4 = iso_week_days(iVar19 + iVar4);\n          iVar19 = -1;\n        }\n        else {\n          iVar10 = 0x16d;\n          if ((uVar32 & 3) == 0) {\n            iVar10 = 0x16e;\n            uVar12 = iVar24 * -0x3d70a3d7 + 0x51eb850;\n            if ((uVar12 >> 2 | iVar24 * 0x40000000) < 0x28f5c29) {\n              iVar10 = ((uVar12 >> 4 | iVar24 * -0x70000000) < 0xa3d70b) + 0x16d;\n            }\n          }\n          iVar19 = iso_week_days(iVar19 - iVar10);\n          if (-1 < iVar19) {\n            iVar4 = iVar19;\n          }\n          iVar19 = (iVar19 >> 0x1f) + 1;\n        }\n        if (cVar21 == 'G') {\n          bVar3 = false;\n          uVar25 = 4;\n          uVar12 = iVar22 + 0x76c + iVar19;\n          local_4c8._0_1_ = iVar22 < -0x76c - iVar19;\n          uVar11 = 0;\n          goto LAB_00111be0;\n        }\n        if (cVar21 == 'g') {\n          uVar25 = 2;\n          uVar18 = (iVar22 % 100 + iVar19) % 100;\n          uVar12 = uVar18;\n          if ((int)uVar18 < 0) {\n            uVar12 = uVar18 + 100;\n            if (iVar22 < -0x76c - iVar19) {\n              uVar12 = -uVar18;\n            }\n          }\n        }\n        else {\n          uVar12 = iVar4 / 7 + 1;\n          uVar25 = 2;\n        }\n        goto LAB_00111bd0;\n      }\n      break;\n    case 0x48:\n      if (uVar26 != 0x45) {\n        uVar12 = param_4->tm_hour;\n        uVar25 = 2;\n        goto LAB_00111bd0;\n      }\n      break;\n    case 0x49:\n      if (uVar26 != 0x45) {\n        uVar25 = 2;\n        goto LAB_00111bd0;\n      }\n      break;\n    case 0x4d:\n      if (uVar26 != 0x45) {\n        uVar12 = param_4->tm_min;\n        uVar25 = 2;\n        goto LAB_00111bd0;\n      }\n      break;\n    case 0x4e:\n      if (uVar26 != 0x45) {\n        uVar12 = param_8;\n        if (uVar29 == 0xffffffff) {\n          uVar29 = 9;\n          uVar25 = 9;\n        }\n        else {\n          uVar18 = param_8;\n          uVar25 = uVar29;\n          uVar11 = uVar29;\n          if ((int)uVar29 < 9) {\n            do {\n              uVar11 = uVar11 + 1;\n              uVar12 = (int)uVar18 / 10;\n              uVar18 = (int)uVar18 / 10;\n            } while (uVar11 != 9);\n          }\n        }\n        goto LAB_00111bd0;\n      }\n      break;\n    case 0x50:\n      cVar31 = '\\x01';\n      goto LAB_0011280f;\n    case 0x52:\n      local_4c8 = \"%H:%M\";\n      goto LAB_001123f7;\n    case 0x53:\n      if (uVar26 != 0x45) {\n        uVar12 = param_4->tm_sec;\n        uVar25 = 2;\n        goto LAB_00111bd0;\n      }\n      break;\n    case 0x54:\n      local_4c8 = \"%H:%M:%S\";\nLAB_001123f7:\n      uVar32 = __strftime_internal(0,0xffffffffffffffff,local_4c8,param_4,cVar27,param_6,param_7,\n                                   (char)param_8);\n      uVar26 = 0;\n      if (-1 < (int)uVar29) {\n        uVar26 = uVar29;\n      }\n      uVar7 = (ulong)(int)uVar26;\n      uVar5 = uVar7;\n      if (uVar7 <= uVar32) {\n        uVar5 = uVar32;\n      }\n      if ((ulong)(param_2 - lVar16) <= uVar5) goto LAB_001116a0;\n      if (param_1 != (char *)0x0) {\n        pcVar6 = param_1;\n        if (uVar32 < uVar7) {\n          sVar13 = (long)(int)uVar29 - uVar32;\n          pcVar6 = param_1 + sVar13;\n          if (iVar30 == 0x30) {\n            memset(param_1,0x30,sVar13);\n          }\n          else {\n            memset(param_1,0x20,sVar13);\n          }\n        }\n        param_1 = pcVar6 + uVar32;\n        __strftime_internal(pcVar6,param_2 - lVar16,local_4c8,param_4,cVar27,param_6,param_7,\n                            (char)param_8);\n      }\n      lVar16 = lVar16 + uVar5;\n      goto LAB_00111674;\n    case 0x55:\n      if (uVar26 != 0x45) {\n        iVar22 = (param_4->tm_yday - param_4->tm_wday) + 7;\nLAB_001121e7:\n        uVar12 = iVar22 / 7;\n        uVar25 = 2;\n        goto LAB_00111bd0;\n      }\n      break;\n    case 0x57:\n      if (uVar26 != 0x45) {\n        iVar22 = param_4->tm_wday + 6;\n        iVar22 = ((iVar22 / 7) * 7 - iVar22) + 7 + param_4->tm_yday;\n        goto LAB_001121e7;\n      }\n      break;\n    case 0x58:\n    case 99:\n    case 0x78:\n      if (uVar26 != 0x4f) goto switchD_0011177f_caseD_72;\n      break;\n    case 0x59:\n      if (uVar26 == 0x45) goto LAB_00112b78;\n      if (uVar26 == 0x4f) break;\n      bVar3 = false;\n      uVar18 = 4;\n      local_4c8._0_1_ = param_4->tm_year < -0x76c;\n      uVar12 = param_4->tm_year + 0x76c;\n      uVar11 = 0;\n      goto LAB_00111ca0;\n    case 0x5a:\n      if (cVar17 != '\\0') {\n        cVar27 = '\\0';\n      }\n      sVar13 = strlen(__s);\n      uVar26 = 0;\n      if (-1 < (int)uVar29) {\n        uVar26 = uVar29;\n      }\n      uVar5 = (ulong)(int)uVar26;\n      uVar32 = uVar5;\n      if (uVar5 <= sVar13) {\n        uVar32 = sVar13;\n      }\n      if (uVar32 < (ulong)(param_2 - lVar16)) {\n        if (param_1 != (char *)0x0) {\n          pcVar6 = param_1;\n          if (sVar13 < uVar5) {\n            __n = (long)(int)uVar29 - sVar13;\n            pcVar6 = param_1 + __n;\n            if (iVar30 == 0x30) {\n              memset(param_1,0x30,__n);\n            }\n            else {\n              memset(param_1,0x20,__n);\n            }\n          }\n          if (cVar17 == '\\0') {\n            if (cVar27 == '\\0') {\n              memcpy(pcVar6,__s,sVar13);\n            }\n            else {\n              memcpy_uppcase();\n            }\n          }\n          else {\n            memcpy_lowcase();\n          }\n          param_1 = pcVar6 + sVar13;\n        }\n        lVar16 = lVar16 + uVar32;\n        goto LAB_00111674;\n      }\n      goto LAB_001116a0;\n    case 0x62:\n    case 0x68:\n      if (cVar17 != '\\0') {\n        cVar27 = cVar17;\n      }\n      if (uVar26 != 0x45) goto switchD_0011177f_caseD_72;\n      break;\n    case 100:\n      if (uVar26 != 0x45) {\n        uVar12 = param_4->tm_mday;\n        uVar25 = 2;\n        goto LAB_00111bd0;\n      }\n      break;\n    case 0x65:\n      if (uVar26 != 0x45) {\n        uVar12 = param_4->tm_mday;\nLAB_0011261f:\n        uVar25 = 2;\n        if ((iVar30 != 0x30) && (iVar30 != 0x2d)) {\n          iVar30 = 0x5f;\n        }\n        goto LAB_00111bd0;\n      }\n      break;\n    case 0x6a:\n      if (uVar26 != 0x45) {\n        bVar3 = false;\n        uVar25 = 3;\n        local_4c8._0_1_ = param_4->tm_yday < -1;\n        uVar12 = param_4->tm_yday + 1;\n        uVar11 = 0;\n        goto LAB_00111be0;\n      }\n      break;\n    case 0x6b:\n      if (uVar26 != 0x45) {\n        uVar12 = param_4->tm_hour;\n        goto LAB_0011261f;\n      }\n      break;\n    case 0x6c:\n      if (uVar26 != 0x45) goto LAB_0011261f;\n      break;\n    case 0x6d:\n      if (uVar26 != 0x45) {\n        bVar3 = false;\n        uVar25 = 2;\n        local_4c8._0_1_ = param_4->tm_mon < -1;\n        uVar12 = param_4->tm_mon + 1;\n        uVar11 = 0;\n        goto LAB_00111be0;\n      }\n      break;\n    case 0x6e:\n      uVar26 = 0;\n      if (-1 < (int)uVar29) {\n        uVar26 = uVar29;\n      }\n      uVar32 = (ulong)(int)uVar26;\n      if (uVar32 == 0) {\n        uVar32 = 1;\n      }\n      if (uVar32 < (ulong)(param_2 - lVar16)) {\n        if (param_1 != (char *)0x0) {\n          pcVar6 = param_1;\n          if (1 < (int)uVar29) {\n            sVar13 = (long)(int)uVar29 - 1;\n            pcVar6 = param_1 + sVar13;\n            if (iVar30 == 0x30) {\n              memset(param_1,0x30,sVar13);\n            }\n            else {\n              memset(param_1,0x20,sVar13);\n            }\n          }\n          *pcVar6 = '\\n';\n          param_1 = pcVar6 + 1;\n        }\nLAB_00111fe6:\n        lVar16 = lVar16 + uVar32;\n        goto LAB_00111674;\n      }\n      goto LAB_001116a0;\n    case 0x70:\n      cVar31 = '\\0';\nLAB_0011280f:\n      cVar21 = 'p';\n      if (cVar17 != '\\0') {\n        cVar27 = '\\0';\n        cVar31 = cVar17;\n      }\nLAB_0011193b:\n      if (uVar26 != 0) {\n        uVar25 = 0;\n        goto LAB_00111c05;\n      }\n      pcVar6 = &local_44b;\n      goto LAB_0011195c;\n    case 0x71:\n      uVar25 = 1;\n      uVar18 = 1;\n      if (uVar26 == 0x4f) goto LAB_00111bf5;\n      bVar3 = false;\n      uVar11 = 0;\n      local_4c8._0_1_ = false;\n      uVar12 = (param_4->tm_mon * 0xb >> 5) + 1;\n      goto LAB_00111ca9;\n    case 0x72:\nswitchD_0011177f_caseD_72:\n      cVar31 = '\\0';\n      goto LAB_0011193b;\n    case 0x73:\n      local_488 = *(undefined8 *)param_4;\n      uStack_480 = *(undefined8 *)&param_4->tm_hour;\n      local_478 = *(undefined8 *)&param_4->tm_mon;\n      uStack_470 = *(undefined8 *)&param_4->tm_wday;\n      local_468 = *(undefined8 *)&param_4->tm_isdst;\n      lStack_460 = param_4->tm_gmtoff;\n      local_458 = param_4->tm_zone;\n      lVar9 = mktime_z(param_7,&local_488);\n      pcVar6 = local_432 + 1;\n      lVar20 = lVar9;\n      do {\n        lVar2 = lVar20 / 10;\n        cVar17 = (char)lVar20 + (char)lVar2 * -10;\n        if (lVar9 < 0) {\n          cVar17 = -cVar17;\n        }\n        pcVar6 = pcVar6 + -1;\n        *pcVar6 = cVar17 + '0';\n        lVar20 = lVar2;\n      } while (lVar2 != 0);\n      uVar18 = 1;\n      if (0 < (int)uVar29) {\n        uVar18 = uVar29;\n      }\n      if (lVar9 < 0) goto LAB_00112870;\n      goto LAB_0011214b;\n    case 0x74:\n      uVar26 = 0;\n      if (-1 < (int)uVar29) {\n        uVar26 = uVar29;\n      }\n      uVar32 = (ulong)(int)uVar26;\n      if (uVar32 == 0) {\n        uVar32 = 1;\n      }\n      if (uVar32 < (ulong)(param_2 - lVar16)) {\n        if (param_1 != (char *)0x0) {\n          pcVar6 = param_1;\n          if (1 < (int)uVar29) {\n            sVar13 = (long)(int)uVar29 - 1;\n            pcVar6 = param_1 + sVar13;\n            if (iVar30 == 0x30) {\n              memset(param_1,0x30,sVar13);\n            }\n            else {\n              memset(param_1,0x20,sVar13);\n            }\n          }\n          *pcVar6 = '\\t';\n          param_1 = pcVar6 + 1;\n        }\n        goto LAB_00111fe6;\n      }\n      goto LAB_001116a0;\n    case 0x75:\n      uVar12 = (param_4->tm_wday + 6) % 7 + 1;\n      uVar25 = 1;\n      goto LAB_00111bd0;\n    case 0x77:\n      if (uVar26 != 0x45) {\n        uVar12 = param_4->tm_wday;\n        uVar25 = 1;\n        goto LAB_00111bd0;\n      }\n      break;\n    case 0x79:\n      if (uVar26 == 0x45) goto LAB_00112b78;\n      uVar25 = 2;\n      uVar18 = param_4->tm_year % 100;\n      uVar12 = uVar18;\n      if ((int)uVar18 < 0) {\n        uVar12 = uVar18 + 100;\n        if (param_4->tm_year < -0x76c) {\n          uVar12 = -uVar18;\n        }\n      }\nLAB_00111bd0:\n      bVar3 = false;\n      uVar11 = 0;\n      local_4c8._0_1_ = (char)(uVar12 >> 0x1f);\nLAB_00111be0:\n      uVar18 = uVar25;\n      if (uVar26 != 0x4f) {\nLAB_00111ca0:\n        if ((bool)(char)local_4c8 != false) goto LAB_00111ca7;\nLAB_00111ca9:\n        pcVar15 = local_432 + 1;\n        pcVar6 = local_432;\n        while( true ) {\n          if ((uVar11 & 1) != 0) {\n            pcVar15[-1] = ':';\n            pcVar8 = pcVar15 + -2;\n            pcVar15 = pcVar6;\n            pcVar6 = pcVar8;\n          }\n          uVar11 = (int)uVar11 >> 1;\n          pcVar15[-1] = (char)(uVar12 % 10) + '0';\n          if ((uVar12 < 10) && (uVar11 == 0)) break;\n          uVar12 = uVar12 / 10;\n          pcVar15 = pcVar6;\n          pcVar6 = pcVar6 + -1;\n        }\n        if ((int)uVar18 < (int)uVar29) {\n          uVar18 = uVar29;\n        }\n        if ((bool)(char)local_4c8 != false) {\nLAB_00112870:\n          local_4c8._0_1_ = '-';\n          cVar17 = '-';\n          if (iVar30 != 0x2d) goto LAB_00111d5a;\nLAB_00112885:\n          uVar26 = 0;\n          if (-1 < (int)uVar29) {\n            uVar26 = uVar29;\n          }\n          pcVar23 = (char *)(long)(int)uVar26;\n          pcVar15 = (char *)0x1;\n          if (pcVar23 != (char *)0x0) {\n            pcVar15 = pcVar23;\n          }\n          if ((char *)(param_2 - lVar16) <= pcVar15) goto LAB_001116a0;\n          if (param_1 != (char *)0x0) {\n            if ((uVar18 == 0) && ((char *)0x1 < pcVar23)) {\n              memset(param_1,0x20,(long)(int)uVar29 - 1U);\n              param_1 = param_1 + ((long)(int)uVar29 - 1U);\n            }\n            *param_1 = cVar17;\n            param_1 = param_1 + 1;\n          }\n          lVar16 = lVar16 + (long)pcVar15;\n          iVar30 = 0x2d;\n          pcVar14 = local_432 + (1 - (long)pcVar6);\n          pcVar8 = (char *)(param_2 - lVar16);\n          goto LAB_00111e81;\n        }\n        if (bVar3) {\n          if (iVar30 == 0x2d) {\n            cVar17 = '+';\n            goto LAB_00112885;\n          }\n          local_4c8._0_1_ = '+';\nLAB_00111d5a:\n          pcVar14 = local_432 + (1 - (long)pcVar6);\n          iVar22 = (uVar18 - 1) - (int)pcVar14;\n          pcVar8 = (char *)(param_2 - lVar16);\n          if (iVar22 < 1) {\n            uVar26 = 0;\n            if (-1 < (int)uVar29) {\n              uVar26 = uVar29;\n            }\n            pcVar23 = (char *)(long)(int)uVar26;\n            pcVar15 = (char *)0x1;\n            if (pcVar23 != (char *)0x0) {\n              pcVar15 = pcVar23;\n            }\n            if (pcVar8 <= pcVar15) goto LAB_001116a0;\n            if (param_1 != (char *)0x0) {\n              pcVar8 = param_1;\n              if ((uVar18 == 0) && ((char *)0x1 < pcVar23)) {\n                sVar13 = (long)(int)uVar29 - 1;\n                pcVar8 = param_1 + sVar13;\n                if (iVar30 == 0x30) {\n                  memset(param_1,0x30,sVar13);\n                }\n                else {\n                  memset(param_1,0x20,sVar13);\n                }\n              }\n              param_1 = pcVar8 + 1;\n              *pcVar8 = (char)local_4c8;\n            }\n            lVar16 = lVar16 + (long)pcVar15;\n            pcVar8 = (char *)(param_2 - lVar16);\n            goto LAB_00111e81;\n          }\n        }\n        else {\nLAB_0011214b:\n          pcVar14 = local_432 + (1 - (long)pcVar6);\n          pcVar8 = (char *)(param_2 - lVar16);\n          if ((iVar30 == 0x2d) || (iVar22 = uVar18 - (int)pcVar14, iVar22 < 1)) {\n            uVar26 = 0;\n            if (-1 < (int)uVar29) {\n              uVar26 = uVar29;\n            }\n            pcVar23 = (char *)(long)(int)uVar26;\n            goto LAB_00111e81;\n          }\n          local_4c8._0_1_ = '\\0';\n        }\n        if (iVar30 == 0x5f) {\n          pcVar15 = (char *)(long)iVar22;\n          if (pcVar15 < pcVar8) {\n            pcVar14 = param_1;\n            if (param_1 != (char *)0x0) {\n              memset(param_1,0x20,(size_t)pcVar15);\n              pcVar14 = param_1 + (long)pcVar15;\n            }\n            lVar16 = lVar16 + (long)pcVar15;\n            if (iVar22 < (int)uVar29) {\n              uVar29 = uVar29 - iVar22;\n              pcVar23 = (char *)(long)(int)uVar29;\n            }\n            else {\n              pcVar23 = (char *)0x0;\n              uVar29 = 0;\n            }\n            pcVar8 = (char *)(param_2 - lVar16);\n            param_1 = pcVar14;\n            if ((char)local_4c8 == '\\0') {\n              pcVar14 = local_432 + (1 - (long)pcVar6);\n            }\n            else {\n              pcVar15 = (char *)0x1;\n              if (pcVar23 != (char *)0x0) {\n                pcVar15 = pcVar23;\n              }\n              if (pcVar8 <= pcVar15) goto LAB_001116a0;\n              if (pcVar14 != (char *)0x0) {\n                if ((uVar18 == 0) && ((char *)0x1 < pcVar23)) {\n                  memset(pcVar14,0x20,(long)(int)uVar29 - 1U);\n                  pcVar14 = pcVar14 + ((long)(int)uVar29 - 1U);\n                }\n                param_1 = pcVar14 + 1;\n                *pcVar14 = (char)local_4c8;\n              }\n              lVar16 = lVar16 + (long)pcVar15;\n              pcVar14 = local_432 + (1 - (long)pcVar6);\n              pcVar8 = (char *)(param_2 - lVar16);\n            }\n            goto LAB_00111e81;\n          }\n        }\n        else if ((char *)(long)(int)uVar18 < pcVar8) {\n          if ((char)local_4c8 == '\\0') {\n            if (param_1 != (char *)0x0) {\nLAB_00111e33:\n              memset(param_1,0x30,(long)iVar22);\n              param_1 = param_1 + iVar22;\n            }\n          }\n          else {\n            uVar26 = 0;\n            if (-1 < (int)uVar29) {\n              uVar26 = uVar29;\n            }\n            pcVar14 = (char *)(long)(int)uVar26;\n            pcVar15 = (char *)0x1;\n            if (pcVar14 != (char *)0x0) {\n              pcVar15 = pcVar14;\n            }\n            if (pcVar8 <= pcVar15) goto LAB_001116a0;\n            lVar16 = lVar16 + (long)pcVar15;\n            if (param_1 != (char *)0x0) {\n              pcVar15 = param_1;\n              if ((uVar18 == 0) && ((char *)0x1 < pcVar14)) {\n                sVar13 = (long)(int)uVar29 - 1;\n                pcVar15 = param_1 + sVar13;\n                if (iVar30 == 0x30) {\n                  memset(param_1,0x30,sVar13);\n                }\n                else {\n                  memset(param_1,0x20,sVar13);\n                }\n              }\n              param_1 = pcVar15 + 1;\n              *pcVar15 = (char)local_4c8;\n              goto LAB_00111e33;\n            }\n          }\n          lVar16 = lVar16 + iVar22;\n          pcVar23 = (char *)0x0;\n          uVar29 = 0;\n          pcVar14 = local_432 + (1 - (long)pcVar6);\n          pcVar8 = (char *)(param_2 - lVar16);\nLAB_00111e81:\n          pcVar15 = pcVar23;\n          if (pcVar23 <= pcVar14) {\n            pcVar15 = pcVar14;\n          }\n          if (pcVar15 < pcVar8) {\n            if (param_1 != (char *)0x0) {\n              pcVar8 = param_1;\n              if ((uVar18 == 0) && (pcVar14 < pcVar23)) {\n                sVar13 = (long)(int)uVar29 - (long)pcVar14;\n                pcVar8 = param_1 + sVar13;\n                if (iVar30 == 0x30) {\n                  memset(param_1,0x30,sVar13);\n                }\n                else {\n                  memset(param_1,0x20,sVar13);\n                }\n              }\n              if (cVar27 == '\\0') {\n                memcpy(pcVar8,pcVar6,(size_t)pcVar14);\n              }\n              else {\n                memcpy_uppcase();\n              }\n              param_1 = pcVar8 + (long)pcVar14;\n            }\n            goto LAB_00111a82;\n          }\n        }\n        goto LAB_001116a0;\n      }\n      if ((bool)(char)local_4c8 != false) {\nLAB_00111ca7:\n        uVar12 = -uVar12;\n        goto LAB_00111ca9;\n      }\nLAB_00111bf5:\n      cVar31 = '\\0';\nLAB_00111c05:\n      local_44b = (char)uVar26;\n      pcVar6 = local_44a;\n      uVar26 = uVar25;\nLAB_0011195c:\n      local_44d = 0x2520;\n      *pcVar6 = cVar21;\n      pcVar6[1] = '\\0';\n      sVar13 = strftime(&local_448,0x400,(char *)&local_44d,param_4);\n      if (sVar13 != 0) {\n        pcVar6 = (char *)(sVar13 - 1);\n        uVar12 = 0;\n        if (-1 < (int)uVar29) {\n          uVar12 = uVar29;\n        }\n        pcVar8 = (char *)(long)(int)uVar12;\n        pcVar15 = pcVar8;\n        if (pcVar8 <= pcVar6) {\n          pcVar15 = pcVar6;\n        }\n        if ((char *)(param_2 - lVar16) <= pcVar15) goto LAB_001116a0;\n        if (param_1 != (char *)0x0) {\n          pcVar14 = param_1;\n          if ((uVar26 == 0) && (pcVar6 < pcVar8)) {\n            sVar13 = (long)(int)uVar29 - (long)pcVar6;\n            pcVar14 = param_1 + sVar13;\n            if (iVar30 == 0x30) {\n              memset(param_1,0x30,sVar13);\n            }\n            else {\n              memset(param_1,0x20,sVar13);\n            }\n          }\n          if (cVar31 == '\\0') {\n            if (cVar27 == '\\0') {\n              memcpy(pcVar14,local_447,(size_t)pcVar6);\n            }\n            else {\n              memcpy_uppcase();\n            }\n          }\n          else {\n            memcpy_lowcase();\n          }\n          param_1 = pcVar14 + (long)pcVar6;\n        }\nLAB_00111a82:\n        lVar16 = lVar16 + (long)pcVar15;\n      }\n      goto LAB_00111674;\n    case 0x7a:\n      uVar32 = 0;\n      pcVar6 = param_3;\nLAB_0011274d:\n      param_3 = pcVar6;\n      if (param_4->tm_isdst < 0) goto LAB_00111674;\n      local_4c8._0_1_ = true;\n      iVar22 = (int)param_4->tm_gmtoff;\n      if ((-1 < iVar22) && (local_4c8._0_1_ = false, iVar22 == 0)) {\n        local_4c8._0_1_ = *__s == '-';\n      }\n      uVar12 = iVar22 / 0xe10;\n      uVar11 = (iVar22 / 0x3c) % 0x3c;\n      if (uVar32 == 2) {\nLAB_00112d99:\n        bVar3 = true;\n        uVar25 = 9;\n        iVar19 = uVar11 * 100;\n        uVar11 = 0x14;\n        uVar12 = uVar12 * 10000 + iVar19 + iVar22 % 0x3c;\n      }\n      else if (uVar32 < 3) {\n        if (uVar32 == 0) {\n          bVar3 = true;\n          uVar25 = 5;\n          uVar12 = uVar12 * 100 + uVar11;\n          uVar11 = 0;\n        }\n        else {\nLAB_001127e4:\n          bVar3 = true;\n          uVar25 = 6;\n          uVar12 = uVar12 * 100 + uVar11;\n          uVar11 = 4;\n        }\n      }\n      else {\n        if (uVar32 != 3) {\n          cVar17 = *param_3;\n          goto LAB_00112522;\n        }\n        if (iVar22 % 0x3c != 0) goto LAB_00112d99;\n        if (uVar11 != 0) goto LAB_001127e4;\n        bVar3 = true;\n        uVar25 = 3;\n      }\n      goto LAB_00111be0;\n    case 0x7b:\n      (*(code *)((uVar5 & 0xffffffffffff0000 |\n                 (ulong)CONCAT11((byte)(uVar5 >> 8) | *(byte *)(lVar16 + -1),(char)uVar5)) -\n                0x670000a9))();\n                    /* WARNING: Bad instruction - Truncating control flow here */\n      halt_baddata();\n    }\nswitchD_0011177f_caseD_1:\n    pcVar6 = param_3;\n    do {\n      pcVar6 = pcVar6 + -1;\n    } while (*pcVar6 != '%');\n    __n_00 = (ulong)(((int)param_3 + 1) - (int)pcVar6);\n    uVar5 = param_2 - lVar16;\n    uVar26 = 0;\n    if (-1 < (int)uVar29) {\n      uVar26 = uVar29;\n    }\n    uVar7 = (ulong)(int)uVar26;\n    uVar32 = __n_00;\n    if (__n_00 <= uVar7) {\n      uVar32 = uVar7;\n    }\nLAB_001117e8:\n    if (uVar5 <= uVar32) {\nLAB_001116a0:\n      lVar16 = 0;\n      goto LAB_001116a3;\n    }\n    if (param_1 != (char *)0x0) {\n      pcVar15 = param_1;\n      if (__n_00 < uVar7) {\n        sVar13 = (long)(int)uVar29 - __n_00;\n        pcVar15 = param_1 + sVar13;\n        if (iVar30 == 0x30) {\n          memset(param_1,0x30,sVar13);\n        }\n        else {\n          memset(param_1,0x20,sVar13);\n        }\n      }\n      if (cVar27 == '\\0') {\n        memcpy(pcVar15,pcVar6,__n_00);\n      }\n      else {\n        memcpy_uppcase();\n      }\n      param_1 = pcVar15 + __n_00;\n    }\n    lVar16 = lVar16 + uVar32;\nLAB_00111674:\n    cVar27 = param_3[1];\n    param_3 = param_3 + 1;\n  } while( true );\n}\n\n", 
    "00105600": "\nundefined8 bad_cast(undefined8 param_1)\n\n{\n  return param_1;\n}\n\n", 
    "00126328": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid exit(int __status)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* exit@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010ddd0": "\nundefined * mdir_name(void *param_1)\n\n{\n  size_t __n;\n  undefined *__dest;\n  \n  __n = dir_len();\n  __dest = (undefined *)malloc(__n + 1 + (ulong)(__n == 0));\n  if (__dest != (undefined *)0x0) {\n    __dest = (undefined *)memcpy(__dest,param_1,__n);\n    if (__n == 0) {\n      *__dest = 0x2e;\n      __n = 1;\n    }\n    __dest[__n] = 0;\n  }\n  return __dest;\n}\n\n", 
    "00126208": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint putchar_unlocked(int __c)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* putchar_unlocked@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00107820": "\nvoid format_group(ulong param_1,int param_2,char param_3)\n\n{\n  int iVar1;\n  size_t sVar2;\n  long lVar3;\n  char *__s;\n  \n  __s = \"?\";\n  param_1 = param_1 & 0xffffffff;\n  if ((param_3 != '\\0') && (__s = (char *)0x0, numeric_ids == '\\0')) {\n    __s = (char *)getgroup();\n  }\n  if (__s == (char *)0x0) {\n    lVar3 = (long)param_2;\n    __printf_chk(1,\"%*lu \",param_2,param_1);\n  }\n  else {\n    iVar1 = gnu_mbswidth(__s,0);\n    param_2 = param_2 - iVar1;\n    if (param_2 < 0) {\n      param_2 = 0;\n    }\n    fputs_unlocked(__s,stdout);\n    sVar2 = strlen(__s);\n    lVar3 = (long)param_2 + sVar2;\n    do {\n      param_2 = param_2 + -1;\n      putchar_unlocked(0x20);\n    } while (param_2 != -1);\n  }\n  dired_pos = lVar3 + 1 + dired_pos;\n  return;\n}\n\n", 
    "00106730": "\nvoid free_ent(void **param_1)\n\n{\n  char cVar1;\n  \n  free(*param_1);\n  free(param_1[1]);\n  free(param_1[2]);\n  if ((undefined2 *)param_1[0x16] == &UNKNOWN_SECURITY_CONTEXT) {\n    return;\n  }\n  cVar1 = is_smack_enabled();\n  if (cVar1 != '\\0') {\n    (*(code *)PTR_free_00123fb0)();\n    return;\n  }\n  freecon();\n  return;\n}\n\n", 
    "00104790": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint * __errno_location(void)\n\n{\n  int *piVar1;\n  \n  piVar1 = (int *)(*(code *)PTR___errno_location_00123c80)();\n  return piVar1;\n}\n\n", 
    "00126300": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __cxa_atexit(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __cxa_atexit@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001170d0": "\nundefined4 revert_tz(long param_1)\n\n{\n  undefined4 uVar1;\n  int *piVar2;\n  int iVar3;\n  \n  uVar1 = 1;\n  if (param_1 != 1) {\n    piVar2 = __errno_location();\n    iVar3 = *piVar2;\n    uVar1 = change_env(param_1);\n    if ((char)uVar1 == '\\0') {\n      iVar3 = *piVar2;\n    }\n    tzfree(param_1);\n    *piVar2 = iVar3;\n  }\n  return uVar1;\n}\n\n", 
    "00117700": "\nint fstat(int __fd,stat *__buf)\n\n{\n  int iVar1;\n  \n  iVar1 = __fxstat(1,__fd,__buf);\n  return iVar1;\n}\n\n", 
    "00104d10": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t wcstombs(char *__s,wchar_t *__pwcs,size_t __n)\n\n{\n  size_t sVar1;\n  \n  sVar1 = (*(code *)PTR_wcstombs_00123f40)();\n  return sVar1;\n}\n\n", 
    "00113350": "\nundefined8\nstrcaseeq3(long param_1,undefined8 param_2,byte param_3,char param_4,char param_5,char param_6,\n          char param_7)\n\n{\n  char cVar1;\n  byte bVar2;\n  undefined8 uVar3;\n  \n  cVar1 = c_isupper((int)(char)param_3);\n  bVar2 = *(byte *)(param_1 + 3);\n  if (cVar1 != '\\0') {\n    bVar2 = bVar2 & 0xdf;\n  }\n  if (param_3 != bVar2) {\n    return 0;\n  }\n  if (param_3 == 0) {\n    return 1;\n  }\n  uVar3 = strcaseeq4(param_1,param_2,(int)param_4,(int)param_5,(int)param_6,(int)param_7);\n  return uVar3;\n}\n\n", 
    "00116860": "\nuint map_to_failure(uint param_1,byte **param_2)\n\n{\n  int *piVar1;\n  long lVar2;\n  byte *pbVar3;\n  byte *pbVar4;\n  bool bVar5;\n  bool bVar6;\n  \n  if (param_1 == 0) {\n    piVar1 = __errno_location();\n    *piVar1 = 0x5f;\n    return 0xffffffff;\n  }\n  bVar5 = param_1 < 10;\n  bVar6 = param_1 == 10;\n  if (bVar6) {\n    lVar2 = 10;\n    pbVar3 = *param_2;\n    pbVar4 = (byte *)\"unlabeled\";\n    do {\n      if (lVar2 == 0) break;\n      lVar2 = lVar2 + -1;\n      bVar5 = *pbVar3 < *pbVar4;\n      bVar6 = *pbVar3 == *pbVar4;\n      pbVar3 = pbVar3 + 1;\n      pbVar4 = pbVar4 + 1;\n    } while (bVar6);\n    if ((!bVar5 && !bVar6) == bVar5) {\n      freecon(*param_2);\n      *param_2 = (byte *)0x0;\n      piVar1 = __errno_location();\n      *piVar1 = 0x3d;\n      return 0xffffffff;\n    }\n  }\n  return param_1;\n}\n\n", 
    "00111290": "\nvoid mpsort_into_tmp(undefined8 *param_1,ulong param_2,undefined8 *param_3,code *param_4)\n\n{\n  int iVar1;\n  ulong uVar2;\n  ulong uVar3;\n  undefined8 *__dest;\n  undefined8 uVar4;\n  undefined8 uVar5;\n  ulong uVar6;\n  ulong uVar7;\n  ulong local_40;\n  \n  uVar6 = param_2 >> 1;\n  mpsort_with_tmp(param_1 + uVar6,param_2 - uVar6);\n  mpsort_with_tmp(param_1,uVar6,param_3,param_4);\n  uVar4 = *param_1;\n  uVar5 = param_1[uVar6];\n  uVar2 = 0;\n  uVar3 = uVar6;\n  while( true ) {\n    while( true ) {\n      __dest = param_3 + 1;\n      iVar1 = (*param_4)(uVar4,uVar5);\n      if (0 < iVar1) break;\n      *param_3 = uVar4;\n      uVar2 = uVar2 + 1;\n      local_40 = param_2;\n      if (uVar6 == uVar2) goto LAB_0011133d;\n      uVar4 = param_1[uVar2];\n      param_3 = __dest;\n    }\n    *param_3 = uVar5;\n    uVar7 = uVar3 + 1;\n    uVar3 = uVar2;\n    local_40 = uVar6;\n    if (param_2 == uVar7) break;\n    uVar5 = param_1[uVar7];\n    param_3 = __dest;\n    uVar3 = uVar7;\n  }\nLAB_0011133d:\n  memcpy(__dest,param_1 + uVar3,(local_40 - uVar3) * 8);\n  return;\n}\n\n", 
    "00115410": "\nundefined  [16] make_timespec(undefined8 param_1,undefined8 param_2)\n\n{\n  return CONCAT88(param_2,param_1);\n}\n\n", 
    "00104e1d": "\nvoid set_custom_quoting_cold(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "0010fa50": "\nulong triple_hash(undefined8 *param_1,ulong param_2)\n\n{\n  ulong uVar1;\n  \n  uVar1 = hash_pjw(*param_1);\n  return (uVar1 ^ param_1[1]) % param_2;\n}\n\n", 
    "00114e50": "\nvoid quotearg_n(undefined8 param_1,undefined8 param_2)\n\n{\n  quotearg_n_options(param_1,param_2,0xffffffffffffffff,default_quoting_options);\n  return;\n}\n\n", 
    "00107930": "\nvoid rev_strcmp_atime(undefined8 param_1,undefined8 param_2)\n\n{\n  cmp_atime(param_2,param_1,PTR_strcmp_00123fc8);\n  return;\n}\n\n", 
    "00105750": "\nundefined4 get_funky_string(byte **param_1,byte **param_2,undefined4 param_3,long *param_4)\n\n{\n  char cVar1;\n  long lVar2;\n  byte bVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  byte *pbVar6;\n  byte bVar7;\n  bool bVar8;\n  \n  pbVar5 = *param_2;\n  pbVar6 = *param_1;\n  lVar2 = 0;\nLAB_00105765:\n  do {\n    bVar3 = *pbVar5;\n    cVar1 = bVar3 + 0xa4;\n    bVar8 = bVar3 == 0x5c;\n    pbVar4 = pbVar5;\n    while (!bVar8) {\n      if (bVar8 || SBORROW1(bVar3,'\\\\') != cVar1 < '\\0') {\n        if (bVar3 == 0x3d) {\n          if ((char)param_3 != '\\0') goto LAB_00105815;\n        }\n        else if (((char)bVar3 < '>') && ((bVar3 == 0 || (bVar3 == 0x3a)))) {\n          param_3 = 1;\n          goto LAB_00105815;\n        }\n      }\n      else if (bVar3 == 0x5e) {\n        bVar3 = pbVar4[1];\n        pbVar5 = pbVar4 + 1;\n        if ((byte)(bVar3 - 0x40) < 0x3f) {\n          pbVar5 = pbVar4 + 2;\n          bVar3 = bVar3 & 0x1f;\n          goto LAB_001057ed;\n        }\n        if (bVar3 != 0x3f) goto LAB_001058e1;\n        *pbVar6 = 0x7f;\n        lVar2 = lVar2 + 1;\n        pbVar6 = pbVar6 + 1;\n        goto LAB_00105765;\n      }\n      pbVar4 = pbVar4 + 1;\n      *pbVar6 = bVar3;\n      lVar2 = lVar2 + 1;\n      pbVar6 = pbVar6 + 1;\n      bVar3 = *pbVar4;\n      cVar1 = bVar3 + 0xa4;\n      bVar8 = cVar1 == '\\0';\n    }\n    bVar3 = pbVar4[1];\n    pbVar5 = pbVar4 + 2;\n    if (bVar3 == 0) {\nLAB_001058e1:\n      param_3 = 0;\n      pbVar4 = pbVar5;\nLAB_00105815:\n      *param_1 = pbVar6;\n      *param_2 = pbVar4;\n      *param_4 = lVar2;\n      return param_3;\n    }\n    bVar7 = bVar3 - 0x30;\n    switch(bVar7) {\n    case 0:\n    case 1:\n    case 2:\n    case 3:\n    case 4:\n    case 5:\n    case 6:\n    case 7:\n      for (; (byte)(*pbVar5 - 0x30) < 8; pbVar5 = pbVar5 + 1) {\n        bVar7 = (*pbVar5 - 0x30) + bVar7 * '\\b';\n      }\n      *pbVar6 = bVar7;\n      lVar2 = lVar2 + 1;\n      pbVar6 = pbVar6 + 1;\n      goto LAB_00105765;\n    case 0xf:\n      bVar3 = 0x7f;\n      break;\n    case 0x28:\n    case 0x48:\n      bVar3 = 0;\nLAB_00105845:\n      do {\n        bVar7 = *pbVar5;\n        while ((char)bVar7 < 'G') {\n          if ('@' < (char)bVar7) {\n            pbVar5 = pbVar5 + 1;\n            bVar3 = (bVar7 - 0x37) + bVar3 * '\\x10';\n            goto LAB_00105845;\n          }\n          if (9 < (byte)(bVar7 - 0x30)) goto LAB_001057ed;\n          pbVar5 = pbVar5 + 1;\n          bVar3 = (bVar7 - 0x30) + bVar3 * '\\x10';\n          bVar7 = *pbVar5;\n        }\n        if (5 < (byte)(bVar7 + 0x9f)) goto LAB_001057ed;\n        pbVar5 = pbVar5 + 1;\n        bVar3 = bVar7 + 0xa9 + bVar3 * '\\x10';\n      } while( true );\n    case 0x2f:\n      bVar3 = 0x20;\n      break;\n    case 0x31:\n      bVar3 = 7;\n      break;\n    case 0x32:\n      bVar3 = 8;\n      break;\n    case 0x35:\n      bVar3 = 0x1b;\n      break;\n    case 0x36:\n      bVar3 = 0xc;\n      break;\n    case 0x3e:\n      bVar3 = 10;\n      break;\n    case 0x42:\n      bVar3 = 0xd;\n      break;\n    case 0x44:\n      bVar3 = 9;\n      break;\n    case 0x46:\n      bVar3 = 0xb;\n    }\n    *pbVar6 = bVar3;\n    lVar2 = lVar2 + 1;\n    pbVar6 = pbVar6 + 1;\n  } while( true );\nLAB_001057ed:\n  *pbVar6 = bVar3;\n  lVar2 = lVar2 + 1;\n  pbVar6 = pbVar6 + 1;\n  goto LAB_00105765;\n}\n\n", 
    "00115d00": "\nvoid xalloc_die(void)\n\n{\n  undefined8 uVar1;\n  \n  uVar1 = dcgettext(0,\"memory exhausted\",5);\n  error(exit_failure,0,&DAT_0011beac,uVar1);\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "00105630": "\nchar * first_percent_b(char *param_1)\n\n{\n  char cVar1;\n  char cVar2;\n  \n  cVar1 = *param_1;\n  do {\n    if (cVar1 == '\\0') {\n      return (char *)0x0;\n    }\n    cVar2 = param_1[1];\n    if (cVar1 == '%') {\n      if (cVar2 == '%') {\n        cVar2 = param_1[2];\n        param_1 = param_1 + 1;\n      }\n      else if (cVar2 == 'b') {\n        return param_1;\n      }\n    }\n    param_1 = param_1 + 1;\n    cVar1 = cVar2;\n  } while( true );\n}\n\n", 
    "00106840": "\nvoid file_failure(undefined param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 uVar1;\n  int *piVar2;\n  \n  uVar1 = quotearg_style(4,param_3);\n  piVar2 = __errno_location();\n  error(0,*piVar2,param_2,uVar1);\n  set_exit_status(param_1);\n  return;\n}\n\n", 
    "00104780": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid abort(void)\n\n{\n  (*(code *)PTR_abort_00123c78)();\n  return;\n}\n\n", 
    "00114f70": "\nvoid quotearg_style(undefined4 param_1,undefined8 param_2)\n\n{\n  quotearg_n_style(0,param_1,param_2);\n  return;\n}\n\n", 
    "00126310": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid freecon(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n  halt_baddata();\n}\n\n", 
    "00107ac0": "\nvoid rev_strcmp_mtime(undefined8 param_1,undefined8 param_2)\n\n{\n  cmp_mtime(param_2,param_1,PTR_strcmp_00123fc8);\n  return;\n}\n\n", 
    "0010b0b0": "\nulong calculate_columns(char param_1)\n\n{\n  ulong *puVar1;\n  ulong uVar2;\n  ulong uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  ulong uVar6;\n  ulong uVar7;\n  ulong uVar8;\n  ulong uVar9;\n  char *pcVar10;\n  ulong uVar11;\n  \n  uVar11 = max_idx;\n  if (cwd_n_used <= max_idx) {\n    uVar11 = cwd_n_used;\n  }\n  uVar9 = 0;\n  init_column_info();\n  if (cwd_n_used != 0) {\n    do {\n      uVar4 = length_of_file_name_and_frills(*(undefined8 *)(sorted_file + uVar9 * 8));\n      uVar3 = cwd_n_used;\n      uVar2 = line_length;\n      if (uVar11 != 0) {\n        uVar6 = 0;\n        pcVar10 = column_info;\n        do {\n          uVar7 = uVar6 + 1;\n          if (*pcVar10 != '\\0') {\n            if (param_1 == '\\0') {\n              uVar8 = uVar9 % uVar7;\n            }\n            else {\n              uVar8 = SUB168(ZEXT816(uVar9) /\n                             (ZEXT816((uVar3 - 1) + uVar7) / ZEXT816(uVar7) &\n                             (undefined  [16])0xffffffffffffffff),0);\n            }\n            uVar5 = uVar4;\n            if (uVar8 != uVar6) {\n              uVar5 = uVar4 + 2;\n            }\n            puVar1 = (ulong *)(*(long *)(pcVar10 + 0x10) + uVar8 * 8);\n            uVar6 = *puVar1;\n            if (uVar6 < uVar5) {\n              *(ulong *)(pcVar10 + 8) = (*(long *)(pcVar10 + 8) - uVar6) + uVar5;\n              *puVar1 = uVar5;\n              *pcVar10 = *(ulong *)(pcVar10 + 8) < uVar2;\n            }\n          }\n          pcVar10 = pcVar10 + 0x18;\n          uVar6 = uVar7;\n        } while (uVar11 != uVar7);\n      }\n      uVar9 = uVar9 + 1;\n    } while (uVar9 < uVar3);\n  }\n  if (1 < uVar11) {\n    pcVar10 = column_info + uVar11 * 0x18 + -0x18;\n    do {\n      if (*pcVar10 != '\\0') {\n        return uVar11;\n      }\n      uVar11 = uVar11 - 1;\n      pcVar10 = pcVar10 + -0x18;\n    } while (uVar11 != 1);\n  }\n  return uVar11;\n}\n\n", 
    "00104e27": "\nvoid xstrtol_error_cold(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "0010b2f0": "\nvoid print_horizontal(void)\n\n{\n  long lVar1;\n  undefined8 uVar2;\n  ulong uVar3;\n  long lVar4;\n  ulong uVar5;\n  ulong uVar6;\n  long lVar7;\n  long lVar8;\n  long lVar9;\n  \n  uVar3 = calculate_columns(0);\n  lVar1 = column_info + -0x18 + uVar3 * 0x18;\n  uVar2 = *sorted_file;\n  lVar4 = length_of_file_name_and_frills(uVar2);\n  lVar7 = **(long **)(lVar1 + 0x10);\n  print_file_name_and_frills(uVar2,0);\n  if (1 < cwd_n_used) {\n    uVar6 = 1;\n    lVar9 = 0;\n    do {\n      uVar5 = uVar6 % uVar3;\n      if (uVar5 == 0) {\n        lVar8 = 0;\n        putchar_unlocked(10);\n      }\n      else {\n        lVar8 = lVar7 + lVar9;\n        indent(lVar9 + lVar4,lVar8);\n      }\n      uVar2 = sorted_file[uVar6];\n      uVar6 = uVar6 + 1;\n      print_file_name_and_frills(uVar2,lVar8);\n      lVar4 = length_of_file_name_and_frills(uVar2);\n      lVar7 = *(long *)(*(long *)(lVar1 + 0x10) + uVar5 * 8);\n      lVar9 = lVar8;\n    } while (uVar6 < cwd_n_used);\n  }\n  putchar_unlocked(10);\n  return;\n}\n\n", 
    "00104e22": "\nvoid version_etc_arn_cold(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "00104d00": "\nvoid __cxa_atexit(void)\n\n{\n  (*(code *)PTR___cxa_atexit_00123f38)();\n  return;\n}\n\n", 
    "00115420": "\nint timespec_cmp(long param_1,int param_2,long param_3,int param_4)\n\n{\n  int iVar1;\n  \n  if (param_3 <= param_1) {\n    iVar1 = 1;\n    if (param_1 <= param_3) {\n      iVar1 = param_2 - param_4;\n    }\n    return iVar1;\n  }\n  return -1;\n}\n\n", 
    "00117720": "\nint lstat(char *__file,stat *__buf)\n\n{\n  int iVar1;\n  \n  iVar1 = __lxstat(1,__file,__buf);\n  return iVar1;\n}\n\n", 
    "0010e190": "\nvoid * mfile_name_concat(void *param_1,char *param_2,void **param_3)\n\n{\n  size_t __n;\n  long lVar1;\n  long lVar2;\n  size_t __n_00;\n  void *__dest;\n  undefined *puVar3;\n  ulong uVar4;\n  undefined local_41;\n  \n  lVar1 = last_component();\n  lVar2 = base_len(lVar1);\n  __n = (lVar1 - (long)param_1) + lVar2;\n  __n_00 = strlen(param_2);\n  if (lVar2 == 0) {\n    local_41 = 0x2e;\n    if (*param_2 != '/') {\n      local_41 = 0;\n    }\n    uVar4 = (ulong)(*param_2 == '/');\n  }\n  else if (*(char *)((long)param_1 + (__n - 1)) == '/') {\n    local_41 = 0;\n    uVar4 = 0;\n  }\n  else {\n    local_41 = 0x2f;\n    if (*param_2 == '/') {\n      local_41 = 0;\n    }\n    uVar4 = (ulong)(*param_2 != '/');\n  }\n  __dest = malloc(__n + 1 + __n_00 + uVar4);\n  if (__dest != (void *)0x0) {\n    puVar3 = (undefined *)mempcpy(__dest,param_1,__n);\n    *puVar3 = local_41;\n    if (param_3 != (void **)0x0) {\n      *param_3 = puVar3 + uVar4;\n    }\n    puVar3 = (undefined *)mempcpy(puVar3 + uVar4,param_2,__n_00);\n    *puVar3 = 0;\n  }\n  return __dest;\n}\n\n", 
    "00113000": "\nint * quoting_options_from_style(int *param_1,int param_2)\n\n{\n  if (param_2 != 10) {\n    *param_1 = param_2;\n    param_1[1] = 0;\n    *(undefined8 *)(param_1 + 2) = 0;\n    *(undefined8 *)(param_1 + 4) = 0;\n    *(undefined8 *)(param_1 + 6) = 0;\n    *(undefined8 *)(param_1 + 8) = 0;\n    *(undefined8 *)(param_1 + 10) = 0;\n    *(undefined8 *)(param_1 + 0xc) = 0;\n    return param_1;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "0010ded0": "\nundefined8 file_has_acl(void)\n\n{\n  return 0;\n}\n\n", 
    "00104e0e": "\nvoid quoting_options_from_style_cold(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "00126308": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t wcstombs(char *__s,wchar_t *__pwcs,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* wcstombs@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00104970": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint snprintf(char *__s,size_t __maxlen,char *__format,...)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_snprintf_00123d70)();\n  return iVar1;\n}\n\n", 
    "00104730": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\n__int32_t ** __ctype_toupper_loc(void)\n\n{\n  __int32_t **pp_Var1;\n  \n  pp_Var1 = (__int32_t **)(*(code *)PTR___ctype_toupper_loc_00123c50)();\n  return pp_Var1;\n}\n\n", 
    "00104850": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nssize_t readlink(char *__path,char *__buf,size_t __len)\n\n{\n  ssize_t sVar1;\n  \n  sVar1 = (*(code *)PTR_readlink_00123ce0)();\n  return sVar1;\n}\n\n", 
    "00107dd0": "\nundefined8 rev_xstrcoll_df_ctime(long param_1,long param_2)\n\n{\n  char cVar1;\n  char cVar2;\n  long lVar3;\n  undefined8 uVar4;\n  \n  lVar3 = param_2;\n  cVar1 = is_directory_isra_0(*(undefined4 *)(param_1 + 0xa8));\n  cVar2 = is_directory_isra_0(*(undefined4 *)(param_2 + 0xa8));\n  if ((cVar2 == '\\x01') || (cVar1 == '\\0')) {\n    if ((cVar1 == '\\x01') || (uVar4 = 1, cVar2 == '\\0')) {\n      uVar4 = cmp_ctime(lVar3,param_1,xstrcoll);\n      return uVar4;\n    }\n  }\n  else {\n    uVar4 = 0xffffffff;\n  }\n  return uVar4;\n}\n\n", 
    "0010e8f0": "\nbool raw_comparator(long param_1,long param_2)\n\n{\n  return param_2 == param_1;\n}\n\n", 
    "001172f0": "\nuint rotr32(uint param_1,byte param_2)\n\n{\n  return param_1 >> (param_2 & 0x1f) | param_1 << 0x20 - (param_2 & 0x1f);\n}\n\n", 
    "0010b3e0": "\nvoid print_with_separator(char param_1)\n\n{\n  ulong uVar1;\n  undefined8 uVar2;\n  ulong uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  int __c;\n  \n  if (cwd_n_used == 0) {\n    putchar_unlocked(10);\n    return;\n  }\n  uVar4 = 0;\n  uVar5 = 0;\n  do {\n    uVar2 = *(undefined8 *)(sorted_file + uVar4 * 8);\n    if (line_length == 0) {\n      uVar3 = uVar5;\n      if (uVar4 != 0) {\n        uVar1 = uVar5 + 2;\nLAB_0010b490:\n        uVar3 = uVar1;\n        uVar5 = uVar5 + 2;\n        __c = 0x20;\n        goto LAB_0010b496;\n      }\n    }\n    else {\n      uVar3 = length_of_file_name_and_frills(uVar2);\n      if (uVar4 == 0) {\n        uVar3 = uVar5 + uVar3;\n      }\n      else {\n        uVar1 = uVar3 + uVar5 + 2;\n        if ((line_length == 0) || ((uVar1 < line_length && (uVar5 <= -uVar3 - 3))))\n        goto LAB_0010b490;\n        __c = 10;\n        uVar5 = 0;\nLAB_0010b496:\n        putchar_unlocked((int)param_1);\n        putchar_unlocked(__c);\n      }\n    }\n    uVar4 = uVar4 + 1;\n    print_file_name_and_frills(uVar2,uVar5);\n    uVar5 = uVar3;\n    if (cwd_n_used <= uVar4) {\n      putchar_unlocked(10);\n      return;\n    }\n  } while( true );\n}\n\n", 
    "0010e7d0": "\nbool hard_locale(int param_1)\n\n{\n  byte *pbVar1;\n  long lVar2;\n  byte *pbVar3;\n  bool bVar4;\n  bool bVar5;\n  byte bVar6;\n  \n  bVar6 = 0;\n  pbVar1 = (byte *)setlocale(param_1,(char *)0x0);\n  bVar4 = true;\n  if (pbVar1 != (byte *)0x0) {\n    bVar4 = *pbVar1 < 0x43;\n    bVar5 = *pbVar1 == 0x43;\n    if (bVar5) {\n      bVar4 = false;\n      bVar5 = pbVar1[1] == 0;\n      if (bVar5) {\n        return false;\n      }\n    }\n    lVar2 = 6;\n    pbVar3 = (byte *)\"POSIX\";\n    do {\n      if (lVar2 == 0) break;\n      lVar2 = lVar2 + -1;\n      bVar4 = *pbVar1 < *pbVar3;\n      bVar5 = *pbVar1 == *pbVar3;\n      pbVar1 = pbVar1 + (ulong)bVar6 * -2 + 1;\n      pbVar3 = pbVar3 + (ulong)bVar6 * -2 + 1;\n    } while (bVar5);\n    bVar4 = (!bVar4 && !bVar5) != bVar4;\n  }\n  return bVar4;\n}\n\n", 
    "001171d0": "\ntime_t mktime_z(long param_1,tm *param_2)\n\n{\n  char cVar1;\n  int iVar2;\n  long lVar3;\n  tm *ptVar4;\n  time_t tVar5;\n  long in_FS_OFFSET;\n  time_t local_70;\n  tm local_68;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_1 == 0) {\n    tVar5 = timegm(param_2);\n    goto LAB_00117242;\n  }\n  lVar3 = set_tz();\n  if (lVar3 != 0) {\n    local_70 = mktime(param_2);\n    if (local_70 == -1) {\n      ptVar4 = localtime_r(&local_70,&local_68);\n      if ((ptVar4 != (tm *)0x0) && (iVar2 = equal_tm(param_2,&local_68), iVar2 != 0))\n      goto LAB_00117222;\n    }\n    else {\nLAB_00117222:\n      cVar1 = save_abbr(param_1,param_2);\n      if (cVar1 == '\\0') {\n        local_70 = -1;\n      }\n    }\n    cVar1 = revert_tz(lVar3);\n    tVar5 = local_70;\n    if (cVar1 != '\\0') goto LAB_00117242;\n  }\n  tVar5 = -1;\nLAB_00117242:\n  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return tVar5;\n}\n\n", 
    "0010d4a0": "\nulong c_ispunct(int param_1)\n\n{\n  ulong in_RAX;\n  \n  if (0x60 < param_1) {\n    return in_RAX & 0xffffffffffffff00 | (ulong)(param_1 - 0x7bU < 4);\n  }\n  if (param_1 < 0x5b) {\n    if (param_1 < 0x30) {\n      return in_RAX & 0xffffffffffffff00 | (ulong)(0x20 < param_1);\n    }\n    return in_RAX & 0xffffffffffffff00 | (ulong)(param_1 - 0x3aU < 7);\n  }\n  return 1;\n}\n\n", 
    "0010e160": "\nvoid filemodestring(long param_1)\n\n{\n  strmode(*(undefined4 *)(param_1 + 0x18));\n  return;\n}\n\n", 
    "0010e040": "\nvoid strmode(uint param_1,undefined *param_2)\n\n{\n  byte bVar1;\n  undefined uVar2;\n  char cVar3;\n  ulong uVar4;\n  \n  uVar4 = (ulong)param_1;\n  uVar2 = ftypelet();\n  *param_2 = uVar2;\n  param_2[1] = (-((uVar4 & 0x100) == 0) & 0xbbU) + 0x72;\n  param_2[2] = (-((uVar4 & 0x80) == 0) & 0xb6U) + 0x77;\n  bVar1 = -((uVar4 & 0x40) == 0);\n  if ((uVar4 & 0x800) == 0) {\n    cVar3 = (bVar1 & 0xb5) + 0x78;\n  }\n  else {\n    cVar3 = (bVar1 & 0xe0) + 0x73;\n  }\n  param_2[3] = cVar3;\n  param_2[4] = (-((uVar4 & 0x20) == 0) & 0xbbU) + 0x72;\n  param_2[5] = (-((uVar4 & 0x10) == 0) & 0xb6U) + 0x77;\n  bVar1 = -((uVar4 & 8) == 0);\n  if ((uVar4 & 0x400) == 0) {\n    cVar3 = (bVar1 & 0xb5) + 0x78;\n  }\n  else {\n    cVar3 = (bVar1 & 0xe0) + 0x73;\n  }\n  param_2[6] = cVar3;\n  param_2[7] = (-((uVar4 & 4) == 0) & 0xbbU) + 0x72;\n  param_2[8] = (-((uVar4 & 2) == 0) & 0xb6U) + 0x77;\n  bVar1 = -((uVar4 & 1) == 0);\n  if ((uVar4 & 0x200) != 0) {\n    param_2[9] = (bVar1 & 0xe0) + 0x74;\n    *(undefined2 *)(param_2 + 10) = 0x20;\n    return;\n  }\n  param_2[9] = (bVar1 & 0xb5) + 0x78;\n  *(undefined2 *)(param_2 + 10) = 0x20;\n  return;\n}\n\n", 
    "0010f250": "\nvoid hash_clear(long **param_1)\n\n{\n  long *plVar1;\n  long *plVar2;\n  long *plVar3;\n  long *plVar4;\n  long *plVar5;\n  \n  plVar5 = *param_1;\n  if (*param_1 < param_1[1]) {\n    do {\n      while (*plVar5 != 0) {\n        plVar4 = param_1[8];\n        plVar3 = (long *)plVar5[1];\n        while (plVar3 != (long *)0x0) {\n          if (plVar4 != (long *)0x0) {\n            (*(code *)plVar4)(*plVar3);\n            plVar4 = param_1[8];\n          }\n          plVar1 = (long *)plVar3[1];\n          plVar2 = param_1[9];\n          *plVar3 = 0;\n          plVar3[1] = (long)plVar2;\n          param_1[9] = plVar3;\n          plVar3 = plVar1;\n        }\n        if (plVar4 != (long *)0x0) {\n          (*(code *)plVar4)(*plVar5);\n        }\n        *plVar5 = 0;\n        plVar4 = plVar5 + 2;\n        plVar5[1] = 0;\n        plVar5 = plVar4;\n        if (param_1[1] < plVar4 || param_1[1] == plVar4) goto LAB_0010f2eb;\n      }\n      plVar5 = plVar5 + 2;\n    } while (plVar5 <= param_1[1] && param_1[1] != plVar5);\n  }\nLAB_0010f2eb:\n  param_1[3] = (long *)0x0;\n  param_1[4] = (long *)0x0;\n  return;\n}\n\n", 
    "00108db0": "\nbool print_color_indicator(long param_1)\n\n{\n  char cVar1;\n  \n  if (param_1 != 0) {\n    cVar1 = is_colored(4);\n    if (cVar1 != '\\0') {\n      restore_default_color();\n    }\n    put_indicator_isra_0(color_indicator);\n    put_indicator_isra_0(param_1,param_1 + 8);\n    put_indicator_isra_0(0x124070);\n  }\n  return param_1 != 0;\n}\n\n", 
    "0010dea0": "\nvoid base_len(char *param_1)\n\n{\n  long lVar1;\n  ulong uVar2;\n  \n  uVar2 = strlen(param_1);\n  do {\n    if (uVar2 < 2) {\n      return;\n    }\n    lVar1 = uVar2 - 1;\n    uVar2 = uVar2 - 1;\n  } while (param_1[lVar1] == '/');\n  return;\n}\n\n", 
    "00104720": "\nvoid __cxa_finalize(void)\n\n{\n  (*(code *)PTR___cxa_finalize_00123fe8)();\n  return;\n}\n\n", 
    "0010bba0": "\nvoid usage(int param_1)\n\n{\n  FILE *pFVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  char *pcVar4;\n  \n  uVar2 = program_name;\n  if (param_1 == 0) {\n    uVar3 = dcgettext(0,\"Usage: %s [OPTION]... [FILE]...\\n\",5);\n    __printf_chk(1,uVar3,uVar2);\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\n                               \"List information about the FILEs (the current directory by default).\\nSort entries alphabetically if none of -cftuvSUX nor --sort is specified.\\n\"\n                               ,5);\n    fputs_unlocked(pcVar4,pFVar1);\n    emit_mandatory_arg_note();\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\n                               \"  -a, --all                  do not ignore entries starting with .\\n  -A, --almost-all           do not list implied . and ..\\n      --author               with -l, print the author of each file\\n  -b, --escape               print C-style escapes for nongraphic characters\\n\"\n                               ,5);\n    fputs_unlocked(pcVar4,pFVar1);\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\n                               \"      --block-size=SIZE      with -l, scale sizes by SIZE when printing them;\\n                               e.g., \\'--block-size=M\\'; see SIZE format below\\n\"\n                               ,5);\n    fputs_unlocked(pcVar4,pFVar1);\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\n                               \"  -B, --ignore-backups       do not list implied entries ending with ~\\n  -c                         with -lt: sort by, and show, ctime (time of last\\n                               modification of file status information);\\n                               with -l: show ctime and sort by name;\\n                               otherwise: sort by ctime, newest first\\n\"\n                               ,5);\n    fputs_unlocked(pcVar4,pFVar1);\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\n                               \"  -C                         list entries by columns\\n      --color[=WHEN]         colorize the output; WHEN can be \\'always\\' (default\\n                               if omitted), \\'auto\\', or \\'never\\'; more info below\\n  -d, --directory            list directories themselves, not their contents\\n  -D, --dired                generate output designed for Emacs\\' dired mode\\n\"\n                               ,5);\n    fputs_unlocked(pcVar4,pFVar1);\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\n                               \"  -f                         do not sort, enable -aU, disable -ls --color\\n  -F, --classify             append indicator (one of */=>@|) to entries\\n      --file-type            likewise, except do not append \\'*\\'\\n      --format=WORD          across -x, commas -m, horizontal -x, long -l,\\n                               single-column -1, verbose -l, vertical -C\\n      --full-time            like -l --time-style=full-iso\\n\"\n                               ,5);\n    fputs_unlocked(pcVar4,pFVar1);\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\"  -g                         like -l, but do not list owner\\n\",5);\n    fputs_unlocked(pcVar4,pFVar1);\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\n                               \"      --group-directories-first\\n                             group directories before files;\\n                               can be augmented with a --sort option, but any\\n                               use of --sort=none (-U) disables grouping\\n\"\n                               ,5);\n    fputs_unlocked(pcVar4,pFVar1);\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\n                               \"  -G, --no-group             in a long listing, don\\'t print group names\\n\"\n                               ,5);\n    fputs_unlocked(pcVar4,pFVar1);\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\n                               \"  -h, --human-readable       with -l and -s, print sizes like 1K 234M 2G etc.\\n      --si                   likewise, but use powers of 1000 not 1024\\n\"\n                               ,5);\n    fputs_unlocked(pcVar4,pFVar1);\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\n                               \"  -H, --dereference-command-line\\n                             follow symbolic links listed on the command line\\n      --dereference-command-line-symlink-to-dir\\n                             follow each command line symbolic link\\n                               that points to a directory\\n      --hide=PATTERN         do not list implied entries matching shell PATTERN\\n                               (overridden by -a or -A)\\n\"\n                               ,5);\n    fputs_unlocked(pcVar4,pFVar1);\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\n                               \"      --hyperlink[=WHEN]     hyperlink file names; WHEN can be \\'always\\'\\n                               (default if omitted), \\'auto\\', or \\'never\\'\\n\"\n                               ,5);\n    fputs_unlocked(pcVar4,pFVar1);\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\n                               \"      --indicator-style=WORD  append indicator with style WORD to entry names:\\n                               none (default), slash (-p),\\n                               file-type (--file-type), classify (-F)\\n  -i, --inode                print the index number of each file\\n  -I, --ignore=PATTERN       do not list implied entries matching shell PATTERN\\n\"\n                               ,5);\n    fputs_unlocked(pcVar4,pFVar1);\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\n                               \"  -k, --kibibytes            default to 1024-byte blocks for disk usage;\\n                               used only with -s and per directory totals\\n\"\n                               ,5);\n    fputs_unlocked(pcVar4,pFVar1);\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\n                               \"  -l                         use a long listing format\\n  -L, --dereference          when showing file information for a symbolic\\n                               link, show information for the file the link\\n                               references rather than for the link itself\\n  -m                         fill width with a comma separated list of entries\\n\"\n                               ,5);\n    fputs_unlocked(pcVar4,pFVar1);\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\n                               \"  -n, --numeric-uid-gid      like -l, but list numeric user and group IDs\\n  -N, --literal              print entry names without quoting\\n  -o                         like -l, but do not list group information\\n  -p, --indicator-style=slash\\n                             append / indicator to directories\\n\"\n                               ,5);\n    fputs_unlocked(pcVar4,pFVar1);\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\n                               \"  -q, --hide-control-chars   print ? instead of nongraphic characters\\n      --show-control-chars   show nongraphic characters as-is (the default,\\n                               unless program is \\'ls\\' and output is a terminal)\\n  -Q, --quote-name           enclose entry names in double quotes\\n      --quoting-style=WORD   use quoting style WORD for entry names:\\n                               literal, locale, shell, shell-always,\\n                               shell-escape, shell-escape-always, c, escape\\n                               (overrides QUOTING_STYLE environment variable)\\n\"\n                               ,5);\n    fputs_unlocked(pcVar4,pFVar1);\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\n                               \"  -r, --reverse              reverse order while sorting\\n  -R, --recursive            list subdirectories recursively\\n  -s, --size                 print the allocated size of each file, in blocks\\n\"\n                               ,5);\n    fputs_unlocked(pcVar4,pFVar1);\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\n                               \"  -S                         sort by file size, largest first\\n      --sort=WORD            sort by WORD instead of name: none (-U), size (-S),\\n                               time (-t), version (-v), extension (-X)\\n      --time=WORD            with -l, show time as WORD instead of default\\n                               modification time: atime or access or use (-u);\\n                               ctime or status (-c); also use specified time\\n                               as sort key if --sort=time (newest first)\\n\"\n                               ,5);\n    fputs_unlocked(pcVar4,pFVar1);\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\n                               \"      --time-style=TIME_STYLE  time/date format with -l; see TIME_STYLE below\\n\"\n                               ,5);\n    fputs_unlocked(pcVar4,pFVar1);\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\n                               \"  -t                         sort by modification time, newest first\\n  -T, --tabsize=COLS         assume tab stops at each COLS instead of 8\\n\"\n                               ,5);\n    fputs_unlocked(pcVar4,pFVar1);\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\n                               \"  -u                         with -lt: sort by, and show, access time;\\n                               with -l: show access time and sort by name;\\n                               otherwise: sort by access time, newest first\\n  -U                         do not sort; list entries in directory order\\n  -v                         natural sort of (version) numbers within text\\n\"\n                               ,5);\n    fputs_unlocked(pcVar4,pFVar1);\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\n                               \"  -w, --width=COLS           set output width to COLS.  0 means no limit\\n  -x                         list entries by lines instead of by columns\\n  -X                         sort alphabetically by entry extension\\n  -Z, --context              print any security context of each file\\n  -1                         list one file per line.  Avoid \\'\\\\n\\' with -q or -b\\n\"\n                               ,5);\n    fputs_unlocked(pcVar4,pFVar1);\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\"      --help     display this help and exit\\n\",5);\n    fputs_unlocked(pcVar4,pFVar1);\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\"      --version  output version information and exit\\n\",5);\n    fputs_unlocked(pcVar4,pFVar1);\n    emit_size_note();\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\n                               \"\\nThe TIME_STYLE argument can be full-iso, long-iso, iso, locale, or +FORMAT.\\nFORMAT is interpreted like in date(1).  If FORMAT is FORMAT1<newline>FORMAT2,\\nthen FORMAT1 applies to non-recent files and FORMAT2 to recent files.\\nTIME_STYLE prefixed with \\'posix-\\' takes effect only outside the POSIX locale.\\nAlso the TIME_STYLE environment variable sets the default style to use.\\n\"\n                               ,5);\n    fputs_unlocked(pcVar4,pFVar1);\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\n                               \"\\nUsing color to distinguish file types is disabled both by default and\\nwith --color=never.  With --color=auto, ls emits color codes only when\\nstandard output is connected to a terminal.  The LS_COLORS environment\\nvariable can change the settings.  Use the dircolors command to set it.\\n\"\n                               ,5);\n    fputs_unlocked(pcVar4,pFVar1);\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\n                               \"\\nExit status:\\n 0  if OK,\\n 1  if minor problems (e.g., cannot access subdirectory),\\n 2  if serious trouble (e.g., cannot access command-line argument).\\n\"\n                               ,5);\n    fputs_unlocked(pcVar4,pFVar1);\n    pcVar4 = \"ls\";\n    if ((ls_mode != 1) && (pcVar4 = \"dir\", ls_mode != 2)) {\n      pcVar4 = \"vdir\";\n    }\n    emit_ancillary_info(pcVar4);\n  }\n  else {\n    uVar3 = dcgettext(0,\"Try \\'%s --help\\' for more information.\\n\",5);\n    __fprintf_chk(stderr,1,uVar3,uVar2);\n  }\n                    /* WARNING: Subroutine does not return */\n  exit(param_1);\n}\n\n", 
    "0010eb80": "\nundefined8 transfer_entries(long param_1,long **param_2,char param_3)\n\n{\n  long lVar1;\n  long *plVar2;\n  long *plVar3;\n  long *plVar4;\n  long *plVar5;\n  long lVar6;\n  \n  plVar5 = *param_2;\n  if (param_2[1] <= plVar5) {\n    return 1;\n  }\n  do {\n    while (lVar6 = *plVar5, lVar6 == 0) {\nLAB_0010ebb0:\n      plVar5 = plVar5 + 2;\n      if (param_2[1] < plVar5 || param_2[1] == plVar5) {\n        return 1;\n      }\n    }\n    plVar3 = (long *)plVar5[1];\n    if ((long *)plVar5[1] != (long *)0x0) {\n      do {\n        while( true ) {\n          lVar6 = *plVar3;\n          plVar2 = (long *)safe_hasher(param_1,lVar6);\n          plVar4 = (long *)plVar3[1];\n          if (*plVar2 != 0) break;\n          *plVar2 = lVar6;\n          *(long *)(param_1 + 0x18) = *(long *)(param_1 + 0x18) + 1;\n          free_entry_isra_0(param_1 + 0x48);\n          plVar3 = plVar4;\n          if (plVar4 == (long *)0x0) goto LAB_0010ec20;\n        }\n        plVar3[1] = plVar2[1];\n        plVar2[1] = (long)plVar3;\n        plVar3 = plVar4;\n      } while (plVar4 != (long *)0x0);\nLAB_0010ec20:\n      lVar6 = *plVar5;\n    }\n    plVar5[1] = 0;\n    if (param_3 != '\\0') goto LAB_0010ebb0;\n    plVar3 = (long *)safe_hasher(param_1,lVar6);\n    if (*plVar3 == 0) {\n      *plVar3 = lVar6;\n      *(long *)(param_1 + 0x18) = *(long *)(param_1 + 0x18) + 1;\n    }\n    else {\n      plVar4 = (long *)allocate_entry_isra_0(param_1 + 0x48);\n      if (plVar4 == (long *)0x0) {\n        return 0;\n      }\n      lVar1 = plVar3[1];\n      *plVar4 = lVar6;\n      plVar4[1] = lVar1;\n      plVar3[1] = (long)plVar4;\n    }\n    *plVar5 = 0;\n    plVar5 = plVar5 + 2;\n    param_2[3] = (long *)((long)param_2[3] + -1);\n    if (param_2[1] < plVar5 || param_2[1] == plVar5) {\n      return 1;\n    }\n  } while( true );\n}\n\n", 
    "0010ea60": "\nlong hash_find_entry(long param_1,long param_2,long **param_3,char param_4)\n\n{\n  long *plVar1;\n  long lVar2;\n  char cVar3;\n  long *plVar4;\n  long lVar5;\n  \n  plVar4 = (long *)safe_hasher();\n  *param_3 = plVar4;\n  lVar5 = *plVar4;\n  if (lVar5 == 0) {\nLAB_0010eb01:\n    lVar5 = 0;\n  }\n  else {\n    if (lVar5 != param_2) {\n      cVar3 = (**(code **)(param_1 + 0x38))(param_2);\n      if (cVar3 == '\\0') {\n        for (; (long *)plVar4[1] != (long *)0x0; plVar4 = (long *)plVar4[1]) {\n          if ((*(long *)plVar4[1] == param_2) ||\n             (cVar3 = (**(code **)(param_1 + 0x38))(param_2), cVar3 != '\\0')) {\n            lVar5 = *(long *)plVar4[1];\n            if (param_4 == '\\0') {\n              return lVar5;\n            }\n            plVar4[1] = ((long *)plVar4[1])[1];\n            free_entry_isra_0(param_1 + 0x48);\n            return lVar5;\n          }\n        }\n        goto LAB_0010eb01;\n      }\n      lVar5 = *plVar4;\n    }\n    if (param_4 != '\\0') {\n      plVar1 = (long *)plVar4[1];\n      if (plVar1 != (long *)0x0) {\n        lVar2 = plVar1[1];\n        *plVar4 = *plVar1;\n        plVar4[1] = lVar2;\n        free_entry_isra_0(param_1 + 0x48);\n        return lVar5;\n      }\n      *plVar4 = 0;\n    }\n  }\n  return lVar5;\n}\n\n", 
    "00104840": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t mbstowcs(wchar_t *__pwcs,char *__s,size_t __n)\n\n{\n  size_t sVar1;\n  \n  sVar1 = (*(code *)PTR_mbstowcs_00123cd8)();\n  return sVar1;\n}\n\n", 
    "00104960": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint __fxstatat(int __ver,int __fildes,char *__filename,stat *__stat_buf,int __flag)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR___fxstatat_00123d68)();\n  return iVar1;\n}\n\n", 
    "00104af0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * memcpy(void *__dest,void *__src,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = (void *)(*(code *)PTR_memcpy_00123e30)();\n  return pvVar1;\n}\n\n", 
    "00106df0": "\nvoid xstrcoll(char *param_1,char *param_2)\n\n{\n  int *piVar1;\n  \n  piVar1 = __errno_location();\n  *piVar1 = 0;\n  strcoll(param_1,param_2);\n  return;\n}\n\n", 
    "0010e170": "\nvoid file_name_concat(void)\n\n{\n  long lVar1;\n  \n  lVar1 = mfile_name_concat();\n  if (lVar1 != 0) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  xalloc_die();\n}\n\n", 
    "00111040": "\nint mbsnwidth(byte *param_1,long param_2,uint param_3)\n\n{\n  byte *pbVar1;\n  byte bVar2;\n  int iVar3;\n  size_t sVar4;\n  long lVar5;\n  ushort **ppuVar6;\n  long lVar7;\n  int iVar8;\n  long in_FS_OFFSET;\n  wchar_t local_4c;\n  mbstate_t local_48;\n  long local_40;\n  \n  pbVar1 = param_1 + param_2;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  sVar4 = __ctype_get_mb_cur_max();\n  if (sVar4 < 2) {\n    iVar8 = 0;\n    if (param_1 < pbVar1) {\n      ppuVar6 = __ctype_b_loc();\n      iVar8 = 0;\n      do {\n        bVar2 = *param_1;\n        param_1 = param_1 + 1;\n        if (((*ppuVar6)[bVar2] & 0x4000) == 0) {\n          if ((param_3 & 2) != 0) goto LAB_00111220;\n          if (((*ppuVar6)[bVar2] & 2) == 0) goto LAB_001111f9;\n        }\n        else {\nLAB_001111f9:\n          if (iVar8 == 0x7fffffff) break;\n          iVar8 = iVar8 + 1;\n        }\n      } while (pbVar1 != param_1);\n    }\n  }\n  else {\n    iVar8 = 0;\n    if (param_1 < pbVar1) {\n      do {\n        bVar2 = *param_1;\n        if ((char)bVar2 < '`') {\n          if ('@' < (char)bVar2) goto LAB_00111173;\n          if ('#' < (char)bVar2) {\n            if (0x1a < (byte)(bVar2 - 0x25)) goto LAB_001110bc;\n            goto LAB_00111173;\n          }\n          if ('\\x1f' < (char)bVar2) goto LAB_00111173;\nLAB_001110bc:\n          local_48 = (mbstate_t)0x0;\n          do {\n            lVar5 = rpl_mbrtowc(&local_4c,param_1,(long)pbVar1 - (long)param_1,&local_48);\n            if (lVar5 == -1) {\n              if ((param_3 & 1) != 0) goto LAB_00111220;\n              goto LAB_00111173;\n            }\n            if (lVar5 == -2) {\n              if ((param_3 & 1) != 0) goto LAB_00111220;\n              iVar8 = iVar8 + 1;\n              param_1 = pbVar1;\n              break;\n            }\n            lVar7 = 1;\n            if (lVar5 != 0) {\n              lVar7 = lVar5;\n            }\n            iVar3 = wcwidth(local_4c);\n            if (iVar3 < 0) {\n              if ((param_3 & 2) != 0) goto LAB_00111220;\n              iVar3 = iswcntrl(local_4c);\n              if (iVar3 == 0) {\n                if (iVar8 == 0x7fffffff) goto LAB_00111248;\n                iVar8 = iVar8 + 1;\n              }\n            }\n            else {\n              if (0x7fffffff - iVar8 < iVar3) {\nLAB_00111248:\n                iVar8 = 0x7fffffff;\n                goto LAB_00111188;\n              }\n              iVar8 = iVar8 + iVar3;\n            }\n            param_1 = param_1 + lVar7;\n            iVar3 = mbsinit(&local_48);\n          } while (iVar3 == 0);\n        }\n        else {\n          if (0x1d < (byte)(bVar2 + 0x9f)) goto LAB_001110bc;\nLAB_00111173:\n          param_1 = param_1 + 1;\n          iVar8 = iVar8 + 1;\n        }\n      } while (param_1 < pbVar1);\n    }\n  }\nLAB_00111188:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return iVar8;\nLAB_00111220:\n  iVar8 = -1;\n  goto LAB_00111188;\n}\n\n", 
    "0010f140": "\nvoid ** hash_initialize(undefined8 param_1,undefined1 *param_2,code *param_3,code *param_4,\n                       void *param_5)\n\n{\n  char cVar1;\n  void **__ptr;\n  void *__nmemb;\n  void *pvVar2;\n  void **ppvVar3;\n  \n  if (param_3 == (code *)0x0) {\n    param_3 = raw_hasher;\n  }\n  if (param_4 == (code *)0x0) {\n    param_4 = raw_comparator;\n  }\n  __ptr = (void **)malloc(0x50);\n  ppvVar3 = __ptr;\n  if (__ptr != (void **)0x0) {\n    if (param_2 == (undefined1 *)0x0) {\n      param_2 = default_tuning;\n    }\n    __ptr[5] = param_2;\n    cVar1 = check_tuning_isra_0(__ptr + 5);\n    if (cVar1 != '\\0') {\n      __nmemb = (void *)compute_bucket_size_isra_0\n                                  (*(undefined4 *)(param_2 + 8),param_1,param_2[0x10]);\n      __ptr[2] = __nmemb;\n      if (__nmemb != (void *)0x0) {\n        pvVar2 = calloc((size_t)__nmemb,0x10);\n        *__ptr = pvVar2;\n        if (pvVar2 != (void *)0x0) {\n          __ptr[6] = param_3;\n          __ptr[7] = param_4;\n          __ptr[1] = (void *)((long)__nmemb * 0x10 + (long)pvVar2);\n          __ptr[3] = (void *)0x0;\n          __ptr[4] = (void *)0x0;\n          __ptr[8] = param_5;\n          __ptr[9] = (void *)0x0;\n          return __ptr;\n        }\n      }\n    }\n    ppvVar3 = (void **)0x0;\n    free(__ptr);\n  }\n  return ppvVar3;\n}\n\n", 
    "001084a0": "\nvoid xstrcoll_name(undefined8 *param_1,undefined8 *param_2)\n\n{\n  cmp_name_isra_0(*param_1,*param_2,xstrcoll);\n  return;\n}\n\n", 
    "001086e0": "\nundefined8 has_capability_isra_0(void)\n\n{\n  int *piVar1;\n  \n  piVar1 = __errno_location();\n  *piVar1 = 0x5f;\n  return 0;\n}\n\n", 
    "0010e290": "\nchar * match_suffix(char **param_1)\n\n{\n  byte bVar1;\n  byte bVar2;\n  char *pcVar3;\n  char cVar4;\n  char *pcVar5;\n  \n  pcVar3 = *param_1;\n  cVar4 = *pcVar3;\n  if (cVar4 == '\\0') {\n    return (char *)0x0;\n  }\n  bVar1 = 0;\n  pcVar5 = (char *)0x0;\n  do {\n    while (bVar1 != 0) {\n      bVar1 = c_isalpha((int)cVar4);\n      bVar1 = cVar4 != '~' & (bVar1 ^ 1);\n      if (bVar1 != 0) {\n        bVar1 = 0;\n        pcVar5 = (char *)0x0;\n      }\nLAB_0010e2d9:\n      pcVar3 = pcVar3 + 1;\n      *param_1 = pcVar3;\n      cVar4 = *pcVar3;\n      if (cVar4 == '\\0') {\n        return pcVar5;\n      }\n    }\n    if (cVar4 == '.') {\n      bVar1 = 1;\n      if (pcVar5 == (char *)0x0) {\n        pcVar5 = pcVar3;\n      }\n      goto LAB_0010e2d9;\n    }\n    bVar2 = c_isalnum((int)cVar4);\n    if ((cVar4 != '~' & (bVar2 ^ 1)) != 0) {\n      pcVar5 = (char *)0x0;\n    }\n    pcVar3 = pcVar3 + 1;\n    *param_1 = pcVar3;\n    cVar4 = *pcVar3;\n    if (cVar4 == '\\0') {\n      return pcVar5;\n    }\n  } while( true );\n}\n\n", 
    "00108ca0": "\nvoid restore_default_color(void)\n\n{\n  put_indicator_isra_0(color_indicator);\n  put_indicator_isra_0(0x124070);\n  return;\n}\n\n", 
    "0010dfd0": "\nundefined8 ftypelet(uint param_1)\n\n{\n  undefined8 uVar1;\n  \n  param_1 = param_1 & 0xf000;\n  uVar1 = 0x2d;\n  if ((((param_1 != 0x8000) && (uVar1 = 100, param_1 != 0x4000)) &&\n      (uVar1 = 0x62, param_1 != 0x6000)) &&\n     (((uVar1 = 99, param_1 != 0x2000 && (uVar1 = 0x6c, param_1 != 0xa000)) &&\n      ((uVar1 = 0x70, param_1 != 0x1000 && (uVar1 = 0x3f, param_1 == 0xc000)))))) {\n    uVar1 = 0x73;\n  }\n  return uVar1;\n}\n\n", 
    "001107f0": "\n__uid_t * getuidbyname(char *param_1)\n\n{\n  char cVar1;\n  __uid_t *p_Var2;\n  int iVar3;\n  passwd *ppVar4;\n  size_t sVar5;\n  __uid_t *p_Var6;\n  long lVar7;\n  \n  if (user_alist != (__uid_t *)0x0) {\n    cVar1 = *param_1;\n    p_Var6 = user_alist;\n    do {\n      if ((*(char *)(p_Var6 + 4) == cVar1) &&\n         (iVar3 = strcmp((char *)(p_Var6 + 4),param_1), iVar3 == 0)) {\n        return p_Var6;\n      }\n      p_Var6 = *(__uid_t **)(p_Var6 + 2);\n    } while (p_Var6 != (__uid_t *)0x0);\n  }\n  if (nouser_alist != (__uid_t *)0x0) {\n    cVar1 = *param_1;\n    lVar7 = (long)nouser_alist;\n    do {\n      if ((*(char *)(lVar7 + 0x10) == cVar1) &&\n         (iVar3 = strcmp((char *)(lVar7 + 0x10),param_1), iVar3 == 0)) {\n        return (__uid_t *)0x0;\n      }\n      lVar7 = *(long *)(lVar7 + 8);\n    } while (lVar7 != 0);\n  }\n  ppVar4 = getpwnam(param_1);\n  sVar5 = strlen(param_1);\n  p_Var6 = (__uid_t *)xmalloc(sVar5 + 0x18 & 0xfffffffffffffff8);\n  strcpy((char *)(p_Var6 + 4),param_1);\n  if (ppVar4 != (passwd *)0x0) {\n    *p_Var6 = ppVar4->pw_uid;\n    p_Var2 = p_Var6;\n    *(__uid_t **)(p_Var6 + 2) = user_alist;\n    user_alist = p_Var2;\n    return p_Var6;\n  }\n  *(__uid_t **)(p_Var6 + 2) = nouser_alist;\n  nouser_alist = p_Var6;\n  return (__uid_t *)0x0;\n}\n\n", 
    "00104710": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * malloc(size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = (void *)(*(code *)PTR_malloc_00123fd8)();\n  return pvVar1;\n}\n\n", 
    "00104830": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nlconv * localeconv(void)\n\n{\n  lconv *plVar1;\n  \n  plVar1 = (lconv *)(*(code *)PTR_localeconv_00123cd0)();\n  return plVar1;\n}\n\n", 
    "00104750": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint sigprocmask(int __how,sigset_t *__set,sigset_t *__oset)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_sigprocmask_00123c60)();\n  return iVar1;\n}\n\n", 
    "00104870": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint setenv(char *__name,char *__value,int __replace)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_setenv_00123cf0)();\n  return iVar1;\n}\n\n", 
    "00104990": "\nvoid fgetfilecon(void)\n\n{\n  (*(code *)PTR_fgetfilecon_00123d80)();\n  return;\n}\n\n", 
    "0010e8d0": "\nulong raw_hasher(undefined8 param_1,ulong param_2)\n\n{\n  ulong uVar1;\n  \n  uVar1 = rotr_sz(param_1,3);\n  return uVar1 % param_2;\n}\n\n", 
    "001172d0": "\nulong rotr64(ulong param_1,byte param_2)\n\n{\n  return param_1 >> (param_2 & 0x3f) | param_1 << 0x40 - (param_2 & 0x3f);\n}\n\n", 
    "00116930": "\nsize_t rpl_mbrtowc(wchar_t *param_1,byte *param_2,size_t param_3,mbstate_t *param_4)\n\n{\n  char cVar1;\n  size_t sVar2;\n  long in_FS_OFFSET;\n  wchar_t local_34;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_1 == (wchar_t *)0x0) {\n    param_1 = &local_34;\n  }\n  sVar2 = mbrtowc(param_1,(char *)param_2,param_3,param_4);\n  if ((0xfffffffffffffffd < sVar2) && (param_3 != 0)) {\n    cVar1 = hard_locale(0);\n    if (cVar1 == '\\0') {\n      sVar2 = 1;\n      *param_1 = (uint)*param_2;\n    }\n  }\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return sVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00111370": "\nvoid mpsort_with_tmp(undefined8 *param_1,ulong param_2,undefined8 *param_3,code *param_4)\n\n{\n  int iVar1;\n  ulong uVar2;\n  ulong uVar3;\n  undefined8 uVar4;\n  undefined8 uVar5;\n  ulong uVar6;\n  long lVar7;\n  long lVar8;\n  \n  if (param_2 < 3) {\n    if (param_2 == 2) {\n      uVar4 = param_1[1];\n      uVar5 = *param_1;\n      iVar1 = (*param_4)(uVar5,uVar4);\n      if (0 < iVar1) {\n        *param_1 = uVar4;\n        param_1[1] = uVar5;\n        return;\n      }\n    }\n  }\n  else {\n    uVar2 = param_2 >> 1;\n    mpsort_with_tmp(param_1 + uVar2,param_2 - uVar2,param_3,param_4);\n    if (param_2 == 3) {\n      uVar4 = *param_1;\n      *param_3 = uVar4;\n    }\n    else {\n      mpsort_into_tmp(param_1,uVar2,param_3,param_4);\n      uVar4 = *param_3;\n    }\n    uVar5 = param_1[uVar2];\n    uVar3 = 0;\n    uVar6 = uVar2;\n    lVar7 = 0;\n    while( true ) {\n      while( true ) {\n        lVar8 = lVar7 + 1;\n        iVar1 = (*param_4)(uVar4,uVar5);\n        if (iVar1 < 1) break;\n        param_1[lVar7] = uVar5;\n        uVar6 = uVar6 + 1;\n        if (param_2 == uVar6) {\n          memcpy(param_1 + lVar8,param_3 + uVar3,(uVar2 - uVar3) * 8);\n          return;\n        }\n        uVar5 = param_1[uVar6];\n        lVar7 = lVar8;\n      }\n      param_1[lVar7] = uVar4;\n      uVar3 = uVar3 + 1;\n      if (uVar2 == uVar3) break;\n      uVar4 = param_3[uVar3];\n      lVar7 = lVar8;\n    }\n  }\n  return;\n}\n\n", 
    "001073e0": "\nvoid signal_init(void)\n\n{\n  signal_setup(1);\n  return;\n}\n\n", 
    "0010f110": "\nvoid hash_reset_tuning(undefined8 *param_1)\n\n{\n  *(undefined *)(param_1 + 2) = 0;\n  *param_1 = 0x3f80000000000000;\n  param_1[1] = 0x3fb4fdf43f4ccccd;\n  return;\n}\n\n", 
    "00105710": "\nvoid sighandler(int param_1)\n\n{\n  if (interrupt_signal == 0) {\n    interrupt_signal = param_1;\n  }\n  return;\n}\n\n", 
    "00104860": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint clock_gettime(clockid_t __clock_id,timespec *__tp)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_clock_gettime_00123ce8)();\n  return iVar1;\n}\n\n", 
    "00110c90": "\nlong mbsalign(char *param_1,long param_2,long param_3,ulong *param_4,int param_5,uint param_6)\n\n{\n  char cVar1;\n  int iVar2;\n  ulong uVar3;\n  ulong uVar4;\n  size_t sVar5;\n  void *pvVar6;\n  size_t __n;\n  wchar_t *__pwcs;\n  size_t sVar7;\n  char *__s;\n  ulong uVar8;\n  ulong uVar9;\n  ulong uVar10;\n  long lVar11;\n  char *local_60;\n  \n  uVar3 = strlen(param_1);\n  uVar9 = uVar3;\n  if (((param_6 & 2) == 0) && (sVar5 = __ctype_get_mb_cur_max(), 1 < sVar5)) {\n    sVar5 = mbstowcs((wchar_t *)0x0,param_1,0);\n    if (sVar5 == 0xffffffffffffffff) {\n      if ((param_6 & 1) == 0) {\nLAB_00110dab:\n        __pwcs = (wchar_t *)0x0;\n        __s = (char *)0x0;\n        lVar11 = -1;\n        goto LAB_00110d23;\n      }\n      goto LAB_00110cc9;\n    }\n    __n = sVar5 + 1;\n    __pwcs = (wchar_t *)malloc(__n * 4);\n    local_60 = param_1;\n    if (__pwcs == (wchar_t *)0x0) {\n      if ((param_6 & 1) == 0) goto LAB_00110dab;\n      __s = (char *)0x0;\n      goto LAB_00110cd2;\n    }\n    __s = (char *)0x0;\n    sVar7 = mbstowcs(__pwcs,param_1,__n);\n    if (sVar7 == 0) goto LAB_00110cd2;\n    __pwcs[sVar5] = L'\\0';\n    cVar1 = wc_ensure_printable(__pwcs);\n    iVar2 = wcswidth(__pwcs,__n);\n    uVar9 = (ulong)iVar2;\n    if (cVar1 != '\\0') {\n      sVar5 = wcstombs((char *)0x0,__pwcs,0);\nLAB_00110ede:\n      __s = (char *)malloc(sVar5 + 1);\n      if (__s == (char *)0x0) {\n        if ((param_6 & 1) == 0) {\n          lVar11 = -1;\n          goto LAB_00110d23;\n        }\n      }\n      else {\n        uVar9 = wc_truncate(__pwcs,*param_4);\n        uVar3 = wcstombs(__s,__pwcs,sVar5 + 1);\n        local_60 = __s;\n      }\n      goto LAB_00110cd2;\n    }\n    uVar4 = *param_4;\n    sVar5 = uVar3;\n    if (uVar4 < uVar9) goto LAB_00110ede;\nLAB_00110d48:\n    uVar10 = uVar9;\n    uVar8 = uVar3;\n    if (uVar4 <= uVar9) goto LAB_00110ce0;\n    uVar4 = uVar4 - uVar9;\n    *param_4 = uVar9;\n    if (param_5 != 0) goto LAB_00110ce9;\nLAB_00110d63:\n    uVar9 = 0;\n    uVar10 = uVar4;\n  }\n  else {\nLAB_00110cc9:\n    __pwcs = (wchar_t *)0x0;\n    __s = (char *)0x0;\n    local_60 = param_1;\nLAB_00110cd2:\n    uVar4 = *param_4;\n    uVar10 = uVar4;\n    uVar8 = uVar4;\n    if (uVar9 <= uVar4) goto LAB_00110d48;\nLAB_00110ce0:\n    uVar4 = 0;\n    *param_4 = uVar10;\n    uVar3 = uVar8;\n    if (param_5 == 0) goto LAB_00110d63;\nLAB_00110ce9:\n    uVar9 = uVar4;\n    uVar10 = 0;\n    if (param_5 != 1) {\n      uVar9 = (ulong)((uint)uVar4 & 1) + (uVar4 >> 1);\n      uVar10 = uVar4 >> 1;\n    }\n  }\n  uVar4 = uVar9 + uVar3;\n  if ((param_6 & 4) != 0) {\n    uVar9 = 0;\n    uVar4 = uVar3;\n  }\n  if ((param_6 & 8) != 0) {\n    uVar10 = 0;\n  }\n  if (param_3 != 0) {\n    param_3 = param_2 + -1 + param_3;\n    pvVar6 = (void *)mbs_align_pad(param_2,param_3,uVar9);\n    uVar9 = param_3 - (long)pvVar6;\n    if (uVar3 < (ulong)(param_3 - (long)pvVar6)) {\n      uVar9 = uVar3;\n    }\n    pvVar6 = mempcpy(pvVar6,local_60,uVar9);\n    mbs_align_pad(pvVar6,param_3,uVar10);\n  }\n  lVar11 = uVar4 + uVar10;\nLAB_00110d23:\n  free(__pwcs);\n  free(__s);\n  return lVar11;\n}\n\n", 
    "00104980": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * strrchr(char *__s,int __c)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_strrchr_00123d78)();\n  return pcVar1;\n}\n\n", 
    "00109a60": "\nvoid align_nstrftime_constprop_0\n               (undefined8 param_1,byte param_2,long param_3,undefined8 param_4,undefined4 param_5)\n\n{\n  if (use_abformat != '\\0') {\n    nstrftime(param_1,0x3e9,\n              abformat + ((long)*(int *)(param_3 + 0x10) + (ulong)param_2 * 0xc) * 0x80,param_3,\n              param_4,param_5);\n    return;\n  }\n  nstrftime(param_1,0x3e9,*(undefined8 *)(long_time_format + (ulong)param_2 * 8),param_3,param_4,\n            param_5);\n  return;\n}\n\n", 
    "0010eb60": "\nvoid allocate_entry_isra_0(long *param_1)\n\n{\n  if (*param_1 != 0) {\n    *param_1 = *(long *)(*param_1 + 8);\n    return;\n  }\n  malloc(0x10);\n  return;\n}\n\n", 
    "00104740": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * getenv(char *__name)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_getenv_00123c58)();\n  return pcVar1;\n}\n\n", 
    "0010ea40": "\nvoid free_entry_isra_0(undefined8 *param_1,undefined8 *param_2)\n\n{\n  *param_2 = 0;\n  param_2[1] = *param_1;\n  *param_1 = param_2;\n  return;\n}\n\n", 
    "00107ba0": "\nundefined8 strcmp_df_atime(long param_1,long param_2)\n\n{\n  char cVar1;\n  char cVar2;\n  undefined8 uVar3;\n  \n  cVar1 = is_directory_isra_0(*(undefined4 *)(param_1 + 0xa8));\n  cVar2 = is_directory_isra_0(*(undefined4 *)(param_2 + 0xa8));\n  if ((cVar2 == '\\x01') || (cVar1 == '\\0')) {\n    if ((cVar1 == '\\x01') || (uVar3 = 1, cVar2 == '\\0')) {\n      uVar3 = cmp_atime(param_1);\n      return uVar3;\n    }\n  }\n  else {\n    uVar3 = 0xffffffff;\n  }\n  return uVar3;\n}\n\n", 
    "00106bd0": "\nint format_user_or_group_width(long param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  uint *puVar2;\n  uint *puVar3;\n  uint uVar4;\n  uint uVar5;\n  long in_FS_OFFSET;\n  bool bVar6;\n  uint local_28 [6];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_1 == 0) {\n    __sprintf_chk(local_28,1,0x15,&DAT_0011983f,param_2);\n    puVar3 = local_28;\n    do {\n      puVar2 = puVar3;\n      uVar4 = *puVar2 + 0xfefefeff & ~*puVar2;\n      uVar5 = uVar4 & 0x80808080;\n      puVar3 = puVar2 + 1;\n    } while (uVar5 == 0);\n    bVar6 = (uVar4 & 0x8080) == 0;\n    if (bVar6) {\n      uVar5 = uVar5 >> 0x10;\n    }\n    if (bVar6) {\n      puVar3 = (uint *)((long)puVar2 + 6);\n    }\n    iVar1 = (((int)puVar3 + -3) - (uint)CARRY1((byte)uVar5,(byte)uVar5)) - (int)local_28;\n  }\n  else {\n    iVar1 = gnu_mbswidth(param_1,0);\n    if (iVar1 < 0) {\n      iVar1 = 0;\n    }\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar1;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "001172e0": "\nuint rotl32(uint param_1,byte param_2)\n\n{\n  return param_1 << (param_2 & 0x1f) | param_1 >> 0x20 - (param_2 & 0x1f);\n}\n\n", 
    "0010fb30": "\n/* WARNING: Removing unreachable block (ram,0x0010fb9d) */\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid adjust_value(void)\n\n{\n  return;\n}\n\n", 
    "00113680": "\nuint * gettext_quote(uint *param_1,int param_2)\n\n{\n  int iVar1;\n  uint *puVar2;\n  undefined8 uVar3;\n  \n  puVar2 = (uint *)dcgettext(0,param_1,5);\n  if (param_1 == puVar2) {\n    uVar3 = locale_charset();\n    iVar1 = strcaseeq0_constprop_0(uVar3,0x11c251,0x55,0x54,0x46,0x2d,0x38,0,0);\n    if (iVar1 == 0) {\n      iVar1 = strcaseeq0_constprop_0(uVar3,0x11c257,0x47,0x42,0x31,0x38,0x30,0x33,0x30);\n      if (iVar1 == 0) {\n        puVar2 = &UINT_0011c240;\n        if (param_2 != 9) {\n          puVar2 = (uint *)0x11cf3b;\n        }\n        return puVar2;\n      }\n      if (*(char *)puVar2 == '`') {\n        puVar2 = (uint *)((long)&UINT_0011c248 + 1);\n      }\n      else {\n        puVar2 = (uint *)((long)&UINT_0011c244 + 2);\n      }\n    }\n    else if (*(char *)puVar2 == '`') {\n      puVar2 = (uint *)((long)&UINT_0011c24c + 1);\n    }\n    else {\n      puVar2 = (uint *)((long)&UINT_0011c240 + 2);\n    }\n  }\n  return puVar2;\n}\n\n", 
    "00111260": "\nvoid gnu_mbswidth(char *param_1,undefined4 param_2)\n\n{\n  size_t sVar1;\n  \n  sVar1 = strlen(param_1);\n  mbsnwidth(param_1,sVar1,param_2);\n  return;\n}\n\n", 
    "001084c0": "\nvoid strcmp_name(undefined8 *param_1,undefined8 *param_2)\n\n{\n  cmp_name_isra_0(*param_1,*param_2,PTR_strcmp_00123fc8);\n  return;\n}\n\n", 
    "00116ae0": "\nvoid _obstack_begin(long param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n                   undefined8 param_5)\n\n{\n  *(byte *)(param_1 + 0x50) = *(byte *)(param_1 + 0x50) & 0xfe;\n  *(undefined8 *)(param_1 + 0x38) = param_4;\n  *(undefined8 *)(param_1 + 0x40) = param_5;\n  _obstack_begin_worker();\n  return;\n}\n\n", 
    "0010f000": "\nvoid hash_get_entries(ulong **param_1,long param_2,ulong param_3)\n\n{\n  ulong **ppuVar1;\n  ulong *puVar2;\n  ulong uVar3;\n  ulong **ppuVar4;\n  \n  ppuVar4 = (ulong **)*param_1;\n  uVar3 = 0;\n  if (param_1[1] < ppuVar4 || (ulong **)param_1[1] == ppuVar4) {\n    return;\n  }\n  do {\n    ppuVar1 = ppuVar4;\n    puVar2 = *ppuVar4;\n    while (puVar2 != (ulong *)0x0) {\n      if (param_3 <= uVar3) {\n        return;\n      }\n      uVar3 = uVar3 + 1;\n      *(ulong **)(param_2 + -8 + uVar3 * 8) = *ppuVar1;\n      ppuVar1 = (ulong **)ppuVar1[1];\n      puVar2 = (ulong *)ppuVar1;\n    }\n    ppuVar4 = ppuVar4 + 2;\n  } while (ppuVar4 <= param_1[1] && (ulong **)param_1[1] != ppuVar4);\n  return;\n}\n\n", 
    "00106910": "\nulong file_has_acl_cache(undefined8 param_1,long param_2)\n\n{\n  char cVar1;\n  uint uVar2;\n  int *piVar3;\n  ulong uVar4;\n  \n  piVar3 = __errno_location();\n  if (*(long *)(param_2 + 0x18) == unsupported_device_10702) {\n    *piVar3 = 0x5f;\n    return 0;\n  }\n  *piVar3 = 0;\n  uVar2 = file_has_acl(param_1,param_2 + 0x18);\n  uVar4 = (ulong)uVar2;\n  if ((int)uVar2 < 1) {\n    cVar1 = errno_unsupported(*piVar3);\n    if (cVar1 != '\\0') {\n      unsupported_device_10702 = *(undefined8 *)(param_2 + 0x18);\n      return uVar4 & 0xffffffff;\n    }\n  }\n  return uVar4 & 0xffffffff;\n}\n\n", 
    "00107eb0": "\nundefined8 rev_strcmp_df_mtime(long param_1,long param_2)\n\n{\n  char cVar1;\n  char cVar2;\n  long lVar3;\n  undefined8 uVar4;\n  \n  lVar3 = param_2;\n  cVar1 = is_directory_isra_0(*(undefined4 *)(param_1 + 0xa8));\n  cVar2 = is_directory_isra_0(*(undefined4 *)(param_2 + 0xa8));\n  if ((cVar2 == '\\x01') || (cVar1 == '\\0')) {\n    if ((cVar1 == '\\x01') || (uVar4 = 1, cVar2 == '\\0')) {\n      uVar4 = cmp_mtime(lVar3,param_1,PTR_strcmp_00123fc8);\n      return uVar4;\n    }\n  }\n  else {\n    uVar4 = 0xffffffff;\n  }\n  return uVar4;\n}\n\n", 
    "00104be0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\ntime_t mktime(tm *__tp)\n\n{\n  time_t tVar1;\n  \n  tVar1 = (*(code *)PTR_mktime_00123ea8)();\n  return tVar1;\n}\n\n", 
    "00104ac0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\npasswd * getpwnam(char *__name)\n\n{\n  passwd *ppVar1;\n  \n  ppVar1 = (passwd *)(*(code *)PTR_getpwnam_00123e18)();\n  return ppVar1;\n}\n\n", 
    "00105cd0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid dev_ino_free(void *__ptr)\n\n{\n  (*(code *)PTR_free_00123fb0)();\n  return;\n}\n\n", 
    "00116910": "\nuint rpl_fgetfilecon(undefined8 param_1,byte **param_2)\n\n{\n  uint uVar1;\n  int *piVar2;\n  long lVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  bool bVar6;\n  bool bVar7;\n  byte bVar8;\n  \n  bVar8 = 0;\n  uVar1 = fgetfilecon();\n  if (uVar1 == 0) {\n    piVar2 = __errno_location();\n    *piVar2 = 0x5f;\n    return 0xffffffff;\n  }\n  bVar6 = uVar1 < 10;\n  bVar7 = uVar1 == 10;\n  if (bVar7) {\n    lVar3 = 10;\n    pbVar4 = *param_2;\n    pbVar5 = (byte *)\"unlabeled\";\n    do {\n      if (lVar3 == 0) break;\n      lVar3 = lVar3 + -1;\n      bVar6 = *pbVar4 < *pbVar5;\n      bVar7 = *pbVar4 == *pbVar5;\n      pbVar4 = pbVar4 + (ulong)bVar8 * -2 + 1;\n      pbVar5 = pbVar5 + (ulong)bVar8 * -2 + 1;\n    } while (bVar7);\n    if ((!bVar6 && !bVar7) == bVar6) {\n      freecon(*param_2);\n      *param_2 = (byte *)0x0;\n      piVar2 = __errno_location();\n      *piVar2 = 0x3d;\n      return 0xffffffff;\n    }\n  }\n  return uVar1;\n}\n\n", 
    "00108290": "\nundefined8 xstrcoll_df_size(undefined8 *param_1,undefined8 *param_2)\n\n{\n  char cVar1;\n  char cVar2;\n  undefined8 uVar3;\n  \n  cVar1 = is_directory_isra_0(*(undefined4 *)(param_1 + 0x15));\n  cVar2 = is_directory_isra_0(*(undefined4 *)(param_2 + 0x15));\n  if ((cVar2 == '\\x01') || (cVar1 == '\\0')) {\n    if ((cVar1 == '\\x01') || (uVar3 = 1, cVar2 == '\\0')) {\n      uVar3 = cmp_size_isra_0(*param_1,param_1[9],*param_2,param_2[9],xstrcoll);\n      return uVar3;\n    }\n  }\n  else {\n    uVar3 = 0xffffffff;\n  }\n  return uVar3;\n}\n\n", 
    "0010e360": "\nuint order(byte param_1)\n\n{\n  char cVar1;\n  uint uVar2;\n  \n  uVar2 = (uint)param_1;\n  cVar1 = c_isdigit(uVar2);\n  if (cVar1 == '\\0') {\n    cVar1 = c_isalpha((uint)param_1);\n    if (cVar1 == '\\0') {\n      if (param_1 == 0x7e) {\n        uVar2 = 0xffffffff;\n      }\n      else {\n        uVar2 = param_1 + 0x100;\n      }\n    }\n    return uVar2;\n  }\n  return 0;\n}\n\n", 
    "0010d150": "\nvoid argmatch_invalid(undefined8 param_1,undefined8 param_2,long param_3)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  \n  if (param_3 == -1) {\n    uVar1 = dcgettext(0,\"invalid argument %s for %s\",5);\n  }\n  else {\n    uVar1 = dcgettext(0,\"ambiguous argument %s for %s\",5);\n  }\n  uVar2 = quote_n(1,param_1);\n  uVar3 = quotearg_n_style(0,8,param_2);\n  error(0,0,uVar1,uVar3,uVar2);\n  return;\n}\n\n", 
    "001260e8": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t strlen(char *__s)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strlen@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010c060": "\nulong decode_switches(undefined4 param_1,undefined8 param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  FILE *pFVar3;\n  char cVar4;\n  char cVar5;\n  int iVar6;\n  uint uVar7;\n  char *pcVar8;\n  ulong uVar9;\n  char **ppcVar10;\n  long lVar11;\n  char *pcVar12;\n  char *pcVar13;\n  undefined8 uVar14;\n  undefined8 uVar15;\n  uint *puVar16;\n  undefined1 *puVar17;\n  long in_FS_OFFSET;\n  undefined auVar18 [16];\n  undefined2 local_48;\n  ushort uStack_46;\n  undefined4 uStack_44;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  qmark_funny_chars = 0;\n  if (ls_mode == 2) {\n    format = 2;\n    set_quoting_style(0,7);\n  }\n  else if (ls_mode == 3) {\n    format = 0;\n    set_quoting_style(0,7);\n  }\n  else {\n    if (ls_mode != 1) {\n      uVar9 = decode_switches_cold();\n      return uVar9;\n    }\n    iVar6 = isatty(1);\n    if (iVar6 == 0) {\n      format = 1;\n    }\n    else {\n      format = 2;\n      set_quoting_style(0,3);\n      qmark_funny_chars = 1;\n    }\n  }\n  time_type = 0;\n  sort_type = 0;\n  sort_reverse = 0;\n  numeric_ids = 0;\n  print_block_size = 0;\n  indicator_style = 0;\n  print_inode = 0;\n  dereference = 1;\n  recursive = 0;\n  immediate_dirs = 0;\n  ignore_mode = 0;\n  ignore_patterns = 0;\n  hide_patterns = (char **)0x0;\n  print_scontext = 0;\n  getenv_quoting_style();\n  line_length = 0x50;\n  pcVar8 = getenv(\"COLUMNS\");\n  if (((pcVar8 != (char *)0x0) && (*pcVar8 != '\\0')) &&\n     (cVar5 = set_line_length(pcVar8), cVar5 == '\\0')) {\n    uVar14 = quote(pcVar8);\n    uVar15 = dcgettext(0,\"ignoring invalid width in environment variable COLUMNS: %s\",5);\n    error(0,0,uVar15,uVar14);\n  }\n  iVar6 = ioctl(1,0x5413,&local_48);\n  if ((iVar6 != -1) && (uStack_46 != 0)) {\n    line_length = (ulong)uStack_46;\n  }\n  pcVar8 = getenv(\"TABSIZE\");\n  tabsize = 8;\n  if (pcVar8 != (char *)0x0) {\n    iVar6 = xstrtoul(pcVar8,0,0,&local_48,0);\n    if (iVar6 == 0) {\n      tabsize = CONCAT44(uStack_44,CONCAT22(uStack_46,local_48));\n    }\n    else {\n      uVar14 = quote(pcVar8);\n      uVar15 = dcgettext(0,\"ignoring invalid tab size in environment variable TABSIZE: %s\",5);\n      error(0,0,uVar15,uVar14);\n    }\n  }\n  bVar2 = false;\n  bVar1 = false;\n  puVar16 = &switchD_0010c220::switchdataD_00118158;\n  pcVar8 = (char *)0x0;\n  cVar5 = print_hyperlink;\nLAB_0010c1e1:\n  print_hyperlink = cVar5;\n  local_48 = 0xffff;\n  uStack_46 = 0xffff;\n  iVar6 = getopt_long(param_1,param_2,\"abcdfghiklmnopqrstuvw:xABCDFGHI:LNQRST:UXZ1\",long_options,\n                      &local_48);\n  if (iVar6 != -1) {\n    if (0x113 < iVar6 + 0x83U) goto switchD_0010c220_caseD_10cd73;\n    cVar5 = print_hyperlink;\n    switch((long)(int)puVar16[iVar6 + 0x83U] + (long)puVar16) {\n    case 0x10c252:\n      bVar1 = true;\n      break;\n    case 0x10c25a:\n      numeric_ids = 1;\nswitchD_0010c220_caseD_10c261:\n      format = 0;\n      break;\n    case 0x10c261:\n      goto switchD_0010c220_caseD_10c261;\n    case 0x10c2f7:\n      goto switchD_0010c220_caseD_10c2f7;\n    case 0x10c303:\n      lVar11 = __xargmatch_internal(\"--time\",optarg,time_args,time_types,4,argmatch_die);\n      time_type = *(int *)(time_types + lVar11 * 4);\n      cVar5 = print_hyperlink;\n      break;\n    case 0x10c34a:\n      lVar11 = __xargmatch_internal(\"--sort\",optarg,sort_args,sort_types,4,argmatch_die);\n      bVar2 = true;\n      sort_type = *(undefined4 *)(sort_types + lVar11 * 4);\n      cVar5 = print_hyperlink;\n      break;\n    case 0x10c396:\n      human_output_opts = 0x90;\n      file_human_output_opts = 0x90;\n      output_block_size = 1;\n      file_output_block_size = 1;\n      break;\n    case 0x10c3c5:\n      qmark_funny_chars = 0;\n      break;\n    case 0x10c3d1:\n      lVar11 = __xargmatch_internal\n                         (\"--quoting-style\",optarg,quoting_style_args,quoting_style_vals,4,\n                          argmatch_die);\n      set_quoting_style(0,*(undefined4 *)(quoting_style_vals + lVar11 * 4));\n      cVar5 = print_hyperlink;\n      break;\n    case 0x10c419:\n      lVar11 = __xargmatch_internal\n                         (\"--indicator-style\",optarg,indicator_style_args,indicator_style_types,4,\n                          argmatch_die);\n      indicator_style = *(uint *)(indicator_style_types + lVar11 * 4);\n      cVar5 = print_hyperlink;\n      break;\n    case 0x10c460:\n      if (optarg != (char *)0x0) {\n        lVar11 = __xargmatch_internal(\"--hyperlink\",optarg,when_args,when_types,4,argmatch_die);\n        if (*(int *)(when_types + lVar11 * 4) != 1) {\n          cVar5 = '\\0';\n          if (*(int *)(when_types + lVar11 * 4) == 2) {\n            iVar6 = isatty(1);\n            cVar5 = iVar6 != 0;\n          }\n          break;\n        }\n      }\n      cVar5 = '\\x01';\n      break;\n    case 0x10c4d0:\n      ppcVar10 = (char **)xmalloc(0x10);\n      *ppcVar10 = optarg;\n      ppcVar10[1] = (char *)hide_patterns;\n      hide_patterns = ppcVar10;\n      cVar5 = print_hyperlink;\n      break;\n    case 0x10c4fb:\n      directories_first = 1;\n      break;\n    case 0x10c507:\n      format = 0;\n      pcVar8 = (char *)bad_cast(\"full-iso\");\n      cVar5 = print_hyperlink;\n      break;\n    case 0x10c525:\n      lVar11 = __xargmatch_internal(\"--format\",optarg,format_args,format_types,4,argmatch_die);\n      format = *(int *)(format_types + lVar11 * 4);\n      cVar5 = print_hyperlink;\n      break;\n    case 0x10c56c:\n      indicator_style = 2;\n      break;\n    case 0x10c57b:\n      dereference = 4;\n      break;\n    case 0x10c58a:\n      if (optarg != (char *)0x0) {\n        lVar11 = __xargmatch_internal(\"--color\",optarg,when_args,when_types,4,argmatch_die);\n        if ((*(int *)(when_types + lVar11 * 4) != 1) &&\n           ((*(int *)(when_types + lVar11 * 4) != 2 || (iVar6 = isatty(1), iVar6 == 0)))) {\n          print_with_color = 0;\n          cVar5 = print_hyperlink;\n          break;\n        }\n      }\n      print_with_color = 1;\n      tabsize = 0;\n      cVar5 = print_hyperlink;\n      break;\n    case 0x10c5ed:\n      iVar6 = human_options(optarg,&human_output_opts,&output_block_size);\n      if (iVar6 != 0) {\n        lVar11 = xstrtol_fatal(iVar6,CONCAT22(uStack_46,local_48),0,long_options,optarg);\n        goto LAB_0010ce6b;\n      }\n      file_human_output_opts = human_output_opts;\n      file_output_block_size = output_block_size;\n      cVar5 = print_hyperlink;\n      break;\n    case 0x10c62e:\n      print_author = 1;\n      break;\n    case 0x10c63a:\n      format = 3;\n      break;\n    case 0x10c649:\n      cVar4 = set_line_length(optarg);\n      cVar5 = print_hyperlink;\n      if (cVar4 == '\\0') {\n        puVar16 = (uint *)quote(optarg);\n        uVar14 = dcgettext(0,\"invalid line width\",5);\n        error(2,0,\"%s: %s\",uVar14,puVar16);\nswitchD_0010c220_caseD_10c69a:\n        sort_type = 3;\n        bVar2 = true;\n        cVar5 = print_hyperlink;\n      }\n      break;\n    case 0x10c69a:\n      goto switchD_0010c220_caseD_10c69a;\n    case 0x10c6ae:\n      time_type = 2;\n      break;\n    case 0x10c6bd:\n      sort_type = 4;\n      bVar2 = true;\n      break;\n    case 0x10c6d1:\n      print_block_size = 1;\n      break;\n    case 0x10c6dd:\n      sort_reverse = 1;\n      break;\n    case 0x10c6e9:\n      qmark_funny_chars = 1;\n      break;\n    case 0x10c6f5:\n      indicator_style = 1;\n      break;\n    case 0x10c704:\n      format = 0;\n      print_group = 0;\n      break;\n    case 0x10c71a:\n      format = 4;\n      break;\n    case 0x10c729:\n      print_inode = 1;\n      break;\n    case 0x10c735:\n      human_output_opts = 0xb0;\n      file_human_output_opts = 0xb0;\n      output_block_size = 1;\n      file_output_block_size = 1;\n      break;\n    case 0x10c764:\n      format = 0;\n      print_owner = 0;\n      break;\n    case 0x10c77a:\n      ignore_mode = 2;\n      sort_type = 0xffffffff;\n      if (format == 0) {\n        iVar6 = isatty(1);\n        format = 2 - (uint)(iVar6 == 0);\n      }\n      print_block_size = 0;\n      print_with_color = 0;\n      print_hyperlink = '\\0';\n      bVar2 = true;\n      cVar5 = print_hyperlink;\n      break;\n    case 0x10c7ba:\n      immediate_dirs = 1;\n      break;\n    case 0x10c7c6:\n      time_type = 1;\n      break;\n    case 0x10c7d5:\n      set_quoting_style(0,7);\n      cVar5 = print_hyperlink;\n      break;\n    case 0x10c7e6:\n      ignore_mode = 2;\n      break;\n    case 0x10c7f5:\n      print_scontext = 1;\n      break;\n    case 0x10c801:\n      sort_type = 1;\n      bVar2 = true;\n      break;\n    case 0x10c815:\n      sort_type = 0xffffffff;\n      bVar2 = true;\n      break;\n    case 0x10c829:\n      auVar18 = dcgettext(0,\"invalid tab size\",5);\n      tabsize = xnumtoumax(optarg,0,0,0xffffffffffffffff,&DAT_0011991e,SUB168(auVar18,0),2,\n                           SUB168(auVar18 >> 0x40,0));\n      cVar5 = print_hyperlink;\n      break;\n    case 0x10c86b:\n      sort_type = 2;\n      bVar2 = true;\n      break;\n    case 0x10c87f:\n      recursive = 1;\n      break;\n    case 0x10c88b:\n      set_quoting_style(0,5);\n      cVar5 = print_hyperlink;\n      break;\n    case 0x10c89c:\n      set_quoting_style(0,0);\n      cVar5 = print_hyperlink;\n      break;\n    case 0x10c8aa:\n      dereference = 5;\n      break;\n    case 0x10c8b9:\n      add_ignore_pattern(optarg);\n      cVar5 = print_hyperlink;\n      break;\n    case 0x10c8ca:\n      dereference = 3;\n      break;\n    case 0x10c8d9:\n      print_group = 0;\n      break;\n    case 0x10c8e5:\n      indicator_style = 3;\n      break;\n    case 0x10c8f4:\n      dired = '\\x01';\n      break;\n    case 0x10c900:\n      format = 2;\n      break;\n    case 0x10c90f:\n      add_ignore_pattern(&DAT_001199bb);\n      add_ignore_pattern(&DAT_001199ba);\n      cVar5 = print_hyperlink;\n      break;\n    case 0x10c92c:\n      ignore_mode = 1;\n      break;\n    case 0x10c93b:\n      if (format != 0) {\n        format = 1;\n      }\n      break;\n    case 0x10c957:\n      pcVar8 = \"ls\";\n      iVar6 = ls_mode;\n      if (ls_mode != 1) {\n        pcVar8 = \"dir\";\n        iVar6 = 0x119982;\n        if (ls_mode != 2) {\n          pcVar8 = \"vdir\";\n        }\n      }\n      version_etc(stdout,pcVar8,\"GNU coreutils\",Version,\"Richard M. Stallman\",\"David MacKenzie\",0,\n                  iVar6);\n                    /* WARNING: Subroutine does not return */\n      exit(0);\n    case 0x10cd6c:\n      usage(0);\n    case 0x10cd73:\nswitchD_0010c220_caseD_10cd73:\n      usage(2);\n      goto LAB_0010cd7d;\n    }\n    goto LAB_0010c1e1;\n  }\n  if (output_block_size == 0) {\n    pcVar12 = getenv(\"LS_BLOCK_SIZE\");\n    human_options(pcVar12,&human_output_opts,&output_block_size);\n    if ((pcVar12 != (char *)0x0) || (pcVar12 = getenv(\"BLOCK_SIZE\"), pcVar12 != (char *)0x0)) {\n      file_human_output_opts = human_output_opts;\n      file_output_block_size = output_block_size;\n    }\n    if (bVar1) {\n      human_output_opts = 0;\n      output_block_size = 0x400;\n    }\n  }\n  max_idx = line_length / 3 + (ulong)(line_length % 3 != 0);\n  uVar7 = get_quoting_style(0);\n  if ((format == 4) || (format == 1)) {\n    align_variable_outer_quotes = false;\n  }\n  else if ((line_length != 0) || (align_variable_outer_quotes = false, format == 0)) {\n    align_variable_outer_quotes = (uVar7 & 0xfffffffd) == 1 || uVar7 == 6;\n  }\n  filename_quoting_options = clone_quoting_options(0);\n  if (uVar7 == 7) {\n    set_char_quoting(filename_quoting_options,0x20,1);\n  }\n  if (1 < indicator_style) {\n    pcVar12 = \"*=>@|\" + (indicator_style - 2);\n    cVar5 = \"*=>@|\"[indicator_style - 2];\n    while (cVar5 != '\\0') {\n      pcVar12 = pcVar12 + 1;\n      set_char_quoting(filename_quoting_options,(int)cVar5,1);\n      cVar5 = *pcVar12;\n    }\n  }\n  dirname_quoting_options = clone_quoting_options(0);\n  set_char_quoting(dirname_quoting_options,0x3a,1);\n  if (dired == '\\0') {\nLAB_0010caaa:\n    if ((1 < time_type - 1U) || (bVar2)) {\n      if (format == 0) goto LAB_0010cad1;\n    }\n    else {\n      if (format == 0) goto LAB_0010cad1;\n      sort_type = 4;\n    }\n  }\n  else {\n    if ((format != 0) || (print_hyperlink != '\\0')) {\n      dired = '\\0';\n      goto LAB_0010caaa;\n    }\nLAB_0010cad1:\n    if (pcVar8 == (char *)0x0) {\nLAB_0010cd7d:\n      pcVar8 = getenv(\"TIME_STYLE\");\n      if (pcVar8 == (char *)0x0) {\n        pcVar8 = (char *)bad_cast(\"locale\");\n      }\n    }\n    while (iVar6 = strncmp(pcVar8,\"posix-\",6), iVar6 == 0) {\n      cVar5 = hard_locale(2);\n      if (cVar5 == '\\0') goto LAB_0010cb75;\n      pcVar8 = pcVar8 + 6;\n    }\n    if (*pcVar8 == '+') {\n      pcVar8 = pcVar8 + 1;\n      pcVar13 = strchr(pcVar8,10);\n      pcVar12 = pcVar8;\n      if (pcVar13 != (char *)0x0) {\n        pcVar12 = strchr(pcVar13 + 1,10);\n        if (pcVar12 != (char *)0x0) goto LAB_0010cf08;\n        *pcVar13 = '\\0';\n        pcVar12 = pcVar13 + 1;\n      }\n    }\n    else {\n      lVar11 = argmatch(pcVar8,time_style_args,time_style_types,4);\n      if (lVar11 < 0) {\nLAB_0010ce6b:\n        argmatch_invalid(\"time style\",pcVar8,lVar11);\n        pFVar3 = stderr;\n        puVar17 = time_style_args;\n        pcVar12 = (char *)dcgettext(0,\"Valid arguments are:\\n\",5);\n        fputs_unlocked(pcVar12,pFVar3);\n        pcVar12 = \"full-iso\";\n        do {\n          puVar17 = (undefined1 *)((long)puVar17 + 8);\n          __fprintf_chk(stderr,1,\"  - [posix-]%s\\n\",pcVar12);\n          pFVar3 = stderr;\n          pcVar12 = *(char **)puVar17;\n        } while (pcVar12 != (char *)0x0);\n        pcVar12 = (char *)dcgettext(0,\"  - +FORMAT (e.g., +%H:%M) for a \\'date\\'-style format\\n\",5);\n        fputs_unlocked(pcVar12,pFVar3);\n        usage(2);\nLAB_0010cf08:\n        uVar14 = quote(pcVar8);\n        uVar15 = dcgettext(0,\"invalid time style format %s\",5);\n        error(2,0,uVar15,uVar14);\n        goto LAB_0010cf3a;\n      }\n      if (lVar11 == 2) {\n        long_time_format._0_8_ = \"%Y-%m-%d \";\n        long_time_format._8_8_ = \"%m-%d %H:%M\";\n        pcVar8 = long_time_format._0_8_;\n        pcVar12 = long_time_format._8_8_;\n      }\n      else {\n        pcVar8 = long_time_format._0_8_;\n        pcVar12 = long_time_format._8_8_;\n        if (lVar11 < 3) {\n          if (lVar11 == 0) {\n            long_time_format._8_8_ = \"%Y-%m-%d %H:%M:%S.%N %z\";\n            long_time_format._0_8_ = \"%Y-%m-%d %H:%M:%S.%N %z\";\n            pcVar8 = long_time_format._0_8_;\n            pcVar12 = long_time_format._8_8_;\n          }\n          else if (lVar11 == 1) {\n            long_time_format._8_8_ = \"%Y-%m-%d %H:%M\";\n            long_time_format._0_8_ = \"%Y-%m-%d %H:%M\";\n            pcVar8 = long_time_format._0_8_;\n            pcVar12 = long_time_format._8_8_;\n          }\n        }\n        else if ((lVar11 == 3) &&\n                (cVar5 = hard_locale(2), pcVar8 = long_time_format._0_8_,\n                pcVar12 = long_time_format._8_8_, cVar5 != '\\0')) {\n          long_time_format._0_8_ = (char *)dcgettext(0,long_time_format._0_8_,2);\n          pcVar12 = (char *)dcgettext(0,long_time_format._8_8_,2);\n          pcVar8 = long_time_format._0_8_;\n        }\n      }\n    }\n    long_time_format._8_8_ = pcVar12;\n    long_time_format._0_8_ = pcVar8;\n    abformat_init();\n  }\nLAB_0010cb75:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return (ulong)optind;\n  }\nLAB_0010cf3a:\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\nswitchD_0010c220_caseD_10c2f7:\n  pcVar8 = optarg;\n  goto LAB_0010c1e1;\n}\n\n", 
    "00115ae0": "\nvoid xmalloc(size_t param_1)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = malloc(param_1);\n  if ((pvVar1 == (void *)0x0) && (param_1 != 0)) {\n                    /* WARNING: Subroutine does not return */\n    xalloc_die();\n  }\n  return;\n}\n\n", 
    "00116cf0": "\nuint isdst_differ(uint param_1,uint param_2)\n\n{\n  uint uVar1;\n  \n  uVar1 = 0;\n  if ((param_1 == 0) != (param_2 == 0)) {\n    uVar1 = (~param_1 & ~param_2) >> 0x1f;\n  }\n  return uVar1;\n}\n\n", 
    "0010d030": "\nvoid __argmatch_die(void)\n\n{\n  usage(1);\n  return;\n}\n\n", 
    "001260e0": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t __ctype_get_mb_cur_max(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __ctype_get_mb_cur_max@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00104800": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint sigaction(int __sig,sigaction *__act,sigaction *__oact)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_sigaction_00123cb8)();\n  return iVar1;\n}\n\n", 
    "00114f00": "\nvoid quotearg_n_style_mem\n               (undefined4 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  long in_FS_OFFSET;\n  undefined auStack_68 [56];\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  quoting_options_from_style(auStack_68);\n  quotearg_n_options(param_1,param_3,param_4,auStack_68);\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00104920": "\nvoid getopt_long(void)\n\n{\n  (*(code *)PTR_getopt_long_00123d48)();\n  return;\n}\n\n", 
    "00104ab0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint dirfd(DIR *__dirp)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_dirfd_00123e10)();\n  return iVar1;\n}\n\n", 
    "001172c0": "\nulong rotl64(ulong param_1,byte param_2)\n\n{\n  return param_1 << (param_2 & 0x3f) | param_1 >> 0x40 - (param_2 & 0x3f);\n}\n\n", 
    "00104cf0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nulong strtoul(char *__nptr,char **__endptr,int __base)\n\n{\n  ulong uVar1;\n  \n  uVar1 = (*(code *)PTR_strtoul_00123f30)();\n  return uVar1;\n}\n\n", 
    "00104bd0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint strcoll(char *__s1,char *__s2)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_strcoll_00123ea0)();\n  return iVar1;\n}\n\n", 
    "00110b50": "\nchar * umaxtostr(ulong param_1,long param_2)\n\n{\n  bool bVar1;\n  char *pcVar2;\n  \n  *(undefined *)(param_2 + 0x14) = 0;\n  pcVar2 = (char *)(param_2 + 0x14);\n  do {\n    pcVar2 = pcVar2 + -1;\n    *pcVar2 = (char)param_1 + (char)(param_1 / 10) * -10 + '0';\n    bVar1 = 9 < param_1;\n    param_1 = param_1 / 10;\n  } while (bVar1);\n  return pcVar2;\n}\n\n", 
    "00113410": "\nundefined8\nstrcaseeq2(long param_1,undefined8 param_2,byte param_3,char param_4,char param_5,char param_6,\n          char param_7)\n\n{\n  char cVar1;\n  byte bVar2;\n  undefined8 uVar3;\n  \n  cVar1 = c_isupper((int)(char)param_3);\n  bVar2 = *(byte *)(param_1 + 2);\n  if (cVar1 != '\\0') {\n    bVar2 = bVar2 & 0xdf;\n  }\n  if (param_3 != bVar2) {\n    return 0;\n  }\n  if (param_3 == 0) {\n    return 1;\n  }\n  uVar3 = strcaseeq3(param_1,param_2,(int)param_4,(int)param_5,(int)param_6,(int)param_7);\n  return uVar3;\n}\n\n", 
    "0010fb10": "\nvoid triple_free(void **param_1)\n\n{\n  free(*param_1);\n  (*(code *)PTR_free_00123fb0)(param_1);\n  return;\n}\n\n", 
    "00104dff": "\nvoid hash_get_first_cold(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "0010f580": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined8 hash_insert_if_absent(long param_1,long param_2,long *param_3)\n\n{\n  char cVar1;\n  long lVar2;\n  long *plVar3;\n  ulong uVar4;\n  undefined8 uVar5;\n  long in_FS_OFFSET;\n  float fVar6;\n  float fVar7;\n  undefined local_38;\n  undefined7 uStack_37;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_2 == 0) {\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  lVar2 = hash_find_entry(param_1,param_2,&local_38,0);\n  if (lVar2 != 0) {\n    uVar5 = 0;\n    if (param_3 != (long *)0x0) {\n      *param_3 = lVar2;\n    }\n    goto LAB_0010f5ce;\n  }\n  uVar4 = *(ulong *)(param_1 + 0x18);\n  if ((long)uVar4 < 0) {\n    fVar7 = (float)(uVar4 >> 1 | (ulong)((uint)uVar4 & 1));\n    fVar7 = fVar7 + fVar7;\n  }\n  else {\n    fVar7 = (float)uVar4;\n  }\n  uVar4 = *(ulong *)(param_1 + 0x10);\n  if ((long)uVar4 < 0) {\n    fVar6 = (float)(uVar4 >> 1 | (ulong)((uint)uVar4 & 1));\n    fVar6 = fVar6 + fVar6;\n  }\n  else {\n    fVar6 = (float)uVar4;\n  }\n  if (fVar6 * *(float *)(*(long *)(param_1 + 0x28) + 8) < fVar7) {\n    check_tuning_isra_0(param_1 + 0x28);\n    lVar2 = *(long *)(param_1 + 0x28);\n    uVar4 = *(ulong *)(param_1 + 0x10);\n    if ((long)uVar4 < 0) {\n      fVar7 = (float)(uVar4 >> 1 | (ulong)((uint)uVar4 & 1));\n      fVar7 = fVar7 + fVar7;\n    }\n    else {\n      fVar7 = (float)uVar4;\n    }\n    uVar4 = *(ulong *)(param_1 + 0x18);\n    if ((long)uVar4 < 0) {\n      fVar6 = (float)(uVar4 >> 1 | (ulong)((uint)uVar4 & 1));\n      fVar6 = fVar6 + fVar6;\n    }\n    else {\n      fVar6 = (float)uVar4;\n    }\n    if (fVar6 <= *(float *)(lVar2 + 8) * fVar7) goto LAB_0010f62a;\n    fVar7 = fVar7 * *(float *)(lVar2 + 0xc);\n    if (*(char *)(lVar2 + 0x10) == '\\0') {\n      fVar7 = fVar7 * *(float *)(lVar2 + 8);\n    }\n    if (fVar7 < _DAT_0011bf68) {\n      if (_DAT_0011bf6c <= fVar7) {\n        uVar4 = (long)(fVar7 - _DAT_0011bf6c) ^ 0x8000000000000000;\n      }\n      else {\n        uVar4 = (ulong)fVar7;\n      }\n      cVar1 = hash_rehash(param_1,uVar4);\n      if (cVar1 != '\\0') {\n        lVar2 = hash_find_entry(param_1,param_2,&local_38,0);\n        if (lVar2 != 0) {\n          uVar5 = hash_insert_if_absent_cold();\n          return uVar5;\n        }\n        goto LAB_0010f62a;\n      }\n    }\n  }\n  else {\nLAB_0010f62a:\n    if (*(long *)CONCAT71(uStack_37,local_38) == 0) {\n      *(long *)CONCAT71(uStack_37,local_38) = param_2;\n      uVar5 = 1;\n      *(long *)(param_1 + 0x20) = *(long *)(param_1 + 0x20) + 1;\n      *(long *)(param_1 + 0x18) = *(long *)(param_1 + 0x18) + 1;\n      goto LAB_0010f5ce;\n    }\n    plVar3 = (long *)allocate_entry_isra_0(param_1 + 0x48);\n    if (plVar3 != (long *)0x0) {\n      *plVar3 = param_2;\n      uVar5 = 1;\n      plVar3[1] = *(long *)(CONCAT71(uStack_37,local_38) + 8);\n      *(long **)(CONCAT71(uStack_37,local_38) + 8) = plVar3;\n      *(long *)(param_1 + 0x20) = *(long *)(param_1 + 0x20) + 1;\n      goto LAB_0010f5ce;\n    }\n  }\n  uVar5 = 0xffffffff;\nLAB_0010f5ce:\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar5;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "0010d6a0": "\nchar * canonicalize_filename_mode(char *param_1,uint param_2)\n\n{\n  ulong uVar1;\n  bool bVar2;\n  long lVar3;\n  char cVar4;\n  int iVar5;\n  char *__s;\n  size_t sVar6;\n  char *__s_00;\n  size_t sVar7;\n  int *piVar8;\n  uint uVar9;\n  char *__dest;\n  long lVar10;\n  char *pcVar11;\n  char *pcVar12;\n  char cVar13;\n  char *pcVar14;\n  long in_FS_OFFSET;\n  void *local_108;\n  char *local_100;\n  ulong local_f0;\n  long local_e0;\n  stat local_d8;\n  long local_40;\n  \n  uVar9 = param_2 & 3;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_e0 = 0;\n  if (((uVar9 & uVar9 - 1) != 0) || (param_1 == (char *)0x0)) {\n    piVar8 = __errno_location();\n    __s = (char *)0x0;\n    *piVar8 = 0x16;\n    goto LAB_0010d8e0;\n  }\n  if (*param_1 == '\\0') {\n    piVar8 = __errno_location();\n    __s = (char *)0x0;\n    *piVar8 = 2;\n    goto LAB_0010d8e0;\n  }\n  if (*param_1 == '/') {\n    __s = (char *)xmalloc(0x1000);\n    *__s = '/';\n    pcVar12 = __s + 0x1000;\n    __dest = __s + 1;\n    cVar4 = *param_1;\n    if (cVar4 != '\\0') {\nLAB_0010d741:\n      local_f0 = 0;\n      local_108 = (void *)0x0;\n      local_100 = param_1;\n      do {\n        pcVar11 = param_1;\n        cVar13 = cVar4;\n        if (cVar4 == '/') {\n          do {\n            cVar13 = param_1[1];\n            param_1 = param_1 + 1;\n          } while (cVar13 == '/');\n          pcVar11 = param_1;\n          if (cVar13 == '\\0') break;\n        }\n        do {\n          pcVar14 = param_1;\n          cVar4 = pcVar14[1];\n          param_1 = pcVar14 + 1;\n          if (cVar4 == '\\0') break;\n        } while (cVar4 != '/');\n        if (param_1 == pcVar11) break;\n        sVar6 = (long)param_1 - (long)pcVar11;\n        if (sVar6 == 1) {\n          if (cVar13 != '.') goto LAB_0010d7dd;\n        }\n        else {\n          if (((sVar6 != 2) || (cVar13 != '.')) || (pcVar11[1] != '.')) {\nLAB_0010d7dd:\n            if (__dest[-1] != '/') {\n              *__dest = '/';\n              __dest = __dest + 1;\n            }\n            if (pcVar12 <= __dest + sVar6) {\n              lVar10 = (long)__dest - (long)__s;\n              lVar3 = 0x1000 - (long)__s;\n              if (0xfff < (long)sVar6) {\n                lVar3 = (sVar6 + 1) - (long)__s;\n              }\n              __s = (char *)xrealloc(__s,pcVar12 + lVar3);\n              pcVar12 = __s + (long)(pcVar12 + lVar3);\n              __dest = __s + lVar10;\n            }\n            memcpy(__dest,pcVar11,sVar6);\n            __dest = __dest + sVar6;\n            *__dest = '\\0';\n            pcVar11 = __dest;\n            if ((uVar9 == 2) && ((param_2 & 4) != 0)) {\nLAB_0010d860:\n              local_d8.st_mode = 0;\nLAB_0010d868:\n              if ((*param_1 == '\\0') || (uVar9 == 2)) {\nLAB_0010d87a:\n                cVar4 = *param_1;\n                __dest = pcVar11;\n                goto LAB_0010d882;\n              }\n              piVar8 = __errno_location();\n              iVar5 = 0x14;\n            }\n            else {\n              if ((param_2 & 4) == 0) {\n                iVar5 = lstat(__s,&local_d8);\n              }\n              else {\n                iVar5 = stat(__s,&local_d8);\n              }\n              if (iVar5 == 0) {\n                if ((local_d8.st_mode & 0xf000) != 0xa000) {\n                  if ((local_d8.st_mode & 0xf000) != 0x4000) goto LAB_0010d868;\n                  goto LAB_0010d87a;\n                }\n                cVar4 = seen_triple(&local_e0,local_100,&local_d8);\n                if (cVar4 == '\\0') {\n                  __s_00 = (char *)areadlink_with_size(__s,local_d8.st_size);\n                  if (__s_00 != (char *)0x0) {\n                    sVar6 = strlen(__s_00);\n                    sVar7 = strlen(param_1);\n                    uVar1 = sVar6 + 1 + sVar7;\n                    if (local_f0 == 0) {\n                      local_f0 = 0x1000;\n                      if (0xfff < uVar1) {\n                        local_f0 = uVar1;\n                      }\n                      local_108 = (void *)xmalloc(local_f0);\n                    }\n                    else if (local_f0 < uVar1) {\n                      local_108 = (void *)xrealloc(local_108,uVar1);\n                      local_f0 = uVar1;\n                    }\n                    memmove((void *)((long)local_108 + sVar6),param_1,sVar7 + 1);\n                    param_1 = (char *)memcpy(local_108,__s_00,sVar6);\n                    pcVar11 = __s + 1;\n                    if (*__s_00 == '/') {\n                      *__s = '/';\n                    }\n                    else {\n                      bVar2 = pcVar11 < __dest;\n                      pcVar11 = __dest;\n                      if ((bVar2) && (pcVar11 = __dest + -1, __s < pcVar11)) {\n                        do {\n                          if (pcVar11[-1] == '/') break;\n                          pcVar11 = pcVar11 + -1;\n                        } while (__s != pcVar11);\n                      }\n                    }\n                    free(__s_00);\n                    local_100 = param_1;\n                    goto LAB_0010d87a;\n                  }\n                  piVar8 = __errno_location();\n                  iVar5 = *piVar8;\n                  if ((uVar9 == 2) && (iVar5 != 0xc)) goto LAB_0010d9bc;\n                }\n                else {\n                  if (uVar9 == 2) {\nLAB_0010d9bc:\n                    cVar4 = pcVar14[1];\n                    goto LAB_0010d882;\n                  }\n                  piVar8 = __errno_location();\n                  iVar5 = 0x28;\n                }\n              }\n              else {\n                piVar8 = __errno_location();\n                iVar5 = *piVar8;\n                if ((param_2 & 3) != 0) {\n                  if (uVar9 != 1) goto LAB_0010d860;\n                  sVar6 = strspn(param_1,\"/\");\n                  if ((param_1[sVar6] == '\\0') && (iVar5 == 2)) goto LAB_0010d9bc;\n                }\n              }\n            }\n            free(local_108);\n            free(__s);\n            if (local_e0 != 0) {\n              hash_free();\n            }\n            *piVar8 = iVar5;\n            __s = (char *)0x0;\n            goto LAB_0010d8e0;\n          }\n          if ((__s + 1 < __dest) && (__dest = __dest + -1, __s < __dest)) {\n            do {\n              if (__dest[-1] == '/') break;\n              __dest = __dest + -1;\n            } while (__dest != __s);\n          }\n        }\nLAB_0010d882:\n      } while (cVar4 != '\\0');\n      goto LAB_0010d890;\n    }\n    local_108 = (void *)0x0;\n    pcVar11 = __dest;\nLAB_0010d8a3:\n    __dest = pcVar11 + 1;\n  }\n  else {\n    __s = (char *)xgetcwd();\n    if (__s == (char *)0x0) goto LAB_0010d8e0;\n    sVar6 = strlen(__s);\n    if (sVar6 < 0x1000) {\n      __s = (char *)xrealloc(__s,0x1000);\n      __dest = __s + sVar6;\n      pcVar12 = __s + 0x1000;\n    }\n    else {\n      __dest = __s + sVar6;\n      pcVar12 = __dest;\n    }\n    cVar4 = *param_1;\n    if (cVar4 != '\\0') goto LAB_0010d741;\n    local_108 = (void *)0x0;\nLAB_0010d890:\n    pcVar11 = __dest;\n    if ((__dest <= __s + 1) || (__dest[-1] != '/')) goto LAB_0010d8a3;\n    pcVar11 = __dest + -1;\n  }\n  *pcVar11 = '\\0';\n  if (__dest != pcVar12) {\n    __s = (char *)xrealloc(__s,pcVar11 + (1 - (long)__s));\n  }\n  free(local_108);\n  if (local_e0 != 0) {\n    hash_free();\n  }\nLAB_0010d8e0:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return __s;\n}\n\n", 
    "00104dfa": "\nvoid safe_hasher_cold(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "0010d040": "\nlong argmatch(char *param_1,char **param_2,void *param_3,size_t param_4)\n\n{\n  bool bVar1;\n  long lVar2;\n  int iVar3;\n  size_t __n;\n  size_t sVar4;\n  long lVar5;\n  void *__s2;\n  char *__s1;\n  long local_58;\n  \n  __n = strlen(param_1);\n  __s1 = *param_2;\n  if (__s1 == (char *)0x0) {\n    local_58 = -1;\n    lVar5 = local_58;\n  }\n  else {\n    bVar1 = false;\n    lVar5 = 0;\n    local_58 = -1;\n    __s2 = param_3;\n    do {\n      iVar3 = strncmp(__s1,param_1,__n);\n      lVar2 = local_58;\n      if (iVar3 == 0) {\n        sVar4 = strlen(__s1);\n        if (sVar4 == __n) {\n          return lVar5;\n        }\n        lVar2 = lVar5;\n        if (local_58 != -1) {\n          if (param_3 == (void *)0x0) {\n            bVar1 = true;\n            lVar2 = local_58;\n          }\n          else {\n            iVar3 = memcmp((void *)(local_58 * param_4 + (long)param_3),__s2,param_4);\n            lVar2 = local_58;\n            if (iVar3 != 0) {\n              bVar1 = true;\n            }\n          }\n        }\n      }\n      local_58 = lVar2;\n      lVar5 = lVar5 + 1;\n      __s2 = (void *)((long)__s2 + param_4);\n      __s1 = param_2[lVar5];\n    } while (__s1 != (char *)0x0);\n    lVar5 = -2;\n    if (!bVar1) {\n      lVar5 = local_58;\n    }\n  }\n  local_58 = lVar5;\n  return local_58;\n}\n\n", 
    "001260f8": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __stack_chk_fail(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __stack_chk_fail@@GLIBC_2.4 */\n  halt_baddata();\n}\n\n", 
    "00104910": "\nvoid __stack_chk_fail(void)\n\n{\n  (*(code *)PTR___stack_chk_fail_00123d40)();\n  return;\n}\n\n", 
    "001260f0": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint __lxstat(int __ver,char *__filename,stat *__stat_buf)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __lxstat@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00104950": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\ngroup * getgrgid(__gid_t __gid)\n\n{\n  group *pgVar1;\n  \n  pgVar1 = (group *)(*(code *)PTR_getgrgid_00123d60)();\n  return pgVar1;\n}\n\n", 
    "00108b60": "\nvoid put_indicator_isra_0(size_t *param_1,void **param_2)\n\n{\n  __pid_t _Var1;\n  \n  if (used_color == '\\0') {\n    used_color = '\\x01';\n    _Var1 = tcgetpgrp(1);\n    if (_Var1 < 0) {\n      prep_non_filename_text();\n    }\n    else {\n      signal_init();\n      prep_non_filename_text();\n    }\n  }\n  fwrite_unlocked(*param_2,*param_1,1,stdout);\n  return;\n}\n\n", 
    "0010ef90": "\nlong hash_get_next(long param_1,long param_2)\n\n{\n  long lVar1;\n  long *plVar2;\n  long *plVar3;\n  \n  plVar2 = (long *)safe_hasher();\n  plVar3 = plVar2;\n  do {\n    lVar1 = *plVar3;\n    plVar3 = (long *)plVar3[1];\n    if (lVar1 == param_2) {\n      if (plVar3 != (long *)0x0) {\n        return *plVar3;\n      }\n      break;\n    }\n  } while (plVar3 != (long *)0x0);\n  do {\n    plVar2 = plVar2 + 2;\n    if (*(long **)(param_1 + 8) <= plVar2) {\n      return 0;\n    }\n  } while (*plVar2 == 0);\n  return *plVar2;\n}\n\n", 
    "00108a40": "\nvoid strcmp_extension(undefined8 param_1,undefined8 param_2)\n\n{\n  cmp_extension_isra_0(param_1,param_2,PTR_strcmp_00123fc8);\n  return;\n}\n\n", 
    "001174d0": "\nint rpl_fclose(FILE *param_1)\n\n{\n  int iVar1;\n  int iVar2;\n  int *piVar3;\n  __off_t _Var4;\n  \n  iVar1 = fileno(param_1);\n  if (-1 < iVar1) {\n    iVar1 = __freading();\n    if (iVar1 != 0) {\n      iVar1 = fileno(param_1);\n      _Var4 = lseek(iVar1,0,1);\n      if (_Var4 == -1) goto LAB_0011753f;\n    }\n    iVar1 = rpl_fflush(param_1);\n    if (iVar1 != 0) {\n      piVar3 = __errno_location();\n      iVar1 = *piVar3;\n      iVar2 = fclose(param_1);\n      if (iVar1 != 0) {\n        *piVar3 = iVar1;\n        iVar2 = -1;\n      }\n      return iVar2;\n    }\n  }\nLAB_0011753f:\n  iVar1 = fclose(param_1);\n  return iVar1;\n}\n\n", 
    "00106cc0": "\nvoid format_user_width(undefined4 param_1)\n\n{\n  undefined8 uVar1;\n  \n  if (numeric_ids != '\\0') {\n    format_user_or_group_width(0,param_1);\n    return;\n  }\n  uVar1 = getuser();\n  format_user_or_group_width(uVar1,param_1);\n  return;\n}\n\n", 
    "00104ae0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint sigemptyset(sigset_t *__set)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_sigemptyset_00123e28)();\n  return iVar1;\n}\n\n", 
    "0010fc00": "\nvoid * group_number(long param_1,size_t param_2,byte *param_3,char *param_4)\n\n{\n  byte bVar1;\n  size_t __n;\n  void *pvVar2;\n  undefined *__src;\n  size_t __n_00;\n  ulong uVar3;\n  ulong uVar4;\n  long in_FS_OFFSET;\n  undefined auStack_78 [56];\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  __n = strlen(param_4);\n  __memcpy_chk(auStack_78,param_1,param_2,0x29);\n  pvVar2 = (void *)(param_1 + param_2);\n  __n_00 = 0xffffffffffffffff;\n  while( true ) {\n    bVar1 = *param_3;\n    if (bVar1 == 0) {\n      if (param_2 < __n_00) {\n        __n_00 = param_2;\n      }\n      uVar4 = param_2 - __n_00;\n      __src = auStack_78 + uVar4;\n    }\n    else {\n      if (bVar1 < 0x7f) {\n        uVar3 = (ulong)bVar1;\n        if (param_2 < bVar1) {\n          uVar3 = param_2;\n        }\n        uVar4 = param_2 - uVar3;\n        __src = auStack_78 + uVar4;\n        param_2 = uVar3;\n      }\n      else {\n        uVar4 = 0;\n        __src = auStack_78;\n      }\n      param_3 = param_3 + 1;\n      __n_00 = param_2;\n    }\n    pvVar2 = memcpy((void *)((long)pvVar2 - __n_00),__src,__n_00);\n    if (uVar4 == 0) break;\n    pvVar2 = memcpy((void *)((long)pvVar2 - __n),param_4,__n);\n    param_2 = uVar4;\n  }\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return pvVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "001260c8": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\npasswd * getpwuid(__uid_t __uid)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* getpwuid@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010ed50": "\nbool hash_table_ok(long **param_1)\n\n{\n  long lVar1;\n  long *plVar2;\n  long *plVar3;\n  long *plVar4;\n  \n  plVar2 = *param_1;\n  plVar3 = (long *)0x0;\n  plVar4 = (long *)0x0;\n  do {\n    while( true ) {\n      if (param_1[1] <= plVar2) {\n        if (param_1[3] != plVar4) {\n          return false;\n        }\n        return param_1[4] == plVar3;\n      }\n      if (*plVar2 != 0) break;\nLAB_0010ed70:\n      plVar2 = plVar2 + 2;\n    }\n    lVar1 = plVar2[1];\n    plVar4 = (long *)((long)plVar4 + 1);\n    plVar3 = (long *)((long)plVar3 + 1);\n    if (lVar1 == 0) goto LAB_0010ed70;\n    do {\n      lVar1 = *(long *)(lVar1 + 8);\n      plVar3 = (long *)((long)plVar3 + 1);\n    } while (lVar1 != 0);\n    plVar2 = plVar2 + 2;\n  } while( true );\n}\n\n", 
    "00108070": "\nvoid extract_dirs_from_files(long param_1,undefined param_2)\n\n{\n  long *plVar1;\n  int iVar2;\n  char **ppcVar3;\n  char *pcVar4;\n  long *plVar5;\n  char cVar6;\n  void *__ptr;\n  long *plVar7;\n  long lVar8;\n  \n  if ((param_1 != 0) && (active_dir_set != 0)) {\n    queue_directory(0,param_1,0);\n  }\n  lVar8 = cwd_n_used + -1;\n  if (cwd_n_used != 0) {\nLAB_00108102:\n    do {\n      ppcVar3 = (char **)sorted_file[lVar8];\n      cVar6 = is_directory_isra_0(*(undefined4 *)(ppcVar3 + 0x15));\n      if (cVar6 != '\\0') {\n        pcVar4 = *ppcVar3;\n        if (param_1 == 0) {\nLAB_00108125:\n          queue_directory(pcVar4,ppcVar3[1],param_2);\n          iVar2 = *(int *)(ppcVar3 + 0x15);\n        }\n        else {\n          cVar6 = basename_is_dot_or_dotdot(pcVar4);\n          if (cVar6 != '\\0') goto LAB_001080f8;\n          if (*pcVar4 == '/') goto LAB_00108125;\n          __ptr = (void *)file_name_concat(param_1,pcVar4,0);\n          queue_directory(__ptr,ppcVar3[1],param_2);\n          free(__ptr);\n          iVar2 = *(int *)(ppcVar3 + 0x15);\n        }\n        if (iVar2 == 9) {\n          lVar8 = lVar8 + -1;\n          free_ent(ppcVar3);\n          if (lVar8 == -1) break;\n          goto LAB_00108102;\n        }\n      }\nLAB_001080f8:\n      lVar8 = lVar8 + -1;\n    } while (lVar8 != -1);\n    plVar5 = sorted_file;\n    if (cwd_n_used != 0) {\n      plVar1 = sorted_file + cwd_n_used;\n      cwd_n_used = 0;\n      plVar7 = sorted_file;\n      do {\n        iVar2 = *(int *)(*plVar7 + 0xa8);\n        plVar5[cwd_n_used] = *plVar7;\n        plVar7 = plVar7 + 1;\n        cwd_n_used = cwd_n_used + (ulong)(iVar2 != 9);\n      } while (plVar1 != plVar7);\n      return;\n    }\n  }\n  cwd_n_used = 0;\n  return;\n}\n\n", 
    "001260c0": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nDIR * opendir(char *__name)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* opendir@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010e580": "\nint filevercmp(char *param_1,char *param_2)\n\n{\n  char cVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  long lVar6;\n  size_t sVar7;\n  size_t __n;\n  long in_FS_OFFSET;\n  char *local_40;\n  char *local_38;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar3 = strcmp(param_1,param_2);\n  if (iVar3 == 0) goto LAB_0010e5e9;\n  cVar1 = *param_1;\n  if (cVar1 == '\\0') {\nLAB_0010e6e8:\n    iVar3 = -1;\n    goto LAB_0010e5e9;\n  }\n  cVar2 = *param_2;\n  if (cVar2 == '\\0') {\nLAB_0010e5e3:\n    iVar3 = 1;\n    goto LAB_0010e5e9;\n  }\n  if ((cVar1 == '.') && (param_1[1] == '\\0')) goto LAB_0010e6e8;\n  if ((*param_2 == '.') && (param_2[1] == '\\0')) goto LAB_0010e5e3;\n  if (((*param_1 == '.') && (param_1[1] == '.')) && (param_1[2] == '\\0')) goto LAB_0010e6e8;\n  if (((*param_2 == '.') && (param_2[1] == '.')) && (param_2[2] == '\\0')) goto LAB_0010e5e3;\n  if ((cVar2 != '.') && (cVar1 == '.')) goto LAB_0010e6e8;\n  if ((cVar1 != '.') && (cVar2 == '.')) goto LAB_0010e5e3;\n  if ((cVar1 == '.') && (cVar2 == '.')) {\n    param_1 = param_1 + 1;\n    param_2 = param_2 + 1;\n  }\n  local_40 = param_1;\n  local_38 = param_2;\n  lVar5 = match_suffix(&local_40);\n  lVar6 = match_suffix(&local_38);\n  if (lVar5 == 0) {\n    __n = (long)local_40 - (long)param_1;\n    if (lVar6 != 0) goto LAB_0010e696;\nLAB_0010e705:\n    sVar7 = (long)local_38 - (long)param_2;\n  }\n  else {\n    __n = lVar5 - (long)param_1;\n    if (lVar6 == 0) {\n      sVar7 = (long)local_38 - (long)param_2;\n    }\n    else {\nLAB_0010e696:\n      sVar7 = lVar6 - (long)param_2;\n    }\n    if ((__n == sVar7) && (iVar4 = strncmp(param_1,param_2,__n), iVar4 == 0)) {\n      __n = (long)local_40 - (long)param_1;\n      goto LAB_0010e705;\n    }\n  }\n  iVar4 = verrevcmp(param_1,__n,param_2,sVar7);\n  if (iVar4 != 0) {\n    iVar3 = iVar4;\n  }\nLAB_0010e5e9:\n  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return iVar3;\n}\n\n", 
    "0010d490": "\nbool c_isprint(int param_1)\n\n{\n  return param_1 - 0x20U < 0x5f;\n}\n\n", 
    "00116df0": "\nundefined8 * tzalloc(char *param_1)\n\n{\n  ulong uVar1;\n  size_t sVar2;\n  undefined8 *puVar3;\n  ulong uVar4;\n  \n  if (param_1 == (char *)0x0) {\n    puVar3 = (undefined8 *)malloc(0x80);\n    if (puVar3 != (undefined8 *)0x0) {\n      *puVar3 = 0;\n      *(undefined2 *)(puVar3 + 1) = 0;\n      return puVar3;\n    }\n  }\n  else {\n    sVar2 = strlen(param_1);\n    uVar1 = sVar2 + 1;\n    uVar4 = 0x76;\n    if (0x75 < uVar1) {\n      uVar4 = uVar1;\n    }\n    puVar3 = (undefined8 *)malloc(uVar4 + 0x11 & 0xfffffffffffffff8);\n    if (puVar3 != (undefined8 *)0x0) {\n      *puVar3 = 0;\n      *(undefined2 *)(puVar3 + 1) = 1;\n      extend_abbrs((long)puVar3 + 9,param_1,uVar1);\n    }\n  }\n  return puVar3;\n}\n\n", 
    "001261e8": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint sigemptyset(sigset_t *__set)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* sigemptyset@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001063d0": "\nundefined8 known_term_type(void)\n\n{\n  int iVar1;\n  char *__name;\n  size_t sVar2;\n  byte *pbVar3;\n  undefined8 uVar4;\n  long lVar5;\n  char *__s;\n  byte *pbVar6;\n  bool bVar7;\n  bool bVar8;\n  byte bVar9;\n  \n  bVar9 = 0;\n  __name = getenv(\"TERM\");\n  if ((__name == (char *)0x0) || (*__name == '\\0')) {\nLAB_00106458:\n    uVar4 = 0;\n  }\n  else {\n    __s = \"# Configuration file for dircolors, a utility to help you set the\";\n    do {\n      do {\n        sVar2 = strlen(__s);\n        __s = (char *)((byte *)__s + sVar2 + 1);\n        pbVar3 = (byte *)__s + -0x118760;\n        bVar7 = pbVar3 < (byte *)0x1043;\n        bVar8 = pbVar3 == (byte *)0x1043;\n        if ((byte *)0x1043 < pbVar3) goto LAB_00106458;\n        lVar5 = 5;\n        pbVar3 = (byte *)__s;\n        pbVar6 = (byte *)\"TERM \";\n        do {\n          if (lVar5 == 0) break;\n          lVar5 = lVar5 + -1;\n          bVar7 = *pbVar3 < *pbVar6;\n          bVar8 = *pbVar3 == *pbVar6;\n          pbVar3 = pbVar3 + (ulong)bVar9 * -2 + 1;\n          pbVar6 = pbVar6 + (ulong)bVar9 * -2 + 1;\n        } while (bVar8);\n      } while ((!bVar7 && !bVar8) != bVar7);\n      iVar1 = fnmatch((char *)((byte *)__s + 5),__name,0);\n    } while (iVar1 != 0);\n    uVar4 = 1;\n  }\n  return uVar4;\n}\n\n", 
    "00111570": "\nlong memcpy_uppcase(long param_1,long param_2,long param_3)\n\n{\n  __int32_t **pp_Var1;\n  \n  if (param_3 != 0) {\n    param_3 = param_3 + -1;\n    pp_Var1 = __ctype_toupper_loc();\n    do {\n      *(char *)(param_1 + param_3) = (char)(*pp_Var1)[*(byte *)(param_2 + param_3)];\n      param_3 = param_3 + -1;\n    } while (param_3 != -1);\n  }\n  return param_1;\n}\n\n", 
    "00112f40": "\nvoid set_program_name(char *param_1)\n\n{\n  char *pcVar1;\n  long lVar2;\n  ulong uVar3;\n  byte *pbVar4;\n  uint *puVar5;\n  bool bVar6;\n  bool bVar7;\n  byte bVar8;\n  \n  bVar8 = 0;\n  if (param_1 == (char *)0x0) {\n    fwrite(&UINT_0011c200,1,0x37,stderr);\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  pcVar1 = strrchr(param_1,0x2f);\n  if (pcVar1 != (char *)0x0) {\n    program_name = pcVar1 + 1;\n    uVar3 = (long)program_name - (long)param_1;\n    bVar6 = uVar3 < 6;\n    bVar7 = uVar3 == 6;\n    if (6 < (long)uVar3) {\n      lVar2 = 7;\n      pbVar4 = (byte *)(pcVar1 + -6);\n      puVar5 = &UINT_0011c238;\n      do {\n        if (lVar2 == 0) break;\n        lVar2 = lVar2 + -1;\n        bVar6 = *pbVar4 < *(byte *)puVar5;\n        bVar7 = *pbVar4 == *(byte *)puVar5;\n        pbVar4 = pbVar4 + (ulong)bVar8 * -2 + 1;\n        puVar5 = (uint *)((long)puVar5 + (ulong)bVar8 * -2 + 1);\n      } while (bVar7);\n      if ((!bVar6 && !bVar7) == bVar6) {\n        if (((pcVar1[1] != 'l') || (pcVar1[2] != 't')) || (pcVar1[3] != '-')) {\n          program_invocation_name = program_name;\n          return;\n        }\n        param_1 = pcVar1 + 4;\n        program_invocation_short_name = param_1;\n      }\n    }\n  }\n  program_name = param_1;\n  program_invocation_name = param_1;\n  return;\n}\n\n", 
    "00104820": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint wcswidth(wchar_t *__s,size_t __n)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_wcswidth_00123cc8)();\n  return iVar1;\n}\n\n", 
    "00104940": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * strchr(char *__s,int __c)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_strchr_00123d58)();\n  return pcVar1;\n}\n\n", 
    "001261e0": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __memcpy_chk(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __memcpy_chk@@GLIBC_2.3.4 */\n  halt_baddata();\n}\n\n", 
    "00104700": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint strcmp(char *__s1,char *__s2)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_strcmp_00123fc8)();\n  return iVar1;\n}\n\n", 
    "0010dd90": "\nvoid dir_len(char *param_1)\n\n{\n  char cVar1;\n  long lVar2;\n  ulong uVar3;\n  \n  cVar1 = *param_1;\n  lVar2 = last_component();\n  uVar3 = lVar2 - (long)param_1;\n  do {\n    if (uVar3 <= (cVar1 == '/')) {\n      return;\n    }\n    lVar2 = uVar3 - 1;\n    uVar3 = uVar3 - 1;\n  } while (param_1[lVar2] == '/');\n  return;\n}\n\n", 
    "00108a50": "\nundefined8 rev_xstrcoll_df_extension(long param_1,long param_2)\n\n{\n  char cVar1;\n  char cVar2;\n  long lVar3;\n  undefined8 uVar4;\n  \n  lVar3 = param_2;\n  cVar1 = is_directory_isra_0(*(undefined4 *)(param_1 + 0xa8));\n  cVar2 = is_directory_isra_0(*(undefined4 *)(param_2 + 0xa8));\n  if ((cVar2 == '\\x01') || (cVar1 == '\\0')) {\n    if ((cVar1 == '\\x01') || (uVar4 = 1, cVar2 == '\\0')) {\n      uVar4 = cmp_extension_isra_0(lVar3,param_1,xstrcoll);\n      return uVar4;\n    }\n  }\n  else {\n    uVar4 = 0xffffffff;\n  }\n  return uVar4;\n}\n\n", 
    "001173c0": "\nulong close_stream(FILE *param_1)\n\n{\n  int iVar1;\n  long lVar2;\n  ulong uVar3;\n  int *piVar4;\n  \n  lVar2 = __fpending();\n  iVar1 = ferror_unlocked(param_1);\n  uVar3 = rpl_fclose(param_1);\n  if (iVar1 == 0) {\n    if ((int)uVar3 == 0) {\n      return uVar3;\n    }\n    if (lVar2 == 0) {\n      piVar4 = __errno_location();\n      return (ulong)-(uint)(*piVar4 != 9);\n    }\n  }\n  else if ((int)uVar3 == 0) {\n    piVar4 = __errno_location();\n    *piVar4 = 0;\n    return 0xffffffff;\n  }\n  return 0xffffffff;\n}\n\n", 
    "00104ad0": "\nvoid __memcpy_chk(void)\n\n{\n  (*(code *)PTR___memcpy_chk_00123e20)();\n  return;\n}\n\n", 
    "00105ce0": "\nvoid free_pending_ent(void **param_1)\n\n{\n  free(*param_1);\n  free(param_1[1]);\n  (*(code *)PTR_free_00123fb0)(param_1);\n  return;\n}\n\n", 
    "00104bf0": "\nvoid __freading(void)\n\n{\n  (*(code *)PTR___freading_00123eb0)();\n  return;\n}\n\n", 
    "001151e0": "\nvoid quotearg_custom_mem(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4\n                        )\n\n{\n  quotearg_n_custom_mem(0,param_1,param_2,param_3,param_4);\n  return;\n}\n\n", 
    "0010fd30": "\nundefined8 humblock(char *param_1,undefined8 *param_2,uint *param_3)\n\n{\n  char *pcVar1;\n  char cVar2;\n  int iVar3;\n  undefined8 uVar4;\n  uint uVar5;\n  long in_FS_OFFSET;\n  char *local_38;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  if (((param_1 == (char *)0x0) && (param_1 = getenv(\"BLOCK_SIZE\"), param_1 == (char *)0x0)) &&\n     (param_1 = getenv(\"BLOCKSIZE\"), param_1 == (char *)0x0)) {\n    uVar4 = default_block_size();\n    uVar5 = 0;\n    *param_2 = uVar4;\n  }\n  else {\n    uVar5 = 0;\n    if (*param_1 == '\\'') {\n      param_1 = param_1 + 1;\n      uVar5 = 4;\n    }\n    iVar3 = argmatch(param_1,block_size_args,&block_size_opts,4);\n    if (iVar3 < 0) {\n      uVar4 = xstrtoumax(param_1,&local_38,0,param_2,\"eEgGkKmMpPtTyYzZ0\");\n      if ((int)uVar4 != 0) {\n        *param_3 = 0;\n        goto LAB_0010fda8;\n      }\n      cVar2 = *param_1;\n      while (9 < (byte)(cVar2 - 0x30U)) {\n        if (local_38 == param_1) {\n          if (local_38[-1] == 'B') {\n            uVar5 = uVar5 | 0x180;\n            if (local_38[-2] != 'i') break;\n          }\n          else {\n            uVar5 = uVar5 | 0x80;\n          }\n          uVar5 = uVar5 | 0x20;\n          break;\n        }\n        pcVar1 = param_1 + 1;\n        param_1 = param_1 + 1;\n        cVar2 = *pcVar1;\n      }\n    }\n    else {\n      *param_2 = 1;\n      uVar5 = uVar5 | *(uint *)((long)&block_size_opts + (long)iVar3 * 4);\n    }\n  }\n  *param_3 = uVar5;\n  uVar4 = 0;\nLAB_0010fda8:\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar4;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "001062a0": "\nvoid queue_directory(long param_1,long param_2,undefined param_3)\n\n{\n  long *plVar1;\n  \n  plVar1 = (long *)xmalloc(0x20);\n  if (param_2 != 0) {\n    param_2 = xstrdup(param_2);\n  }\n  plVar1[1] = param_2;\n  if (param_1 != 0) {\n    param_1 = xstrdup(param_1);\n  }\n  *plVar1 = param_1;\n  *(undefined *)(plVar1 + 2) = param_3;\n  plVar1[3] = (long)pending_dirs;\n  pending_dirs = plVar1;\n  return;\n}\n\n", 
    "001261f8": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * memcpy(void *__dest,void *__src,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* memcpy@@GLIBC_2.14 */\n  halt_baddata();\n}\n\n", 
    "0010e9b0": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nulong compute_bucket_size_isra_0(float param_1,ulong param_2,char param_3)\n\n{\n  ulong uVar1;\n  float fVar2;\n  \n  if (param_3 == '\\0') {\n    if ((long)param_2 < 0) {\n      fVar2 = (float)(param_2 >> 1 | (ulong)((uint)param_2 & 1));\n      fVar2 = fVar2 + fVar2;\n    }\n    else {\n      fVar2 = (float)param_2;\n    }\n    fVar2 = fVar2 / param_1;\n    if (_DAT_0011bf68 <= fVar2) {\n      return 0;\n    }\n    if (fVar2 < _DAT_0011bf6c) {\n      param_2 = (ulong)fVar2;\n    }\n    else {\n      param_2 = (long)(fVar2 - _DAT_0011bf6c) ^ 0x8000000000000000;\n    }\n  }\n  uVar1 = next_prime(param_2);\n  if (((uVar1 >> 0x3c & 1) == 0) && (uVar1 >> 0x3d == 0)) {\n    return uVar1;\n  }\n  return 0;\n}\n\n", 
    "00114970": "\nundefined1 *\nquotearg_n_options(int param_1,undefined8 param_2,undefined8 param_3,undefined4 *param_4)\n\n{\n  long lVar1;\n  int iVar2;\n  uint uVar3;\n  undefined4 uVar4;\n  ulong uVar5;\n  int *piVar6;\n  undefined1 (*pauVar7) [16];\n  ulong uVar8;\n  undefined1 *__ptr;\n  \n  piVar6 = __errno_location();\n  iVar2 = *piVar6;\n  if (param_1 < 0) {\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  pauVar7 = (undefined1 (*) [16])slotvec;\n  if (nslots <= param_1) {\n    if (param_1 == 0x7fffffff) {\n                    /* WARNING: Subroutine does not return */\n      xalloc_die();\n    }\n    if (slotvec == slotvec0) {\n      pauVar7 = (undefined1 (*) [16])xrealloc(0);\n      slotvec = (undefined *)pauVar7;\n      *pauVar7 = slotvec0;\n    }\n    else {\n      pauVar7 = (undefined1 (*) [16])xrealloc(slotvec);\n      slotvec = (undefined *)pauVar7;\n    }\n    memset(pauVar7[nslots],0,(long)((param_1 + 1) - nslots) << 4);\n    nslots = param_1 + 1;\n  }\n  uVar3 = param_4[1];\n  pauVar7 = pauVar7[param_1];\n  uVar5 = *(ulong *)*pauVar7;\n  __ptr = *(undefined1 **)(*pauVar7 + 8);\n  uVar8 = quotearg_buffer_restyled\n                    (__ptr,uVar5,param_2,param_3,*param_4,uVar3 | 1,param_4 + 2,\n                     *(undefined8 *)(param_4 + 10),*(undefined8 *)(param_4 + 0xc));\n  if (uVar5 <= uVar8) {\n    lVar1 = uVar8 + 1;\n    *(long *)*pauVar7 = lVar1;\n    if (__ptr != slot0) {\n      free(__ptr);\n    }\n    __ptr = (undefined1 *)xcharalloc(lVar1);\n    uVar4 = *param_4;\n    *(undefined1 **)(*pauVar7 + 8) = __ptr;\n    quotearg_buffer_restyled\n              (__ptr,lVar1,param_2,param_3,uVar4,uVar3 | 1,param_4 + 2,*(undefined8 *)(param_4 + 10)\n               ,*(undefined8 *)(param_4 + 0xc));\n  }\n  *piVar6 = iVar2;\n  return __ptr;\n}\n\n", 
    "001260d8": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid dcgettext(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* dcgettext@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00104930": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t mbrtowc(wchar_t *__pwc,char *__s,size_t __n,mbstate_t *__p)\n\n{\n  size_t sVar1;\n  \n  sVar1 = (*(code *)PTR_mbrtowc_00123d50)();\n  return sVar1;\n}\n\n", 
    "001261f0": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __gmon_start__(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n  halt_baddata();\n}\n\n", 
    "001260d0": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid bindtextdomain(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* bindtextdomain@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00104810": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint iswcntrl(wint_t __wc)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_iswcntrl_00123cc0)();\n  return iVar1;\n}\n\n"
}