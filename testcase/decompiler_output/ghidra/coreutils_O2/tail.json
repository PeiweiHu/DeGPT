{
    "0010c820": "\nint c_tolower(int param_1)\n\n{\n  if (param_1 - 0x41U < 0x1a) {\n    param_1 = param_1 + 0x20;\n  }\n  return param_1;\n}\n\n", 
    "00107840": "\nlong __xargmatch_internal\n               (undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n               undefined8 param_5,code *param_6)\n\n{\n  long lVar1;\n  \n  lVar1 = argmatch(param_2,param_3,param_4,param_5);\n  if (lVar1 < 0) {\n    argmatch_invalid(param_1,param_2,lVar1);\n    argmatch_valid(param_3,param_4,param_5);\n    (*param_6)();\n    lVar1 = -1;\n  }\n  return lVar1;\n}\n\n", 
    "0010293e": "\nvoid quotearg_n_options_cold(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "00104cc0": "\nvoid check_output_alive(void)\n\n{\n  int iVar1;\n  long lVar2;\n  __fd_mask *p_Var3;\n  long in_FS_OFFSET;\n  timeval local_a8;\n  ulong local_98 [17];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  if (monitor_output != '\\0') {\n    local_a8.tv_sec = 0;\n    local_a8.tv_usec = 0;\n    p_Var3 = (__fd_mask *)local_98;\n    for (lVar2 = 0x10; lVar2 != 0; lVar2 = lVar2 + -1) {\n      *p_Var3 = 0;\n      p_Var3 = p_Var3 + 1;\n    }\n    local_98[0] = local_98[0] | 2;\n    iVar1 = select(2,(fd_set *)local_98,(fd_set *)0x0,(fd_set *)0x0,&local_a8);\n    if (iVar1 == 1) {\n      raise(0xd);\n    }\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "001151b0": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __freading(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __freading@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00115108": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nssize_t read(int __fd,void *__buf,size_t __nbytes)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* read@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00108370": "\nlong hash_get_first(long **param_1)\n\n{\n  long lVar1;\n  long *plVar2;\n  \n  if (param_1[4] == (long *)0x0) {\n    return 0;\n  }\n  plVar2 = *param_1;\n  if (param_1[1] <= plVar2) {\n    lVar1 = hash_get_first_cold();\n    return lVar1;\n  }\n  do {\n    if (*plVar2 != 0) {\n      return *plVar2;\n    }\n    plVar2 = plVar2 + 2;\n  } while (plVar2 < param_1[1]);\n  lVar1 = hash_get_first_cold();\n  return lVar1;\n}\n\n", 
    "001028d0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fflush_unlocked(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_fflush_unlocked_00113fb0)();\n  return iVar1;\n}\n\n", 
    "001027b0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint inotify_add_watch(int __fd,char *__name,uint32_t __mask)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_inotify_add_watch_00113f20)();\n  return iVar1;\n}\n\n", 
    "00115228": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid _ITM_registerTMCloneTable(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n  halt_baddata();\n}\n\n", 
    "0010c8c0": "\nulong close_stream(FILE *param_1)\n\n{\n  int iVar1;\n  long lVar2;\n  ulong uVar3;\n  int *piVar4;\n  \n  lVar2 = __fpending();\n  iVar1 = ferror_unlocked(param_1);\n  uVar3 = rpl_fclose(param_1);\n  if (iVar1 == 0) {\n    if ((int)uVar3 == 0) {\n      return uVar3;\n    }\n    if (lVar2 == 0) {\n      piVar4 = __errno_location();\n      return (ulong)-(uint)(*piVar4 != 9);\n    }\n  }\n  else if ((int)uVar3 == 0) {\n    piVar4 = __errno_location();\n    *piVar4 = 0;\n    return 0xffffffff;\n  }\n  return 0xffffffff;\n}\n\n", 
    "0010b290": "\nvoid quote_n(undefined8 param_1,undefined8 param_2)\n\n{\n  quote_n_mem(param_1,param_2,0xffffffffffffffff);\n  return;\n}\n\n", 
    "00103c40": "\nvoid xwrite_stdout(void *param_1,ulong param_2)\n\n{\n  size_t sVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  int *piVar4;\n  \n  if (param_2 == 0) {\n    return;\n  }\n  sVar1 = fwrite_unlocked(param_1,1,param_2,stdout);\n  if (param_2 <= sVar1) {\n    return;\n  }\n  clearerr_unlocked(stdout);\n  uVar2 = quotearg_style(4,\"standard output\");\n  uVar3 = dcgettext(0,\"error writing %s\",5);\n  piVar4 = __errno_location();\n                    /* WARNING: Subroutine does not return */\n  error(1,*piVar4,uVar3,uVar2);\n}\n\n", 
    "00102948": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid version_etc_arn_cold(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "00115230": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fflush_unlocked(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fflush_unlocked@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00115110": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __libc_start_main(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __libc_start_main@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00102700": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint strcmp(char *__s1,char *__s2)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_strcmp_00113ec8)();\n  return iVar1;\n}\n\n", 
    "00102943": "\nvoid set_custom_quoting_cold(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "001151b8": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t fwrite_unlocked(void *__ptr,size_t __size,size_t __n,FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fwrite_unlocked@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00102820": "\nvoid __printf_chk(void)\n\n{\n  (*(code *)PTR___printf_chk_00113f58)();\n  return;\n}\n\n", 
    "0010c710": "\nulong c_iscntrl(uint param_1)\n\n{\n  ulong in_RAX;\n  \n  if ((int)param_1 < 0x20) {\n    return (ulong)(~param_1 >> 0x1f);\n  }\n  return in_RAX & 0xffffffffffffff00 | (ulong)(param_1 == 0x7f);\n}\n\n", 
    "0010aec0": "\nvoid quotearg_n(undefined8 param_1,undefined8 param_2)\n\n{\n  quotearg_n_options(param_1,param_2,0xffffffffffffffff,default_quoting_options);\n  return;\n}\n\n", 
    "0010ba70": "\nvoid xnmalloc(ulong param_1,ulong param_2)\n\n{\n  if ((-1 < SUB168(ZEXT816(param_1) * ZEXT816(param_2),0)) &&\n     (SUB168(ZEXT816(param_1) * ZEXT816(param_2) >> 0x40,0) == 0)) {\n    xmalloc();\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  xalloc_die();\n}\n\n", 
    "001151c0": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * realloc(void *__ptr,size_t __size)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* realloc@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010292f": "\nvoid hash_insert_if_absent_cold(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "001150a0": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __stack_chk_fail(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __stack_chk_fail@@GLIBC_2.4 */\n  halt_baddata();\n}\n\n", 
    "00102020": "\nvoid FUN_00102020(void)\n\n{\n                    /* WARNING: Treating indirect jump as call */\n  (*(code *)PTR_00113d98)();\n  return;\n}\n\n", 
    "0010292a": "\nvoid hash_rehash_cold(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "00108120": "\nulong hash_get_max_bucket_length(long **param_1)\n\n{\n  long lVar1;\n  long *plVar2;\n  ulong uVar3;\n  ulong uVar4;\n  \n  plVar2 = *param_1;\n  uVar4 = 0;\n  do {\n    if (param_1[1] <= plVar2) {\n      return uVar4;\n    }\n    while (*plVar2 != 0) {\n      uVar3 = 1;\n      for (lVar1 = plVar2[1]; lVar1 != 0; lVar1 = *(long *)(lVar1 + 8)) {\n        uVar3 = uVar3 + 1;\n      }\n      if (uVar4 < uVar3) {\n        uVar4 = uVar3;\n      }\n      plVar2 = plVar2 + 2;\n      if (param_1[1] <= plVar2) {\n        return uVar4;\n      }\n    }\n    plVar2 = plVar2 + 2;\n  } while( true );\n}\n\n", 
    "0010cb60": "\nvoid rpl_fflush(FILE *param_1)\n\n{\n  int iVar1;\n  \n  if (param_1 != (FILE *)0x0) {\n    iVar1 = __freading();\n    if (iVar1 != 0) {\n      clear_ungetc_buffer_preserving_position(param_1);\n      fflush(param_1);\n      return;\n    }\n  }\n  fflush(param_1);\n  return;\n}\n\n", 
    "00108480": "\nlong hash_do_for_each(long **param_1,code *param_2,undefined8 param_3)\n\n{\n  char cVar1;\n  long *plVar2;\n  long lVar3;\n  long lVar4;\n  long *plVar5;\n  \n  plVar5 = *param_1;\n  if (param_1[1] < plVar5 || param_1[1] == plVar5) {\n    lVar4 = 0;\n  }\n  else {\n    lVar4 = 0;\n    do {\n      lVar3 = *plVar5;\n      plVar2 = plVar5;\n      if (lVar3 != 0) {\n        while( true ) {\n          cVar1 = (*param_2)(lVar3,param_3);\n          if (cVar1 == '\\0') {\n            return lVar4;\n          }\n          plVar2 = (long *)plVar2[1];\n          lVar4 = lVar4 + 1;\n          if (plVar2 == (long *)0x0) break;\n          lVar3 = *plVar2;\n        }\n      }\n      plVar5 = plVar5 + 2;\n    } while (plVar5 <= param_1[1] && param_1[1] != plVar5);\n  }\n  return lVar4;\n}\n\n", 
    "001028c0": "\nvoid __fprintf_chk(void)\n\n{\n  (*(code *)PTR___fprintf_chk_00113fa8)();\n  return;\n}\n\n", 
    "00115238": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint mbsinit(mbstate_t *__ps)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* mbsinit@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001027a0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fflush(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_fflush_00113f18)();\n  return iVar1;\n}\n\n", 
    "00105090": "\nvoid check_fspec(undefined8 *param_1,undefined8 *param_2)\n\n{\n  uint uVar1;\n  int iVar2;\n  undefined8 uVar3;\n  long lVar4;\n  int *piVar5;\n  undefined8 uVar6;\n  long in_FS_OFFSET;\n  undefined auVar7 [16];\n  stat sStack_c8;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  if (*(int *)(param_1 + 7) != -1) {\n    uVar3 = pretty_name_isra_0(*param_1);\n    uVar1 = fstat(*(int *)(param_1 + 7),&sStack_c8);\n    if (uVar1 == 0) {\n      if ((*(uint *)(param_1 + 6) & 0xf000) == 0x8000) {\n        if (sStack_c8.st_size < (long)param_1[1]) {\n          uVar3 = quotearg_n_style_colon(0,3,uVar3);\n          uVar6 = dcgettext(0,\"%s: file truncated\",5);\n                    /* WARNING: Subroutine does not return */\n          error(0,0,uVar6,uVar3);\n        }\n        if (sStack_c8.st_size == param_1[1]) {\n          auVar7 = get_stat_mtime_isra_0(sStack_c8.st_mtim.tv_sec,sStack_c8.st_mtim.tv_nsec);\n          iVar2 = timespec_cmp(param_1[2],param_1[3],SUB168(auVar7,0),SUB168(auVar7 >> 0x40,0));\n          if (iVar2 == 0) goto LAB_0010511d;\n        }\n      }\n      if (print_headers != '\\0') {\n        uVar1 = (uint)((undefined8 *)*param_2 != param_1);\n      }\n      lVar4 = dump_remainder(uVar1,uVar3,*(undefined4 *)(param_1 + 7),0xffffffffffffffff);\n      param_1[1] = param_1[1] + lVar4;\n      if (lVar4 != 0) {\n        *param_2 = param_1;\n        iVar2 = fflush_unlocked(stdout);\n        if (iVar2 != 0) {\n          uVar3 = dcgettext(0,\"write error\",5);\n          piVar5 = __errno_location();\n                    /* WARNING: Subroutine does not return */\n          error(1,*piVar5,uVar3);\n        }\n      }\n    }\n    else {\n      piVar5 = __errno_location();\n      *(int *)((long)param_1 + 0x3c) = *piVar5;\n      close_fd(*(undefined4 *)(param_1 + 7),uVar3);\n      *(undefined4 *)(param_1 + 7) = 0xffffffff;\n    }\n  }\nLAB_0010511d:\n  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n", 
    "00115118": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint memcmp(void *__s1,void *__s2,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* memcmp@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00102939": "\nvoid quotearg_buffer_restyled_cold(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "0010ae10": "\nvoid quotearg_alloc(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  quotearg_alloc_mem(param_1,param_2,0,param_3);\n  return;\n}\n\n", 
    "00109480": "\nundefined8\nstrcaseeq2(long param_1,undefined8 param_2,byte param_3,char param_4,char param_5,char param_6,\n          char param_7)\n\n{\n  char cVar1;\n  byte bVar2;\n  undefined8 uVar3;\n  \n  cVar1 = c_isupper((int)(char)param_3);\n  bVar2 = *(byte *)(param_1 + 2);\n  if (cVar1 != '\\0') {\n    bVar2 = bVar2 & 0xdf;\n  }\n  if (param_3 != bVar2) {\n    return 0;\n  }\n  if (param_3 == 0) {\n    return 1;\n  }\n  uVar3 = strcaseeq3(param_1,param_2,(int)param_4,(int)param_5,(int)param_6,(int)param_7);\n  return uVar3;\n}\n\n", 
    "0010b180": "\nvoid quotearg_n_custom_mem\n               (undefined4 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n               undefined8 param_5)\n\n{\n  long in_FS_OFFSET;\n  undefined8 local_68;\n  undefined8 uStack_60;\n  undefined8 local_58;\n  undefined8 uStack_50;\n  undefined8 local_48;\n  undefined8 uStack_40;\n  undefined8 local_38;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  local_68 = default_quoting_options._0_8_;\n  uStack_60 = default_quoting_options._8_8_;\n  local_38 = default_quoting_options._48_8_;\n  local_58 = default_quoting_options._16_8_;\n  uStack_50 = default_quoting_options._24_8_;\n  local_48 = default_quoting_options._32_8_;\n  uStack_40 = default_quoting_options._40_8_;\n  set_custom_quoting(&local_68);\n  quotearg_n_options(param_1,param_4,param_5,&local_68);\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00115240": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint iswprint(wint_t __wc)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* iswprint@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001043c0": "\nundefined8 pipe_bytes(undefined8 param_1,undefined4 param_2,ulong param_3,long *param_4)\n\n{\n  ulong uVar1;\n  void *pvVar2;\n  void *pvVar3;\n  size_t __n;\n  ulong uVar4;\n  undefined8 uVar5;\n  undefined8 uVar6;\n  int *piVar7;\n  void *__ptr;\n  long lVar8;\n  void *__ptr_00;\n  void *pvVar9;\n  ulong uVar10;\n  \n  pvVar2 = (void *)xmalloc(0x2010);\n  *(undefined8 *)((long)pvVar2 + 0x2000) = 0;\n  *(undefined8 *)((long)pvVar2 + 0x2008) = 0;\n  pvVar3 = (void *)xmalloc(0x2010);\n  __ptr = pvVar3;\n  pvVar9 = pvVar2;\n  uVar10 = 0;\n  while (__ptr_00 = __ptr, __ptr = pvVar2, __n = safe_read(param_2,pvVar3,0x2000),\n        __n - 1 < 0xfffffffffffffffe) {\n    uVar10 = uVar10 + __n;\n    *param_4 = *param_4 + __n;\n    *(size_t *)((long)__ptr_00 + 0x2000) = __n;\n    lVar8 = *(long *)((long)pvVar9 + 0x2000);\n    *(undefined8 *)((long)__ptr_00 + 0x2008) = 0;\n    pvVar2 = __ptr;\n    if (lVar8 + __n < 0x2000) {\n      memcpy((void *)(lVar8 + (long)pvVar9),pvVar3,__n);\n      *(long *)((long)pvVar9 + 0x2000) =\n           *(long *)((long)pvVar9 + 0x2000) + *(long *)((long)__ptr_00 + 0x2000);\n      __ptr = __ptr_00;\n    }\n    else {\n      *(void **)((long)pvVar9 + 0x2008) = __ptr_00;\n      uVar4 = uVar10 - *(long *)((long)__ptr + 0x2000);\n      pvVar9 = __ptr_00;\n      if (param_3 < uVar4) {\n        pvVar2 = *(void **)((long)__ptr + 0x2008);\n        pvVar3 = __ptr;\n        uVar10 = uVar4;\n      }\n      else {\n        pvVar3 = (void *)xmalloc(0x2010);\n        __ptr = pvVar3;\n      }\n    }\n  }\n  free(__ptr_00);\n  if (__n != 0xffffffffffffffff) {\n    lVar8 = *(long *)((long)__ptr + 0x2000);\n    uVar4 = uVar10 - lVar8;\n    pvVar2 = __ptr;\n    while (uVar1 = uVar4, param_3 < uVar1) {\n      pvVar2 = *(void **)((long)pvVar2 + 0x2008);\n      lVar8 = *(long *)((long)pvVar2 + 0x2000);\n      uVar10 = uVar1;\n      uVar4 = uVar1 - lVar8;\n    }\n    pvVar3 = pvVar2;\n    if (param_3 < uVar10) {\n      lVar8 = lVar8 + (param_3 - uVar10);\n      pvVar3 = (void *)((long)pvVar2 + (uVar10 - param_3));\n    }\n    xwrite_stdout(pvVar3,lVar8);\n    for (lVar8 = *(long *)((long)pvVar2 + 0x2008); lVar8 != 0; lVar8 = *(long *)(lVar8 + 0x2008)) {\n      xwrite_stdout(lVar8,*(undefined8 *)(lVar8 + 0x2000));\n    }\n    do {\n      pvVar2 = *(void **)((long)__ptr + 0x2008);\n      free(__ptr);\n      __ptr = pvVar2;\n    } while (pvVar2 != (void *)0x0);\n    return 1;\n  }\n  uVar5 = quotearg_style(4,param_1);\n  uVar6 = dcgettext(0,\"error reading %s\",5);\n  piVar7 = __errno_location();\n                    /* WARNING: Subroutine does not return */\n  error(0,*piVar7,uVar6,uVar5);\n}\n\n", 
    "00115120": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fputs_unlocked(char *__s,FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fputs_unlocked@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00115000": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * getenv(char *__name)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* getenv@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00102810": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * setlocale(int __category,char *__locale)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_setlocale_00113f50)();\n  return pcVar1;\n}\n\n", 
    "00102934": "\nvoid quoting_options_from_style_cold(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "0010afe0": "\nvoid quotearg_style(undefined4 param_1,undefined8 param_2)\n\n{\n  quotearg_n_style(0,param_1,param_2);\n  return;\n}\n\n", 
    "0010b860": "\nvoid version_etc_ar(void)\n\n{\n  long lVar1;\n  long *in_R8;\n  long lVar2;\n  \n  lVar2 = 0;\n  lVar1 = *in_R8;\n  while (lVar1 != 0) {\n    lVar2 = lVar2 + 1;\n    lVar1 = in_R8[lVar2];\n  }\n  version_etc_arn();\n  return;\n}\n\n", 
    "001151c8": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * setlocale(int __category,char *__locale)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* setlocale@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001150a8": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid getopt_long(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* getopt_long@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00107fb0": "\nundefined8 transfer_entries(long param_1,long **param_2,char param_3)\n\n{\n  long lVar1;\n  long *plVar2;\n  long *plVar3;\n  long *plVar4;\n  long *plVar5;\n  long lVar6;\n  \n  plVar5 = *param_2;\n  if (param_2[1] <= plVar5) {\n    return 1;\n  }\n  do {\n    while (lVar6 = *plVar5, lVar6 == 0) {\nLAB_00107fe0:\n      plVar5 = plVar5 + 2;\n      if (param_2[1] < plVar5 || param_2[1] == plVar5) {\n        return 1;\n      }\n    }\n    plVar3 = (long *)plVar5[1];\n    if ((long *)plVar5[1] != (long *)0x0) {\n      do {\n        while( true ) {\n          lVar6 = *plVar3;\n          plVar2 = (long *)safe_hasher(param_1,lVar6);\n          plVar4 = (long *)plVar3[1];\n          if (*plVar2 != 0) break;\n          *plVar2 = lVar6;\n          *(long *)(param_1 + 0x18) = *(long *)(param_1 + 0x18) + 1;\n          free_entry_isra_0(param_1 + 0x48);\n          plVar3 = plVar4;\n          if (plVar4 == (long *)0x0) goto LAB_00108050;\n        }\n        plVar3[1] = plVar2[1];\n        plVar2[1] = (long)plVar3;\n        plVar3 = plVar4;\n      } while (plVar4 != (long *)0x0);\nLAB_00108050:\n      lVar6 = *plVar5;\n    }\n    plVar5[1] = 0;\n    if (param_3 != '\\0') goto LAB_00107fe0;\n    plVar3 = (long *)safe_hasher(param_1,lVar6);\n    if (*plVar3 == 0) {\n      *plVar3 = lVar6;\n      *(long *)(param_1 + 0x18) = *(long *)(param_1 + 0x18) + 1;\n    }\n    else {\n      plVar4 = (long *)allocate_entry_isra_0(param_1 + 0x48);\n      if (plVar4 == (long *)0x0) {\n        return 0;\n      }\n      lVar1 = plVar3[1];\n      *plVar4 = lVar6;\n      plVar4[1] = lVar1;\n      plVar3[1] = (long)plVar4;\n    }\n    *plVar5 = 0;\n    plVar5 = plVar5 + 2;\n    param_2[3] = (long *)((long)param_2[3] + -1);\n    if (param_2[1] < plVar5 || param_2[1] == plVar5) {\n      return 1;\n    }\n  } while( true );\n}\n\n", 
    "00107740": "\nvoid argmatch_valid(long *param_1,void *param_2,size_t param_3)\n\n{\n  long lVar1;\n  FILE *__stream;\n  int iVar2;\n  char *__s;\n  undefined8 uVar3;\n  long lVar4;\n  void *__s1;\n  \n  __stream = stderr;\n  __s1 = (void *)0x0;\n  __s = (char *)dcgettext(0,\"Valid arguments are:\",5);\n  fputs_unlocked(__s,__stream);\n  lVar4 = 0;\n  lVar1 = *param_1;\n  while (lVar1 != 0) {\n    if ((lVar4 == 0) || (iVar2 = memcmp(__s1,param_2,param_3), iVar2 != 0)) {\n      uVar3 = quote(lVar1);\n      __fprintf_chk(stderr,1,\"\\n  - %s\",uVar3);\n      __s1 = param_2;\n    }\n    else {\n      uVar3 = quote(lVar1);\n      __fprintf_chk(stderr,1,&DAT_0010e522,uVar3);\n    }\n    lVar4 = lVar4 + 1;\n    param_2 = (void *)((long)param_2 + param_3);\n    lVar1 = param_1[lVar4];\n  }\n  putc_unlocked(10,stderr);\n  return;\n}\n\n", 
    "00108e80": "\nchar * offtostr(ulong param_1,long param_2)\n\n{\n  ulong uVar1;\n  char *pcVar2;\n  char *pcVar3;\n  \n  *(undefined *)(param_2 + 0x14) = 0;\n  pcVar2 = (char *)(param_2 + 0x14);\n  if ((long)param_1 < 0) {\n    do {\n      pcVar3 = pcVar2;\n      uVar1 = (long)param_1 / 10;\n      pcVar3[-1] = ((char)uVar1 * '\\n' + '0') - (char)param_1;\n      param_1 = uVar1;\n      pcVar2 = pcVar3 + -1;\n    } while (uVar1 != 0);\n    pcVar3[-2] = '-';\n    return pcVar3 + -2;\n  }\n  do {\n    pcVar2 = pcVar2 + -1;\n    uVar1 = param_1 / 10;\n    *pcVar2 = (char)param_1 + (char)uVar1 * -10 + '0';\n    param_1 = uVar1;\n  } while (uVar1 != 0);\n  return pcVar2;\n}\n\n", 
    "00115208": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __cxa_atexit(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __cxa_atexit@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010b0e0": "\nvoid quotearg_n_style_colon(undefined4 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  long in_FS_OFFSET;\n  undefined8 local_98;\n  undefined8 uStack_90;\n  undefined8 local_88;\n  undefined8 uStack_80;\n  undefined8 local_78;\n  undefined8 uStack_70;\n  undefined8 local_68;\n  undefined8 local_58;\n  undefined8 uStack_50;\n  undefined8 local_48;\n  undefined8 uStack_40;\n  undefined8 local_38;\n  undefined8 uStack_30;\n  undefined8 local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  quoting_options_from_style(&local_98);\n  puVar1 = &local_58;\n  local_58 = local_98;\n  uStack_50 = uStack_90;\n  local_48 = local_88;\n  uStack_40 = uStack_80;\n  local_38 = local_78;\n  uStack_30 = uStack_70;\n  local_28 = local_68;\n  set_char_quoting(puVar1,0x3a,1);\n  quotearg_n_options(param_1,param_3,0xffffffffffffffff,puVar1);\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "001027d0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint __fxstat(int __ver,int __fildes,stat *__stat_buf)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR___fxstat_00113f30)();\n  return iVar1;\n}\n\n", 
    "001026b0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nssize_t read(int __fd,void *__buf,size_t __nbytes)\n\n{\n  ssize_t sVar1;\n  \n  sVar1 = (*(code *)PTR_read_00113ea0)();\n  return sVar1;\n}\n\n", 
    "001037a0": "\nchar any_remote_file(long param_1,long param_2)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  \n  pcVar2 = (char *)(param_1 + 0x35);\n  pcVar1 = pcVar2 + param_2 * 0x60;\n  while ((*(int *)(pcVar2 + 3) < 0 || (*pcVar2 == '\\0'))) {\n    pcVar2 = pcVar2 + 0x60;\n    if (pcVar2 == pcVar1) {\n      return '\\0';\n    }\n  }\n  return *pcVar2;\n}\n\n", 
    "00115210": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid exit(int __status)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* exit@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001028f0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint iswprint(wint_t __wc)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_iswprint_00113fc0)();\n  return iVar1;\n}\n\n", 
    "001075a0": "\nlong argmatch(char *param_1,char **param_2,void *param_3,size_t param_4)\n\n{\n  bool bVar1;\n  long lVar2;\n  int iVar3;\n  size_t __n;\n  size_t sVar4;\n  long lVar5;\n  void *__s2;\n  char *__s1;\n  long local_58;\n  \n  __n = strlen(param_1);\n  __s1 = *param_2;\n  if (__s1 == (char *)0x0) {\n    local_58 = -1;\n    lVar5 = local_58;\n  }\n  else {\n    bVar1 = false;\n    lVar5 = 0;\n    local_58 = -1;\n    __s2 = param_3;\n    do {\n      iVar3 = strncmp(__s1,param_1,__n);\n      lVar2 = local_58;\n      if (iVar3 == 0) {\n        sVar4 = strlen(__s1);\n        if (sVar4 == __n) {\n          return lVar5;\n        }\n        lVar2 = lVar5;\n        if (local_58 != -1) {\n          if (param_3 == (void *)0x0) {\n            bVar1 = true;\n            lVar2 = local_58;\n          }\n          else {\n            iVar3 = memcmp((void *)(local_58 * param_4 + (long)param_3),__s2,param_4);\n            lVar2 = local_58;\n            if (iVar3 != 0) {\n              bVar1 = true;\n            }\n          }\n        }\n      }\n      local_58 = lVar2;\n      lVar5 = lVar5 + 1;\n      __s2 = (void *)((long)__s2 + param_4);\n      __s1 = param_2[lVar5];\n    } while (__s1 != (char *)0x0);\n    lVar5 = -2;\n    if (!bVar1) {\n      lVar5 = local_58;\n    }\n  }\n  local_58 = lVar5;\n  return local_58;\n}\n\n", 
    "00104d50": "\nbool usable_st_size_isra_0(uint param_1)\n\n{\n  return (param_1 & 0xd000) == 0x8000;\n}\n\n", 
    "00104c30": "\nundefined8 any_symlinks(char **param_1,long param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  char **ppcVar3;\n  long in_FS_OFFSET;\n  stat sStack_b8;\n  long local_20;\n  \n  ppcVar3 = param_1 + param_2 * 0xc;\n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  while( true ) {\n    iVar1 = lstat(*param_1,&sStack_b8);\n    if ((iVar1 == 0) && ((sStack_b8.st_mode & 0xf000) == 0xa000)) break;\n    param_1 = param_1 + 0xc;\n    if (param_1 == ppcVar3) {\n      uVar2 = 0;\nLAB_00104c8a:\n      if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n        return uVar2;\n      }\n                    /* WARNING: Subroutine does not return */\n      __stack_chk_fail();\n    }\n  }\n  uVar2 = 1;\n  goto LAB_00104c8a;\n}\n\n", 
    "0010af00": "\nvoid quotearg_mem(undefined8 param_1,undefined8 param_2)\n\n{\n  quotearg_n_mem(0,param_1,param_2);\n  return;\n}\n\n", 
    "0010cab0": "\nint rpl_fclose(FILE *param_1)\n\n{\n  int iVar1;\n  int iVar2;\n  int *piVar3;\n  __off_t _Var4;\n  \n  iVar1 = fileno(param_1);\n  if (-1 < iVar1) {\n    iVar1 = __freading();\n    if (iVar1 != 0) {\n      iVar1 = fileno(param_1);\n      _Var4 = lseek(iVar1,0,1);\n      if (_Var4 == -1) goto LAB_0010cb1f;\n    }\n    iVar1 = rpl_fflush(param_1);\n    if (iVar1 != 0) {\n      piVar3 = __errno_location();\n      iVar1 = *piVar3;\n      iVar2 = fclose(param_1);\n      if (iVar1 != 0) {\n        *piVar3 = iVar1;\n        iVar2 = -1;\n      }\n      return iVar2;\n    }\n  }\nLAB_0010cb1f:\n  iVar1 = fclose(param_1);\n  return iVar1;\n}\n\n", 
    "0010b270": "\nvoid quote_n_mem(void)\n\n{\n  quotearg_n_options();\n  return;\n}\n\n", 
    "00102840": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * memrchr(void *__s,int __c,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = (void *)(*(code *)PTR_memrchr_00113f68)();\n  return pvVar1;\n}\n\n", 
    "001081f0": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid hash_print_statistics(undefined8 param_1,undefined8 param_2)\n\n{\n  undefined8 uVar1;\n  ulong uVar2;\n  ulong uVar3;\n  undefined8 uVar4;\n  double dVar5;\n  double dVar6;\n  \n  uVar1 = hash_get_n_entries();\n  uVar2 = hash_get_n_buckets();\n  uVar3 = hash_get_n_buckets_used();\n  uVar4 = hash_get_max_bucket_length();\n  __fprintf_chk(param_2,1,\"# entries:         %lu\\n\",uVar1);\n  __fprintf_chk(param_2,1,\"# buckets:         %lu\\n\",uVar2);\n  if ((long)uVar3 < 0) {\n    dVar5 = (double)(uVar3 >> 1 | (ulong)((uint)uVar3 & 1));\n    dVar5 = dVar5 + dVar5;\n  }\n  else {\n    dVar5 = (double)uVar3;\n  }\n  if ((long)uVar2 < 0) {\n    dVar6 = (double)(uVar2 >> 1 | (ulong)((uint)uVar2 & 1));\n    dVar6 = dVar6 + dVar6;\n  }\n  else {\n    dVar6 = (double)uVar2;\n  }\n  __fprintf_chk((dVar5 * _DAT_0010e5d0) / dVar6,param_2,1,\"# buckets used:    %lu (%.2f%%)\\n\",uVar3)\n  ;\n  __fprintf_chk(param_2,1,\"max bucket length: %lu\\n\",uVar4);\n  return;\n}\n\n", 
    "00102720": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * memcpy(void *__dest,void *__src,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = (void *)(*(code *)PTR_memcpy_00113ed8)();\n  return pvVar1;\n}\n\n", 
    "00102600": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t mbrtowc(wchar_t *__pwc,char *__s,size_t __n,mbstate_t *__p)\n\n{\n  size_t sVar1;\n  \n  sVar1 = (*(code *)PTR_mbrtowc_00113e48)();\n  return sVar1;\n}\n\n", 
    "0010c930": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid dtotimespec(double param_1)\n\n{\n  long lVar1;\n  long lVar2;\n  double dVar3;\n  \n  if (param_1 <= _DAT_0010f2c8) {\n    make_timespec(0x8000000000000000,0);\n    return;\n  }\n  if (param_1 < _DAT_0010f2d0) {\n    dVar3 = (param_1 - (double)(long)param_1) * _DAT_0010ed68;\n    lVar1 = (long)dVar3;\n    lVar1 = (ulong)((double)lVar1 < dVar3) + lVar1;\n    lVar2 = (long)param_1 + lVar1 / 1000000000;\n    lVar1 = lVar1 % 1000000000;\n    if (-1 < lVar1) {\n      make_timespec(lVar2);\n      return;\n    }\n    make_timespec(lVar2 + -1,lVar1 + 1000000000);\n    return;\n  }\n  make_timespec(0x7fffffffffffffff,999999999);\n  return;\n}\n\n", 
    "00108820": "\nundefined4 hash_rehash(void **param_1,undefined8 param_2)\n\n{\n  void *pvVar1;\n  char cVar2;\n  undefined4 uVar3;\n  void *__nmemb;\n  long in_FS_OFFSET;\n  void *local_88;\n  void *local_80;\n  void *local_78;\n  void *local_70;\n  undefined8 local_68;\n  void *local_60;\n  void *local_58;\n  void *local_50;\n  void *local_48;\n  void *local_40;\n  long local_30;\n  \n  pvVar1 = param_1[5];\n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  __nmemb = (void *)compute_bucket_size_isra_0\n                              (*(undefined4 *)((long)pvVar1 + 8),param_2,\n                               *(undefined *)((long)pvVar1 + 0x10));\n  if (__nmemb != (void *)0x0) {\n    if (param_1[2] == __nmemb) {\n      uVar3 = 1;\n      goto LAB_0010892c;\n    }\n    local_88 = calloc((size_t)__nmemb,0x10);\n    if (local_88 != (void *)0x0) {\n      local_80 = (void *)((long)__nmemb * 0x10 + (long)local_88);\n      local_58 = param_1[6];\n      local_50 = param_1[7];\n      local_48 = param_1[8];\n      local_70 = (void *)0x0;\n      local_40 = param_1[9];\n      local_68 = 0;\n      local_78 = __nmemb;\n      local_60 = pvVar1;\n      uVar3 = transfer_entries(&local_88,param_1,0);\n      if ((char)uVar3 == '\\0') {\n        param_1[9] = local_40;\n        cVar2 = transfer_entries(param_1,&local_88,1);\n        if (cVar2 != '\\0') {\n          cVar2 = transfer_entries(param_1,&local_88,0);\n          if (cVar2 != '\\0') {\n            free(local_88);\n            goto LAB_0010892c;\n          }\n        }\n                    /* WARNING: Subroutine does not return */\n        abort();\n      }\n      free(*param_1);\n      *param_1 = local_88;\n      param_1[1] = local_80;\n      param_1[2] = local_78;\n      param_1[3] = local_70;\n      param_1[9] = local_40;\n      goto LAB_0010892c;\n    }\n  }\n  uVar3 = 0;\nLAB_0010892c:\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar3;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00107970": "\ndouble c_strtod(char *param_1,char **param_2)\n\n{\n  __locale_t __loc;\n  double dVar1;\n  \n  __loc = (__locale_t)c_locale();\n  if (__loc != (__locale_t)0x0) {\n    dVar1 = strtod_l(param_1,param_2,__loc);\n    return dVar1;\n  }\n  if (param_2 != (char **)0x0) {\n    *param_2 = param_1;\n  }\n  return 0.0;\n}\n\n", 
    "001151a0": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * nl_langinfo(nl_item __item)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* nl_langinfo@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00115218": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t fwrite(void *__ptr,size_t __size,size_t __n,FILE *__s)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fwrite@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010cb40": "\nvoid clear_ungetc_buffer_preserving_position(uint *param_1)\n\n{\n  if ((*param_1 & 0x100) == 0) {\n    return;\n  }\n  rpl_fseeko(param_1,0,1);\n  return;\n}\n\n", 
    "0010ba50": "\nvoid xmalloc(size_t param_1)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = malloc(param_1);\n  if ((pvVar1 == (void *)0x0) && (param_1 != 0)) {\n                    /* WARNING: Subroutine does not return */\n    xalloc_die();\n  }\n  return;\n}\n\n", 
    "001028e0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint mbsinit(mbstate_t *__ps)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_mbsinit_00113fb8)();\n  return iVar1;\n}\n\n", 
    "001039d0": "\nvoid close_fd(int param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  int *piVar4;\n  \n  if (param_1 + 1U < 2) {\n    return;\n  }\n  iVar1 = close(param_1);\n  if (iVar1 == 0) {\n    return;\n  }\n  uVar2 = quotearg_style(4,param_2);\n  uVar3 = dcgettext(0,\"closing %s (fd=%d)\",5);\n  piVar4 = __errno_location();\n                    /* WARNING: Subroutine does not return */\n  error(0,*piVar4,uVar3,uVar2,param_1);\n}\n\n", 
    "001027c0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * nl_langinfo(nl_item __item)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_nl_langinfo_00113f28)();\n  return pcVar1;\n}\n\n", 
    "001026a0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * memchr(void *__s,int __c,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = (void *)(*(code *)PTR_memchr_00113e98)();\n  return pvVar1;\n}\n\n", 
    "001038b0": "\nvoid emit_mandatory_arg_note(void)\n\n{\n  char *__s;\n  FILE *__stream;\n  \n  __stream = stdout;\n  __s = (char *)dcgettext(0,\n                          \"\\nMandatory arguments to long options are mandatory for short options too.\\n\"\n                          ,5);\n  fputs_unlocked(__s,__stream);\n  return;\n}\n\n", 
    "0010af10": "\nvoid quotearg_n_style(undefined4 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  long in_FS_OFFSET;\n  undefined auStack_58 [56];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  quoting_options_from_style(auStack_58);\n  quotearg_n_options(param_1,param_3,0xffffffffffffffff,auStack_58);\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00115100": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * memchr(void *__s,int __c,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* memchr@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001076b0": "\nvoid argmatch_invalid(undefined8 param_1,undefined8 param_2,long param_3)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  \n  if (param_3 == -1) {\n    uVar1 = dcgettext(0,\"invalid argument %s for %s\",5);\n  }\n  else {\n    uVar1 = dcgettext(0,\"ambiguous argument %s for %s\",5);\n  }\n  uVar2 = quote_n(1,param_1);\n  uVar3 = quotearg_n_style(0,8,param_2);\n                    /* WARNING: Subroutine does not return */\n  error(0,0,uVar1,uVar3,uVar2);\n}\n\n", 
    "0010c490": "\nsize_t rpl_mbrtowc(wchar_t *param_1,byte *param_2,size_t param_3,mbstate_t *param_4)\n\n{\n  char cVar1;\n  size_t sVar2;\n  long in_FS_OFFSET;\n  wchar_t local_34;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_1 == (wchar_t *)0x0) {\n    param_1 = &local_34;\n  }\n  sVar2 = mbrtowc(param_1,(char *)param_2,param_3,param_4);\n  if ((0xfffffffffffffffd < sVar2) && (param_3 != 0)) {\n    cVar1 = hard_locale(0);\n    if (cVar1 == '\\0') {\n      sVar2 = 1;\n      *param_1 = (uint)*param_2;\n    }\n  }\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return sVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "0010b280": "\nvoid quote_mem(undefined8 param_1,undefined8 param_2)\n\n{\n  quote_n_mem(0,param_1,param_2);\n  return;\n}\n\n", 
    "001055f0": "\nvoid recheck(byte **param_1,char param_2)\n\n{\n  uint uVar1;\n  char cVar2;\n  char cVar3;\n  char cVar4;\n  char cVar5;\n  int __fd;\n  int iVar6;\n  uint *puVar7;\n  undefined8 uVar8;\n  int *piVar9;\n  undefined8 uVar10;\n  uint uVar11;\n  char *pcVar12;\n  byte *pbVar13;\n  long in_FS_OFFSET;\n  stat local_d8;\n  long local_40;\n  \n  pbVar13 = *param_1;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  uVar11 = *pbVar13 - 0x2d;\n  if (uVar11 == 0) {\n    uVar11 = (uint)pbVar13[1];\n  }\n  cVar5 = *(char *)((long)param_1 + 0x36);\n  uVar1 = *(uint *)((long)param_1 + 0x3c);\n  if (uVar11 == 0) {\n    __fd = 0;\n    uVar11 = uVar1;\n  }\n  else {\n    __fd = open_safer(pbVar13,(ulong)(param_2 == '\\0') << 0xb);\n    uVar11 = *(uint *)((long)param_1 + 0x3c);\n  }\n  cVar4 = valid_file_spec_isra_0(*(undefined4 *)(param_1 + 7),uVar11);\n  cVar3 = reopen_inaccessible_files;\n  cVar2 = disable_inotify;\n  if (cVar4 == '\\0') {\n                    /* WARNING: Subroutine does not return */\n    __assert_fail(\"valid_file_spec (f)\",\"src/tail.c\",0x3c7,\"recheck\");\n  }\n  if (reopen_inaccessible_files == '\\0') {\n    *(undefined *)((long)param_1 + 0x36) = 1;\n    if (((cVar2 == '\\0') && (iVar6 = lstat((char *)*param_1,&local_d8), iVar6 == 0)) &&\n       ((local_d8.st_mode & 0xf000) == 0xa000)) {\nLAB_00105ad8:\n      *(undefined4 *)((long)param_1 + 0x3c) = 0xffffffff;\n      *(undefined *)((long)param_1 + 0x34) = 1;\n      uVar8 = pretty_name_isra_0(*param_1);\n      uVar8 = quotearg_style(4,uVar8);\n      uVar10 = dcgettext(0,\"%s has been replaced with an untailable symbolic link\",5);\n                    /* WARNING: Subroutine does not return */\n      error(0,0,uVar10,uVar8);\n    }\n    if (__fd != -1) goto LAB_00105743;\nLAB_00105697:\n    puVar7 = (uint *)__errno_location();\n    pbVar13 = *param_1;\n    uVar11 = *puVar7;\n    *(uint *)((long)param_1 + 0x3c) = uVar11;\n    if (*(char *)((long)param_1 + 0x36) == '\\0') {\nLAB_00105859:\n      if (cVar5 != '\\0') {\n        uVar8 = pretty_name_isra_0(pbVar13);\n        uVar8 = quotearg_style(4,uVar8);\n        uVar10 = dcgettext(0,\"%s has become inaccessible\",5);\n                    /* WARNING: Subroutine does not return */\n        error(0,*(undefined4 *)((long)param_1 + 0x3c),uVar10,uVar8);\n      }\n    }\n    else if (uVar11 != uVar1) {\n      uVar8 = pretty_name_isra_0(pbVar13);\n      uVar8 = quotearg_n_style_colon(0,3,uVar8);\n                    /* WARNING: Subroutine does not return */\n      error(0,*puVar7,&DAT_0010e524,uVar8);\n    }\n  }\n  else {\n    if (__fd == -1) {\n      *(undefined *)((long)param_1 + 0x36) = 0;\n      pbVar13 = *param_1;\n      if (cVar2 == '\\0') {\n        iVar6 = lstat((char *)pbVar13,&local_d8);\n        if ((iVar6 == 0) && ((local_d8.st_mode & 0xf000) == 0xa000)) goto LAB_00105ad8;\n        goto LAB_00105697;\n      }\n      piVar9 = __errno_location();\n      *(int *)((long)param_1 + 0x3c) = *piVar9;\n      goto LAB_00105859;\n    }\n    *(undefined *)((long)param_1 + 0x36) = 1;\n    if (((cVar2 == '\\0') && (iVar6 = lstat((char *)*param_1,&local_d8), iVar6 == 0)) &&\n       ((local_d8.st_mode & 0xf000) == 0xa000)) goto LAB_00105ad8;\nLAB_00105743:\n    iVar6 = fstat(__fd,&local_d8);\n    if (iVar6 < 0) goto LAB_00105697;\n    if ((((local_d8.st_mode & 0xf000) - 0x1000 & 0xffffe000) == 0) ||\n       ((local_d8.st_mode & 0xb000) == 0x8000)) {\n      uVar8 = pretty_name_isra_0(*param_1);\n      cVar5 = fremote(__fd,uVar8);\n      *(char *)((long)param_1 + 0x35) = cVar5;\n      if ((cVar5 != '\\0') && (disable_inotify == '\\0')) {\n        *(undefined4 *)((long)param_1 + 0x3c) = 0xffffffff;\n        uVar8 = pretty_name_isra_0(*param_1);\n        uVar8 = quotearg_style(4,uVar8);\n        uVar10 = dcgettext(0,\"%s has been replaced with an untailable remote file\",5);\n                    /* WARNING: Subroutine does not return */\n        error(0,0,uVar10,uVar8);\n      }\n      *(undefined4 *)((long)param_1 + 0x3c) = 0;\n      if ((uVar1 & 0xfffffffd) != 0) {\n        if (*(int *)(param_1 + 7) != -1) {\n                    /* WARNING: Subroutine does not return */\n          __assert_fail(\"f->fd == -1\",\"src/tail.c\",0x414,\"recheck\");\n        }\n        uVar8 = pretty_name_isra_0(*param_1);\n        uVar8 = quotearg_style(4,uVar8);\n        pcVar12 = \"%s has become accessible\";\nLAB_001057e7:\n        uVar10 = dcgettext(0,pcVar12,5);\n                    /* WARNING: Subroutine does not return */\n        error(0,0,uVar10,uVar8);\n      }\n      pbVar13 = *param_1;\n      if (*(int *)(param_1 + 7) == -1) {\n        uVar8 = pretty_name_isra_0(pbVar13);\n        uVar8 = quotearg_style(4,uVar8);\n        pcVar12 = \"%s has appeared;  following new file\";\n        goto LAB_001057e7;\n      }\n      if ((param_1[5] != (byte *)local_d8.st_ino) || (param_1[4] != (byte *)local_d8.st_dev)) {\n        uVar8 = pretty_name_isra_0(pbVar13);\n        uVar8 = quotearg_style(4,uVar8);\n        uVar10 = dcgettext(0,\"%s has been replaced;  following new file\",5);\n                    /* WARNING: Subroutine does not return */\n        error(0,0,uVar10,uVar8);\n      }\n      uVar8 = pretty_name_isra_0(pbVar13);\n      close_fd(__fd,uVar8);\n      goto LAB_001056eb;\n    }\n    *(undefined4 *)((long)param_1 + 0x3c) = 0xffffffff;\n    *(undefined *)((long)param_1 + 0x36) = 0;\n    if ((cVar3 == '\\0') || (follow_mode != 1)) {\n      *(undefined *)((long)param_1 + 0x34) = 1;\n      if ((cVar5 != '\\0') || (uVar1 != 0xffffffff)) {\n        pcVar12 = (char *)dcgettext(0,\"; giving up on this name\",5);\n        pbVar13 = *param_1;\n        goto LAB_00105a5a;\n      }\n      pbVar13 = *param_1;\n    }\n    else {\n      pbVar13 = *param_1;\n      *(undefined *)((long)param_1 + 0x34) = 0;\n      if (cVar5 != '\\0') {\n        pcVar12 = \"\";\nLAB_00105a5a:\n        uVar8 = pretty_name_isra_0(pbVar13);\n        uVar8 = quotearg_style(4,uVar8);\n        uVar10 = dcgettext(0,\"%s has been replaced with an untailable file%s\",5);\n                    /* WARNING: Subroutine does not return */\n        error(0,0,uVar10,uVar8,pcVar12);\n      }\n      pcVar12 = \"\";\n      if (uVar1 != 0xffffffff) goto LAB_00105a5a;\n    }\n  }\n  uVar8 = pretty_name_isra_0(pbVar13);\n  close_fd(__fd,uVar8);\n  uVar8 = pretty_name_isra_0(*param_1);\n  close_fd(*(undefined4 *)(param_1 + 7),uVar8);\n  *(undefined4 *)(param_1 + 7) = 0xffffffff;\nLAB_001056eb:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n", 
    "00115220": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __fprintf_chk(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __fprintf_chk@@GLIBC_2.3.4 */\n  halt_baddata();\n}\n\n", 
    "00103800": "\nuint any_non_regular_fifo(long param_1,long param_2)\n\n{\n  uint *puVar1;\n  uint uVar2;\n  uint *puVar3;\n  \n  puVar3 = (uint *)(param_1 + 0x30);\n  puVar1 = puVar3 + param_2 * 0x18;\n  while (((int)puVar3[2] < 0 || (uVar2 = *puVar3 & 0xf000, uVar2 == 0x1000 || uVar2 == 0x8000))) {\n    puVar3 = puVar3 + 0x18;\n    if (puVar1 == puVar3) {\n      return 0;\n    }\n  }\n  return puVar3[2] & 0xffffff00 | (uint)(uVar2 != 0x1000 && uVar2 != 0x8000);\n}\n\n", 
    "0010baf0": "\nvoid xnrealloc(undefined8 param_1,ulong param_2,ulong param_3)\n\n{\n  if ((-1 < SUB168(ZEXT816(param_2) * ZEXT816(param_3),0)) &&\n     (SUB168(ZEXT816(param_2) * ZEXT816(param_3) >> 0x40,0) == 0)) {\n    xrealloc();\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  xalloc_die();\n}\n\n", 
    "00102950": "\nbyte main(int param_1,undefined8 *param_2)\n\n{\n  char *pcVar1;\n  bool bVar2;\n  byte bVar3;\n  byte bVar4;\n  char cVar5;\n  int iVar6;\n  int iVar7;\n  char **ppcVar8;\n  char **ppcVar9;\n  long lVar10;\n  undefined8 uVar11;\n  int *piVar12;\n  undefined8 uVar13;\n  undefined **ppuVar14;\n  char **ppcVar15;\n  long lVar16;\n  long in_FS_OFFSET;\n  int local_ec;\n  long local_e8;\n  undefined8 local_e0;\n  stat local_d8;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_ec = 0;\n  local_e8 = 10;\n  local_e0 = DAT_0010e4c0;\n  set_program_name(*param_2);\n  setlocale(6,\"\");\n  bindtextdomain(\"coreutils\",\"/usr/local/share/locale\");\n  textdomain(\"coreutils\");\n  atexit(close_stdout);\n  have_read_stdin = '\\0';\n  count_lines = 1;\n  print_headers = 0;\n  from_start = '\\0';\n  forever = '\\0';\n  line_end = 10;\n  bVar3 = parse_obsolete_option(param_1,param_2,&local_e8);\n  param_1 = param_1 - (uint)bVar3;\n  parse_options(param_1,param_2 + bVar3,&local_e8,&local_ec,&local_e0);\n  if ((from_start != '\\0') && (local_e8 != 0)) {\n    local_e8 = local_e8 + -1;\n  }\n  ppuVar14 = &dummy_stdin_7878;\n  lVar16 = 1;\n  if (optind < param_1) {\n    ppuVar14 = (undefined **)(param_2 + bVar3 + optind);\n    lVar16 = (long)(param_1 - optind);\n  }\n  ppcVar15 = ppuVar14 + lVar16;\n  bVar2 = false;\n  ppcVar9 = ppuVar14;\n  do {\n    if ((**ppcVar9 == '-') && ((*ppcVar9)[1] == '\\0')) {\n      bVar2 = true;\n    }\n    ppcVar9 = ppcVar9 + 1;\n  } while (ppcVar9 != ppcVar15);\n  if (bVar2) {\n    if (follow_mode == 1) {\n      uVar11 = quotearg_style(4,&DAT_0010df5f);\n      uVar13 = dcgettext(0,\"cannot follow %s by name\",5);\n                    /* WARNING: Subroutine does not return */\n      error(1,0,uVar13,uVar11);\n    }\n    if (forever != '\\0') {\n      if (((((pid != 0) || (follow_mode != 2)) || (lVar16 != 1)) ||\n          ((iVar6 = fstat(0,&local_d8), iVar6 != 0 || ((local_d8.st_mode & 0xf000) == 0x8000)))) &&\n         (iVar6 = isatty(0), iVar6 != 0)) {\n        uVar11 = dcgettext(0,\"warning: following standard input indefinitely is ineffective\",5);\n                    /* WARNING: Subroutine does not return */\n        error(0,0,uVar11);\n      }\n      goto LAB_00102aef;\n    }\n    if (local_e8 == 0) goto LAB_00102bee;\n  }\n  else {\nLAB_00102aef:\n    if ((local_e8 == 0) && (forever == '\\0')) {\nLAB_00102bee:\n      bVar3 = 0;\n      if (from_start == '\\0') goto LAB_00102b9f;\n    }\n  }\n  ppcVar8 = (char **)xnmalloc(lVar16,0x60);\n  ppcVar9 = ppcVar8;\n  do {\n    pcVar1 = *ppuVar14;\n    ppuVar14 = ppuVar14 + 1;\n    *ppcVar9 = pcVar1;\n    ppcVar9 = ppcVar9 + 0xc;\n  } while (ppuVar14 != ppcVar15);\n  if ((local_ec == 1) || ((lVar16 != 1 && (local_ec == 0)))) {\n    print_headers = 1;\n  }\n  bVar3 = 1;\n  ppcVar15 = ppcVar8;\n  do {\n    ppcVar9 = ppcVar15 + 0xc;\n    bVar4 = tail_file(ppcVar15,local_e8);\n    bVar3 = bVar3 & bVar4;\n    ppcVar15 = ppcVar9;\n  } while (ppcVar8 + lVar16 * 0xc != ppcVar9);\n  if ((forever != '\\0') && (lVar10 = ignore_fifo_and_pipe(ppcVar8,lVar16), lVar10 != 0)) {\n    iVar6 = fstat(1,&local_d8);\n    if (iVar6 < 0) {\n      uVar11 = dcgettext(0,\"standard output\",5);\n      piVar12 = __errno_location();\n                    /* WARNING: Subroutine does not return */\n      error(1,*piVar12,uVar11);\n    }\n    monitor_output = (local_d8.st_mode & 0xf000) == 0x1000;\n    if ((((disable_inotify == '\\0') && (cVar5 = tailable_stdin(ppcVar8,lVar16), cVar5 == '\\0')) &&\n        (cVar5 = any_remote_file(ppcVar8), cVar5 == '\\0')) &&\n       (((cVar5 = any_non_remote_file(ppcVar8), cVar5 != '\\0' &&\n         (cVar5 = any_symlinks(ppcVar8), cVar5 == '\\0')) &&\n        ((cVar5 = any_non_regular_fifo(ppcVar8,lVar16), cVar5 == '\\0' &&\n         ((bVar3 != 0 || (follow_mode != 2)))))))) {\n      iVar6 = inotify_init();\n      if (iVar6 < 0) {\nLAB_00102cee:\n        uVar11 = dcgettext(0,\"inotify cannot be used, reverting to polling\",5);\n        piVar12 = __errno_location();\n                    /* WARNING: Subroutine does not return */\n        error(0,*piVar12,uVar11);\n      }\n      iVar7 = fflush_unlocked(stdout);\n      if (iVar7 != 0) {\n        uVar11 = dcgettext(0,\"write error\",5);\n        piVar12 = __errno_location();\n                    /* WARNING: Subroutine does not return */\n        error(1,*piVar12,uVar11);\n      }\n      cVar5 = tail_forever_inotify(local_e0,iVar6,ppcVar8,lVar16);\n      if (cVar5 != '\\0') goto LAB_00102cee;\n      bVar3 = 1;\n      goto LAB_00102b9f;\n    }\n    disable_inotify = '\\x01';\n    tail_forever(local_e0,ppcVar8,lVar16);\n  }\n  if ((have_read_stdin != '\\0') && (iVar6 = close(0), iVar6 < 0)) {\n    piVar12 = __errno_location();\n                    /* WARNING: Subroutine does not return */\n    error(1,*piVar12,&DAT_0010df5f);\n  }\n  bVar3 = bVar3 ^ 1;\nLAB_00102b9f:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return bVar3;\n}\n\n", 
    "001070f0": "\nvoid parse_options(undefined4 param_1,undefined8 param_2,undefined8 *param_3,undefined4 *param_4,\n                  double *param_5)\n\n{\n  char cVar1;\n  int iVar2;\n  long lVar3;\n  int *piVar4;\n  undefined8 uVar5;\n  undefined8 uVar6;\n  undefined8 extraout_RDX;\n  char *pcVar7;\n  long in_FS_OFFSET;\n  double local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  while (iVar2 = getopt_long(param_1,param_2,\"c:n:fFqs:vz0123456789\",long_options,0), iVar2 != -1) {\n    if (0x85 < iVar2) {\nswitchD_0010717f_caseD_3a:\n      usage(1);\n      goto LAB_0010751c;\n    }\n    if (iVar2 < 0x30) {\n      if (iVar2 == -0x83) {\n        version_etc(stdout,&DAT_0010e125,\"GNU coreutils\",Version,\"Paul Rubin\",\"David MacKenzie\",\n                    \"Ian Lance Taylor\",\"Jim Meyering\",0);\n                    /* WARNING: Subroutine does not return */\n        exit(0);\n      }\n      if (iVar2 == -0x82) {\n        usage(0);\n        uVar5 = extraout_RDX;\nLAB_001073d5:\n        uVar5 = dcgettext(0,\"invalid number of lines\",uVar5);\n        goto LAB_00107321;\n      }\n      goto switchD_0010717f_caseD_3a;\n    }\n    switch(iVar2) {\n    case 0x30:\n    case 0x31:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n      uVar5 = dcgettext(0,\"option used in invalid context -- %c\",5);\n                    /* WARNING: Subroutine does not return */\n      error(1,0,uVar5,iVar2);\n    default:\n      goto switchD_0010717f_caseD_3a;\n    case 0x46:\n      forever = '\\x01';\n      follow_mode = 1;\n      reopen_inaccessible_files = '\\x01';\n      break;\n    case 99:\n    case 0x6e:\n      count_lines = iVar2 == 0x6e;\n      if (*optarg == '+') {\n        from_start = 1;\n      }\n      else if (*optarg == '-') {\n        optarg = optarg + 1;\n      }\n      uVar5 = 5;\n      if (iVar2 == 0x6e) goto LAB_001073d5;\n      uVar5 = dcgettext(0,\"invalid number of bytes\",5);\nLAB_00107321:\n      uVar5 = xdectoumax(optarg,0,0xffffffffffffffff,\"bkKmMGTPEZY0\",uVar5,0);\n      *param_3 = uVar5;\n      break;\n    case 0x66:\n    case 0x84:\n      forever = '\\x01';\n      if (optarg == (char *)0x0) {\n        follow_mode = 2;\n      }\n      else {\n        lVar3 = __xargmatch_internal(\"--follow\",optarg,follow_mode_string,&follow_mode_map,4);\n        follow_mode = *(int *)((long)&follow_mode_map + lVar3 * 4);\n      }\n      break;\n    case 0x71:\n      *param_4 = 2;\n      break;\n    case 0x73:\n      cVar1 = xstrtod(optarg,0,&local_48,c_strtod);\n      if ((cVar1 == '\\0') || (local_48 < 0.0)) {\n        uVar5 = quote(optarg);\n        uVar6 = dcgettext(0,\"invalid number of seconds: %s\",5);\n                    /* WARNING: Subroutine does not return */\n        error(1,0,uVar6,uVar5);\n      }\n      *param_5 = local_48;\n      break;\n    case 0x76:\n      *param_4 = 1;\n      break;\n    case 0x7a:\n      line_end = 0;\n      break;\n    case 0x80:\n      reopen_inaccessible_files = '\\x01';\n      break;\n    case 0x81:\n      uVar5 = dcgettext(0,\"invalid maximum number of unchanged stats between opens\",5);\n      max_n_unchanged_stats_between_opens = xdectoumax(optarg,0,0xffffffffffffffff,\"\",uVar5,0);\n      break;\n    case 0x82:\n      uVar5 = dcgettext(0,\"invalid PID\",5);\n      pid = xdectoumax(optarg,0,0x7fffffff,\"\",uVar5,0);\n      break;\n    case 0x83:\n      presume_input_pipe = 1;\n      break;\n    case 0x85:\n      disable_inotify = 1;\n    }\n  }\n  if (reopen_inaccessible_files == '\\0') {\n    if (pid == 0) goto LAB_0010742f;\n    if (forever == '\\0') {\nLAB_0010751c:\n      uVar5 = dcgettext(0,\"warning: PID ignored; --pid=PID is useful only when following\",5);\n                    /* WARNING: Subroutine does not return */\n      error(0,0,uVar5);\n    }\n  }\n  else {\n    if (forever == '\\0') {\n      reopen_inaccessible_files = '\\0';\n      pcVar7 = \"warning: --retry ignored; --retry is useful only when following\";\nLAB_00107475:\n      uVar5 = dcgettext(0,pcVar7,5);\n                    /* WARNING: Subroutine does not return */\n      error(0,0,uVar5);\n    }\n    if (follow_mode == 2) {\n      pcVar7 = \"warning: --retry only effective for the initial open\";\n      goto LAB_00107475;\n    }\n    if (pid == 0) goto LAB_0010742f;\n  }\n  iVar2 = kill(pid,0);\n  if ((iVar2 != 0) && (piVar4 = __errno_location(), *piVar4 == 0x26)) {\n    uVar5 = dcgettext(0,\"warning: --pid=PID is not supported on this system\",5);\n                    /* WARNING: Subroutine does not return */\n    error(0,0,uVar5);\n  }\nLAB_0010742f:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00102830": "\nvoid error(void)\n\n{\n  (*(code *)PTR_error_00113f60)();\n  return;\n}\n\n", 
    "00103920": "\nlong ignore_fifo_and_pipe(char **param_1,long param_2)\n\n{\n  char **ppcVar1;\n  long lVar2;\n  \n  lVar2 = 0;\n  ppcVar1 = param_1 + param_2 * 0xc;\n  do {\n    if ((((**param_1 == '-') && ((*param_1)[1] == '\\0')) &&\n        (*(char *)((long)param_1 + 0x34) == '\\0')) &&\n       ((-1 < *(int *)(param_1 + 7) && ((*(uint *)(param_1 + 6) & 0xf000) == 0x1000)))) {\n      *(undefined4 *)(param_1 + 7) = 0xffffffff;\n      *(undefined *)((long)param_1 + 0x34) = 1;\n    }\n    else {\n      lVar2 = lVar2 + 1;\n    }\n    param_1 = param_1 + 0xc;\n  } while (ppcVar1 != param_1);\n  return lVar2;\n}\n\n", 
    "00102710": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nlong strtol(char *__nptr,char **__endptr,int __base)\n\n{\n  long lVar1;\n  \n  lVar1 = (*(code *)PTR_strtol_00113ed0)();\n  return lVar1;\n}\n\n", 
    "001151a8": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint __fxstat(int __ver,int __fildes,stat *__stat_buf)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __fxstat@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00107920": "\n__locale_t c_locale(void)\n\n{\n  if (c_locale_cache != (__locale_t)0x0) {\n    return c_locale_cache;\n  }\n  c_locale_cache = newlocale(0x1fbf,\"C\",(__locale_t)0x0);\n  return c_locale_cache;\n}\n\n", 
    "00102590": "\nvoid bindtextdomain(void)\n\n{\n  (*(code *)PTR_bindtextdomain_00113e10)();\n  return;\n}\n\n", 
    "00108c20": "\nundefined8 hash_insert(undefined8 param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  undefined8 local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = hash_insert_if_absent(param_1,param_2,&local_18);\n  if (iVar1 == -1) {\n    param_2 = 0;\n  }\n  else if (iVar1 == 0) {\n    param_2 = local_18;\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return param_2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "0010b0c0": "\nvoid quotearg_colon(undefined8 param_1)\n\n{\n  quotearg_char(param_1,0x3a);\n  return;\n}\n\n", 
    "00107bd0": "\nvoid open_safer(char *param_1,uint param_2,ulong param_3)\n\n{\n  long lVar1;\n  int iVar2;\n  ulong uVar3;\n  long in_FS_OFFSET;\n  \n  uVar3 = 0;\n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((param_2 & 0x40) != 0) {\n    uVar3 = param_3 & 0xffffffff;\n  }\n  iVar2 = open(param_1,param_2,uVar3);\n  fd_safer(iVar2);\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00105060": "\nchar * pretty_name_isra_0(char *param_1)\n\n{\n  char *pcVar1;\n  \n  if ((*param_1 == '-') && (param_1[1] == '\\0')) {\n    pcVar1 = (char *)dcgettext(0,\"standard input\",5);\n    return pcVar1;\n  }\n  return param_1;\n}\n\n", 
    "00108570": "\nvoid ** hash_initialize(undefined8 param_1,undefined1 *param_2,code *param_3,code *param_4,\n                       void *param_5)\n\n{\n  char cVar1;\n  void **__ptr;\n  void *__nmemb;\n  void *pvVar2;\n  void **ppvVar3;\n  \n  if (param_3 == (code *)0x0) {\n    param_3 = raw_hasher;\n  }\n  if (param_4 == (code *)0x0) {\n    param_4 = raw_comparator;\n  }\n  __ptr = (void **)malloc(0x50);\n  ppvVar3 = __ptr;\n  if (__ptr != (void **)0x0) {\n    if (param_2 == (undefined1 *)0x0) {\n      param_2 = default_tuning;\n    }\n    __ptr[5] = param_2;\n    cVar1 = check_tuning_isra_0(__ptr + 5);\n    if (cVar1 != '\\0') {\n      __nmemb = (void *)compute_bucket_size_isra_0\n                                  (*(undefined4 *)(param_2 + 8),param_1,param_2[0x10]);\n      __ptr[2] = __nmemb;\n      if (__nmemb != (void *)0x0) {\n        pvVar2 = calloc((size_t)__nmemb,0x10);\n        *__ptr = pvVar2;\n        if (pvVar2 != (void *)0x0) {\n          __ptr[6] = param_3;\n          __ptr[7] = param_4;\n          __ptr[1] = (void *)((long)__nmemb * 0x10 + (long)pvVar2);\n          __ptr[3] = (void *)0x0;\n          __ptr[4] = (void *)0x0;\n          __ptr[8] = param_5;\n          __ptr[9] = (void *)0x0;\n          return __ptr;\n        }\n      }\n    }\n    ppvVar3 = (void **)0x0;\n    free(__ptr);\n  }\n  return ppvVar3;\n}\n\n", 
    "001079c0": "\nvoid close_stdout_set_file_name(undefined8 param_1)\n\n{\n  file_name = param_1;\n  return;\n}\n\n", 
    "00103f60": "\nundefined8 start_bytes(undefined8 param_1,undefined4 param_2,ulong param_3,long *param_4)\n\n{\n  ulong uVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  int *piVar4;\n  long in_FS_OFFSET;\n  undefined auStack_2038 [8200];\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_3 != 0) {\n    do {\n      uVar1 = safe_read(param_2,auStack_2038,0x2000);\n      if (uVar1 == 0) {\n        uVar2 = 0xffffffff;\n        goto LAB_00103ffa;\n      }\n      if (uVar1 == 0xffffffffffffffff) {\n        uVar2 = quotearg_style(4,param_1);\n        uVar3 = dcgettext(0,\"error reading %s\",5);\n        piVar4 = __errno_location();\n                    /* WARNING: Subroutine does not return */\n        error(0,*piVar4,uVar3,uVar2);\n      }\n      *param_4 = *param_4 + uVar1;\n      if (param_3 < uVar1) {\n        if (uVar1 - param_3 != 0) {\n          xwrite_stdout(auStack_2038 + param_3,uVar1 - param_3);\n        }\n        break;\n      }\n      param_3 = param_3 - uVar1;\n    } while (param_3 != 0);\n  }\n  uVar2 = 0;\nLAB_00103ffa:\n  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n", 
    "00109550": "\nundefined8\nstrcaseeq1(long param_1,undefined8 param_2,byte param_3,char param_4,char param_5,char param_6,\n          char param_7)\n\n{\n  char cVar1;\n  byte bVar2;\n  undefined8 uVar3;\n  \n  cVar1 = c_isupper((int)(char)param_3);\n  bVar2 = *(byte *)(param_1 + 1);\n  if (cVar1 != '\\0') {\n    bVar2 = bVar2 & 0xdf;\n  }\n  if (param_3 != bVar2) {\n    return 0;\n  }\n  if (param_3 == 0) {\n    return 1;\n  }\n  uVar3 = strcaseeq2(param_1,param_2,(int)param_4,(int)param_5,(int)param_6,(int)param_7);\n  return uVar3;\n}\n\n", 
    "00109310": "\nundefined8\nstrcaseeq4(long param_1,undefined8 param_2,byte param_3,char param_4,char param_5,char param_6,\n          char param_7)\n\n{\n  char cVar1;\n  byte bVar2;\n  undefined8 uVar3;\n  \n  cVar1 = c_isupper((int)(char)param_3);\n  bVar2 = *(byte *)(param_1 + 4);\n  if (cVar1 != '\\0') {\n    bVar2 = bVar2 & 0xdf;\n  }\n  if (param_3 != bVar2) {\n    return 0;\n  }\n  if (param_3 == 0) {\n    return 1;\n  }\n  uVar3 = strcaseeq5(param_1,param_2,(int)param_4,(int)param_5,(int)param_6,(int)param_7);\n  return uVar3;\n}\n\n", 
    "0010b250": "\nvoid quotearg_custom_mem(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4\n                        )\n\n{\n  quotearg_n_custom_mem(0,param_1,param_2,param_3,param_4);\n  return;\n}\n\n", 
    "00107d60": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined8 check_tuning_isra_0(float **param_1)\n\n{\n  float fVar1;\n  float *pfVar2;\n  float fVar3;\n  \n  pfVar2 = *param_1;\n  if (pfVar2 == (float *)default_tuning) {\n    return 1;\n  }\n  fVar1 = pfVar2[2];\n  if ((((_DAT_0010e5b4 < fVar1) && (fVar1 < DAT_0010e5b8)) && (_DAT_0010e5bc < pfVar2[3])) &&\n     (_DAT_0010e5c0 <= *pfVar2)) {\n    fVar3 = *pfVar2 + _DAT_0010e5b4;\n    if (((fVar3 < pfVar2[1]) && (pfVar2[1] <= DAT_0010e5c4)) && (fVar3 < fVar1)) {\n      return 1;\n    }\n  }\n  *param_1 = (float *)default_tuning;\n  return 0;\n}\n\n", 
    "0010bbe0": "\nvoid xcalloc(size_t param_1,ulong param_2)\n\n{\n  void *pvVar1;\n  \n  if ((-1 < SUB168(ZEXT816(param_1) * ZEXT816(param_2),0)) &&\n     (SUB168(ZEXT816(param_1) * ZEXT816(param_2) >> 0x40,0) == 0)) {\n    pvVar1 = calloc(param_1,param_2);\n    if (pvVar1 != (void *)0x0) {\n      return;\n    }\n  }\n                    /* WARNING: Subroutine does not return */\n  xalloc_die();\n}\n\n", 
    "00102900": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint inotify_rm_watch(int __fd,int __wd)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_inotify_rm_watch_00113fc8)();\n  return iVar1;\n}\n\n", 
    "0010b010": "\nvoid quotearg_char_mem(undefined8 param_1,undefined8 param_2,char param_3,undefined8 param_4)\n\n{\n  undefined8 *puVar1;\n  long in_FS_OFFSET;\n  undefined8 local_48;\n  undefined8 uStack_40;\n  undefined8 local_38;\n  undefined8 uStack_30;\n  undefined8 local_28;\n  undefined8 uStack_20;\n  undefined8 local_18;\n  long local_10;\n  \n  puVar1 = &local_48;\n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_48 = default_quoting_options._0_8_;\n  uStack_40 = default_quoting_options._8_8_;\n  local_38 = default_quoting_options._16_8_;\n  uStack_30 = default_quoting_options._24_8_;\n  local_28 = default_quoting_options._32_8_;\n  uStack_20 = default_quoting_options._40_8_;\n  local_18 = default_quoting_options._48_8_;\n  set_char_quoting(&local_48,(int)param_3,1,param_4,param_1,param_2);\n  quotearg_n_options(0,param_1,param_2,puVar1);\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00104fd0": "\nulong tail(undefined8 param_1,int param_2,undefined8 param_3,long *param_4)\n\n{\n  int iVar1;\n  uint uVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  int *piVar5;\n  long lVar6;\n  __off_t _Var7;\n  __off_t _Var8;\n  ulong uVar9;\n  uint uVar10;\n  long in_FS_OFFSET;\n  bool bVar11;\n  stat sStack_d8;\n  long lStack_40;\n  \n  bVar11 = count_lines == '\\0';\n  *param_4 = 0;\n  if (bVar11) {\n    uVar9 = tail_bytes();\n    return uVar9;\n  }\n  lStack_40 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = fstat(param_2,&sStack_d8);\n  if (iVar1 != 0) {\n    uVar3 = quotearg_style(4,param_1);\n    uVar4 = dcgettext(0,\"cannot fstat %s\",5);\n    piVar5 = __errno_location();\n                    /* WARNING: Subroutine does not return */\n    error(0,*piVar5,uVar4,uVar3);\n  }\n  uVar10 = (uint)from_start;\n  if (from_start == 0) {\n    if ((presume_input_pipe == '\\0') && ((sStack_d8.st_mode & 0xf000) == 0x8000)) {\n      _Var7 = lseek(param_2,0,1);\n      if (_Var7 != -1) {\n        _Var8 = lseek(param_2,0,2);\n        if (_Var7 < _Var8) {\n          *param_4 = _Var8;\n          uVar10 = 1;\n          if (_Var8 != 0) {\n            uVar10 = file_lines(param_1,param_2,param_3,_Var7,_Var8,param_4);\n          }\n          goto LAB_001049ee;\n        }\n        xlseek(param_2,_Var7,0,param_1);\n      }\n    }\n    uVar10 = pipe_lines(param_1,param_2,param_3,param_4);\n  }\n  else {\n    uVar2 = start_lines(param_1,param_2,param_3,param_4);\n    if (uVar2 == 0) {\n      lVar6 = dump_remainder(0,param_1,param_2,0xffffffffffffffff);\n      *param_4 = *param_4 + lVar6;\n    }\n    else {\n      uVar10 = uVar2 >> 0x1f;\n    }\n  }\nLAB_001049ee:\n  if (lStack_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return (ulong)uVar10;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00102580": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fclose(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_fclose_00113e08)();\n  return iVar1;\n}\n\n", 
    "001093c0": "\nundefined8\nstrcaseeq3(long param_1,undefined8 param_2,byte param_3,char param_4,char param_5,char param_6,\n          char param_7)\n\n{\n  char cVar1;\n  byte bVar2;\n  undefined8 uVar3;\n  \n  cVar1 = c_isupper((int)(char)param_3);\n  bVar2 = *(byte *)(param_1 + 3);\n  if (cVar1 != '\\0') {\n    bVar2 = bVar2 & 0xdf;\n  }\n  if (param_3 != bVar2) {\n    return 0;\n  }\n  if (param_3 == 0) {\n    return 1;\n  }\n  uVar3 = strcaseeq4(param_1,param_2,(int)param_4,(int)param_5,(int)param_6,(int)param_7);\n  return uVar3;\n}\n\n", 
    "00108680": "\nvoid hash_clear(long **param_1)\n\n{\n  long *plVar1;\n  long *plVar2;\n  long *plVar3;\n  long *plVar4;\n  long *plVar5;\n  \n  plVar5 = *param_1;\n  if (*param_1 < param_1[1]) {\n    do {\n      while (*plVar5 != 0) {\n        plVar4 = param_1[8];\n        plVar3 = (long *)plVar5[1];\n        while (plVar3 != (long *)0x0) {\n          if (plVar4 != (long *)0x0) {\n            (*(code *)plVar4)(*plVar3);\n            plVar4 = param_1[8];\n          }\n          plVar1 = (long *)plVar3[1];\n          plVar2 = param_1[9];\n          *plVar3 = 0;\n          plVar3[1] = (long)plVar2;\n          param_1[9] = plVar3;\n          plVar3 = plVar1;\n        }\n        if (plVar4 != (long *)0x0) {\n          (*(code *)plVar4)(*plVar5);\n        }\n        *plVar5 = 0;\n        plVar4 = plVar5 + 2;\n        plVar5[1] = 0;\n        plVar5 = plVar4;\n        if (param_1[1] < plVar4 || param_1[1] == plVar4) goto LAB_0010871b;\n      }\n      plVar5 = plVar5 + 2;\n    } while (plVar5 <= param_1[1] && param_1[1] != plVar5);\n  }\nLAB_0010871b:\n  param_1[3] = (long *)0x0;\n  param_1[4] = (long *)0x0;\n  return;\n}\n\n", 
    "0010ab80": "\nvoid clone_quoting_options(undefined1 *param_1)\n\n{\n  int iVar1;\n  int *piVar2;\n  \n  piVar2 = __errno_location();\n  iVar1 = *piVar2;\n  if (param_1 == (undefined1 *)0x0) {\n    param_1 = default_quoting_options;\n  }\n  xmemdup(param_1,0x38);\n  *piVar2 = iVar1;\n  return;\n}\n\n", 
    "0010bc70": "\nvoid xalloc_die(void)\n\n{\n  undefined8 uVar1;\n  \n  uVar1 = dcgettext(0,\"memory exhausted\",5);\n                    /* WARNING: Subroutine does not return */\n  error(exit_failure,0,&DAT_0010e524,uVar1);\n}\n\n", 
    "00105050": "\nuint valid_file_spec_isra_0(int param_1,int param_2,uint param_3)\n\n{\n  uint in_EAX;\n  \n  return (in_EAX & 0xffffff00 | (uint)(param_1 == -1)) ^\n         (param_3 & 0xffffff00 | (uint)(param_2 == 0));\n}\n\n", 
    "00107590": "\nvoid __argmatch_die(void)\n\n{\n  usage(1);\n  return;\n}\n\n", 
    "0010b0d0": "\nvoid quotearg_colon_mem(undefined8 param_1,undefined8 param_2)\n\n{\n  quotearg_char_mem(param_1,param_2,0x3a);\n  return;\n}\n\n", 
    "0010ca00": "\nbool hard_locale(int param_1)\n\n{\n  byte *pbVar1;\n  long lVar2;\n  byte *pbVar3;\n  bool bVar4;\n  bool bVar5;\n  byte bVar6;\n  \n  bVar6 = 0;\n  pbVar1 = (byte *)setlocale(param_1,(char *)0x0);\n  bVar4 = true;\n  if (pbVar1 != (byte *)0x0) {\n    bVar4 = *pbVar1 < 0x43;\n    bVar5 = *pbVar1 == 0x43;\n    if (bVar5) {\n      bVar4 = false;\n      bVar5 = pbVar1[1] == 0;\n      if (bVar5) {\n        return false;\n      }\n    }\n    lVar2 = 6;\n    pbVar3 = (byte *)0x10f2d8;\n    do {\n      if (lVar2 == 0) break;\n      lVar2 = lVar2 + -1;\n      bVar4 = *pbVar1 < *pbVar3;\n      bVar5 = *pbVar1 == *pbVar3;\n      pbVar1 = pbVar1 + (ulong)bVar6 * -2 + 1;\n      pbVar3 = pbVar3 + (ulong)bVar6 * -2 + 1;\n    } while (bVar5);\n    bVar4 = (!bVar4 && !bVar5) != bVar4;\n  }\n  return bVar4;\n}\n\n", 
    "00115200": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fstatfs(int __fildes,statfs *__buf)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fstatfs@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001083c0": "\nlong hash_get_next(long param_1,long param_2)\n\n{\n  long lVar1;\n  long *plVar2;\n  long *plVar3;\n  \n  plVar2 = (long *)safe_hasher();\n  plVar3 = plVar2;\n  do {\n    lVar1 = *plVar3;\n    plVar3 = (long *)plVar3[1];\n    if (lVar1 == param_2) {\n      if (plVar3 != (long *)0x0) {\n        return *plVar3;\n      }\n      break;\n    }\n  } while (plVar3 != (long *)0x0);\n  do {\n    plVar2 = plVar2 + 2;\n    if (*(long **)(param_1 + 8) <= plVar2) {\n      return 0;\n    }\n  } while (*plVar2 == 0);\n  return *plVar2;\n}\n\n", 
    "00107e70": "\nvoid free_entry_isra_0(undefined8 *param_1,undefined8 *param_2)\n\n{\n  *param_2 = 0;\n  param_2[1] = *param_1;\n  *param_1 = param_2;\n  return;\n}\n\n", 
    "0010cce0": "\nint fstat(int __fd,stat *__buf)\n\n{\n  int iVar1;\n  \n  iVar1 = __fxstat(1,__fd,__buf);\n  return iVar1;\n}\n\n", 
    "00107f90": "\nvoid allocate_entry_isra_0(long *param_1)\n\n{\n  if (*param_1 != 0) {\n    *param_1 = *(long *)(*param_1 + 8);\n    return;\n  }\n  malloc(0x10);\n  return;\n}\n\n", 
    "0010b380": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\ndouble timespectod(long param_1,long param_2)\n\n{\n  return (double)param_2 / _DAT_0010ed68 + (double)param_1;\n}\n\n", 
    "00103cd0": "\nundefined8 start_lines(undefined8 param_1,undefined4 param_2,long param_3,long *param_4)\n\n{\n  undefined *puVar1;\n  long lVar2;\n  void *pvVar3;\n  undefined8 uVar4;\n  undefined8 uVar5;\n  int *piVar6;\n  undefined *__s;\n  int __c;\n  long in_FS_OFFSET;\n  undefined auStack_2049 [8201];\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  uVar4 = 0;\n  if (param_3 != 0) {\n    while( true ) {\n      lVar2 = safe_read(param_2,(undefined *)((long)register0x00000020 + -0x2048),0x2000);\n      if (lVar2 == 0) break;\n      if (lVar2 == -1) {\n        uVar4 = quotearg_style(4,param_1);\n        uVar5 = dcgettext(0,\"error reading %s\",5);\n        piVar6 = __errno_location();\n                    /* WARNING: Subroutine does not return */\n        error(0,*piVar6,uVar5,uVar4);\n      }\n      *param_4 = *param_4 + lVar2;\n      __c = (int)line_end;\n      puVar1 = (undefined *)((long)register0x00000020 + -0x2048) + lVar2;\n      __s = (undefined *)((long)register0x00000020 + -0x2048);\n      while( true ) {\n        pvVar3 = memchr(__s,__c,(long)puVar1 - (long)__s);\n        if (pvVar3 == (void *)0x0) break;\n        __s = (undefined *)((long)pvVar3 + 1);\n        param_3 = param_3 + -1;\n        if (param_3 == 0) {\n          uVar4 = 0;\n          if (__s < puVar1) {\n            xwrite_stdout(__s,(long)puVar1 - (long)__s);\n            uVar4 = 0;\n          }\n          goto LAB_00103d84;\n        }\n      }\n    }\n    uVar4 = 0xffffffff;\n  }\nLAB_00103d84:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar4;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "001096f0": "\nchar * gettext_quote(char *param_1,int param_2)\n\n{\n  int iVar1;\n  char *pcVar2;\n  undefined8 uVar3;\n  \n  pcVar2 = (char *)dcgettext(0,param_1,5);\n  if (param_1 == pcVar2) {\n    uVar3 = locale_charset();\n    iVar1 = strcaseeq0_constprop_0(uVar3,\"UTF-8\",0x55,0x54,0x46,0x2d,0x38,0,0);\n    if (iVar1 == 0) {\n      iVar1 = strcaseeq0_constprop_0(uVar3,\"GB18030\",0x47,0x42,0x31,0x38,0x30,0x33,0x30);\n      if (iVar1 == 0) {\n        pcVar2 = \"\\\"\";\n        if (param_2 != 9) {\n          pcVar2 = \"\\'\";\n        }\n        return pcVar2;\n      }\n      if (*pcVar2 == '`') {\n        pcVar2 = &DAT_0010e631;\n      }\n      else {\n        pcVar2 = &DAT_0010e62e;\n      }\n    }\n    else if (*pcVar2 == '`') {\n      pcVar2 = &DAT_0010e635;\n    }\n    else {\n      pcVar2 = &DAT_0010e62a;\n    }\n  }\n  return pcVar2;\n}\n\n", 
    "0010b910": "\nvoid version_etc(void)\n\n{\n  long lVar1;\n  long in_FS_OFFSET;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  version_etc_va();\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00108110": "\nundefined8 hash_get_n_entries(long param_1)\n\n{\n  return *(undefined8 *)(param_1 + 0x20);\n}\n\n", 
    "00107ad0": "\nundefined * mdir_name(void *param_1)\n\n{\n  size_t __n;\n  undefined *__dest;\n  \n  __n = dir_len();\n  __dest = (undefined *)malloc(__n + 1 + (ulong)(__n == 0));\n  if (__dest != (undefined *)0x0) {\n    __dest = (undefined *)memcpy(__dest,param_1,__n);\n    if (__n == 0) {\n      *__dest = 0x2e;\n      __n = 1;\n    }\n    __dest[__n] = 0;\n  }\n  return __dest;\n}\n\n", 
    "0010b0a0": "\nvoid quotearg_char(undefined8 param_1,char param_2)\n\n{\n  quotearg_char_mem(param_1,0xffffffffffffffff,(int)param_2);\n  return;\n}\n\n", 
    "0010bb20": "\nvoid x2nrealloc(long param_1,ulong *param_2,ulong param_3)\n\n{\n  undefined auVar1 [16];\n  ulong uVar2;\n  ulong uVar3;\n  \n  uVar3 = *param_2;\n  if (param_1 == 0) {\n    if (uVar3 == 0) {\n      uVar3 = (ulong)(0x80 < param_3) +\n              SUB168((ZEXT816(0) << 0x40 | ZEXT816(0x80)) / ZEXT816(param_3),0);\n    }\n    uVar2 = (ulong)(SUB168(ZEXT816(uVar3) * ZEXT816(param_3) >> 0x40,0) != 0);\n    if ((SUB168(ZEXT816(uVar3) * ZEXT816(param_3),0) < 0) || (uVar2 != 0)) goto LAB_0010bb7b;\n  }\n  else {\n    auVar1 = ZEXT816(0) << 0x40 | ZEXT816(0x5555555555555554);\n    uVar2 = SUB168(auVar1 % ZEXT816(param_3),0);\n    if (SUB168(auVar1 / ZEXT816(param_3),0) <= uVar3) {\nLAB_0010bb7b:\n                    /* WARNING: Subroutine does not return */\n      xalloc_die(param_1,uVar3,uVar2);\n    }\n    uVar3 = (uVar3 >> 1) + 1 + uVar3;\n  }\n  *param_2 = uVar3;\n  xrealloc(param_1,uVar3 * param_3);\n  return;\n}\n\n", 
    "001028b0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t fwrite(void *__ptr,size_t __size,size_t __n,FILE *__s)\n\n{\n  size_t sVar1;\n  \n  sVar1 = (*(code *)PTR_fwrite_00113fa0)();\n  return sVar1;\n}\n\n", 
    "0010a9e0": "\nundefined1 *\nquotearg_n_options(int param_1,undefined8 param_2,undefined8 param_3,undefined4 *param_4)\n\n{\n  long lVar1;\n  int iVar2;\n  uint uVar3;\n  undefined4 uVar4;\n  ulong uVar5;\n  int *piVar6;\n  undefined1 (*pauVar7) [16];\n  ulong uVar8;\n  undefined1 *__ptr;\n  \n  piVar6 = __errno_location();\n  iVar2 = *piVar6;\n  if (param_1 < 0) {\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  pauVar7 = (undefined1 (*) [16])slotvec;\n  if (nslots <= param_1) {\n    if (param_1 == 0x7fffffff) {\n                    /* WARNING: Subroutine does not return */\n      xalloc_die();\n    }\n    if (slotvec == slotvec0) {\n      pauVar7 = (undefined1 (*) [16])xrealloc(0);\n      slotvec = (undefined *)pauVar7;\n      *pauVar7 = slotvec0;\n    }\n    else {\n      pauVar7 = (undefined1 (*) [16])xrealloc(slotvec);\n      slotvec = (undefined *)pauVar7;\n    }\n    memset(pauVar7[nslots],0,(long)((param_1 + 1) - nslots) << 4);\n    nslots = param_1 + 1;\n  }\n  uVar3 = param_4[1];\n  pauVar7 = pauVar7[param_1];\n  uVar5 = *(ulong *)*pauVar7;\n  __ptr = *(undefined1 **)(*pauVar7 + 8);\n  uVar8 = quotearg_buffer_restyled\n                    (__ptr,uVar5,param_2,param_3,*param_4,uVar3 | 1,param_4 + 2,\n                     *(undefined8 *)(param_4 + 10),*(undefined8 *)(param_4 + 0xc));\n  if (uVar5 <= uVar8) {\n    lVar1 = uVar8 + 1;\n    *(long *)*pauVar7 = lVar1;\n    if (__ptr != slot0) {\n      free(__ptr);\n    }\n    __ptr = (undefined1 *)xcharalloc(lVar1);\n    uVar4 = *param_4;\n    *(undefined1 **)(*pauVar7 + 8) = __ptr;\n    quotearg_buffer_restyled\n              (__ptr,lVar1,param_2,param_3,uVar4,uVar3 | 1,param_4 + 2,*(undefined8 *)(param_4 + 10)\n               ,*(undefined8 *)(param_4 + 0xc));\n  }\n  *piVar6 = iVar2;\n  return __ptr;\n}\n\n", 
    "001089b0": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined8 hash_insert_if_absent(long param_1,long param_2,long *param_3)\n\n{\n  char cVar1;\n  long lVar2;\n  long *plVar3;\n  ulong uVar4;\n  undefined8 uVar5;\n  long in_FS_OFFSET;\n  float fVar6;\n  float fVar7;\n  undefined local_38;\n  undefined7 uStack_37;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_2 == 0) {\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  lVar2 = hash_find_entry(param_1,param_2,&local_38,0);\n  if (lVar2 != 0) {\n    uVar5 = 0;\n    if (param_3 != (long *)0x0) {\n      *param_3 = lVar2;\n    }\n    goto LAB_001089fe;\n  }\n  uVar4 = *(ulong *)(param_1 + 0x18);\n  if ((long)uVar4 < 0) {\n    fVar7 = (float)(uVar4 >> 1 | (ulong)((uint)uVar4 & 1));\n    fVar7 = fVar7 + fVar7;\n  }\n  else {\n    fVar7 = (float)uVar4;\n  }\n  uVar4 = *(ulong *)(param_1 + 0x10);\n  if ((long)uVar4 < 0) {\n    fVar6 = (float)(uVar4 >> 1 | (ulong)((uint)uVar4 & 1));\n    fVar6 = fVar6 + fVar6;\n  }\n  else {\n    fVar6 = (float)uVar4;\n  }\n  if (fVar6 * *(float *)(*(long *)(param_1 + 0x28) + 8) < fVar7) {\n    check_tuning_isra_0(param_1 + 0x28);\n    lVar2 = *(long *)(param_1 + 0x28);\n    uVar4 = *(ulong *)(param_1 + 0x10);\n    if ((long)uVar4 < 0) {\n      fVar7 = (float)(uVar4 >> 1 | (ulong)((uint)uVar4 & 1));\n      fVar7 = fVar7 + fVar7;\n    }\n    else {\n      fVar7 = (float)uVar4;\n    }\n    uVar4 = *(ulong *)(param_1 + 0x18);\n    if ((long)uVar4 < 0) {\n      fVar6 = (float)(uVar4 >> 1 | (ulong)((uint)uVar4 & 1));\n      fVar6 = fVar6 + fVar6;\n    }\n    else {\n      fVar6 = (float)uVar4;\n    }\n    if (fVar6 <= *(float *)(lVar2 + 8) * fVar7) goto LAB_00108a5a;\n    fVar7 = fVar7 * *(float *)(lVar2 + 0xc);\n    if (*(char *)(lVar2 + 0x10) == '\\0') {\n      fVar7 = fVar7 * *(float *)(lVar2 + 8);\n    }\n    if (fVar7 < _DAT_0010e5c8) {\n      if (_DAT_0010e5cc <= fVar7) {\n        uVar4 = (long)(fVar7 - _DAT_0010e5cc) ^ 0x8000000000000000;\n      }\n      else {\n        uVar4 = (ulong)fVar7;\n      }\n      cVar1 = hash_rehash(param_1,uVar4);\n      if (cVar1 != '\\0') {\n        lVar2 = hash_find_entry(param_1,param_2,&local_38,0);\n        if (lVar2 != 0) {\n          uVar5 = hash_insert_if_absent_cold();\n          return uVar5;\n        }\n        goto LAB_00108a5a;\n      }\n    }\n  }\n  else {\nLAB_00108a5a:\n    if (*(long *)CONCAT71(uStack_37,local_38) == 0) {\n      *(long *)CONCAT71(uStack_37,local_38) = param_2;\n      uVar5 = 1;\n      *(long *)(param_1 + 0x20) = *(long *)(param_1 + 0x20) + 1;\n      *(long *)(param_1 + 0x18) = *(long *)(param_1 + 0x18) + 1;\n      goto LAB_001089fe;\n    }\n    plVar3 = (long *)allocate_entry_isra_0(param_1 + 0x48);\n    if (plVar3 != (long *)0x0) {\n      *plVar3 = param_2;\n      uVar5 = 1;\n      plVar3[1] = *(long *)(CONCAT71(uStack_37,local_38) + 8);\n      *(long **)(CONCAT71(uStack_37,local_38) + 8) = plVar3;\n      *(long *)(param_1 + 0x20) = *(long *)(param_1 + 0x20) + 1;\n      goto LAB_001089fe;\n    }\n  }\n  uVar5 = 0xffffffff;\nLAB_001089fe:\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar5;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "001078c0": "\nlong argmatch_to_argument(void *param_1,long *param_2,void *param_3,size_t param_4)\n\n{\n  int iVar1;\n  long lVar2;\n  \n  lVar2 = *param_2;\n  if (lVar2 != 0) {\n    param_2 = param_2 + 1;\n    do {\n      iVar1 = memcmp(param_1,param_3,param_4);\n      if (iVar1 == 0) {\n        return lVar2;\n      }\n      lVar2 = *param_2;\n      param_3 = (void *)((long)param_3 + param_4);\n      param_2 = param_2 + 1;\n    } while (lVar2 != 0);\n  }\n  return lVar2;\n}\n\n", 
    "001079e0": "\nvoid close_stdout(void)\n\n{\n  int iVar1;\n  int *piVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  \n  iVar1 = close_stream(stdout);\n  if (iVar1 != 0) {\n    piVar2 = __errno_location();\n    if ((ignore_EPIPE == '\\0') || (*piVar2 != 0x20)) {\n      uVar3 = dcgettext(0,\"write error\",5);\n      if (file_name != 0) {\n        uVar4 = quotearg_colon();\n                    /* WARNING: Subroutine does not return */\n        error(0,*piVar2,\"%s: %s\",uVar4,uVar3);\n      }\n                    /* WARNING: Subroutine does not return */\n      error(0,*piVar2,&DAT_0010e524,uVar3);\n    }\n  }\n  iVar1 = close_stream(stderr);\n  if (iVar1 == 0) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  _exit(exit_failure);\n}\n\n", 
    "00102925": "\nvoid hash_get_first_cold(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "00115098": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint __lxstat(int __ver,char *__filename,stat *__stat_buf)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __lxstat@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00102920": "\nvoid safe_hasher_cold(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "00102800": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * realloc(void *__ptr,size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = (void *)(*(code *)PTR_realloc_00113f48)();\n  return pvVar1;\n}\n\n", 
    "00107b40": "\nchar * last_component(char *param_1)\n\n{\n  bool bVar1;\n  char *pcVar2;\n  char cVar3;\n  \n  cVar3 = *param_1;\n  while (cVar3 == '/') {\n    pcVar2 = param_1 + 1;\n    param_1 = param_1 + 1;\n    cVar3 = *pcVar2;\n  }\n  if (cVar3 != '\\0') {\n    bVar1 = false;\n    pcVar2 = param_1;\n    do {\n      while (cVar3 != '/') {\n        if (bVar1) {\n          bVar1 = false;\n          param_1 = pcVar2;\n        }\n        cVar3 = pcVar2[1];\n        pcVar2 = pcVar2 + 1;\n        if (cVar3 == '\\0') {\n          return param_1;\n        }\n      }\n      cVar3 = pcVar2[1];\n      pcVar2 = pcVar2 + 1;\n      bVar1 = true;\n    } while (cVar3 != '\\0');\n  }\n  return param_1;\n}\n\n", 
    "0010c680": "\nuint rotr8(uint param_1,byte param_2)\n\n{\n  return param_1 & 0xffffff00 |\n         (uint)(byte)((byte)param_1 >> (param_2 & 7) | (byte)param_1 << 8 - (param_2 & 7));\n}\n\n", 
    "0010b230": "\nvoid quotearg_custom(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  quotearg_n_custom(0,param_1,param_2,param_3);\n  return;\n}\n\n", 
    "0010baa0": "\nvoid xcharalloc(void)\n\n{\n  xmalloc();\n  return;\n}\n\n", 
    "0010c320": "\n/* WARNING: Restarted to delay deadcode elimination for space: stack */\n\nint rpl_fcntl(ulong param_1,int param_2,ulong param_3)\n\n{\n  long lVar1;\n  int iVar2;\n  uint uVar3;\n  int iVar4;\n  int *piVar5;\n  int __fd;\n  long in_FS_OFFSET;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_2 != 0x406) {\n    iVar2 = fcntl((int)param_1,param_2,param_3);\n    goto LAB_0010c3a4;\n  }\n  if (have_dupfd_cloexec_3397 < 0) {\n    iVar2 = rpl_fcntl(param_1,0,param_3 & 0xffffffff);\n    if ((iVar2 < 0) || (__fd = iVar2, have_dupfd_cloexec_3397 != -1)) goto LAB_0010c3a4;\nLAB_0010c3e1:\n    uVar3 = fcntl(__fd,1);\n    if (-1 < (int)uVar3) {\n      iVar4 = fcntl(__fd,2,(ulong)(uVar3 | 1));\n      iVar2 = __fd;\n      if (iVar4 != -1) goto LAB_0010c3a4;\n    }\n    piVar5 = __errno_location();\n    iVar2 = -1;\n    iVar4 = *piVar5;\n    close(__fd);\n    *piVar5 = iVar4;\n  }\n  else {\n    iVar2 = fcntl((int)param_1,0x406);\n    if (iVar2 < 0) {\n      piVar5 = __errno_location();\n      if (*piVar5 == 0x16) {\n        iVar2 = rpl_fcntl(param_1 & 0xffffffff,0,param_3 & 0xffffffff);\n        if (iVar2 < 0) goto LAB_0010c3a4;\n        have_dupfd_cloexec_3397 = -1;\n        __fd = iVar2;\n        goto LAB_0010c3e1;\n      }\n    }\n    have_dupfd_cloexec_3397 = 1;\n  }\nLAB_0010c3a4:\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00115090": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t strlen(char *__s)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strlen@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010bbc0": "\nvoid xzalloc(size_t param_1)\n\n{\n  void *__s;\n  \n  __s = (void *)xmalloc();\n  memset(__s,0,param_1);\n  return;\n}\n\n", 
    "00102000": "\nint _init(EVP_PKEY_CTX *ctx)\n\n{\n  undefined *puVar1;\n  \n  puVar1 = PTR___gmon_start___00113fe8;\n  if (PTR___gmon_start___00113fe8 != (undefined *)0x0) {\n    puVar1 = (undefined *)(*(code *)PTR___gmon_start___00113fe8)();\n  }\n  return (int)puVar1;\n}\n\n", 
    "00104ff0": "\nundefined  [16] get_stat_mtime_isra_0(undefined8 param_1,undefined8 param_2)\n\n{\n  return CONCAT88(param_2,param_1);\n}\n\n", 
    "00108100": "\nundefined8 hash_get_n_buckets_used(long param_1)\n\n{\n  return *(undefined8 *)(param_1 + 0x18);\n}\n\n", 
    "001028a0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid exit(int __status)\n\n{\n  (*(code *)PTR_exit_00113f98)();\n  return;\n}\n\n", 
    "0010bc50": "\nvoid xstrdup(char *param_1)\n\n{\n  size_t sVar1;\n  \n  sVar1 = strlen(param_1);\n  xmemdup(param_1,sVar1 + 1);\n  return;\n}\n\n", 
    "0010cc20": "\nvoid __libc_csu_init(EVP_PKEY_CTX *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  long lVar1;\n  \n  _init(param_1);\n  lVar1 = 0;\n  do {\n    (*(code *)(&__frame_dummy_init_array_entry)[lVar1])((ulong)param_1 & 0xffffffff,param_2,param_3)\n    ;\n    lVar1 = lVar1 + 1;\n  } while (lVar1 != 1);\n  return;\n}\n\n", 
    "0010b9c0": "\nvoid emit_bug_reporting_address(void)\n\n{\n  FILE *__stream;\n  undefined8 uVar1;\n  char *__s;\n  \n  uVar1 = dcgettext(0,\"\\nReport bugs to: %s\\n\",5);\n  __printf_chk(1,uVar1,\"bug-coreutils@gnu.org\");\n  uVar1 = dcgettext(0,\"%s home page: <%s>\\n\",5);\n  __printf_chk(1,uVar1,\"GNU coreutils\",\"https://www.gnu.org/software/coreutils/\");\n  __stream = stdout;\n  __s = (char *)dcgettext(0,\"General help using GNU software: <https://www.gnu.org/gethelp/>\\n\",5);\n  fputs_unlocked(__s,__stream);\n  return;\n}\n\n", 
    "001079d0": "\nvoid close_stdout_set_ignore_EPIPE(undefined param_1)\n\n{\n  ignore_EPIPE = param_1;\n  return;\n}\n\n", 
    "00102e80": "\nvoid _start(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 unaff_retaddr;\n  undefined auStack_8 [8];\n  \n  (*(code *)PTR___libc_start_main_00113fe0)\n            (main,unaff_retaddr,&stack0x00000008,__libc_csu_init,__libc_csu_fini,param_3,auStack_8);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n", 
    "0010b360": "\nulong timespec_sign(ulong param_1,ulong param_2)\n\n{\n  ulong uVar1;\n  \n  uVar1 = 0xffffffff;\n  if (-1 < (long)param_1) {\n    uVar1 = (ulong)((param_1 | param_2) != 0);\n  }\n  return uVar1;\n}\n\n", 
    "00102910": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nushort ** __ctype_b_loc(void)\n\n{\n  ushort **ppuVar1;\n  \n  ppuVar1 = (ushort **)(*(code *)PTR___ctype_b_loc_00113fd0)();\n  return ppuVar1;\n}\n\n", 
    "00107c50": "\nulong is_prime(ulong param_1)\n\n{\n  ulong uVar1;\n  ulong uVar2;\n  ulong uVar3;\n  ulong uVar4;\n  long lVar5;\n  \n  uVar1 = param_1 - (param_1 / 3 +\n                    (SUB168(ZEXT816(param_1) * ZEXT816(0xaaaaaaaaaaaaaaab) >> 0x40,0) &\n                    0xfffffffffffffffe));\n  uVar3 = uVar1;\n  if ((9 < param_1) && (uVar1 != 0)) {\n    lVar5 = 0x10;\n    uVar4 = 9;\n    uVar2 = 3;\n    do {\n      uVar2 = uVar2 + 2;\n      uVar4 = uVar4 + lVar5;\n      uVar1 = param_1 / uVar2;\n      uVar3 = param_1 % uVar2;\n      if (param_1 <= uVar4) break;\n      lVar5 = lVar5 + 8;\n    } while (uVar3 != 0);\n  }\n  return uVar1 & 0xffffffffffffff00 | (ulong)(uVar3 != 0);\n}\n\n", 
    "0010c690": "\nulong c_isalnum(int param_1)\n\n{\n  ulong in_RAX;\n  ulong uVar1;\n  \n  if (param_1 < 0x5b) {\n    uVar1 = 1;\n    if (param_1 < 0x41) {\n      return (ulong)(param_1 - 0x30U < 10);\n    }\n  }\n  else {\n    uVar1 = in_RAX & 0xffffffffffffff00 | (ulong)(param_1 - 0x61U < 0x1a);\n  }\n  return uVar1;\n}\n\n", 
    "00107e90": "\nlong hash_find_entry(long param_1,long param_2,long **param_3,char param_4)\n\n{\n  long *plVar1;\n  long lVar2;\n  char cVar3;\n  long *plVar4;\n  long lVar5;\n  \n  plVar4 = (long *)safe_hasher();\n  *param_3 = plVar4;\n  lVar5 = *plVar4;\n  if (lVar5 == 0) {\nLAB_00107f31:\n    lVar5 = 0;\n  }\n  else {\n    if (lVar5 != param_2) {\n      cVar3 = (**(code **)(param_1 + 0x38))(param_2);\n      if (cVar3 == '\\0') {\n        for (; (long *)plVar4[1] != (long *)0x0; plVar4 = (long *)plVar4[1]) {\n          if ((*(long *)plVar4[1] == param_2) ||\n             (cVar3 = (**(code **)(param_1 + 0x38))(param_2), cVar3 != '\\0')) {\n            lVar5 = *(long *)plVar4[1];\n            if (param_4 == '\\0') {\n              return lVar5;\n            }\n            plVar4[1] = ((long *)plVar4[1])[1];\n            free_entry_isra_0(param_1 + 0x48);\n            return lVar5;\n          }\n        }\n        goto LAB_00107f31;\n      }\n      lVar5 = *plVar4;\n    }\n    if (param_4 != '\\0') {\n      plVar1 = (long *)plVar4[1];\n      if (plVar1 != (long *)0x0) {\n        lVar2 = plVar1[1];\n        *plVar4 = *plVar1;\n        plVar4[1] = lVar2;\n        free_entry_isra_0(param_1 + 0x48);\n        return lVar5;\n      }\n      *plVar4 = 0;\n    }\n  }\n  return lVar5;\n}\n\n", 
    "0010cba0": "\nint rpl_fseeko(FILE *param_1,__off_t param_2,int param_3)\n\n{\n  int iVar1;\n  __off_t _Var2;\n  \n  if (((param_1->_IO_read_end == param_1->_IO_read_ptr) &&\n      (param_1->_IO_write_ptr == param_1->_IO_write_base)) &&\n     (param_1->_IO_save_base == (char *)0x0)) {\n    iVar1 = fileno(param_1);\n    _Var2 = lseek(iVar1,param_2,param_3);\n    if (_Var2 == -1) {\n      iVar1 = -1;\n    }\n    else {\n      param_1->_flags = param_1->_flags & 0xffffffef;\n      param_1->_offset = _Var2;\n      iVar1 = 0;\n    }\n    return iVar1;\n  }\n  iVar1 = fseeko(param_1,param_2,param_3);\n  return iVar1;\n}\n\n", 
    "0010bab0": "\nvoid * xrealloc(void *param_1,size_t param_2)\n\n{\n  void *pvVar1;\n  \n  if ((param_2 == 0) && (param_1 != (void *)0x0)) {\n    free(param_1);\n    return (void *)0x0;\n  }\n  pvVar1 = realloc(param_1,param_2);\n  if ((pvVar1 == (void *)0x0) && (param_2 != 0)) {\n                    /* WARNING: Subroutine does not return */\n    xalloc_die();\n  }\n  return pvVar1;\n}\n\n", 
    "0010ccc0": "\nint stat(char *__file,stat *__buf)\n\n{\n  int iVar1;\n  \n  iVar1 = __xstat(1,__file,__buf);\n  return iVar1;\n}\n\n", 
    "00102670": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid __assert_fail(char *__assertion,char *__file,uint __line,char *__function)\n\n{\n  (*(code *)PTR___assert_fail_00113e80)();\n  return;\n}\n\n", 
    "00102ee0": "\n/* WARNING: Removing unreachable block (ram,0x00102f04) */\n/* WARNING: Removing unreachable block (ram,0x00102f10) */\n\nvoid register_tm_clones(void)\n\n{\n  return;\n}\n\n", 
    "00104970": "\nuint tail_lines(undefined8 param_1,int param_2,undefined8 param_3,long *param_4)\n\n{\n  int iVar1;\n  uint uVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  int *piVar5;\n  long lVar6;\n  __off_t _Var7;\n  __off_t _Var8;\n  uint uVar9;\n  long in_FS_OFFSET;\n  stat sStack_d8;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = fstat(param_2,&sStack_d8);\n  if (iVar1 != 0) {\n    uVar3 = quotearg_style(4,param_1);\n    uVar4 = dcgettext(0,\"cannot fstat %s\",5);\n    piVar5 = __errno_location();\n                    /* WARNING: Subroutine does not return */\n    error(0,*piVar5,uVar4,uVar3);\n  }\n  uVar9 = (uint)from_start;\n  if (from_start == 0) {\n    if ((presume_input_pipe == '\\0') && ((sStack_d8.st_mode & 0xf000) == 0x8000)) {\n      _Var7 = lseek(param_2,0,1);\n      if (_Var7 != -1) {\n        _Var8 = lseek(param_2,0,2);\n        if (_Var7 < _Var8) {\n          *param_4 = _Var8;\n          uVar9 = 1;\n          if (_Var8 != 0) {\n            uVar9 = file_lines(param_1,param_2,param_3,_Var7,_Var8,param_4);\n          }\n          goto LAB_001049ee;\n        }\n        xlseek(param_2,_Var7,0,param_1);\n      }\n    }\n    uVar9 = pipe_lines(param_1,param_2,param_3,param_4);\n  }\n  else {\n    uVar2 = start_lines(param_1,param_2,param_3,param_4);\n    if (uVar2 == 0) {\n      lVar6 = dump_remainder(0,param_1,param_2,0xffffffffffffffff);\n      *param_4 = *param_4 + lVar6;\n    }\n    else {\n      uVar9 = uVar2 >> 0x1f;\n    }\n  }\nLAB_001049ee:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar9;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00102550": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid clearerr_unlocked(FILE *__stream)\n\n{\n  (*(code *)PTR_clearerr_unlocked_00113df0)();\n  return;\n}\n\n", 
    "00103880": "\nvoid emit_stdin_note(void)\n\n{\n  char *__s;\n  FILE *__stream;\n  \n  __stream = stdout;\n  __s = (char *)dcgettext(0,\"\\nWith no FILE, or when FILE is -, read standard input.\\n\",5);\n  fputs_unlocked(__s,__stream);\n  return;\n}\n\n", 
    "00102790": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * malloc(size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = (void *)(*(code *)PTR_malloc_00113f10)();\n  return pvVar1;\n}\n\n", 
    "0010c5f0": "\nulong rotl64(ulong param_1,byte param_2)\n\n{\n  return param_1 << (param_2 & 0x3f) | param_1 >> 0x40 - (param_2 & 0x3f);\n}\n\n", 
    "0010bc20": "\nvoid xmemdup(void *param_1,size_t param_2)\n\n{\n  void *__dest;\n  \n  __dest = (void *)xmalloc(param_2);\n  memcpy(__dest,param_1,param_2);\n  return;\n}\n\n", 
    "00109070": "\nint * quoting_options_from_style(int *param_1,int param_2)\n\n{\n  if (param_2 != 10) {\n    *param_1 = param_2;\n    param_1[1] = 0;\n    *(undefined8 *)(param_1 + 2) = 0;\n    *(undefined8 *)(param_1 + 4) = 0;\n    *(undefined8 *)(param_1 + 6) = 0;\n    *(undefined8 *)(param_1 + 8) = 0;\n    *(undefined8 *)(param_1 + 10) = 0;\n    *(undefined8 *)(param_1 + 0xc) = 0;\n    return param_1;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "0010be60": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nbool xstrtod(char *param_1,char **param_2,double *param_3,code *param_4)\n\n{\n  int *piVar1;\n  long in_FS_OFFSET;\n  bool bVar2;\n  double dVar3;\n  char *local_38;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  piVar1 = __errno_location();\n  *piVar1 = 0;\n  dVar3 = (double)(*param_4)(param_1,&local_38);\n  if (local_38 == param_1) {\n    bVar2 = false;\nLAB_0010becc:\n    if (param_2 == (char **)0x0) goto LAB_0010bed5;\n  }\n  else {\n    if (param_2 == (char **)0x0) {\n      bVar2 = false;\n      if ((*local_38 != '\\0') || (bVar2 = true, dVar3 == _DAT_0010f0e0)) goto LAB_0010bed5;\nLAB_0010bec3:\n      bVar2 = *piVar1 != 0x22;\n      goto LAB_0010becc;\n    }\n    bVar2 = true;\n    if (dVar3 != _DAT_0010f0e0) goto LAB_0010bec3;\n  }\n  *param_2 = local_38;\nLAB_0010bed5:\n  *param_3 = dVar3;\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return bVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "001025f0": "\nvoid getopt_long(void)\n\n{\n  (*(code *)PTR_getopt_long_00113e40)();\n  return;\n}\n\n", 
    "00115078": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid bindtextdomain(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* bindtextdomain@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001024d0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid free(void *__ptr)\n\n{\n  (*(code *)PTR_free_00113db0)();\n  return;\n}\n\n", 
    "0010cd00": "\nint lstat(char *__file,stat *__buf)\n\n{\n  int iVar1;\n  \n  iVar1 = __lxstat(1,__file,__buf);\n  return iVar1;\n}\n\n", 
    "00107d20": "\nbool raw_comparator(long param_1,long param_2)\n\n{\n  return param_2 == param_1;\n}\n\n", 
    "00106c30": "\nvoid emit_ancillary_info_constprop_0(void)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  char *pcVar3;\n  long lVar4;\n  undefined **ppuVar5;\n  byte *pbVar6;\n  byte *pbVar7;\n  undefined1 *puVar8;\n  long in_FS_OFFSET;\n  bool bVar9;\n  bool bVar10;\n  undefined *local_98;\n  char *local_90;\n  char *local_88;\n  char *local_80 [5];\n  char *local_58;\n  char *local_50;\n  char *local_48;\n  char *local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  long local_20;\n  \n  pbVar7 = (byte *)0x10e1a4;\n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_80[3] = \"sha256sum\";\n  local_98 = &DAT_0010e12a;\n  local_90 = \"test invocation\";\n  local_80[0] = \"Multi-call invocation\";\n  local_80[1] = \"sha224sum\";\n  local_58 = \"sha384sum\";\n  local_48 = \"sha512sum\";\n  local_88 = \"coreutils\";\n  local_80[2] = \"sha2 utilities\";\n  local_80[4] = \"sha2 utilities\";\n  local_50 = \"sha2 utilities\";\n  local_40 = \"sha2 utilities\";\n  local_38 = 0;\n  local_30 = 0;\n  ppuVar5 = &local_98;\n  while( true ) {\n    bVar9 = false;\n    bVar10 = pbVar7 == (byte *)0x0;\n    if (bVar10) break;\n    lVar4 = 5;\n    pbVar6 = &DAT_0010e125;\n    do {\n      if (lVar4 == 0) break;\n      lVar4 = lVar4 + -1;\n      bVar9 = *pbVar6 < *pbVar7;\n      bVar10 = *pbVar6 == *pbVar7;\n      pbVar6 = pbVar6 + 1;\n      pbVar7 = pbVar7 + 1;\n    } while (bVar10);\n    if ((!bVar9 && !bVar10) == bVar9) break;\n    pbVar7 = *(byte **)((long)ppuVar5 + 0x20);\n    ppuVar5 = (undefined **)((long)ppuVar5 + 0x10);\n  }\n  puVar8 = *(undefined1 **)((long)ppuVar5 + 0x18);\n  if (puVar8 == (undefined1 *)0x0) {\n    uVar2 = dcgettext(0,\"\\n%s online help: <%s>\\n\",5);\n    __printf_chk(1,uVar2,\"GNU coreutils\",\"https://www.gnu.org/software/coreutils/\");\n    pcVar3 = setlocale(5,(char *)0x0);\n    if (pcVar3 != (char *)0x0) {\n      iVar1 = strncmp(pcVar3,\"en_\",3);\n      if (iVar1 != 0) {\n        puVar8 = &DAT_0010e125;\n        goto LAB_00106e4e;\n      }\n    }\n    uVar2 = dcgettext(0,\"Full documentation at: <%s%s>\\n\",5);\n    puVar8 = &DAT_0010e125;\n    __printf_chk(1,uVar2,\"https://www.gnu.org/software/coreutils/\",&DAT_0010e125);\n    pcVar3 = \" invocation\";\n  }\n  else {\n    uVar2 = dcgettext(0,\"\\n%s online help: <%s>\\n\",5);\n    __printf_chk(1,uVar2,\"GNU coreutils\",\"https://www.gnu.org/software/coreutils/\");\n    pcVar3 = setlocale(5,(char *)0x0);\n    if (pcVar3 != (char *)0x0) {\n      iVar1 = strncmp(pcVar3,\"en_\",3);\n      if (iVar1 != 0) {\nLAB_00106e4e:\n        uVar2 = dcgettext(0,\"Report %s translation bugs to <https://translationproject.org/team/>\\n\"\n                          ,5);\n        __printf_chk(1,uVar2,&DAT_0010e125);\n      }\n    }\n    uVar2 = dcgettext(0,\"Full documentation at: <%s%s>\\n\",5);\n    pcVar3 = \" invocation\";\n    __printf_chk(1,uVar2,\"https://www.gnu.org/software/coreutils/\",&DAT_0010e125);\n    if (puVar8 != &DAT_0010e125) {\n      pcVar3 = \"\";\n    }\n  }\n  uVar2 = dcgettext(0,\"or available locally via: info \\'(coreutils) %s%s\\'\\n\",5);\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    __printf_chk(1,uVar2,puVar8,pcVar3);\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00115198": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint inotify_add_watch(int __fd,char *__name,uint32_t __mask)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* inotify_add_watch@@GLIBC_2.4 */\n  halt_baddata();\n}\n\n", 
    "00115070": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fclose(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fclose@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010b330": "\nint timespec_cmp(long param_1,int param_2,long param_3,int param_4)\n\n{\n  int iVar1;\n  \n  if (param_3 <= param_1) {\n    iVar1 = 1;\n    if (param_1 <= param_3) {\n      iVar1 = param_2 - param_4;\n    }\n    return iVar1;\n  }\n  return -1;\n}\n\n", 
    "0010bde0": "\n/* WARNING: Could not reconcile some variable overlaps */\n\nundefined8 xnanosleep(void)\n\n{\n  uint *puVar1;\n  undefined8 uVar2;\n  long in_FS_OFFSET;\n  undefined local_38 [24];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_38._0_16_ = dtotimespec();\n  puVar1 = (uint *)__errno_location();\n  do {\n    *puVar1 = 0;\n    uVar2 = rpl_nanosleep(local_38,0);\n    if ((int)uVar2 == 0) goto LAB_0010be34;\n  } while ((*puVar1 & 0xfffffffb) == 0);\n  uVar2 = 0xffffffff;\nLAB_0010be34:\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "0010c660": "\nuint rotr16(uint param_1,byte param_2)\n\n{\n  return param_1 & 0xffff0000 |\n         (uint)(ushort)((ushort)param_1 >> (param_2 & 0xf) |\n                       (ushort)param_1 << 0x10 - (param_2 & 0xf));\n}\n\n", 
    "00115190": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fflush(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fflush@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00102780": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint putc_unlocked(int __c,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_putc_unlocked_00113f08)();\n  return iVar1;\n}\n\n", 
    "00103870": "\nuint wd_comparator(long param_1,long param_2)\n\n{\n  return *(uint *)(param_2 + 0x44) & 0xffffff00 |\n         (uint)(*(uint *)(param_1 + 0x44) == *(uint *)(param_2 + 0x44));\n}\n\n", 
    "00102660": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\n__off_t lseek(int __fd,__off_t __offset,int __whence)\n\n{\n  __off_t _Var1;\n  \n  _Var1 = (*(code *)PTR_lseek_00113e78)();\n  return _Var1;\n}\n\n", 
    "00103990": "\nundefined8 tailable_stdin(char **param_1,long param_2)\n\n{\n  char **ppcVar1;\n  \n  ppcVar1 = param_1 + param_2 * 0xc;\n  while (((*(char *)((long)param_1 + 0x34) != '\\0' || (**param_1 != '-')) || ((*param_1)[1] != '\\0')\n         )) {\n    param_1 = param_1 + 0xc;\n    if (param_1 == ppcVar1) {\n      return 0;\n    }\n  }\n  return 1;\n}\n\n", 
    "00102540": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fcntl(int __fd,int __cmd,...)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_fcntl_00113de8)();\n  return iVar1;\n}\n\n", 
    "00103750": "\nbyte any_live_files(long param_1,long param_2)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  byte *pbVar3;\n  \n  if ((reopen_inaccessible_files == 0) || (bVar1 = reopen_inaccessible_files, follow_mode != 1)) {\n    pbVar3 = (byte *)(param_1 + 0x34);\n    pbVar2 = pbVar3 + param_2 * 0x60;\n    while (*(int *)(pbVar3 + 4) < 0) {\n      bVar1 = (*pbVar3 ^ 1) & reopen_inaccessible_files;\n      if (bVar1 != 0) {\n        return bVar1;\n      }\n      pbVar3 = pbVar3 + 0x60;\n      if (pbVar3 == pbVar2) {\n        return bVar1;\n      }\n    }\n    bVar1 = 1;\n  }\n  return bVar1;\n}\n\n", 
    "00105250": "\nuint tail_file(byte **param_1,undefined8 param_2)\n\n{\n  byte bVar1;\n  undefined uVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  int iVar6;\n  undefined8 uVar7;\n  undefined8 uVar8;\n  int *piVar9;\n  byte *pbVar10;\n  char *pcVar11;\n  long in_FS_OFFSET;\n  undefined8 local_d0;\n  stat local_c8;\n  long local_30;\n  \n  pbVar10 = *param_1;\n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  uVar3 = *pbVar10 - 0x2d;\n  if ((uVar3 == 0) && (uVar3 = (uint)pbVar10[1], pbVar10[1] == 0)) {\n    have_read_stdin = 1;\n    iVar6 = 0;\n  }\n  else {\n    iVar6 = open_safer(pbVar10,0);\n    bVar1 = reopen_inaccessible_files;\n    if (reopen_inaccessible_files == 0) {\n      *(undefined *)((long)param_1 + 0x36) = 1;\n      pbVar10 = *param_1;\n      if (iVar6 == -1) goto LAB_00105337;\n      goto LAB_0010529e;\n    }\n    pbVar10 = *param_1;\n    if (iVar6 == -1) {\n      *(undefined *)((long)param_1 + 0x36) = 0;\nLAB_00105337:\n      piVar9 = __errno_location();\n      if (forever != '\\0') {\n        *(undefined4 *)(param_1 + 7) = 0xffffffff;\n        iVar6 = *piVar9;\n        *(byte *)((long)param_1 + 0x34) = bVar1 ^ 1;\n        *(int *)((long)param_1 + 0x3c) = iVar6;\n        param_1[5] = (byte *)0x0;\n        param_1[4] = (byte *)0x0;\n      }\n      uVar7 = pretty_name_isra_0(pbVar10);\n      uVar7 = quotearg_style(4,uVar7);\n      uVar8 = dcgettext(0,\"cannot open %s for reading\",5);\n                    /* WARNING: Subroutine does not return */\n      error(0,*piVar9,uVar8,uVar7);\n    }\n  }\n  *(undefined *)((long)param_1 + 0x36) = 1;\nLAB_0010529e:\n  if (print_headers != '\\0') {\n    uVar7 = pretty_name_isra_0();\n    write_header(uVar7);\n    pbVar10 = *param_1;\n  }\n  uVar7 = pretty_name_isra_0(pbVar10);\n  uVar4 = tail(uVar7,iVar6,param_2,&local_d0);\n  if (forever == '\\0') {\n    if ((uVar3 != 0) && (iVar6 = close(iVar6), iVar6 != 0)) {\n      uVar7 = pretty_name_isra_0(*param_1);\n      uVar7 = quotearg_style(4,uVar7);\n      uVar8 = dcgettext(0,\"error reading %s\",5);\n      piVar9 = __errno_location();\n                    /* WARNING: Subroutine does not return */\n      error(0,*piVar9,uVar8,uVar7);\n    }\n  }\n  else {\n    *(uint *)((long)param_1 + 0x3c) = (uVar4 & 0xff) - 1;\n    iVar5 = fstat(iVar6,&local_c8);\n    bVar1 = reopen_inaccessible_files;\n    if (iVar5 < 0) {\n      piVar9 = __errno_location();\n      *(int *)((long)param_1 + 0x3c) = *piVar9;\n      uVar7 = pretty_name_isra_0(*param_1);\n      uVar7 = quotearg_style(4,uVar7);\n      uVar8 = dcgettext(0,\"error reading %s\",5);\n                    /* WARNING: Subroutine does not return */\n      error(0,*piVar9,uVar8,uVar7);\n    }\n    if ((((local_c8.st_mode & 0xf000) - 0x1000 & 0xffffe000) != 0) &&\n       ((local_c8.st_mode & 0xb000) != 0x8000)) {\n      *(undefined4 *)((long)param_1 + 0x3c) = 0xffffffff;\n      pcVar11 = \"\";\n      *(undefined *)((long)param_1 + 0x36) = 0;\n      *(byte *)((long)param_1 + 0x34) = bVar1 ^ 1;\n      if ((bVar1 ^ 1) != 0) {\n        pcVar11 = (char *)dcgettext(0,\"; giving up on this name\",5);\n      }\n      uVar7 = pretty_name_isra_0(*param_1);\n      uVar7 = quotearg_n_style_colon(0,3,uVar7);\n      uVar8 = dcgettext(0,\"%s: cannot follow end of this type of file%s\",5);\n                    /* WARNING: Subroutine does not return */\n      error(0,0,uVar8,uVar7,pcVar11);\n    }\n    if ((char)uVar4 == '\\0') {\n      uVar4 = 0;\n      *(byte *)((long)param_1 + 0x34) = reopen_inaccessible_files ^ 1;\n      uVar7 = pretty_name_isra_0(*param_1);\n      close_fd(iVar6,uVar7);\n      *(undefined4 *)(param_1 + 7) = 0xffffffff;\n    }\n    else {\n      record_open_fd(param_1,iVar6,local_d0,&local_c8,-(uint)(uVar3 == 0) | 1);\n      uVar7 = pretty_name_isra_0(*param_1);\n      uVar2 = fremote(iVar6,uVar7);\n      *(undefined *)((long)param_1 + 0x35) = uVar2;\n    }\n  }\n  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar4;\n}\n\n", 
    "0010ac60": "\nvoid set_custom_quoting(undefined1 *param_1,long param_2,long param_3)\n\n{\n  if ((undefined4 *)param_1 == (undefined4 *)0x0) {\n    param_1 = default_quoting_options;\n  }\n  *(undefined4 *)param_1 = 10;\n  if ((param_2 != 0) && (param_3 != 0)) {\n    *(long *)((long)param_1 + 0x28) = param_2;\n    *(long *)((long)param_1 + 0x30) = param_3;\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "0010bf90": "\nuint xstrtoumax(byte *param_1,byte **param_2,uint param_3,uintmax_t *param_4,char *param_5)\n\n{\n  byte bVar1;\n  uint uVar2;\n  int *piVar3;\n  ushort **ppuVar4;\n  byte *pbVar5;\n  uintmax_t uVar6;\n  char *pcVar7;\n  int iVar8;\n  undefined8 uVar9;\n  uint uVar10;\n  byte bVar11;\n  long in_FS_OFFSET;\n  byte *local_50;\n  uintmax_t local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (0x24 < param_3) {\n                    /* WARNING: Subroutine does not return */\n    __assert_fail(\"0 <= strtol_base && strtol_base <= 36\",\"lib/xstrtol.c\",0x60,\"xstrtoumax\");\n  }\n  if (param_2 == (byte **)0x0) {\n    param_2 = &local_50;\n  }\n  piVar3 = __errno_location();\n  *piVar3 = 0;\n  bVar11 = *param_1;\n  ppuVar4 = __ctype_b_loc();\n  pbVar5 = param_1;\n  while ((*(byte *)((long)*ppuVar4 + (ulong)bVar11 * 2 + 1) & 0x20) != 0) {\n    bVar11 = pbVar5[1];\n    pbVar5 = pbVar5 + 1;\n  }\n  if (bVar11 != 0x2d) {\n    uVar6 = strtoumax((char *)param_1,(char **)param_2,param_3);\n    pbVar5 = *param_2;\n    local_48 = uVar6;\n    if (pbVar5 != param_1) {\n      if (*piVar3 == 0) {\n        uVar10 = 0;\n      }\n      else {\n        uVar10 = 1;\n        if (*piVar3 != 0x22) goto LAB_0010c08b;\n      }\n      if ((param_5 != (char *)0x0) && (bVar11 = *pbVar5, bVar11 != 0)) {\n        iVar8 = (int)(char)bVar11;\nLAB_0010c0cc:\n        pcVar7 = strchr(param_5,iVar8);\n        if (pcVar7 == (char *)0x0) {\nswitchD_0010c120_caseD_43:\n          uVar10 = uVar10 | 2;\n          *param_4 = local_48;\n          goto LAB_0010c052;\n        }\n        switch(bVar11) {\n        case 0x45:\n        case 0x47:\n        case 0x4b:\n        case 0x4d:\n        case 0x50:\n        case 0x54:\n        case 0x59:\n        case 0x5a:\n        case 0x67:\n        case 0x6b:\n        case 0x6d:\n        case 0x74:\n          pcVar7 = strchr(param_5,0x30);\n          if (pcVar7 == (char *)0x0) goto switchD_0010c0f6_caseD_46;\n          bVar1 = pbVar5[1];\n          if (bVar1 == 0x44) {\n            iVar8 = 2;\n            uVar9 = 1000;\n          }\n          else if (bVar1 == 0x69) {\n            uVar9 = 0x400;\n            iVar8 = (pbVar5[2] == 0x42) + 1 + (uint)(pbVar5[2] == 0x42);\n          }\n          else {\n            iVar8 = (bVar1 == 0x42) + 1;\n            uVar9 = 0x400;\n            if (bVar1 == 0x42) {\n              uVar9 = 1000;\n            }\n          }\n          break;\n        default:\nswitchD_0010c0f6_caseD_46:\n          iVar8 = 1;\n          uVar9 = 0x400;\n        }\n        switch(bVar11) {\n        case 0x42:\n          uVar2 = bkm_scale(&local_48,0x400);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n          break;\n        default:\n          goto switchD_0010c120_caseD_43;\n        case 0x45:\n          uVar2 = bkm_scale_by_power(&local_48,uVar9,6);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n          break;\n        case 0x47:\n        case 0x67:\n          uVar2 = bkm_scale_by_power(&local_48,uVar9,3);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n          break;\n        case 0x4b:\n        case 0x6b:\n          uVar2 = bkm_scale_by_power(&local_48,uVar9,1);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n          break;\n        case 0x4d:\n        case 0x6d:\n          uVar2 = bkm_scale_by_power(&local_48,uVar9,2);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n          break;\n        case 0x50:\n          uVar2 = bkm_scale_by_power(&local_48,uVar9,5);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n          break;\n        case 0x54:\n        case 0x74:\n          uVar2 = bkm_scale_by_power(&local_48,uVar9,4);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n          break;\n        case 0x59:\n          uVar2 = bkm_scale_by_power(&local_48,uVar9,8);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n          break;\n        case 0x5a:\n          uVar2 = bkm_scale_by_power(&local_48,uVar9,7);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n          break;\n        case 0x62:\n          uVar2 = bkm_scale(&local_48,0x200);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n          break;\n        case 99:\n          break;\n        case 0x77:\n          uVar2 = bkm_scale(&local_48,2);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n        }\n        uVar6 = local_48;\n        *param_2 = pbVar5 + iVar8;\n        if (pbVar5[iVar8] != 0) {\n          uVar10 = uVar10 | 2;\n        }\n      }\n      *param_4 = uVar6;\n      goto LAB_0010c052;\n    }\n    if ((param_5 != (char *)0x0) && (bVar11 = *param_1, bVar11 != 0)) {\n      iVar8 = (int)(char)bVar11;\n      pcVar7 = strchr(param_5,iVar8);\n      if (pcVar7 != (char *)0x0) {\n        local_48 = 1;\n        uVar10 = 0;\n        goto LAB_0010c0cc;\n      }\n    }\n  }\nLAB_0010c08b:\n  uVar10 = 4;\nLAB_0010c052:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar10;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "0010cd14": "\nvoid _fini(void)\n\n{\n  return;\n}\n\n", 
    "001025e0": "\nvoid __stack_chk_fail(void)\n\n{\n  (*(code *)PTR___stack_chk_fail_00113e38)();\n  return;\n}\n\n", 
    "001024c0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint raise(int __sig)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_raise_00113da8)();\n  return iVar1;\n}\n\n", 
    "00115088": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t __ctype_get_mb_cur_max(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __ctype_get_mb_cur_max@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00109640": "\nundefined8\nstrcaseeq0_constprop_0\n          (byte *param_1,undefined8 param_2,byte param_3,char param_4,char param_5,char param_6,\n          char param_7,char param_8,char param_9)\n\n{\n  char cVar1;\n  byte bVar2;\n  undefined8 uVar3;\n  \n  cVar1 = c_isupper((int)(char)param_3);\n  bVar2 = *param_1;\n  if (cVar1 != '\\0') {\n    bVar2 = bVar2 & 0xdf;\n  }\n  uVar3 = 0;\n  if (bVar2 == param_3) {\n    uVar3 = strcaseeq1(param_1,param_2,(int)param_4,(int)param_5,(int)param_6,(int)param_7,\n                       (int)param_8,(int)param_9,0,0);\n  }\n  return uVar3;\n}\n\n", 
    "0010c670": "\nuint rotl8(uint param_1,byte param_2)\n\n{\n  return param_1 & 0xffffff00 |\n         (uint)(byte)((byte)param_1 << (param_2 & 7) | (byte)param_1 >> 8 - (param_2 & 7));\n}\n\n", 
    "0010abe0": "\nvoid set_quoting_style(undefined1 *param_1,undefined4 param_2)\n\n{\n  if ((undefined4 *)param_1 == (undefined4 *)0x0) {\n    param_1 = default_quoting_options;\n  }\n  *(undefined4 *)param_1 = param_2;\n  return;\n}\n\n", 
    "0010cca0": "\nint atexit(__func *__func)\n\n{\n  int iVar1;\n  \n  iVar1 = __cxa_atexit(__func,0,__dso_handle);\n  return iVar1;\n}\n\n", 
    "0010bbb0": "\nvoid x2realloc(undefined8 param_1,undefined8 param_2)\n\n{\n  x2nrealloc(param_1,param_2,1);\n  return;\n}\n\n", 
    "0010b220": "\nvoid quotearg_n_custom(void)\n\n{\n  quotearg_n_custom_mem();\n  return;\n}\n\n", 
    "00115080": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid dcgettext(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* dcgettext@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001150f8": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint close(int __fd)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* close@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00102690": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint close(int __fd)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_close_00113e90)();\n  return iVar1;\n}\n\n", 
    "00108310": "\nlong hash_lookup(long param_1,long param_2)\n\n{\n  char cVar1;\n  long *plVar2;\n  long lVar3;\n  \n  plVar2 = (long *)safe_hasher();\n  lVar3 = *plVar2;\n  if (lVar3 == 0) {\n    return 0;\n  }\n  while( true ) {\n    if (lVar3 == param_2) {\n      return param_2;\n    }\n    cVar1 = (**(code **)(param_1 + 0x38))(param_2);\n    if (cVar1 != '\\0') break;\n    plVar2 = (long *)plVar2[1];\n    if (plVar2 == (long *)0x0) {\n      return 0;\n    }\n    lVar3 = *plVar2;\n  }\n  return *plVar2;\n}\n\n", 
    "00102570": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\ndouble strtod_l(char *__nptr,char **__endptr,__locale_t __loc)\n\n{\n  double dVar1;\n  \n  dVar1 = (double)(*(code *)PTR_strtod_l_00113e00)();\n  return dVar1;\n}\n\n", 
    "00108430": "\nvoid hash_get_entries(ulong **param_1,long param_2,ulong param_3)\n\n{\n  ulong **ppuVar1;\n  ulong *puVar2;\n  ulong uVar3;\n  ulong **ppuVar4;\n  \n  ppuVar4 = (ulong **)*param_1;\n  uVar3 = 0;\n  if (param_1[1] < ppuVar4 || (ulong **)param_1[1] == ppuVar4) {\n    return;\n  }\n  do {\n    ppuVar1 = ppuVar4;\n    puVar2 = *ppuVar4;\n    while (puVar2 != (ulong *)0x0) {\n      if (param_3 <= uVar3) {\n        return;\n      }\n      uVar3 = uVar3 + 1;\n      *(ulong **)(param_2 + -8 + uVar3 * 8) = *ppuVar1;\n      ppuVar1 = (ulong **)ppuVar1[1];\n      puVar2 = (ulong *)ppuVar1;\n    }\n    ppuVar4 = ppuVar4 + 2;\n  } while (ppuVar4 <= param_1[1] && (ulong **)param_1[1] != ppuVar4);\n  return;\n}\n\n", 
    "0010ca90": "\nvoid dup_safer(undefined8 param_1)\n\n{\n  rpl_fcntl(param_1,0,3);\n  return;\n}\n\n", 
    "00104070": "\nvoid xlseek(int param_1,__off_t param_2,int param_3,undefined8 param_4)\n\n{\n  __off_t _Var1;\n  undefined8 uVar2;\n  int *piVar3;\n  undefined8 uVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  long in_FS_OFFSET;\n  undefined auStack_48 [24];\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  _Var1 = lseek(param_1,param_2,param_3);\n  if (_Var1 < 0) {\n    uVar2 = offtostr(param_2,auStack_48);\n    piVar3 = __errno_location();\n    if (param_3 == 1) {\n      uVar4 = quotearg_n_style_colon(0,3,param_4);\n      pcVar6 = \"%s: cannot seek to relative offset %s\";\n    }\n    else {\n      uVar4 = quotearg_n_style_colon(0,3,param_4);\n      pcVar6 = \"%s: cannot seek to offset %s\";\n    }\n    uVar5 = dcgettext(0,pcVar6,5);\n                    /* WARNING: Subroutine does not return */\n    error(0,*piVar3,uVar5,uVar4,uVar2);\n  }\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "001150f0": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * memset(void *__s,int __c,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* memset@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00108f20": "\nulong posix2_version(void)\n\n{\n  char *__nptr;\n  ulong uVar1;\n  ulong uVar2;\n  long in_FS_OFFSET;\n  char *local_18;\n  long local_10;\n  \n  uVar2 = 0x31069;\n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  __nptr = getenv(\"_POSIX2_VERSION\");\n  if (((__nptr != (char *)0x0) && (*__nptr != '\\0')) &&\n     (uVar1 = strtol(__nptr,&local_18,10), *local_18 == '\\0')) {\n    if ((long)uVar1 < -0x80000000) {\n      uVar2 = 0x80000000;\n    }\n    else {\n      uVar2 = 0x7fffffff;\n      if ((long)uVar1 < 0x80000000) {\n        uVar2 = uVar1;\n      }\n    }\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2 & 0xffffffff;\n}\n\n", 
    "0010b2a0": "\nvoid quote(undefined8 param_1)\n\n{\n  quote_n(0,param_1);\n  return;\n}\n\n", 
    "0010bf60": "\nuint bkm_scale_by_power(undefined8 param_1,uint param_2,int param_3)\n\n{\n  uint uVar1;\n  uint uVar2;\n  ulong uVar3;\n  \n  uVar3 = (ulong)param_2;\n  param_3 = param_3 + -1;\n  uVar2 = 0;\n  do {\n    uVar1 = bkm_scale(param_1,uVar3 & 0xffffffff);\n    param_3 = param_3 + -1;\n    uVar2 = uVar2 | uVar1;\n  } while (param_3 != -1);\n  return uVar2;\n}\n\n", 
    "0010c6f0": "\nuint c_isblank(int param_1,undefined8 param_2,uint param_3)\n\n{\n  uint in_EAX;\n  \n  return in_EAX & 0xffffff00 | (uint)(param_1 == 0x20) | param_3 & 0xffffff00 | (uint)(param_1 == 9)\n  ;\n}\n\n", 
    "00102f70": "\nuint is_local_fs_type(ulong param_1)\n\n{\n  uint uVar1;\n  bool bVar2;\n  \n  if (param_1 != 0x65735543) {\n    if (param_1 < 0x65735544) {\n      if (param_1 != 0xbd00bd0) {\n        if (param_1 < 0xbd00bd1) {\n          if (param_1 == 0x7275) {\n            return 1;\n          }\n          if (param_1 < 0x7276) {\n            if (param_1 == 0x564c) {\n              return 0;\n            }\n            if (0x564c < param_1) {\n              if (param_1 == 0x5df5) {\n                return 1;\n              }\n              return -(uint)(param_1 != 0x6969);\n            }\n            if (param_1 == 0x517b) {\n              return 0;\n            }\n            if (0x517b < param_1) {\n              return 0xffffffff;\n            }\n            if (param_1 == 0x2478) {\n              return 1;\n            }\n            if (0x2478 < param_1) {\n              if (param_1 == 0x4244) {\n                return 1;\n              }\n              if (param_1 < 0x4245) {\n                if (param_1 == 0x3434) {\n                  return 1;\n                }\n                if (6 < param_1 - 0x4000) {\n                  return 0xffffffff;\n                }\n                return -(uint)((1L << ((byte)(param_1 - 0x4000) & 0x3f) & 0x51U) == 0) | 1;\n              }\n              if (param_1 == 0x4d44) {\n                return 1;\n              }\n              if (param_1 < 0x4d45) {\n                if (param_1 == 0x482b) {\n                  return 1;\n                }\n                return ((param_1 == 0x4858) - 1) + (uint)(param_1 == 0x4858);\n              }\n              return ((param_1 == 0x4d5a) - 1) + (uint)(param_1 == 0x4d5a);\n            }\n            if (0x138f < param_1) {\n              if (param_1 == 0x1cd1) {\n                return 1;\n              }\n              return ((param_1 == 0x2468) - 1) + (uint)(param_1 == 0x2468);\n            }\n            if (0x1372 < param_1) {\n              return -(uint)((1L << ((char)param_1 + 0x8dU & 0x3f) & 0x10001401U) == 0) | 1;\n            }\n            if (param_1 == 0x187) {\n              return 1;\n            }\n            if (param_1 == 0x7c0) {\n              return 1;\n            }\n            return ((param_1 == 0x2f) - 1) + (uint)(param_1 == 0x2f);\n          }\n          if (param_1 == 0x1161970) {\n            return 0;\n          }\n          if (0x1161970 < param_1) {\n            if (param_1 == 0x13111a8) {\n              return 0;\n            }\n            if (param_1 < 0x13111a9) {\n              if (param_1 == 0x12fd16d) {\n                return 1;\n              }\n              return (-(uint)(param_1 - 0x12ff7b4 < 4) & 2) - 1;\n            }\n            if (param_1 == 0x9041934) {\n              return 1;\n            }\n            if (param_1 == 0xbad1dea) {\n              return 1;\n            }\n            return ((param_1 == 0x7655821) - 1) + (uint)(param_1 == 0x7655821);\n          }\n          if (param_1 == 0xc36400) {\n            return 0;\n          }\n          if (0xc36400 < param_1) {\n            if (param_1 == 0x1021994) {\n              return 1;\n            }\n            return ((param_1 == 0x1021997) - 1) + (uint)(param_1 == 0x1021997);\n          }\n          if (param_1 == 0xef53) {\n            return 1;\n          }\n          if (0xef53 < param_1) {\n            if (param_1 == 0x27e0eb) {\n              return 1;\n            }\n            if (0x27e0eb < param_1) {\n              if (param_1 == 0x414a53) {\n                return 1;\n              }\n              return ((param_1 == 0xc0ffee) - 1) + (uint)(param_1 == 0xc0ffee);\n            }\n            if (param_1 == 0xf15f) {\n              return 1;\n            }\n            return ((param_1 == 0x11954) - 1) + (uint)(param_1 == 0x11954);\n          }\n          if (param_1 == 0xadf5) {\n            return 1;\n          }\n          if (0xadf5 < param_1) {\n            if (param_1 == 0xadff) {\n              return 1;\n            }\n            return ((param_1 == 0xef51) - 1) + (uint)(param_1 == 0xef51);\n          }\n          if (param_1 == 0x9660) {\n            return 1;\n          }\n          if (param_1 < 0x9661) {\n            return ((param_1 == 0x72b6) - 1) + (uint)(param_1 == 0x72b6);\n          }\n          return (-(uint)(param_1 - 0x9fa0 < 3) & 2) - 1;\n        }\n        if (param_1 == 0x5346314d) {\n          return 1;\n        }\n        if (param_1 < 0x5346314e) {\n          if (param_1 == 0x47504653) {\n            return 0;\n          }\n          if (0x47504653 < param_1) {\n            if (param_1 == 0x50495045) {\n              return 0;\n            }\n            return ((param_1 == 0x52654973) - 1) + (uint)(param_1 == 0x52654973);\n          }\n          if (param_1 == 0x19830326) {\n            return 0;\n          }\n          if (param_1 < 0x19830327) {\n            if (param_1 == 0x15013346) {\n              return 1;\n            }\n            if (param_1 < 0x15013347) {\n              if (param_1 == 0x11307854) {\n                return 1;\n              }\n              return ((param_1 == 0x13661366) - 1) + (uint)(param_1 == 0x13661366);\n            }\n            return ((param_1 == 0x19800202) - 1) + (uint)(param_1 == 0x19800202);\n          }\n          if (param_1 == 0x3153464a) {\n            return 1;\n          }\n          if (param_1 < 0x3153464b) {\n            if (param_1 == 0x28cd3d45) {\n              return 1;\n            }\n            if (0x28cd3d45 < param_1) {\n              if (param_1 == 0x2bad1dea) {\n                return 1;\n              }\n              return ((param_1 == 0x2fc12fc1) - 1) + (uint)(param_1 == 0x2fc12fc1);\n            }\n            if (param_1 == 0x1badface) {\n              return 1;\n            }\n            return ((param_1 == 0x24051905) - 1) + (uint)(param_1 == 0x24051905);\n          }\n          if (param_1 == 0x43415d53) {\n            return 1;\n          }\n          if (0x43415d53 < param_1) {\n            if (param_1 == 0x453dcd28) {\n              return 1;\n            }\n            return ((param_1 == 0x45584653) - 1) + (uint)(param_1 == 0x45584653);\n          }\n          if (param_1 == 0x42465331) {\n            return 1;\n          }\n          return ((param_1 == 0x42494e4d) - 1) + (uint)(param_1 == 0x42494e4d);\n        }\n        if (param_1 == 0x61636673) {\n          return 0;\n        }\n        if (param_1 < 0x61636674) {\n          if (param_1 == 0x5346414f) {\n            return 0;\n          }\n          if (param_1 < 0x5346414f) {\n            return 0xffffffff;\n          }\n          if (param_1 == 0x565a4653) {\n            return 1;\n          }\n          if (0x565a4653 < param_1) {\n            if (param_1 == 0x58465342) {\n              return 1;\n            }\n            if (param_1 == 0x5a3c69f0) {\n              return 1;\n            }\n            return ((param_1 == 0x58295829) - 1) + (uint)(param_1 == 0x58295829);\n          }\n          if (param_1 == 0x534f434b) {\n            return 1;\n          }\n          if (param_1 < 0x534f434c) {\n            if (param_1 == 0x53464846) {\n              return 1;\n            }\n            return ((param_1 == 0x5346544e) - 1) + (uint)(param_1 == 0x5346544e);\n          }\n          return ((param_1 == 0x54190100) - 1) + (uint)(param_1 == 0x54190100);\n        }\n        if (param_1 == 0x61756673) {\n          return 0;\n        }\n        if (param_1 < 0x61756674) {\n          return ((param_1 == 0x6165676c) - 1) + (uint)(param_1 == 0x6165676c);\n        }\n        if (param_1 == 0x63677270) {\n          return 1;\n        }\n        if (0x63677270 < param_1) {\n          if (param_1 == 0x64626720) {\n            return 1;\n          }\n          return ((param_1 == 0x64646178) - 1) + (uint)(param_1 == 0x64646178);\n        }\n        if ((param_1 & 0xfffffffffffffffd) == 0x62656570) {\n          return 1;\n        }\n        return ((param_1 == 0x62646576) - 1) + (uint)(param_1 == 0x62646576);\n      }\n    }\n    else if (param_1 != 0x7c7c6673) {\n      if (param_1 < 0x7c7c6674) {\n        if (param_1 == 0x73636673) {\n          return 1;\n        }\n        uVar1 = 0;\n        if (param_1 < 0x73636674) {\n          if (param_1 != 0x6b414653) {\n            if (param_1 < 0x6b414654) {\n              if (((param_1 != 0x65735546) && (uVar1 = 0xffffffff, 0x65735545 < param_1)) &&\n                 (uVar1 = 1, param_1 != 0x67596969)) {\n                return ((param_1 == 0x68191122) - 1) + (uint)(param_1 == 0x68191122);\n              }\n            }\n            else if (param_1 != 0x6e667364) {\n              return ((param_1 == 0x6e736673) - 1) + (uint)(param_1 == 0x6e736673);\n            }\n          }\n        }\n        else if (param_1 != 0x7461636f) {\n          if (0x7461636f < param_1) {\n            if (param_1 == 0x74726163) {\n              return 1;\n            }\n            return -(uint)(param_1 != 0x794c7630);\n          }\n          if (((param_1 != 0x73757245) && (uVar1 = 0xffffffff, param_1 < 0x73757246)) &&\n             (uVar1 = 1, param_1 != 0x73717368)) {\n            return ((param_1 == 0x73727279) - 1) + (uint)(param_1 == 0x73727279);\n          }\n        }\n      }\n      else {\n        if (param_1 == 0xbeefdead) {\n          return 0;\n        }\n        uVar1 = 0;\n        if (param_1 < 0xbeefdeae) {\n          if (param_1 != 0xaad7aaea) {\n            if (param_1 < 0xaad7aaeb) {\n              if (param_1 == 0xa501fcf5) {\n                return 0;\n              }\n              if (0xa501fcf5 < param_1) {\n                return 0xffffffff;\n              }\n              if (param_1 != 0x9123683e) {\n                bVar2 = (param_1 & 0xffffffffefffffff) == 0x858458f6;\n                return (bVar2 - 1) + (uint)bVar2;\n              }\n            }\n            else if (param_1 != 0xabba1974) {\n              return -(uint)(param_1 != 0xbacbacbc);\n            }\n            return 1;\n          }\n        }\n        else if (param_1 != 0xfe534d42) {\n          if (0xfe534d42 < param_1) {\n            return -(uint)(param_1 != 0xff534d42);\n          }\n          if (param_1 == 0xf2f52010) {\n            return 1;\n          }\n          if (param_1 < 0xf2f52011) {\n            uVar1 = 1;\n            if ((param_1 != 0xcafe4a11) && (param_1 != 0xde5e81e4)) {\n              return ((param_1 == 0xc97e8168) - 1) + (uint)(param_1 == 0xc97e8168);\n            }\n          }\n          else {\n            uVar1 = 1;\n            if (param_1 != 0xf97cff8c) {\n              return ((param_1 == 0xf995e849) - 1) + (uint)(param_1 == 0xf995e849);\n            }\n          }\n        }\n      }\n      return uVar1;\n    }\n  }\n  return 0;\n}\n\n", 
    "00103e20": "\nlong dump_remainder(char param_1,undefined8 param_2,undefined4 param_3,ulong param_4)\n\n{\n  long lVar1;\n  int *piVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  ulong uVar5;\n  ulong uVar6;\n  long lVar7;\n  long in_FS_OFFSET;\n  undefined local_2048 [8200];\n  long local_40;\n  \n  lVar7 = 0;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  uVar6 = param_4;\n  while( true ) {\n    uVar5 = 0x2000;\n    if (uVar6 < 0x2001) {\n      uVar5 = uVar6;\n    }\n    lVar1 = safe_read(param_3,local_2048,uVar5);\n    if (lVar1 == -1) break;\n    if (lVar1 == 0) goto LAB_00103edd;\n    if (param_1 != '\\0') {\n      write_header(param_2);\n    }\n    lVar7 = lVar7 + lVar1;\n    xwrite_stdout(local_2048,lVar1);\n    if ((param_4 != 0xffffffffffffffff) &&\n       ((uVar6 = uVar6 - lVar1, uVar6 == 0 || (param_4 == 0xfffffffffffffffe)))) goto LAB_00103edd;\n    param_1 = '\\0';\n  }\n  piVar2 = __errno_location();\n  if (*piVar2 != 0xb) {\n    uVar3 = quotearg_style(4,param_2);\n    uVar4 = dcgettext(0,\"error reading %s\",5);\n                    /* WARNING: Subroutine does not return */\n    error(1,*piVar2,uVar4,uVar3);\n  }\nLAB_00103edd:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return lVar7;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00115178": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint __xstat(int __ver,char *__filename,stat *__stat_buf)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __xstat@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00115058": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid clearerr_unlocked(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* clearerr_unlocked@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001024f0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint * __errno_location(void)\n\n{\n  int *piVar1;\n  \n  piVar1 = (int *)(*(code *)PTR___errno_location_00113dc0)();\n  return piVar1;\n}\n\n", 
    "00115170": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint select(int __nfds,fd_set *__readfds,fd_set *__writefds,fd_set *__exceptfds,timeval *__timeout)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* select@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00115050": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fcntl(int __fd,int __cmd,...)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fcntl@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010c520": "\nint rpl_nanosleep(long *param_1,timespec *param_2)\n\n{\n  int iVar1;\n  int *piVar2;\n  long lVar3;\n  long in_FS_OFFSET;\n  timespec local_38;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((ulong)param_1[1] < 1000000000) {\n    lVar3 = *param_1;\n    local_38.tv_nsec = param_1[1];\n    while (0x1fa400 < lVar3) {\n      local_38.tv_sec = 0x1fa400;\n      lVar3 = lVar3 + -0x1fa400;\n      iVar1 = nanosleep(&local_38,param_2);\n      if (iVar1 != 0) {\n        if (param_2 != (timespec *)0x0) {\n          param_2->tv_sec = param_2->tv_sec + lVar3;\n        }\n        goto LAB_0010c5b7;\n      }\n      local_38.tv_nsec = 0;\n    }\n    local_38.tv_sec = lVar3;\n    iVar1 = nanosleep(&local_38,param_2);\n  }\n  else {\n    piVar2 = __errno_location();\n    *piVar2 = 0x16;\n    iVar1 = -1;\n  }\nLAB_0010c5b7:\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar1;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "0010c640": "\nvoid rotr_sz(void)\n\n{\n  rotr64();\n  return;\n}\n\n", 
    "0010c760": "\nbool c_isprint(int param_1)\n\n{\n  return param_1 - 0x20U < 0x5f;\n}\n\n", 
    "00102560": "\nvoid textdomain(void)\n\n{\n  (*(code *)PTR_textdomain_00113df8)();\n  return;\n}\n\n", 
    "00107ba0": "\nvoid base_len(char *param_1)\n\n{\n  long lVar1;\n  ulong uVar2;\n  \n  uVar2 = strlen(param_1);\n  do {\n    if (uVar2 < 2) {\n      return;\n    }\n    lVar1 = uVar2 - 1;\n    uVar2 = uVar2 - 1;\n  } while (param_1[lVar1] == '/');\n  return;\n}\n\n", 
    "00102680": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * memset(void *__s,int __c,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = (void *)(*(code *)PTR_memset_00113e88)();\n  return pvVar1;\n}\n\n", 
    "00107cc0": "\nulong next_prime(ulong param_1)\n\n{\n  char cVar1;\n  ulong uVar2;\n  \n  uVar2 = 10;\n  if (9 < param_1) {\n    uVar2 = param_1;\n  }\n  uVar2 = uVar2 | 1;\n  while ((uVar2 != 0xffffffffffffffff && (cVar1 = is_prime(uVar2), cVar1 == '\\0'))) {\n    uVar2 = uVar2 + 2;\n  }\n  return uVar2;\n}\n\n", 
    "00108540": "\nvoid hash_reset_tuning(undefined8 *param_1)\n\n{\n  *(undefined *)(param_1 + 2) = 0;\n  *param_1 = 0x3f80000000000000;\n  param_1[1] = 0x3fb4fdf43f4ccccd;\n  return;\n}\n\n", 
    "00107de0": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nulong compute_bucket_size_isra_0(float param_1,ulong param_2,char param_3)\n\n{\n  ulong uVar1;\n  float fVar2;\n  \n  if (param_3 == '\\0') {\n    if ((long)param_2 < 0) {\n      fVar2 = (float)(param_2 >> 1 | (ulong)((uint)param_2 & 1));\n      fVar2 = fVar2 + fVar2;\n    }\n    else {\n      fVar2 = (float)param_2;\n    }\n    fVar2 = fVar2 / param_1;\n    if (_DAT_0010e5c8 <= fVar2) {\n      return 0;\n    }\n    if (fVar2 < _DAT_0010e5cc) {\n      param_2 = (ulong)fVar2;\n    }\n    else {\n      param_2 = (long)(fVar2 - _DAT_0010e5cc) ^ 0x8000000000000000;\n    }\n  }\n  uVar1 = next_prime(param_2);\n  if (((uVar1 >> 0x3c & 1) == 0) && (uVar1 >> 0x3d == 0)) {\n    return uVar1;\n  }\n  return 0;\n}\n\n", 
    "0010ac40": "\nundefined4 set_quoting_flags(undefined1 *param_1,undefined4 param_2)\n\n{\n  undefined4 uVar1;\n  \n  if (param_1 == (undefined1 *)0x0) {\n    param_1 = default_quoting_options;\n  }\n  uVar1 = *(undefined4 *)(param_1 + 4);\n  *(undefined4 *)(param_1 + 4) = param_2;\n  return uVar1;\n}\n\n", 
    "0010b2b0": "\nssize_t safe_read(int param_1,void *param_2,ulong param_3)\n\n{\n  ssize_t sVar1;\n  int *piVar2;\n  \n  while( true ) {\n    do {\n      sVar1 = read(param_1,param_2,param_3);\n      if (-1 < sVar1) {\n        return sVar1;\n      }\n      piVar2 = __errno_location();\n    } while (*piVar2 == 4);\n    if (param_3 < 0x7ff00001) break;\n    if (*piVar2 != 0x16) {\n      return sVar1;\n    }\n    param_3 = 0x7ff00000;\n  }\n  return sVar1;\n}\n\n", 
    "001024e0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid abort(void)\n\n{\n  (*(code *)PTR_abort_00113db8)();\n  return;\n}\n\n", 
    "00102f60": "\nvoid frame_dummy(void)\n\n{\n  register_tm_clones();\n  return;\n}\n\n", 
    "00115188": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * malloc(size_t __size)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* malloc@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00115068": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\ndouble strtod_l(char *__nptr,char **__endptr,__locale_t __loc)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strtod_l@@GLIBC_2.3 */\n  halt_baddata();\n}\n\n", 
    "00107d30": "\nlong safe_hasher(long *param_1,undefined8 param_2)\n\n{\n  ulong uVar1;\n  \n  uVar1 = (*(code *)param_1[6])(param_2,param_1[2]);\n  if (uVar1 <= (ulong)param_1[2] && param_1[2] != uVar1) {\n    return uVar1 * 0x10 + *param_1;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "00115180": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint putc_unlocked(int __c,FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* putc_unlocked@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00115060": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid textdomain(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* textdomain@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010b320": "\nundefined  [16] make_timespec(undefined8 param_1,undefined8 param_2)\n\n{\n  return CONCAT88(param_2,param_1);\n}\n\n", 
    "00104610": "\nuint pipe_lines(undefined8 param_1,undefined4 param_2,ulong param_3,long *param_4)\n\n{\n  ulong uVar1;\n  void *pvVar2;\n  void *pvVar3;\n  long lVar4;\n  ulong uVar5;\n  void *__src;\n  undefined8 uVar6;\n  undefined8 uVar7;\n  int *piVar8;\n  uint extraout_EDX;\n  uint uVar9;\n  long lVar10;\n  int iVar11;\n  void *__ptr;\n  void *local_68;\n  ulong local_60;\n  \n  pvVar2 = (void *)xmalloc(0x2018);\n  *(undefined8 *)((long)pvVar2 + 0x2008) = 0;\n  *(undefined8 *)((long)pvVar2 + 0x2000) = 0;\n  *(undefined8 *)((long)pvVar2 + 0x2010) = 0;\n  pvVar3 = (void *)xmalloc(0x2018);\n  local_60 = 0;\n  __src = pvVar3;\n  local_68 = pvVar2;\n  while (__ptr = pvVar2, lVar4 = safe_read(param_2,__src,0x2000), lVar4 - 1U < 0xfffffffffffffffe) {\n    *(long *)((long)pvVar3 + 0x2000) = lVar4;\n    iVar11 = (int)line_end;\n    *param_4 = *param_4 + lVar4;\n    *(undefined8 *)((long)pvVar3 + 0x2008) = 0;\n    *(undefined8 *)((long)pvVar3 + 0x2010) = 0;\n    pvVar2 = __src;\n    lVar10 = 0;\n    while( true ) {\n      pvVar2 = memchr(pvVar2,iVar11,(long)__src + (lVar4 - (long)pvVar2));\n      if (pvVar2 == (void *)0x0) break;\n      *(long *)((long)pvVar3 + 0x2008) = lVar10 + 1;\n      pvVar2 = (void *)((long)pvVar2 + 1);\n      lVar10 = lVar10 + 1;\n    }\n    local_60 = local_60 + lVar10;\n    pvVar2 = __ptr;\n    if (*(size_t *)((long)pvVar3 + 0x2000) + *(long *)((long)local_68 + 0x2000) < 0x2000) {\n      memcpy((void *)(*(long *)((long)local_68 + 0x2000) + (long)local_68),__src,\n             *(size_t *)((long)pvVar3 + 0x2000));\n      *(long *)((long)local_68 + 0x2000) =\n           *(long *)((long)local_68 + 0x2000) + *(long *)((long)pvVar3 + 0x2000);\n      *(long *)((long)local_68 + 0x2008) =\n           *(long *)((long)local_68 + 0x2008) + *(long *)((long)pvVar3 + 0x2008);\n    }\n    else {\n      *(void **)((long)local_68 + 0x2010) = pvVar3;\n      uVar5 = local_60 - *(long *)((long)__ptr + 0x2008);\n      local_68 = pvVar3;\n      if (param_3 < uVar5) {\n        pvVar3 = __ptr;\n        pvVar2 = *(void **)((long)__ptr + 0x2010);\n        __src = __ptr;\n        local_60 = uVar5;\n      }\n      else {\n        __src = (void *)xmalloc(0x2018);\n        pvVar3 = __src;\n      }\n    }\n  }\n  free(pvVar3);\n  if (lVar4 != -1) {\n    lVar4 = *(long *)((long)local_68 + 0x2000);\n    uVar9 = extraout_EDX & 0xffffff00 | (uint)(param_3 == 0 || lVar4 == 0);\n    if (param_3 == 0 || lVar4 == 0) {\n      if (__ptr == (void *)0x0) {\n        return uVar9;\n      }\n    }\n    else {\n      iVar11 = (int)line_end;\n      if (*(char *)((long)local_68 + lVar4 + -1) != line_end) {\n        *(long *)((long)local_68 + 0x2008) = *(long *)((long)local_68 + 0x2008) + 1;\n        local_60 = local_60 + 1;\n      }\n      uVar5 = local_60 - *(long *)((long)__ptr + 0x2008);\n      pvVar3 = __ptr;\n      while (uVar1 = uVar5, param_3 < uVar1) {\n        pvVar3 = *(void **)((long)pvVar3 + 0x2010);\n        local_60 = uVar1;\n        uVar5 = uVar1 - *(long *)((long)pvVar3 + 0x2008);\n      }\n      lVar4 = *(long *)((long)pvVar3 + 0x2000);\n      pvVar2 = pvVar3;\n      if (param_3 < local_60) {\n        lVar10 = local_60 - param_3;\n        do {\n          pvVar2 = memchr(pvVar2,iVar11,(long)pvVar3 + (lVar4 - (long)pvVar2));\n          if (pvVar2 == (void *)0x0) {\n                    /* WARNING: Subroutine does not return */\n            __assert_fail(\"beg\",\"src/tail.c\",0x2c9,\"pipe_lines\");\n          }\n          pvVar2 = (void *)((long)pvVar2 + 1);\n          lVar10 = lVar10 + -1;\n        } while (lVar10 != 0);\n      }\n      xwrite_stdout(pvVar2,(long)pvVar3 + (lVar4 - (long)pvVar2));\n      for (lVar4 = *(long *)((long)pvVar3 + 0x2010); lVar4 != 0; lVar4 = *(long *)(lVar4 + 0x2010))\n      {\n        xwrite_stdout(lVar4,*(undefined8 *)(lVar4 + 0x2000));\n      }\n      uVar9 = 1;\n    }\n    do {\n      pvVar3 = *(void **)((long)__ptr + 0x2010);\n      free(__ptr);\n      __ptr = pvVar3;\n    } while (pvVar3 != (void *)0x0);\n    return uVar9;\n  }\n  uVar6 = quotearg_style(4,param_1);\n  uVar7 = dcgettext(0,\"error reading %s\",5);\n  piVar8 = __errno_location();\n                    /* WARNING: Subroutine does not return */\n  error(0,*piVar8,uVar7,uVar6);\n}\n\n", 
    "0010bcb0": "\nulong xnumtoumax(undefined8 param_1,undefined4 param_2,ulong param_3,ulong param_4,\n                undefined8 param_5,undefined8 param_6,int param_7)\n\n{\n  int iVar1;\n  int *piVar2;\n  undefined8 uVar3;\n  long in_FS_OFFSET;\n  ulong local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = xstrtoumax(param_1,0,param_2,&local_48);\n  if (iVar1 == 0) {\n    if ((param_3 <= local_48) && (local_48 <= param_4)) {\n      if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n        return local_48;\n      }\n                    /* WARNING: Subroutine does not return */\n      __stack_chk_fail();\n    }\n    piVar2 = __errno_location();\n    *piVar2 = (-(uint)(local_48 < 0x40000000) & 0xffffffd7) + 0x4b;\n  }\n  else {\n    piVar2 = __errno_location();\n    if (iVar1 == 1) {\n      *piVar2 = 0x4b;\n    }\n    else if (iVar1 == 3) {\n      *piVar2 = 0;\n    }\n  }\n  uVar3 = quote(param_1);\n  iVar1 = *piVar2;\n  if (iVar1 == 0x16) {\n    iVar1 = 0;\n  }\n  if (param_7 == 0) {\n    param_7 = 1;\n  }\n                    /* WARNING: Subroutine does not return */\n  error(param_7,iVar1,\"%s: %s\",param_6,uVar3);\n}\n\n", 
    "0010c650": "\nuint rotl16(uint param_1,byte param_2)\n\n{\n  return param_1 & 0xffff0000 |\n         (uint)(ushort)((ushort)param_1 << (param_2 & 0xf) |\n                       (ushort)param_1 >> 0x10 - (param_2 & 0xf));\n}\n\n", 
    "0010abc0": "\nundefined4 get_quoting_style(undefined1 *param_1)\n\n{\n  if ((undefined4 *)param_1 == (undefined4 *)0x0) {\n    param_1 = default_quoting_options;\n  }\n  return *(undefined4 *)param_1;\n}\n\n", 
    "0010c770": "\nulong c_ispunct(int param_1)\n\n{\n  ulong in_RAX;\n  \n  if (0x60 < param_1) {\n    return in_RAX & 0xffffffffffffff00 | (ulong)(param_1 - 0x7bU < 4);\n  }\n  if (param_1 < 0x5b) {\n    if (param_1 < 0x30) {\n      return in_RAX & 0xffffffffffffff00 | (ulong)(0x20 < param_1);\n    }\n    return in_RAX & 0xffffffffffffff00 | (ulong)(param_1 - 0x3aU < 7);\n  }\n  return 1;\n}\n\n", 
    "00102870": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nuintmax_t strtoumax(char *__nptr,char **__endptr,int __base)\n\n{\n  uintmax_t uVar1;\n  \n  uVar1 = (*(code *)PTR_strtoumax_00113f80)();\n  return uVar1;\n}\n\n", 
    "0010b410": "\nundefined8\nversion_etc_arn(FILE *param_1,long param_2,undefined8 param_3,undefined8 param_4,undefined8 *param_5\n               ,undefined8 param_6)\n\n{\n  undefined8 uVar1;\n  char *pcVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  undefined8 uVar5;\n  undefined8 uVar6;\n  undefined8 local_60;\n  undefined8 local_58;\n  undefined8 local_50;\n  undefined8 local_48;\n  \n  if (param_2 == 0) {\n    __fprintf_chk(param_1,1,\"%s %s\\n\",param_3,param_4);\n  }\n  else {\n    __fprintf_chk(param_1,1,\"%s (%s) %s\\n\",param_2,param_3,param_4);\n  }\n  uVar1 = dcgettext(0,&DAT_0010ed83,5);\n  __fprintf_chk(param_1,1,\"Copyright %s %d Free Software Foundation, Inc.\",uVar1,0x7e2);\n  pcVar2 = (char *)dcgettext(0,\n                             \"\\nLicense GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>.\\nThis is free software: you are free to change and redistribute it.\\nThere is NO WARRANTY, to the extent permitted by law.\\n\\n\"\n                             ,5);\n  fputs_unlocked(pcVar2,param_1);\n  switch(param_6) {\n  case 0:\n                    /* WARNING: Subroutine does not return */\n    abort();\n  case 1:\n    uVar1 = *param_5;\n    uVar4 = dcgettext(0,\"Written by %s.\\n\",5);\n    uVar1 = __fprintf_chk(param_1,1,uVar4,uVar1);\n    return uVar1;\n  case 2:\n    uVar1 = param_5[1];\n    uVar4 = *param_5;\n    uVar5 = dcgettext(0,\"Written by %s and %s.\\n\",5);\n    uVar1 = __fprintf_chk(param_1,1,uVar5,uVar4,uVar1);\n    return uVar1;\n  case 3:\n    uVar1 = param_5[2];\n    uVar4 = param_5[1];\n    uVar5 = *param_5;\n    uVar6 = dcgettext(0,\"Written by %s, %s, and %s.\\n\",5);\n    uVar1 = __fprintf_chk(param_1,1,uVar6,uVar5,uVar4,uVar1);\n    return uVar1;\n  case 4:\n    uVar1 = param_5[3];\n    uVar4 = param_5[2];\n    uVar5 = param_5[1];\n    uVar6 = *param_5;\n    uVar3 = dcgettext(0,\"Written by %s, %s, %s,\\nand %s.\\n\",5);\n    goto LAB_0010b6d9;\n  case 5:\n    uVar1 = param_5[3];\n    uVar4 = param_5[2];\n    uVar5 = param_5[1];\n    uVar6 = *param_5;\n    uVar3 = dcgettext(0,\"Written by %s, %s, %s,\\n%s, and %s.\\n\",5);\nLAB_0010b6d9:\n    __fprintf_chk(param_1,1,uVar3,uVar6,uVar5,uVar4);\n    return uVar1;\n  case 6:\n    local_58 = param_5[5];\n    local_60 = param_5[4];\n    uVar1 = param_5[3];\n    uVar4 = param_5[2];\n    uVar5 = param_5[1];\n    uVar6 = *param_5;\n    uVar3 = dcgettext(0,\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\",5);\n    goto LAB_0010b77b;\n  case 7:\n    local_58 = param_5[5];\n    local_60 = param_5[4];\n    uVar1 = param_5[3];\n    uVar4 = param_5[2];\n    uVar5 = param_5[1];\n    uVar6 = *param_5;\n    uVar3 = dcgettext(0,\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\",5);\nLAB_0010b77b:\n    uVar1 = __fprintf_chk(param_1,1,uVar3,uVar6,uVar5,uVar4,uVar1,local_60,local_58);\n    return uVar1;\n  case 8:\n    local_48 = param_5[7];\n    local_50 = param_5[6];\n    local_58 = param_5[5];\n    local_60 = param_5[4];\n    uVar1 = param_5[3];\n    uVar4 = param_5[2];\n    uVar5 = param_5[1];\n    uVar6 = *param_5;\n    uVar3 = dcgettext(0,\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\",5);\n    goto LAB_0010b52d;\n  case 9:\n    local_48 = param_5[7];\n    pcVar2 = \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\";\n    local_50 = param_5[6];\n    local_58 = param_5[5];\n    local_60 = param_5[4];\n    uVar1 = param_5[3];\n    uVar4 = param_5[2];\n    uVar5 = param_5[1];\n    uVar6 = *param_5;\n    break;\n  default:\n    local_48 = param_5[7];\n    pcVar2 = \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\";\n    local_50 = param_5[6];\n    local_58 = param_5[5];\n    local_60 = param_5[4];\n    uVar1 = param_5[3];\n    uVar4 = param_5[2];\n    uVar5 = param_5[1];\n    uVar6 = *param_5;\n  }\n  uVar3 = dcgettext(0,pcVar2,5);\nLAB_0010b52d:\n  uVar1 = __fprintf_chk(param_1,1,uVar3,uVar6,uVar5,uVar4,uVar1,local_60,local_58,local_50,local_48)\n  ;\n  return uVar1;\n}\n\n", 
    "001151f8": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nuintmax_t strtoumax(char *__nptr,char **__endptr,int __base)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strtoumax@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00102750": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fileno(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_fileno_00113ef0)();\n  return iVar1;\n}\n\n", 
    "0010c620": "\nuint rotr32(uint param_1,byte param_2)\n\n{\n  return param_1 >> (param_2 & 0x1f) | param_1 << 0x20 - (param_2 & 0x1f);\n}\n\n", 
    "001150d8": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * strrchr(char *__s,int __c)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strrchr@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00108730": "\nvoid hash_free(long **param_1)\n\n{\n  void *pvVar1;\n  void *__ptr;\n  long *plVar2;\n  long *plVar3;\n  long *plVar4;\n  long lVar5;\n  \n  plVar4 = *param_1;\n  plVar2 = param_1[1];\n  if ((param_1[8] != (long *)0x0) && (param_1[4] != (long *)0x0)) {\n    if (plVar2 <= plVar4) goto LAB_001087dc;\n    do {\n      while (lVar5 = *plVar4, plVar3 = plVar4, lVar5 == 0) {\n        plVar4 = plVar4 + 2;\n        if (plVar2 <= plVar4) goto LAB_0010879f;\n      }\n      while( true ) {\n        (*(code *)param_1[8])(lVar5);\n        plVar3 = (long *)plVar3[1];\n        if (plVar3 == (long *)0x0) break;\n        lVar5 = *plVar3;\n      }\n      plVar2 = param_1[1];\n      plVar4 = plVar4 + 2;\n    } while (plVar4 < plVar2);\nLAB_0010879f:\n    plVar4 = *param_1;\n  }\n  if (plVar4 < plVar2) {\n    do {\n      __ptr = (void *)plVar4[1];\n      while (__ptr != (void *)0x0) {\n        pvVar1 = *(void **)((long)__ptr + 8);\n        free(__ptr);\n        __ptr = pvVar1;\n      }\n      plVar4 = plVar4 + 2;\n    } while (plVar4 <= param_1[1] && param_1[1] != plVar4);\n  }\nLAB_001087dc:\n  plVar4 = param_1[9];\n  while (plVar4 != (long *)0x0) {\n    plVar2 = (long *)plVar4[1];\n    free(plVar4);\n    plVar4 = plVar2;\n  }\n  free(*param_1);\n  free(param_1);\n  return;\n}\n\n", 
    "001151f0": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fseeko(FILE *__stream,__off_t __off,int __whence)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fseeko@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001150d0": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint nanosleep(timespec *__requested_time,timespec *__remaining)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* nanosleep@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001025b0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t __ctype_get_mb_cur_max(void)\n\n{\n  size_t sVar1;\n  \n  sVar1 = (*(code *)PTR___ctype_get_mb_cur_max_00113e20)();\n  return sVar1;\n}\n\n", 
    "00115148": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nlong strtol(char *__nptr,char **__endptr,int __base)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strtol@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00115028": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint strncmp(char *__s1,char *__s2,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strncmp@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010af70": "\nvoid quotearg_n_style_mem\n               (undefined4 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  long in_FS_OFFSET;\n  undefined auStack_68 [56];\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  quoting_options_from_style(auStack_68);\n  quotearg_n_options(param_1,param_3,param_4,auStack_68);\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "0010c7f0": "\nulong c_isxdigit(int param_1)\n\n{\n  ulong uVar1;\n  \n  if (param_1 - 0x30U < 0x37) {\n    uVar1 = 1L << ((byte)(param_1 - 0x30U) & 0x3f);\n    return uVar1 & 0xffffffffffffff00 | (ulong)((uVar1 & 0x7e0000007e03ff) != 0);\n  }\n  return 0;\n}\n\n", 
    "001038e0": "\nvoid write_header(undefined8 param_1)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = \"\";\n  if (first_file_7404 == '\\0') {\n    pcVar1 = \"\\n\";\n  }\n  __printf_chk(1,\"%s==> %s <==\\n\",pcVar1,param_1);\n  first_file_7404 = 0;\n  return;\n}\n\n", 
    "001027f0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t fwrite_unlocked(void *__ptr,size_t __size,size_t __n,FILE *__stream)\n\n{\n  size_t sVar1;\n  \n  sVar1 = (*(code *)PTR_fwrite_unlocked_00113f40)();\n  return sVar1;\n}\n\n", 
    "0010ad20": "\nundefined8\nquotearg_alloc_mem(undefined8 param_1,undefined8 param_2,long *param_3,undefined1 *param_4)\n\n{\n  int iVar1;\n  int *piVar2;\n  long lVar3;\n  undefined8 uVar4;\n  uint uVar5;\n  \n  if ((undefined4 *)param_4 == (undefined4 *)0x0) {\n    param_4 = default_quoting_options;\n  }\n  piVar2 = __errno_location();\n  iVar1 = *piVar2;\n  uVar5 = (uint)(param_3 == (long *)0x0) | *(uint *)((long)param_4 + 4);\n  lVar3 = quotearg_buffer_restyled\n                    (0,0,param_1,param_2,*(undefined4 *)param_4,uVar5,\n                     (undefined4 *)((long)param_4 + 8),*(undefined8 *)((long)param_4 + 0x28),\n                     *(undefined8 *)((long)param_4 + 0x30));\n  uVar4 = xcharalloc(lVar3 + 1);\n  quotearg_buffer_restyled\n            (uVar4,lVar3 + 1,param_1,param_2,*(undefined4 *)param_4,uVar5,\n             (undefined4 *)((long)param_4 + 8),*(undefined8 *)((long)param_4 + 0x28),\n             *(undefined8 *)((long)param_4 + 0x30));\n  *piVar2 = iVar1;\n  if (param_3 != (long *)0x0) {\n    *param_3 = lVar3;\n  }\n  return uVar4;\n}\n\n", 
    "001026d0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fputs_unlocked(char *__s,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_fputs_unlocked_00113eb0)();\n  return iVar1;\n}\n\n", 
    "0010ac00": "\nuint set_char_quoting(undefined1 *param_1,byte param_2,uint param_3)\n\n{\n  uint uVar1;\n  uint uVar2;\n  \n  if (param_1 == (undefined1 *)0x0) {\n    param_1 = default_quoting_options;\n  }\n  uVar1 = *(uint *)(param_1 + (ulong)(param_2 >> 5) * 4 + 8);\n  uVar2 = uVar1 >> (param_2 & 0x1f);\n  *(uint *)(param_1 + (ulong)(param_2 >> 5) * 4 + 8) =\n       ((param_3 ^ uVar2) & 1) << (param_2 & 0x1f) ^ uVar1;\n  return uVar2 & 1;\n}\n\n", 
    "0010bf30": "\nbool bkm_scale(ulong *param_1,int param_2)\n\n{\n  ulong uVar1;\n  bool bVar2;\n  \n  uVar1 = SUB168(ZEXT816((ulong)(long)param_2) * ZEXT816(*param_1),0);\n  bVar2 = SUB168(ZEXT816((ulong)(long)param_2) * ZEXT816(*param_1) >> 0x40,0) != 0;\n  if (bVar2) {\n    uVar1 = 0xffffffffffffffff;\n  }\n  *param_1 = uVar1;\n  return bVar2;\n}\n\n", 
    "00115158": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint kill(__pid_t __pid,int __sig)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* kill@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00104b30": "\nundefined8 fremote(int param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  int *piVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  long in_FS_OFFSET;\n  statfs local_a8;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = fstatfs(param_1,&local_a8);\n  if (iVar1 == 0) {\n    iVar1 = is_local_fs_type(local_a8.f_type);\n    if (iVar1 < 1) {\n      if (iVar1 < -1) {\nLAB_00104bb2:\n                    /* WARNING: Subroutine does not return */\n        __assert_fail(\"!\\\"unexpected return value from is_local_fs_type\\\"\",\"src/tail.c\",0x3b1,\n                      \"fremote\");\n      }\n      uVar4 = 1;\n    }\n    else {\n      if (iVar1 != 1) goto LAB_00104bb2;\n      uVar4 = 0;\n    }\n  }\n  else {\n    piVar2 = __errno_location();\n    uVar4 = 1;\n    if (*piVar2 != 0x26) {\n      uVar4 = quotearg_style(4,param_2);\n      uVar3 = dcgettext(0,\"cannot determine location of %s. reverting to polling\",5);\n                    /* WARNING: Subroutine does not return */\n      error(0,*piVar2,uVar3,uVar4);\n    }\n  }\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar4;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00115030": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid _ITM_deregisterTMCloneTable(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n  halt_baddata();\n}\n\n", 
    "00108fb0": "\nvoid set_program_name(char *param_1)\n\n{\n  char *pcVar1;\n  long lVar2;\n  ulong uVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  bool bVar6;\n  bool bVar7;\n  byte bVar8;\n  \n  bVar8 = 0;\n  if (param_1 == (char *)0x0) {\n    fwrite(\"A NULL argv[0] was passed through an exec system call.\\n\",1,0x37,stderr);\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  pcVar1 = strrchr(param_1,0x2f);\n  if (pcVar1 != (char *)0x0) {\n    program_name = pcVar1 + 1;\n    uVar3 = (long)program_name - (long)param_1;\n    bVar6 = uVar3 < 6;\n    bVar7 = uVar3 == 6;\n    if (6 < (long)uVar3) {\n      lVar2 = 7;\n      pbVar4 = (byte *)(pcVar1 + -6);\n      pbVar5 = (byte *)\"/.libs/\";\n      do {\n        if (lVar2 == 0) break;\n        lVar2 = lVar2 + -1;\n        bVar6 = *pbVar4 < *pbVar5;\n        bVar7 = *pbVar4 == *pbVar5;\n        pbVar4 = pbVar4 + (ulong)bVar8 * -2 + 1;\n        pbVar5 = pbVar5 + (ulong)bVar8 * -2 + 1;\n      } while (bVar7);\n      if ((!bVar6 && !bVar7) == bVar6) {\n        if (((pcVar1[1] != 'l') || (pcVar1[2] != 't')) || (pcVar1[3] != '-')) {\n          program_invocation_name = program_name;\n          return;\n        }\n        param_1 = pcVar1 + 4;\n        program_invocation_short_name = param_1;\n      }\n    }\n  }\n  program_name = param_1;\n  program_invocation_name = param_1;\n  return;\n}\n\n", 
    "00115150": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * memcpy(void *__dest,void *__src,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* memcpy@@GLIBC_2.14 */\n  halt_baddata();\n}\n\n", 
    "00102740": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint inotify_init(void)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_inotify_init_00113ee8)();\n  return iVar1;\n}\n\n", 
    "0010c740": "\nbool c_isgraph(int param_1)\n\n{\n  return param_1 - 0x21U < 0x5e;\n}\n\n", 
    "00102620": "\nvoid __fdelt_chk(void)\n\n{\n  (*(code *)PTR___fdelt_chk_00113e58)();\n  return;\n}\n\n", 
    "0010c860": "\nint c_strcasecmp(undefined *param_1,undefined *param_2)\n\n{\n  byte bVar1;\n  byte bVar2;\n  int iVar3;\n  \n  iVar3 = 0;\n  if (param_1 != param_2) {\n    do {\n      bVar1 = c_tolower(*param_1);\n      bVar2 = c_tolower(*param_2);\n      if (bVar1 == 0) break;\n      param_1 = param_1 + 1;\n      param_2 = param_2 + 1;\n    } while (bVar1 == bVar2);\n    iVar3 = (uint)bVar1 - (uint)bVar2;\n  }\n  return iVar3;\n}\n\n", 
    "00102500": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint strncmp(char *__s1,char *__s2,size_t __n)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_strncmp_00113dc8)();\n  return iVar1;\n}\n\n", 
    "001080f0": "\nundefined8 hash_get_n_buckets(long param_1)\n\n{\n  return *(undefined8 *)(param_1 + 0x10);\n}\n\n", 
    "0010aef0": "\nvoid quotearg(undefined8 param_1)\n\n{\n  quotearg_n(0,param_1);\n  return;\n}\n\n", 
    "001090e0": "\nundefined8 strcaseeq8(long param_1,undefined8 param_2,byte param_3)\n\n{\n  char cVar1;\n  byte bVar2;\n  undefined8 uVar3;\n  \n  cVar1 = c_isupper((int)(char)param_3);\n  bVar2 = *(byte *)(param_1 + 8);\n  if (cVar1 != '\\0') {\n    bVar2 = bVar2 & 0xdf;\n  }\n  if (param_3 != bVar2) {\n    return 0;\n  }\n  if (param_3 == 0) {\n    return 1;\n  }\n  uVar3 = strcaseeq9(param_1,param_2);\n  return uVar3;\n}\n\n", 
    "001150e8": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid __assert_fail(char *__assertion,char *__file,uint __line,char *__function)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __assert_fail@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00102860": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fseeko(FILE *__stream,__off_t __off,int __whence)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_fseeko_00113f78)();\n  return iVar1;\n}\n\n", 
    "00106ed0": "\nvoid usage(int param_1)\n\n{\n  FILE *pFVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  char *pcVar4;\n  \n  uVar3 = program_name;\n  if (param_1 == 0) {\n    uVar2 = dcgettext(0,\"Usage: %s [OPTION]... [FILE]...\\n\",5);\n    __printf_chk(1,uVar2,uVar3);\n    uVar3 = dcgettext(0,\n                      \"Print the last %d lines of each FILE to standard output.\\nWith more than one FILE, precede each with a header giving the file name.\\n\"\n                      ,5);\n    __printf_chk(1,uVar3,10);\n    emit_stdin_note();\n    emit_mandatory_arg_note();\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\n                               \"  -c, --bytes=[+]NUM       output the last NUM bytes; or use -c +NUM to\\n                             output starting with byte NUM of each file\\n\"\n                               ,5);\n    fputs_unlocked(pcVar4,pFVar1);\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\n                               \"  -f, --follow[={name|descriptor}]\\n                           output appended data as the file grows;\\n                             an absent option argument means \\'descriptor\\'\\n  -F                       same as --follow=name --retry\\n\"\n                               ,5);\n    fputs_unlocked(pcVar4,pFVar1);\n    uVar3 = dcgettext(0,\n                      \"  -n, --lines=[+]NUM       output the last NUM lines, instead of the last %d;\\n                             or use -n +NUM to output starting with line NUM\\n      --max-unchanged-stats=N\\n                           with --follow=name, reopen a FILE which has not\\n                             changed size after N (default %d) iterations\\n                             to see if it has been unlinked or renamed\\n                             (this is the usual case of rotated log files);\\n                             with inotify, this option is rarely useful\\n\"\n                      ,5);\n    __printf_chk(1,uVar3,10,5);\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\n                               \"      --pid=PID            with -f, terminate after process ID, PID dies\\n  -q, --quiet, --silent    never output headers giving file names\\n      --retry              keep trying to open a file if it is inaccessible\\n\"\n                               ,5);\n    fputs_unlocked(pcVar4,pFVar1);\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\n                               \"  -s, --sleep-interval=N   with -f, sleep for approximately N seconds\\n                             (default 1.0) between iterations;\\n                             with inotify and --pid=P, check process P at\\n                             least once every N seconds\\n  -v, --verbose            always output headers giving file names\\n\"\n                               ,5);\n    fputs_unlocked(pcVar4,pFVar1);\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\"  -z, --zero-terminated    line delimiter is NUL, not newline\\n\",5\n                              );\n    fputs_unlocked(pcVar4,pFVar1);\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\"      --help     display this help and exit\\n\",5);\n    fputs_unlocked(pcVar4,pFVar1);\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\"      --version  output version information and exit\\n\",5);\n    fputs_unlocked(pcVar4,pFVar1);\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\n                               \"\\nNUM may have a multiplier suffix:\\nb 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\\nGB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y.\\n\\n\"\n                               ,5);\n    fputs_unlocked(pcVar4,pFVar1);\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\n                               \"With --follow (-f), tail defaults to following the file descriptor, which\\nmeans that even if a tail\\'ed file is renamed, tail will continue to track\\nits end.  This default behavior is not desirable when you really want to\\ntrack the actual name of the file, not the file descriptor (e.g., log\\nrotation).  Use --follow=name in that case.  That causes tail to track the\\nnamed file in a way that accommodates renaming, removal and creation.\\n\"\n                               ,5);\n    fputs_unlocked(pcVar4,pFVar1);\n    emit_ancillary_info_constprop_0();\n  }\n  else {\n    uVar2 = dcgettext(0,\"Try \\'%s --help\\' for more information.\\n\",5);\n    __fprintf_chk(stderr,1,uVar2,uVar3);\n  }\n                    /* WARNING: Subroutine does not return */\n  exit(param_1);\n}\n\n", 
    "00106660": "\nvoid tail_forever(undefined8 param_1,undefined8 *param_2,long param_3)\n\n{\n  uint uVar1;\n  bool bVar2;\n  bool bVar3;\n  bool bVar4;\n  __time_t _Var5;\n  char cVar6;\n  uint uVar7;\n  int iVar8;\n  uint uVar9;\n  int iVar10;\n  undefined8 uVar11;\n  int *piVar12;\n  undefined8 uVar13;\n  long lVar14;\n  long lVar15;\n  uint uVar16;\n  undefined8 *puVar17;\n  long in_FS_OFFSET;\n  bool bVar18;\n  undefined auVar19 [16];\n  long local_108;\n  bool local_e2;\n  stat local_d8;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (pid == 0) {\n    local_e2 = follow_mode == 2 && param_3 == 1;\n    uVar16 = pid;\n    if (local_e2) {\n      if (*(int *)(param_2 + 7) == -1) {\n        local_e2 = false;\n      }\n      else {\n        bVar18 = (*(uint *)(param_2 + 6) & 0xf000) != 0x8000;\n        local_e2 = bVar18 && local_e2;\n        uVar16 = (uint)bVar18;\n      }\n    }\n  }\n  else {\n    local_e2 = false;\n    uVar16 = 0;\n  }\n  local_108 = param_3 + -1;\n  bVar18 = false;\n  do {\n    bVar3 = bVar18;\n    bVar4 = false;\n    lVar15 = 0;\n    puVar17 = param_2;\nLAB_00106785:\n    do {\n      if (*(char *)((long)puVar17 + 0x34) == '\\0') {\n        iVar10 = *(int *)(puVar17 + 7);\n        if (iVar10 < 0) {\n          lVar15 = lVar15 + 1;\n          recheck(puVar17,uVar16);\n          puVar17 = puVar17 + 0xc;\n          if (param_3 == lVar15) break;\n          goto LAB_00106785;\n        }\n        uVar11 = pretty_name_isra_0(*puVar17);\n        uVar1 = *(uint *)(puVar17 + 6);\n        uVar9 = uVar16;\n        if (*(uint *)(puVar17 + 8) != uVar16) {\n          uVar7 = rpl_fcntl(iVar10,3);\n          if (uVar16 == 0) {\n            if ((-1 < (int)uVar7) &&\n               ((uVar7 == (uVar7 | 0x800) || (iVar8 = rpl_fcntl(iVar10,4), iVar8 != -1)))) {\nLAB_00106747:\n              *(uint *)(puVar17 + 8) = uVar16;\n              goto LAB_0010674e;\n            }\n          }\n          else if (-1 < (int)uVar7) goto LAB_00106747;\n          piVar12 = __errno_location();\n          if (((*(uint *)(puVar17 + 6) & 0xf000) != 0x8000) || (*piVar12 != 1)) {\n            uVar11 = quotearg_n_style_colon(0,3,uVar11);\n            uVar13 = dcgettext(0,\"%s: cannot change nonblocking mode\",5);\n                    /* WARNING: Subroutine does not return */\n            error(1,*piVar12,uVar13,uVar11);\n          }\n          uVar9 = *(uint *)(puVar17 + 8);\n        }\nLAB_0010674e:\n        lVar14 = -2;\n        if (uVar9 == 0) {\n          iVar8 = fstat(iVar10,&local_d8);\n          lVar14 = local_d8.st_mtim.tv_nsec;\n          _Var5 = local_d8.st_mtim.tv_sec;\n          uVar9 = local_d8.st_mode;\n          if (iVar8 != 0) {\n            *(undefined4 *)(puVar17 + 7) = 0xffffffff;\n            piVar12 = __errno_location();\n            *(int *)((long)puVar17 + 0x3c) = *piVar12;\n            uVar11 = quotearg_n_style_colon(0,3,uVar11);\n                    /* WARNING: Subroutine does not return */\n            error(0,*piVar12,&DAT_0010e524,uVar11);\n          }\n          if ((*(uint *)(puVar17 + 6) == local_d8.st_mode) &&\n             (((local_d8.st_mode & 0xf000) != 0x8000 || (puVar17[1] == local_d8.st_size)))) {\n            auVar19 = get_stat_mtime_isra_0(local_d8.st_mtim.tv_sec,local_d8.st_mtim.tv_nsec);\n            iVar8 = timespec_cmp(puVar17[2],puVar17[3],SUB168(auVar19,0),SUB168(auVar19 >> 0x40,0));\n            if (iVar8 == 0) {\n              bVar18 = max_n_unchanged_stats_between_opens <= (ulong)puVar17[0xb];\n              puVar17[0xb] = puVar17[0xb] + 1;\n              if ((bVar18) && (follow_mode == 1)) {\n                recheck(puVar17,*(int *)(puVar17 + 8) != 0);\n                puVar17[0xb] = 0;\n              }\n              goto LAB_00106777;\n            }\n          }\n          auVar19 = get_stat_mtime_isra_0(_Var5,lVar14);\n          puVar17[0xb] = 0;\n          *(undefined (*) [16])(puVar17 + 2) = auVar19;\n          *(uint *)(puVar17 + 6) = uVar9;\n          if (((uVar1 & 0xf000) == 0x8000) && (local_d8.st_size < (long)puVar17[1])) {\n            uVar11 = quotearg_n_style_colon(0,3,uVar11);\n            uVar13 = dcgettext(0,\"%s: file truncated\",5);\n                    /* WARNING: Subroutine does not return */\n            error(0,0,uVar13,uVar11);\n          }\n          if ((local_108 != lVar15) && (print_headers != '\\0')) {\n            write_header(uVar11);\n          }\n          local_108 = lVar15;\n          if (*(int *)(puVar17 + 8) == 0) {\n            lVar14 = -1;\n            if (((uVar1 & 0xf000) == 0x8000) && (*(char *)((long)puVar17 + 0x35) != '\\0')) {\n              lVar14 = local_d8.st_size - puVar17[1];\n            }\n          }\n          else {\n            lVar14 = -2;\n          }\n        }\n        lVar14 = dump_remainder(0,uVar11,iVar10,lVar14);\n        puVar17[1] = puVar17[1] + lVar14;\n        bVar4 = (bool)(bVar4 | lVar14 != 0);\n      }\nLAB_00106777:\n      lVar15 = lVar15 + 1;\n      puVar17 = puVar17 + 0xc;\n    } while (param_3 != lVar15);\n    cVar6 = any_live_files(param_2);\n    if (cVar6 == '\\0') {\n      uVar11 = dcgettext(0,\"no files remaining\",5);\n                    /* WARNING: Subroutine does not return */\n      error(0,0,uVar11);\n    }\n    bVar2 = (bool)(bVar4 ^ 1U | local_e2);\n    bVar18 = bVar3;\n    if (bVar2) {\n      iVar10 = fflush_unlocked(stdout);\n      if (iVar10 != 0) {\n        uVar11 = dcgettext(0,\"write error\",5);\n        piVar12 = __errno_location();\n                    /* WARNING: Subroutine does not return */\n        error(1,*piVar12,uVar11);\n      }\n      check_output_alive();\n      if (!bVar4) {\n        if (bVar3) {\n          if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n            return;\n          }\n                    /* WARNING: Subroutine does not return */\n          __stack_chk_fail();\n        }\n        if ((((pid == 0) || (iVar10 = kill(pid,0), iVar10 == 0)) ||\n            (piVar12 = __errno_location(), bVar18 = bVar2, *piVar12 == 1)) &&\n           (iVar10 = xnanosleep(param_1), bVar18 = bVar3, iVar10 != 0)) {\n          uVar11 = dcgettext(0,\"cannot read realtime clock\",5);\n          piVar12 = __errno_location();\n                    /* WARNING: Subroutine does not return */\n          error(1,*piVar12,uVar11);\n        }\n      }\n    }\n    else {\n      check_output_alive();\n    }\n  } while( true );\n}\n\n", 
    "001150e0": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\n__off_t lseek(int __fd,__off_t __offset,int __whence)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* lseek@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001026c0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint memcmp(void *__s1,void *__s2,size_t __n)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_memcmp_00113ea8)();\n  return iVar1;\n}\n\n", 
    "0010b3b0": "\nuint fd_safer(uint param_1)\n\n{\n  int iVar1;\n  uint uVar2;\n  int *piVar3;\n  \n  if (2 < param_1) {\n    return param_1;\n  }\n  uVar2 = dup_safer();\n  piVar3 = __errno_location();\n  iVar1 = *piVar3;\n  close(param_1);\n  *piVar3 = iVar1;\n  return uVar2;\n}\n\n", 
    "00115038": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid _exit(int __status)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* _exit@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001025a0": "\nvoid dcgettext(void)\n\n{\n  (*(code *)PTR_dcgettext_00113e18)();\n  return;\n}\n\n", 
    "0010c6e0": "\nbool c_isascii(uint param_1)\n\n{\n  return param_1 < 0x80;\n}\n\n", 
    "00105c10": "\nchar tail_forever_inotify(double param_1,int param_2,char **param_3,long param_4)\n\n{\n  char cVar1;\n  uint uVar2;\n  uint uVar3;\n  bool bVar4;\n  char cVar5;\n  uint32_t __mask;\n  int iVar6;\n  int iVar7;\n  long lVar8;\n  size_t sVar9;\n  long lVar10;\n  long lVar11;\n  uint *puVar12;\n  undefined8 uVar13;\n  undefined8 uVar14;\n  int *piVar15;\n  char **ppcVar16;\n  char **ppcVar17;\n  char *__name;\n  stat *psVar18;\n  timeval *__timeout;\n  ulong uVar19;\n  char *__s;\n  long in_FS_OFFSET;\n  ulong local_1b8;\n  ulong local_1b0;\n  long local_198;\n  long local_170;\n  int local_15c;\n  timeval local_138 [4];\n  int local_f4;\n  stat local_d8;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  lVar8 = hash_initialize(param_4,0,wd_hasher,wd_comparator,0);\n  if (lVar8 == 0) {\nLAB_0010664c:\n                    /* WARNING: Subroutine does not return */\n    xalloc_die();\n  }\n  bVar4 = false;\n  cVar5 = '\\0';\n  __mask = 2;\n  if (follow_mode == 1) {\n    __mask = 0xc06;\n  }\n  uVar19 = 0;\n  ppcVar16 = param_3;\n  iVar7 = follow_mode;\n  do {\n    if (*(char *)((long)ppcVar16 + 0x34) == '\\0') {\n      __s = *ppcVar16;\n      sVar9 = strlen(__s);\n      *(undefined4 *)((long)ppcVar16 + 0x44) = 0xffffffff;\n      if (uVar19 < sVar9) {\n        uVar19 = sVar9;\n      }\n      if (iVar7 == 1) {\n        lVar10 = dir_len(__s);\n        cVar1 = __s[lVar10];\n        lVar11 = last_component(__s);\n        __name = \".\";\n        ppcVar16[10] = (char *)(lVar11 - (long)__s);\n        __s[lVar10] = '\\0';\n        if (lVar10 != 0) {\n          __name = *ppcVar16;\n        }\n        iVar6 = inotify_add_watch(param_2,__name,0x784);\n        *(int *)(ppcVar16 + 9) = iVar6;\n        (*ppcVar16)[lVar10] = cVar1;\n        if (*(int *)(ppcVar16 + 9) < 0) {\n          piVar15 = __errno_location();\n          if (*piVar15 != 0x1c) {\n            uVar13 = quotearg_style(4,*ppcVar16);\n            uVar14 = dcgettext(0,\"cannot watch parent directory of %s\",5);\n                    /* WARNING: Subroutine does not return */\n            error(0,*piVar15,uVar14,uVar13);\n          }\n          goto LAB_00105da0;\n        }\n        __s = *ppcVar16;\n      }\n      iVar6 = inotify_add_watch(param_2,__s,__mask);\n      *(int *)((long)ppcVar16 + 0x44) = iVar6;\n      if (iVar6 < 0) {\n        if (*(int *)(ppcVar16 + 7) != -1) {\n          bVar4 = true;\n        }\n        puVar12 = (uint *)__errno_location();\n        if ((*puVar12 & 0xffffffef) == 0xc) {\nLAB_00105da0:\n          uVar13 = dcgettext(0,\"inotify resources exhausted\",5);\n                    /* WARNING: Subroutine does not return */\n          error(0,0,uVar13);\n        }\n        if (*(uint *)((long)ppcVar16 + 0x3c) != *puVar12) {\n          uVar13 = quotearg_style(4,*ppcVar16);\n          uVar14 = dcgettext(0,\"cannot watch %s\",5);\n                    /* WARNING: Subroutine does not return */\n          error(0,*puVar12,uVar14,uVar13);\n        }\n      }\n      else {\n        lVar10 = hash_insert(lVar8,ppcVar16);\n        if (lVar10 == 0) goto LAB_0010664c;\n        cVar5 = '\\x01';\n        iVar7 = follow_mode;\n      }\n    }\n    ppcVar16 = ppcVar16 + 0xc;\n  } while (ppcVar16 != param_3 + param_4 * 0xc);\n  ppcVar16 = param_3;\n  if (iVar7 != 2) {\nLAB_00105ec4:\n    do {\n      if (*(char *)((long)ppcVar16 + 0x34) == '\\0') {\n        if (follow_mode == 1) {\n          recheck(ppcVar16,0);\n        }\n        else if (((*(int *)(ppcVar16 + 7) != -1) && (iVar7 = stat(*ppcVar16,&local_d8), iVar7 == 0))\n                && ((ppcVar16[4] != (char *)local_d8.st_dev ||\n                    (ppcVar16[5] != (char *)local_d8.st_ino)))) {\n          uVar13 = pretty_name_isra_0(*ppcVar16);\n          uVar13 = quotearg_style(4,uVar13);\n          uVar14 = dcgettext(0,\"%s was replaced\",5);\n          piVar15 = __errno_location();\n                    /* WARNING: Subroutine does not return */\n          error(0,*piVar15,uVar14,uVar13);\n        }\n        check_fspec(ppcVar16);\n      }\n      ppcVar16 = ppcVar16 + 0xc;\n    } while (ppcVar16 != param_3 + param_4 * 0xc);\n    local_170 = uVar19 + 0x11;\n    bVar4 = false;\n    local_198 = xmalloc(local_170);\n    local_1b0 = 0;\n    local_15c = 3;\n    local_1b8 = 0;\nLAB_00105f91:\n    do {\n      if (((follow_mode == 1) && (reopen_inaccessible_files == '\\0')) &&\n         (lVar10 = hash_get_n_entries(lVar8), lVar10 == 0)) {\n        uVar13 = dcgettext(0,\"no files remaining\",5);\n                    /* WARNING: Subroutine does not return */\n        error(0,0,uVar13);\n      }\n      if (local_1b8 < local_1b0) {\nLAB_001060ee:\n        piVar15 = (int *)(local_198 + local_1b8);\n        uVar2 = piVar15[3];\n        iVar7 = *piVar15;\n        local_1b8 = local_1b8 + 0x10 + (ulong)uVar2;\n        uVar3 = piVar15[1];\n        if ((uVar3 & 0x400) == 0) {\n          if (uVar2 == 0) goto LAB_00106208;\n        }\n        else {\n          ppcVar16 = param_3 + 9;\n          if (uVar2 == 0) {\n            do {\n              if (*(int *)ppcVar16 == iVar7) {\n                hash_free(lVar8);\n                uVar13 = dcgettext(0,\"directory containing watched file was removed\",5);\n                    /* WARNING: Subroutine does not return */\n                error(0,0,uVar13);\n              }\n              ppcVar16 = ppcVar16 + 0xc;\n            } while (param_3 + 9 + param_4 * 0xc != ppcVar16);\nLAB_00106208:\n            local_f4 = iVar7;\n            ppcVar16 = (char **)hash_lookup(lVar8);\nLAB_001061d0:\n            if (ppcVar16 != (char **)0x0) {\nLAB_001061d9:\n              if ((piVar15[1] & 0xe04U) == 0) {\n                check_fspec(ppcVar16);\n              }\n              else {\n                if ((piVar15[1] & 0x400U) != 0) {\n                  inotify_rm_watch(param_2,*(int *)((long)ppcVar16 + 0x44));\n                  hash_delete(lVar8);\n                }\n                recheck(ppcVar16);\n              }\n            }\n            goto LAB_00105f91;\n          }\n        }\n        lVar10 = 0;\n        ppcVar16 = param_3;\n        do {\n          if ((*(int *)(ppcVar16 + 9) == iVar7) &&\n             (iVar6 = strcmp((char *)(piVar15 + 4),ppcVar16[10] + (long)*ppcVar16), iVar6 == 0)) {\n            if (param_4 == lVar10) break;\n            ppcVar16 = param_3 + lVar10 * 0xc;\n            if ((uVar3 & 0x200) == 0) {\n              iVar7 = inotify_add_watch(param_2,*ppcVar16,__mask);\n              if (iVar7 < 0) {\n                puVar12 = (uint *)__errno_location();\n                if ((*puVar12 & 0xffffffef) != 0xc) {\n                  uVar13 = quotearg_style(4,*ppcVar16);\n                  uVar14 = dcgettext(0,\"cannot watch %s\",5);\n                    /* WARNING: Subroutine does not return */\n                  error(0,*puVar12,uVar14,uVar13);\n                }\n                uVar13 = dcgettext(0,\"inotify resources exhausted\",5);\n                    /* WARNING: Subroutine does not return */\n                error(0,0,uVar13);\n              }\n              iVar6 = *(int *)((long)ppcVar16 + 0x44);\n              if (iVar6 == iVar7) {\n                if (iVar6 < 0) goto LAB_001063e0;\n              }\n              else {\n                if (-1 < iVar6) {\n                  inotify_rm_watch(param_2,iVar6);\n                  hash_delete(lVar8);\n                }\nLAB_001063e0:\n                *(int *)((long)ppcVar16 + 0x44) = iVar7;\n                if (iVar7 == -1) break;\n                ppcVar17 = (char **)hash_delete(lVar8,ppcVar16);\n                if ((ppcVar17 != (char **)0x0) && (ppcVar16 != ppcVar17)) {\n                  if (follow_mode == 1) {\n                    recheck(ppcVar17,0);\n                  }\n                  *(undefined4 *)((long)ppcVar17 + 0x44) = 0xffffffff;\n                  uVar13 = pretty_name_isra_0(*ppcVar17);\n                  close_fd(*(undefined4 *)(ppcVar17 + 7),uVar13);\n                }\n                lVar10 = hash_insert(lVar8);\n                if (lVar10 == 0) goto LAB_0010664c;\n              }\n              if (follow_mode != 1) goto LAB_001061d9;\n            }\n            else if (follow_mode != 1) goto LAB_001061d0;\n            recheck(ppcVar16);\n            goto LAB_001061d0;\n          }\n          lVar10 = lVar10 + 1;\n          ppcVar16 = ppcVar16 + 0xc;\n        } while (param_4 != lVar10);\n        goto LAB_00105f91;\n      }\n      while( true ) {\n        do {\n          if (pid != 0) {\n            if (bVar4) {\n                    /* WARNING: Subroutine does not return */\n              exit(0);\n            }\n            iVar7 = kill(pid,0);\n            if ((iVar7 == 0) || (piVar15 = __errno_location(), *piVar15 == 1)) {\n              local_138[0].tv_sec = (__time_t)param_1;\n              local_138[0].tv_usec =\n                   (__suseconds_t)(DAT_0010e4b8 * (param_1 - (double)local_138[0].tv_sec));\n            }\n            else {\n              local_138[0].tv_usec = 0;\n              bVar4 = true;\n              local_138[0].tv_sec = 0;\n            }\n          }\n          psVar18 = &local_d8;\n          for (lVar10 = 0x10; lVar10 != 0; lVar10 = lVar10 + -1) {\n            psVar18->st_dev = 0;\n            psVar18 = (stat *)&psVar18->st_ino;\n          }\n          lVar10 = __fdelt_chk((long)param_2);\n          local_d8.__unused[lVar10 + -0xf] =\n               local_d8.__unused[lVar10 + -0xf] | 1L << ((byte)((long)param_2 % 0x40) & 0x3f);\n          if (monitor_output != '\\0') {\n            local_d8.st_dev = local_d8.st_dev | 2;\n          }\n          __timeout = local_138;\n          if (pid == 0) {\n            __timeout = (timeval *)0x0;\n          }\n          iVar7 = 1;\n          if (0 < param_2) {\n            iVar7 = param_2;\n          }\n          iVar7 = select(iVar7 + 1,(fd_set *)&local_d8,(fd_set *)0x0,(fd_set *)0x0,__timeout);\n        } while (iVar7 == 0);\n        if (iVar7 == -1) {\n          uVar13 = dcgettext(0,\"error waiting for inotify and output events\",5);\n          piVar15 = __errno_location();\n                    /* WARNING: Subroutine does not return */\n          error(1,*piVar15,uVar13);\n        }\n        if ((local_d8.st_dev & 2) == 0) break;\n        raise(0xd);\n      }\n      local_1b0 = safe_read(param_2,local_198,local_170);\n      if (local_1b0 != 0) {\n        local_1b8 = 0;\n        if (local_1b0 != 0xffffffffffffffff) goto LAB_001060ee;\n        piVar15 = __errno_location();\n        if (*piVar15 != 0x16) {\nLAB_001062b2:\n          uVar13 = dcgettext(0,\"error reading inotify event\",5);\n          piVar15 = __errno_location();\n                    /* WARNING: Subroutine does not return */\n          error(1,*piVar15,uVar13);\n        }\n      }\n      if (local_15c == 0) goto LAB_001062b2;\n      local_15c = local_15c + -1;\n      local_170 = local_170 * 2;\n      local_198 = xrealloc(local_198);\n      local_1b0 = 0;\n      local_1b8 = 0;\n    } while( true );\n  }\n  if (bVar4) {\n    piVar15 = __errno_location();\n    hash_free(lVar8);\n    *piVar15 = 0;\n    cVar5 = '\\x01';\n  }\n  else if (cVar5 != '\\0') goto LAB_00105ec4;\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return cVar5;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00115168": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fileno(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fileno@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001027e0": "\nvoid __freading(void)\n\n{\n  (*(code *)PTR___freading_00113f38)();\n  return;\n}\n\n", 
    "00115048": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint isatty(int __fd)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* isatty@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00104d60": "\nulong tail_bytes(undefined8 param_1,int param_2,ulong param_3,long *param_4)\n\n{\n  char cVar1;\n  int iVar2;\n  uint uVar3;\n  __off_t _Var4;\n  long lVar5;\n  ulong uVar6;\n  undefined8 uVar7;\n  undefined8 uVar8;\n  int *piVar9;\n  long in_FS_OFFSET;\n  stat sStack_c8;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar2 = fstat(param_2,&sStack_c8);\n  if (iVar2 != 0) {\n    uVar7 = quotearg_style(4,param_1);\n    uVar8 = dcgettext(0,\"cannot fstat %s\",5);\n    piVar9 = __errno_location();\n                    /* WARNING: Subroutine does not return */\n    error(0,*piVar9,uVar8,uVar7);\n  }\n  if (from_start == '\\0') {\n    if ((presume_input_pipe == '\\0') && (-1 < (long)param_3)) {\n      cVar1 = usable_st_size_isra_0(sStack_c8.st_mode);\n      if (cVar1 == '\\0') {\n        lVar5 = lseek(param_2,-param_3,2);\n        if (lVar5 == -1) goto LAB_00104f48;\n        sStack_c8.st_size = lVar5 + param_3;\n      }\n      else {\n        lVar5 = -1;\n      }\n      if (0x1fffffffffffffff < sStack_c8.st_blksize - 1U) {\n        sStack_c8.st_blksize = 0x200;\n      }\n      if (sStack_c8.st_blksize < sStack_c8.st_size) {\n        if (lVar5 == -1) {\n          lVar5 = xlseek(param_2,0,1,param_1);\n        }\n        if ((lVar5 < sStack_c8.st_size) && (param_3 < (ulong)(sStack_c8.st_size - lVar5))) {\n          lVar5 = sStack_c8.st_size - param_3;\n          xlseek(param_2,lVar5,0,param_1);\n        }\n        *param_4 = lVar5;\n        goto LAB_00104e00;\n      }\n    }\nLAB_00104f48:\n    uVar6 = pipe_bytes(param_1,param_2,param_3,param_4);\n  }\n  else {\n    if (((presume_input_pipe == '\\0') && (-1 < (long)param_3)) &&\n       ((((sStack_c8.st_mode & 0xf000) == 0x8000 &&\n         (lVar5 = xlseek(param_2,param_3,1,param_1), -1 < lVar5)) ||\n        (_Var4 = lseek(param_2,param_3,1), _Var4 != -1)))) {\n      *param_4 = *param_4 + param_3;\n      param_3 = 0xffffffffffffffff;\n    }\n    else {\n      uVar3 = start_bytes(param_1,param_2,param_3,param_4);\n      param_3 = 0xffffffffffffffff;\n      if (uVar3 != 0) {\n        uVar6 = (ulong)(uVar3 >> 0x1f);\n        goto LAB_00104e19;\n      }\n    }\nLAB_00104e00:\n    lVar5 = dump_remainder(0,param_1,param_2,param_3);\n    *param_4 = *param_4 + lVar5;\n    uVar6 = 1;\n  }\nLAB_00104e19:\n  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar6;\n}\n\n", 
    "00115160": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint inotify_init(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* inotify_init@@GLIBC_2.4 */\n  halt_baddata();\n}\n\n", 
    "00115040": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __fpending(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __fpending@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00102850": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint open(char *__file,int __oflag,...)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_open_00113f70)();\n  return iVar1;\n}\n\n", 
    "0010bdb0": "\nvoid xdectoumax(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n               undefined8 param_5,undefined8 param_6)\n\n{\n  xnumtoumax(param_1,10,param_2,param_3,param_4,param_5,param_6);\n  return;\n}\n\n", 
    "0010c630": "\nvoid rotl_sz(void)\n\n{\n  rotl64();\n  return;\n}\n\n", 
    "00102730": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint kill(__pid_t __pid,int __sig)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_kill_00113ee0)();\n  return iVar1;\n}\n\n", 
    "0010c750": "\nbool c_islower(int param_1)\n\n{\n  return param_1 - 0x61U < 0x1a;\n}\n\n", 
    "00102610": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * strchr(char *__s,int __c)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_strchr_00113e50)();\n  return pcVar1;\n}\n\n", 
    "00102890": "\nvoid __cxa_atexit(void)\n\n{\n  (*(code *)PTR___cxa_atexit_00113f90)();\n  return;\n}\n\n", 
    "00102770": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint __xstat(int __ver,char *__filename,stat *__stat_buf)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR___xstat_00113f00)();\n  return iVar1;\n}\n\n", 
    "0010c600": "\nulong rotr64(ulong param_1,byte param_2)\n\n{\n  return param_1 >> (param_2 & 0x3f) | param_1 << 0x40 - (param_2 & 0x3f);\n}\n\n", 
    "00102650": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * strrchr(char *__s,int __c)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_strrchr_00113e70)();\n  return pcVar1;\n}\n\n", 
    "00108c80": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nlong hash_delete(long param_1,undefined8 param_2)\n\n{\n  void *pvVar1;\n  void *__ptr;\n  char cVar2;\n  long lVar3;\n  ulong uVar4;\n  ulong uVar5;\n  float *pfVar6;\n  long in_FS_OFFSET;\n  float fVar7;\n  float fVar8;\n  long *local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  lVar3 = hash_find_entry(param_1,param_2,&local_28,1);\n  if ((lVar3 == 0) || (*(long *)(param_1 + 0x20) = *(long *)(param_1 + 0x20) + -1, *local_28 != 0))\n  goto LAB_00108cc3;\n  uVar4 = *(long *)(param_1 + 0x18) - 1;\n  *(ulong *)(param_1 + 0x18) = uVar4;\n  if ((long)uVar4 < 0) {\n    uVar5 = *(ulong *)(param_1 + 0x10);\n    fVar7 = (float)(uVar4 >> 1 | (ulong)((uint)uVar4 & 1));\n    pfVar6 = *(float **)(param_1 + 0x28);\n    fVar7 = fVar7 + fVar7;\n    if ((long)uVar5 < 0) goto LAB_00108dfa;\nLAB_00108d14:\n    fVar8 = (float)uVar5;\n  }\n  else {\n    pfVar6 = *(float **)(param_1 + 0x28);\n    fVar7 = (float)uVar4;\n    uVar5 = *(ulong *)(param_1 + 0x10);\n    if (-1 < (long)uVar5) goto LAB_00108d14;\nLAB_00108dfa:\n    fVar8 = (float)(uVar5 >> 1 | (ulong)((uint)uVar5 & 1));\n    fVar8 = fVar8 + fVar8;\n  }\n  if (fVar7 < fVar8 * *pfVar6) {\n    check_tuning_isra_0(param_1 + 0x28);\n    uVar4 = *(ulong *)(param_1 + 0x10);\n    pfVar6 = *(float **)(param_1 + 0x28);\n    if ((long)uVar4 < 0) {\n      fVar7 = (float)(uVar4 >> 1 | (ulong)((uint)uVar4 & 1));\n      fVar7 = fVar7 + fVar7;\n    }\n    else {\n      fVar7 = (float)uVar4;\n    }\n    uVar4 = *(ulong *)(param_1 + 0x18);\n    if ((long)uVar4 < 0) {\n      fVar8 = (float)(uVar4 >> 1 | (ulong)((uint)uVar4 & 1));\n      fVar8 = fVar8 + fVar8;\n    }\n    else {\n      fVar8 = (float)uVar4;\n    }\n    if (fVar8 < *pfVar6 * fVar7) {\n      fVar7 = fVar7 * pfVar6[1];\n      if (*(char *)(pfVar6 + 4) == '\\0') {\n        fVar7 = fVar7 * pfVar6[2];\n      }\n      if (_DAT_0010e5cc <= fVar7) {\n        uVar4 = (long)(fVar7 - _DAT_0010e5cc) ^ 0x8000000000000000;\n      }\n      else {\n        uVar4 = (ulong)fVar7;\n      }\n      cVar2 = hash_rehash(param_1,uVar4);\n      if (cVar2 == '\\0') {\n        __ptr = *(void **)(param_1 + 0x48);\n        while (__ptr != (void *)0x0) {\n          pvVar1 = *(void **)((long)__ptr + 8);\n          free(__ptr);\n          __ptr = pvVar1;\n        }\n        *(undefined8 *)(param_1 + 0x48) = 0;\n      }\n    }\n  }\nLAB_00108cc3:\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return lVar3;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00102530": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint isatty(int __fd)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_isatty_00113de0)();\n  return iVar1;\n}\n\n", 
    "001091d0": "\nundefined8 strcaseeq6(long param_1,undefined8 param_2,byte param_3,char param_4,char param_5)\n\n{\n  char cVar1;\n  byte bVar2;\n  undefined8 uVar3;\n  \n  cVar1 = c_isupper((int)(char)param_3);\n  bVar2 = *(byte *)(param_1 + 6);\n  if (cVar1 != '\\0') {\n    bVar2 = bVar2 & 0xdf;\n  }\n  if (param_3 != bVar2) {\n    return 0;\n  }\n  if (param_3 == 0) {\n    return 1;\n  }\n  uVar3 = strcaseeq7(param_1,param_2,(int)param_4,(int)param_5);\n  return uVar3;\n}\n\n", 
    "0010c840": "\nint c_toupper(int param_1)\n\n{\n  if (param_1 - 0x61U < 0x1a) {\n    param_1 = param_1 + -0x20;\n  }\n  return param_1;\n}\n\n", 
    "00105000": "\nvoid record_open_fd(long param_1,undefined4 param_2,undefined8 param_3,undefined8 *param_4,\n                   undefined4 param_5)\n\n{\n  undefined4 uVar1;\n  undefined8 uVar2;\n  undefined auVar3 [16];\n  \n  *(undefined4 *)(param_1 + 0x38) = param_2;\n  uVar2 = param_4[0xc];\n  *(undefined8 *)(param_1 + 8) = param_3;\n  auVar3 = get_stat_mtime_isra_0(param_4[0xb],uVar2);\n  uVar2 = *param_4;\n  *(undefined (*) [16])(param_1 + 0x10) = auVar3;\n  *(undefined8 *)(param_1 + 0x20) = uVar2;\n  *(undefined8 *)(param_1 + 0x28) = param_4[1];\n  uVar1 = *(undefined4 *)(param_4 + 3);\n  *(undefined4 *)(param_1 + 0x40) = param_5;\n  *(undefined4 *)(param_1 + 0x30) = uVar1;\n  *(undefined8 *)(param_1 + 0x58) = 0;\n  *(undefined *)(param_1 + 0x34) = 0;\n  return;\n}\n\n", 
    "001151d0": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __printf_chk(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __printf_chk@@GLIBC_2.3.4 */\n  halt_baddata();\n}\n\n", 
    "0010cc90": "\nvoid __libc_csu_fini(void)\n\n{\n  return;\n}\n\n", 
    "001150b0": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t mbrtowc(wchar_t *__pwc,char *__s,size_t __n,mbstate_t *__p)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* mbrtowc@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010ca50": "\nchar * locale_charset(void)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = nl_langinfo(0xe);\n  if (pcVar1 != (char *)0x0) {\n    if (*pcVar1 == '\\0') {\n      pcVar1 = \"ASCII\";\n    }\n    return pcVar1;\n  }\n  return \"ASCII\";\n}\n\n", 
    "00115248": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint inotify_rm_watch(int __fd,int __wd)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* inotify_rm_watch@@GLIBC_2.4 */\n  halt_baddata();\n}\n\n", 
    "00115128": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint ferror_unlocked(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* ferror_unlocked@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00115008": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint raise(int __sig)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* raise@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001026f0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * calloc(size_t __nmemb,size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = (void *)(*(code *)PTR_calloc_00113ec0)();\n  return pvVar1;\n}\n\n", 
    "001025d0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint __lxstat(int __ver,char *__filename,stat *__stat_buf)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR___lxstat_00113e30)();\n  return iVar1;\n}\n\n", 
    "001024b0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * getenv(char *__name)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_getenv_00113da0)();\n  return pcVar1;\n}\n\n", 
    "00107d00": "\nulong raw_hasher(undefined8 param_1,ulong param_2)\n\n{\n  ulong uVar1;\n  \n  uVar1 = rotr_sz(param_1,3);\n  return uVar1 % param_2;\n}\n\n", 
    "0010ae20": "\nvoid quotearg_free(void)\n\n{\n  void **ppvVar1;\n  void *__ptr;\n  undefined *__ptr_00;\n  void **ppvVar2;\n  \n  __ptr_00 = slotvec;\n  if (1 < nslots) {\n    ppvVar2 = (void **)(slotvec + 0x18);\n    ppvVar1 = (void **)(slotvec + (ulong)(nslots - 2) * 0x10 + 0x28);\n    do {\n      __ptr = *ppvVar2;\n      ppvVar2 = ppvVar2 + 2;\n      free(__ptr);\n    } while (ppvVar2 != ppvVar1);\n  }\n  if (*(undefined1 **)(__ptr_00 + 8) != slot0) {\n    free(*(undefined1 **)(__ptr_00 + 8));\n    slotvec0._8_8_ = slot0;\n    slotvec0._0_8_ = 0x100;\n  }\n  if (__ptr_00 != slotvec0) {\n    free(__ptr_00);\n    slotvec = slotvec0;\n  }\n  nslots = 1;\n  return;\n}\n\n", 
    "0010c7c0": "\nbool c_isspace(int param_1)\n\n{\n  if (param_1 < 0xe) {\n    return 8 < param_1;\n  }\n  return param_1 == 0x20;\n}\n\n", 
    "00115250": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nushort ** __ctype_b_loc(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __ctype_b_loc@@GLIBC_2.3 */\n  halt_baddata();\n}\n\n", 
    "00115130": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * calloc(size_t __nmemb,size_t __size)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* calloc@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00115010": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid free(void *__ptr)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* free@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00103a60": "\nundefined8 parse_obsolete_option(int param_1,long param_2,undefined8 *param_3)\n\n{\n  char cVar1;\n  int iVar2;\n  uint uVar3;\n  char *pcVar4;\n  undefined8 uVar5;\n  int *piVar6;\n  undefined8 uVar7;\n  char *pcVar8;\n  undefined uVar9;\n  char *pcVar10;\n  undefined uVar11;\n  \n  if (param_1 != 2) {\n    if (param_1 == 3) {\n      pcVar10 = *(char **)(param_2 + 0x10);\n      if ((*pcVar10 != '-') || (pcVar10[1] == '\\0')) goto LAB_00103a95;\n    }\n    else {\n      if (param_1 != 4) {\n        return 0;\n      }\n      pcVar10 = *(char **)(param_2 + 0x10);\n    }\n    iVar2 = strcmp(pcVar10,\"--\");\n    if (iVar2 != 0) {\n      return 0;\n    }\n  }\nLAB_00103a95:\n  iVar2 = posix2_version();\n  pcVar8 = *(char **)(param_2 + 8);\n  pcVar10 = pcVar8 + 1;\n  if (*pcVar8 == '+') {\n    uVar9 = 1;\n    if (iVar2 - 0x30db0U < 0x2b9) {\n      return 0;\n    }\n  }\n  else {\n    if (*pcVar8 != '-') {\n      return 0;\n    }\n    if ((0x30daf < iVar2) && (pcVar8[(ulong)(pcVar8[1] == 'c') + 1] == '\\0')) {\n      return 0;\n    }\n    uVar9 = 0;\n  }\n  cVar1 = pcVar8[1];\n  pcVar8 = pcVar10;\n  while ((int)cVar1 - 0x30U < 10) {\n    pcVar4 = pcVar8 + 1;\n    pcVar8 = pcVar8 + 1;\n    cVar1 = *pcVar4;\n  }\n  if (cVar1 == 'c') {\n    uVar11 = 0;\n    uVar7 = 10;\n  }\n  else if (cVar1 == 'l') {\n    uVar11 = 1;\n    uVar7 = 10;\n  }\n  else {\n    if (cVar1 != 'b') {\n      uVar11 = 1;\n      uVar7 = 10;\n      pcVar4 = pcVar8;\n      goto LAB_00103b2b;\n    }\n    uVar11 = 0;\n    uVar7 = 0x1400;\n  }\n  pcVar4 = pcVar8 + 1;\nLAB_00103b2b:\n  cVar1 = *pcVar4;\n  if (cVar1 == 'f') {\n    pcVar4 = pcVar4 + 1;\n  }\n  if (*pcVar4 != '\\0') {\n    return 0;\n  }\n  if (pcVar10 == pcVar8) {\n    *param_3 = uVar7;\n  }\n  else {\n    uVar3 = xstrtoumax(pcVar10,0,10,param_3,&DAT_0010df61);\n    if ((uVar3 & 0xfffffffd) != 0) {\n      uVar7 = quote(*(undefined8 *)(param_2 + 8));\n      uVar5 = dcgettext(0,\"invalid number\",5);\n      piVar6 = __errno_location();\n                    /* WARNING: Subroutine does not return */\n      error(1,*piVar6,\"%s: %s\",uVar5,uVar7);\n    }\n  }\n  from_start = uVar9;\n  forever = cVar1 == 'f';\n  count_lines = uVar11;\n  return 1;\n}\n\n", 
    "00102520": "\nvoid __fpending(void)\n\n{\n  (*(code *)PTR___fpending_00113dd8)();\n  return;\n}\n\n", 
    "001151d8": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid error(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* error@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00102eb0": "\n/* WARNING: Removing unreachable block (ram,0x00102ec3) */\n/* WARNING: Removing unreachable block (ram,0x00102ecf) */\n\nvoid deregister_tm_clones(void)\n\n{\n  return;\n}\n\n", 
    "0010aff0": "\nvoid quotearg_style_mem(undefined4 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  quotearg_n_style_mem(0,param_1,param_2,param_3);\n  return;\n}\n\n", 
    "001150b8": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * strchr(char *__s,int __c)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strchr@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00102880": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fstatfs(int __fildes,statfs *__buf)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_fstatfs_00113f88)();\n  return iVar1;\n}\n\n", 
    "00102760": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint select(int __nfds,fd_set *__readfds,fd_set *__writefds,fd_set *__exceptfds,timeval *__timeout)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_select_00113ef8)();\n  return iVar1;\n}\n\n", 
    "00103850": "\nulong wd_hasher(long param_1,ulong param_2)\n\n{\n  return (ulong)(long)*(int *)(param_1 + 0x44) % param_2;\n}\n\n", 
    "0010aca0": "\nvoid quotearg_buffer(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n                    undefined1 *param_5)\n\n{\n  int iVar1;\n  int *piVar2;\n  \n  if ((undefined4 *)param_5 == (undefined4 *)0x0) {\n    param_5 = default_quoting_options;\n  }\n  piVar2 = __errno_location();\n  iVar1 = *piVar2;\n  quotearg_buffer_restyled\n            (param_1,param_2,param_3,param_4,*(undefined4 *)param_5,\n             *(undefined4 *)((long)param_5 + 4),(undefined4 *)((long)param_5 + 8),\n             *(undefined8 *)((long)param_5 + 0x28),*(undefined8 *)((long)param_5 + 0x30));\n  *piVar2 = iVar1;\n  return;\n}\n\n", 
    "0010c610": "\nuint rotl32(uint param_1,byte param_2)\n\n{\n  return param_1 << (param_2 & 0x1f) | param_1 >> 0x20 - (param_2 & 0x1f);\n}\n\n", 
    "00102640": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint nanosleep(timespec *__requested_time,timespec *__remaining)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_nanosleep_00113e68)();\n  return iVar1;\n}\n\n", 
    "00108500": "\nulong hash_string(byte *param_1,ulong param_2)\n\n{\n  byte bVar1;\n  ulong uVar2;\n  \n  uVar2 = 0;\n  bVar1 = *param_1;\n  while (bVar1 != 0) {\n    param_1 = param_1 + 1;\n    uVar2 = (uVar2 * 0x1f + (ulong)bVar1) % param_2;\n    bVar1 = *param_1;\n  }\n  return uVar2;\n}\n\n", 
    "001090c0": "\nbool strcaseeq9(long param_1,long param_2)\n\n{\n  int iVar1;\n  \n  iVar1 = c_strcasecmp(param_1 + 9,param_2 + 9);\n  return iVar1 == 0;\n}\n\n", 
    "0010c730": "\nbool c_isdigit(int param_1)\n\n{\n  return param_1 - 0x30U < 10;\n}\n\n", 
    "001151e8": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint open(char *__file,int __oflag,...)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* open@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001150c0": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __fdelt_chk(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __fdelt_chk@@GLIBC_2.15 */\n  halt_baddata();\n}\n\n", 
    "00104140": "\nundefined8\nfile_lines(undefined8 param_1,undefined4 param_2,long param_3,long param_4,long param_5,\n          long *param_6)\n\n{\n  char cVar1;\n  size_t __n;\n  void *pvVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  int *piVar5;\n  int __c;\n  long lVar6;\n  size_t sVar7;\n  long in_FS_OFFSET;\n  bool bVar8;\n  undefined8 local_2050;\n  undefined local_2048 [8200];\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_2050 = param_5;\n  if (param_3 != 0) {\n    lVar6 = (param_5 - param_4) % 0x2000;\n    if (lVar6 == 0) {\n      lVar6 = 0x2000;\n    }\n    param_5 = param_5 - lVar6;\n    xlseek(param_2,param_5,0,param_1);\n    __n = safe_read(param_2,local_2048,lVar6);\n    cVar1 = line_end;\n    if (__n == 0xffffffffffffffff) {\nLAB_00104337:\n      uVar3 = quotearg_style(4,param_1);\n      uVar4 = dcgettext(0,\"error reading %s\",5);\n      piVar5 = __errno_location();\n                    /* WARNING: Subroutine does not return */\n      error(0,*piVar5,uVar4,uVar3);\n    }\n    __c = (int)line_end;\n    *param_6 = param_5 + __n;\n    sVar7 = __n;\n    if ((__n != 0) && (local_2048[__n - 1] != cVar1)) {\n      param_3 = param_3 + -1;\n    }\n    do {\n      while ((__n == 0 || (pvVar2 = memrchr(local_2048,__c,__n), pvVar2 == (void *)0x0))) {\n        if (param_5 == param_4) {\n          xlseek(param_2,param_5,0,param_1);\n          lVar6 = dump_remainder(0,param_1,param_2,local_2050);\n          *param_6 = param_5 + lVar6;\n          goto LAB_00104303;\n        }\n        param_5 = param_5 + -0x2000;\n        xlseek(param_2,param_5,0,param_1);\n        __n = safe_read(param_2,local_2048,0x2000);\n        if (__n == 0xffffffffffffffff) goto LAB_00104337;\n        *param_6 = param_5 + __n;\n        if (__n == 0) goto LAB_00104303;\n        __c = (int)line_end;\n        sVar7 = __n;\n      }\n      __n = (long)pvVar2 - (long)local_2048;\n      bVar8 = param_3 != 0;\n      param_3 = param_3 + -1;\n    } while (bVar8);\n    if (sVar7 - 1 != __n) {\n      xwrite_stdout((long)pvVar2 + 1,(sVar7 - 1) - __n);\n    }\n    lVar6 = dump_remainder(0,param_1,param_2,(local_2050 - sVar7) - param_5);\n    *param_6 = *param_6 + lVar6;\n  }\nLAB_00104303:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return 1;\n}\n\n", 
    "001151e0": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * memrchr(void *__s,int __c,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* memrchr@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001024a0": "\nvoid __cxa_finalize(void)\n\n{\n  (*(code *)PTR___cxa_finalize_00113ff8)();\n  return;\n}\n\n", 
    "00102f20": "\nvoid __do_global_dtors_aux(void)\n\n{\n  if (completed_8061 == '\\0') {\n    if (PTR___cxa_finalize_00113ff8 != (undefined *)0x0) {\n      __cxa_finalize(__dso_handle);\n    }\n    deregister_tm_clones();\n    completed_8061 = 1;\n    return;\n  }\n  return;\n}\n\n", 
    "0010c6c0": "\nbool c_isalpha(int param_1)\n\n{\n  if (param_1 < 0x5b) {\n    return 0x40 < param_1;\n  }\n  return param_1 - 0x61U < 0x1a;\n}\n\n", 
    "00115258": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __cxa_finalize(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __cxa_finalize@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010c7e0": "\nbool c_isupper(int param_1)\n\n{\n  return param_1 - 0x41U < 0x1a;\n}\n\n", 
    "00115138": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint strcmp(char *__s1,char *__s2)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strcmp@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00115018": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid abort(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* abort@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00108180": "\nbool hash_table_ok(long **param_1)\n\n{\n  long lVar1;\n  long *plVar2;\n  long *plVar3;\n  long *plVar4;\n  \n  plVar2 = *param_1;\n  plVar3 = (long *)0x0;\n  plVar4 = (long *)0x0;\n  do {\n    while( true ) {\n      if (param_1[1] <= plVar2) {\n        if (param_1[3] != plVar4) {\n          return false;\n        }\n        return param_1[4] == plVar3;\n      }\n      if (*plVar2 != 0) break;\nLAB_001081a0:\n      plVar2 = plVar2 + 2;\n    }\n    lVar1 = plVar2[1];\n    plVar4 = (long *)((long)plVar4 + 1);\n    plVar3 = (long *)((long)plVar3 + 1);\n    if (lVar1 == 0) goto LAB_001081a0;\n    do {\n      lVar1 = *(long *)(lVar1 + 8);\n      plVar3 = (long *)((long)plVar3 + 1);\n    } while (lVar1 != 0);\n    plVar2 = plVar2 + 2;\n  } while( true );\n}\n\n", 
    "001037d0": "\nundefined8 any_non_remote_file(long param_1,long param_2)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  \n  pcVar2 = (char *)(param_1 + 0x35);\n  pcVar1 = pcVar2 + param_2 * 0x60;\n  while ((*(int *)(pcVar2 + 3) < 0 || (*pcVar2 != '\\0'))) {\n    pcVar2 = pcVar2 + 0x60;\n    if (pcVar2 == pcVar1) {\n      return 0;\n    }\n  }\n  return 1;\n}\n\n", 
    "001026e0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint ferror_unlocked(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_ferror_unlocked_00113eb8)();\n  return iVar1;\n}\n\n", 
    "00109260": "\nundefined8\nstrcaseeq5(long param_1,undefined8 param_2,byte param_3,char param_4,char param_5,char param_6)\n\n{\n  char cVar1;\n  byte bVar2;\n  undefined8 uVar3;\n  \n  cVar1 = c_isupper((int)(char)param_3);\n  bVar2 = *(byte *)(param_1 + 5);\n  if (cVar1 != '\\0') {\n    bVar2 = bVar2 & 0xdf;\n  }\n  if (param_3 != bVar2) {\n    return 0;\n  }\n  if (param_3 == 0) {\n    return 1;\n  }\n  uVar3 = strcaseeq6(param_1,param_2,(int)param_4,(int)param_5,(int)param_6);\n  return uVar3;\n}\n\n", 
    "001025c0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t strlen(char *__s)\n\n{\n  size_t sVar1;\n  \n  sVar1 = (*(code *)PTR_strlen_00113e28)();\n  return sVar1;\n}\n\n", 
    "00109140": "\nundefined8 strcaseeq7(long param_1,undefined8 param_2,byte param_3,char param_4)\n\n{\n  char cVar1;\n  byte bVar2;\n  undefined8 uVar3;\n  \n  cVar1 = c_isupper((int)(char)param_3);\n  bVar2 = *(byte *)(param_1 + 7);\n  if (cVar1 != '\\0') {\n    bVar2 = bVar2 & 0xdf;\n  }\n  if (param_3 != bVar2) {\n    return 0;\n  }\n  if (param_3 == 0) {\n    return 1;\n  }\n  uVar3 = strcaseeq8(param_1,param_2,(int)param_4);\n  return uVar3;\n}\n\n", 
    "00115140": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __gmon_start__(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n  halt_baddata();\n}\n\n", 
    "00115020": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint * __errno_location(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __errno_location@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00102630": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\n__locale_t newlocale(int __category_mask,char *__locale,__locale_t __base)\n\n{\n  __locale_t p_Var1;\n  \n  p_Var1 = (__locale_t)(*(code *)PTR_newlocale_00113e60)();\n  return p_Var1;\n}\n\n", 
    "00109820": "\nulong quotearg_buffer_restyled\n                (undefined *param_1,ulong param_2,char *param_3,ulong param_4,int param_5,\n                uint param_6,long param_7,char *param_8,char *param_9)\n\n{\n  byte *__s1;\n  bool bVar1;\n  bool bVar2;\n  bool bVar3;\n  bool bVar4;\n  bool bVar5;\n  bool bVar6;\n  int iVar7;\n  size_t sVar8;\n  ushort **ppuVar9;\n  long lVar10;\n  char cVar11;\n  uint uVar12;\n  ulong uVar13;\n  byte bVar14;\n  ulong uVar15;\n  char *pcVar16;\n  ulong uVar17;\n  ulong uVar18;\n  ulong uVar19;\n  long in_FS_OFFSET;\n  bool bVar20;\n  bool bVar21;\n  bool bVar22;\n  bool bVar23;\n  bool bVar24;\n  size_t local_c8;\n  char *local_98;\n  ulong local_90;\n  char *local_78;\n  char *local_70;\n  bool local_64;\n  wint_t local_4c;\n  mbstate_t local_48;\n  long local_40;\n  \n  local_70 = param_8;\n  local_78 = param_9;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  sVar8 = __ctype_get_mb_cur_max();\n  uVar12 = param_6 & 2;\n  bVar20 = uVar12 != 0;\n  switch(param_5) {\n  case 0:\n    bVar6 = true;\n    bVar2 = false;\n    uVar18 = 0;\n    local_64 = false;\n    local_90 = 0;\n    bVar20 = false;\n    bVar1 = false;\n    local_c8 = 0;\n    local_98 = (char *)0x0;\n    break;\n  case 2:\n    if (uVar12 == 0) {\n      bVar1 = false;\nLAB_00109ca7:\n      if (param_2 == 0) {\n        local_90 = 0;\n        bVar2 = false;\n        bVar6 = true;\n        local_64 = false;\n        goto LAB_00109cc9;\n      }\n      bVar2 = false;\n      local_64 = false;\n      bVar6 = true;\n      uVar13 = 0;\n      local_90 = param_2;\n      goto LAB_0010a266;\n    }\n    bVar2 = false;\n    uVar18 = 0;\n    bVar6 = true;\n    local_64 = false;\n    local_90 = 0;\n    bVar20 = true;\n    bVar1 = false;\n    local_c8 = 1;\n    local_98 = \"\\'\";\n    break;\n  case 3:\n    bVar1 = true;\n    goto LAB_00109c1f;\n  case 4:\n    if (uVar12 == 0) {\n      bVar1 = true;\n      goto LAB_00109ca7;\n    }\n  case 1:\n    bVar1 = false;\nLAB_00109c1f:\n    bVar6 = true;\n    local_64 = false;\n    bVar20 = true;\n    local_90 = 0;\n    bVar2 = false;\n    uVar18 = 0;\n    param_5 = 2;\n    local_c8 = 1;\n    local_98 = \"\\'\";\n    break;\n  case 5:\n    if (uVar12 == 0) {\n      if (param_2 != 0) {\n        *param_1 = 0x22;\n      }\n      bVar6 = true;\n      local_64 = false;\n      local_90 = 0;\n      bVar2 = false;\n      bVar20 = false;\n      uVar18 = 1;\n      bVar1 = true;\n      local_c8 = 1;\n      local_98 = \"\\\"\";\n    }\n    else {\n      bVar2 = false;\n      uVar18 = 0;\n      bVar6 = true;\n      local_64 = false;\n      local_90 = 0;\n      bVar20 = true;\n      bVar1 = true;\n      local_c8 = 1;\n      local_98 = \"\\\"\";\n    }\n    break;\n  case 6:\n    bVar2 = false;\n    uVar18 = 0;\n    bVar6 = true;\n    local_64 = false;\n    param_5 = 5;\n    local_90 = 0;\n    bVar20 = true;\n    bVar1 = true;\n    local_c8 = 1;\n    local_98 = \"\\\"\";\n    break;\n  case 7:\n    bVar6 = true;\n    bVar2 = false;\n    uVar18 = 0;\n    local_64 = false;\n    local_90 = 0;\n    bVar20 = false;\n    bVar1 = true;\n    local_c8 = 0;\n    local_98 = (char *)0x0;\n    break;\n  case 8:\n  case 9:\n  case 10:\n    if (param_5 != 10) {\n      local_70 = (char *)gettext_quote(&DAT_0010e649,param_5);\n      local_78 = (char *)gettext_quote(&DAT_0010e639);\n    }\n    uVar18 = 0;\n    if (uVar12 == 0) {\n      cVar11 = *local_70;\n      while (cVar11 != '\\0') {\n        if (uVar18 < param_2) {\n          param_1[uVar18] = cVar11;\n        }\n        uVar18 = uVar18 + 1;\n        cVar11 = local_70[uVar18];\n      }\n    }\n    bVar2 = false;\n    local_c8 = strlen(local_78);\n    local_98 = local_78;\n    bVar6 = true;\n    local_64 = false;\n    local_90 = 0;\n    bVar1 = true;\n    break;\n  default:\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  do {\n    uVar13 = 0;\n    bVar4 = local_64;\nLAB_00109970:\n    bVar21 = param_4 != uVar13;\n    if (param_4 == 0xffffffffffffffff) {\n      bVar21 = param_3[uVar13] != '\\0';\n    }\n    bVar24 = bVar1;\n    if (bVar21) {\n      bVar23 = (bool)(param_5 != 2 & bVar1);\n      __s1 = (byte *)(param_3 + uVar13);\n      uVar17 = uVar13;\n      bVar3 = bVar2;\n      bVar5 = bVar23;\n      if (!bVar23) {\n        uVar15 = (ulong)*__s1;\n        switch(uVar15) {\n        case 0:\n          if (bVar1) goto switchD_0010a1d0_caseD_0;\n          bVar5 = false;\n          uVar15 = 0;\n          if ((param_6 & 1) != 0) goto code_r0x0010a16b;\n          goto LAB_00109f5b;\n        default:\nswitchD_0010a080_caseD_1:\n          bVar22 = bVar1;\n          if (sVar8 != 1) {\n            local_48 = (mbstate_t)0x0;\n            if (param_4 == 0xffffffffffffffff) {\n              param_4 = strlen(param_3);\n            }\n            uVar17 = 0;\n            do {\n              uVar19 = uVar13 + uVar17;\n              lVar10 = rpl_mbrtowc(&local_4c,param_3 + uVar19,param_4 - uVar19,&local_48);\n              if (lVar10 == 0) break;\n              if (lVar10 == -1) {\n                bVar21 = false;\n                goto LAB_0010a458;\n              }\n              if (lVar10 == -2) goto joined_r0x0010a86a;\n              if (((param_5 == 2) && (bVar20)) && (lVar10 != 1)) {\n                pcVar16 = param_3 + uVar19 + 1;\n                do {\n                  if (((byte)(*pcVar16 + 0xa5U) < 0x22) &&\n                     ((1L << (*pcVar16 + 0xa5U & 0x3f) & 0x20000002bU) != 0)) {\n                    param_5 = 2;\n                    goto LAB_00109e40;\n                  }\n                  pcVar16 = pcVar16 + 1;\n                } while (param_3 + uVar19 + lVar10 != pcVar16);\n              }\n              iVar7 = iswprint(local_4c);\n              if (iVar7 == 0) {\n                bVar21 = false;\n              }\n              uVar17 = uVar17 + lVar10;\n              iVar7 = mbsinit(&local_48);\n            } while (iVar7 == 0);\n            bVar22 = (bool)((bVar21 ^ 1U) & bVar1);\n            goto LAB_0010a458;\n          }\n          ppuVar9 = __ctype_b_loc();\n          uVar17 = 1;\n          bVar22 = ((*ppuVar9)[uVar15] & 0x4000) == 0;\n          bVar21 = !bVar22;\n          bVar22 = (bool)(bVar22 & bVar1);\n          goto LAB_00109be1;\n        case 7:\n          uVar15 = 7;\n          bVar14 = 0x61;\n          break;\n        case 8:\n          uVar15 = 8;\n          bVar14 = 0x62;\n          break;\n        case 9:\n          uVar15 = 9;\n          bVar14 = 0x74;\n          goto LAB_0010a128;\n        case 10:\n          uVar15 = 10;\n          bVar14 = 0x6e;\n          goto LAB_0010a128;\n        case 0xb:\n          uVar15 = 0xb;\n          bVar14 = 0x76;\n          break;\n        case 0xc:\n          uVar15 = 0xc;\n          bVar14 = 0x66;\n          break;\n        case 0xd:\n          uVar15 = 0xd;\n          bVar14 = 0x72;\nLAB_0010a128:\n          bVar23 = (bool)(param_5 == 2 & bVar20);\n          if (bVar23) goto LAB_00109e37;\n          break;\n        case 0x20:\n          uVar15 = 0x20;\n          goto LAB_00109e24;\n        case 0x21:\n        case 0x22:\n        case 0x24:\n        case 0x26:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x3b:\n        case 0x3c:\n        case 0x3d:\n        case 0x3e:\n        case 0x5b:\n        case 0x5e:\n        case 0x60:\n        case 0x7c:\n          bVar21 = false;\nLAB_00109e24:\n          bVar22 = param_5 == 2;\n          bVar23 = bVar21;\n          if ((!bVar20) || (!bVar22)) goto LAB_00109b48;\n          goto LAB_00109e37;\n        case 0x23:\n        case 0x7e:\nLAB_00109e1b:\n          bVar22 = param_5 == 2;\n          if (uVar13 == 0) goto LAB_00109e24;\n          goto LAB_00109b45;\n        case 0x25:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x2f:\n        case 0x30:\n        case 0x31:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x41:\n        case 0x42:\n        case 0x43:\n        case 0x44:\n        case 0x45:\n        case 0x46:\n        case 0x47:\n        case 0x48:\n        case 0x49:\n        case 0x4a:\n        case 0x4b:\n        case 0x4c:\n        case 0x4d:\n        case 0x4e:\n        case 0x4f:\n        case 0x50:\n        case 0x51:\n        case 0x52:\n        case 0x53:\n        case 0x54:\n        case 0x55:\n        case 0x56:\n        case 0x57:\n        case 0x58:\n        case 0x59:\n        case 0x5a:\n        case 0x5d:\n        case 0x5f:\n        case 0x61:\n        case 0x62:\n        case 99:\n        case 100:\n        case 0x65:\n        case 0x66:\n        case 0x67:\n        case 0x68:\n        case 0x69:\n        case 0x6a:\n        case 0x6b:\n        case 0x6c:\n        case 0x6d:\n        case 0x6e:\n        case 0x6f:\n        case 0x70:\n        case 0x71:\n        case 0x72:\n        case 0x73:\n        case 0x74:\n        case 0x75:\n        case 0x76:\n        case 0x77:\n        case 0x78:\n        case 0x79:\n        case 0x7a:\n          goto switchD_0010a080_caseD_25;\n        case 0x27:\nswitchD_0010a080_caseD_27:\n          bVar4 = bVar21;\n          if (param_5 != 2) {\n            bVar22 = false;\n            uVar15 = 0x27;\n            bVar23 = bVar21;\n            goto LAB_00109b48;\n          }\n          if (!bVar20) {\n            if ((param_2 == 0) || (uVar13 = 0, uVar15 = param_2, local_90 != 0)) {\n              if (uVar18 < param_2) {\n                param_1[uVar18] = 0x27;\n              }\n              if (uVar18 + 1 < param_2) {\n                param_1[uVar18 + 1] = 0x5c;\n              }\n              uVar13 = param_2;\n              uVar15 = local_90;\n              if (uVar18 + 2 < param_2) {\n                param_1[uVar18 + 2] = 0x27;\n              }\n            }\n            bVar14 = 0x27;\n            uVar18 = uVar18 + 3;\n            param_2 = uVar13;\n            local_90 = uVar15;\n            bVar3 = false;\n            bVar22 = false;\n            goto joined_r0x00109b6b;\n          }\n          goto LAB_00109e40;\n        case 0x3f:\nswitchD_0010a080_caseD_3f:\n          if (param_5 != 2) {\n            if ((((param_5 == 5) && ((param_6 & 4) != 0)) && (uVar17 = uVar13 + 2, uVar17 < param_4)\n                ) && (param_3[uVar13 + 1] == '?')) {\n              uVar15 = (ulong)(byte)param_3[uVar17];\n              switch(param_3[uVar17]) {\n              case '!':\n              case '\\'':\n              case '(':\n              case ')':\n              case '-':\n              case '/':\n              case '<':\n              case '=':\n              case '>':\n                goto switchD_0010a7ce_caseD_21;\n              default:\n                break;\n              }\n            }\n            bVar22 = false;\n            uVar15 = 0x3f;\n            bVar23 = false;\n            goto LAB_00109b48;\n          }\n          if (!bVar20) {\n            bVar14 = 0x3f;\n            bVar22 = false;\n            bVar21 = false;\n            goto joined_r0x00109b6b;\n          }\n          goto LAB_00109e40;\n        case 0x5c:\n          if (param_5 != 2) goto switchD_00109a78_caseD_5c;\n          if (!bVar20) {\nLAB_0010a0b8:\n            uVar13 = uVar13 + 1;\n            bVar21 = false;\n            bVar14 = 0x5c;\n            goto LAB_0010a0d0;\n          }\n          goto LAB_00109e40;\n        case 0x7b:\n        case 0x7d:\nswitchD_0010a080_caseD_7b:\n          bVar23 = param_4 != 1;\n          if (param_4 == 0xffffffffffffffff) {\n            bVar23 = param_3[1] != '\\0';\n          }\n          bVar22 = param_5 == 2;\n          if (!bVar23) goto LAB_00109e1b;\nLAB_00109b45:\n          bVar23 = false;\n          goto LAB_00109b48;\n        }\nLAB_00109f50:\n        bVar5 = bVar23;\n        if (!bVar1) {\nLAB_00109f5b:\n          bVar14 = (byte)uVar15;\n          bVar23 = false;\n          bVar21 = false;\n          bVar22 = false;\n          if (!bVar20) goto LAB_00109b68;\n          goto LAB_00109a90;\n        }\nLAB_00109f90:\n        bVar21 = false;\n        goto joined_r0x00109fa1;\n      }\n      if (local_c8 != 0) {\n        if ((param_4 == 0xffffffffffffffff) && (1 < local_c8)) {\n          param_4 = strlen(param_3);\n        }\n        if ((param_4 < uVar13 + local_c8) || (iVar7 = memcmp(__s1,local_98,local_c8), iVar7 != 0))\n        goto LAB_0010a1b0;\n        if (!bVar20) {\n          uVar15 = (ulong)*__s1;\n          switch(uVar15) {\n          case 0:\n            goto switchD_00109a78_caseD_0;\n          default:\n            goto switchD_0010a080_caseD_1;\n          case 7:\n            goto switchD_0010a1d0_caseD_7;\n          case 8:\n            goto switchD_0010a1d0_caseD_8;\n          case 9:\n            goto switchD_00109a78_caseD_9;\n          case 10:\n            goto switchD_0010a1d0_caseD_a;\n          case 0xb:\n            goto switchD_0010a1d0_caseD_b;\n          case 0xc:\n            goto switchD_0010a1d0_caseD_c;\n          case 0xd:\n            goto switchD_0010a1d0_caseD_d;\n          case 0x20:\n            goto LAB_0010a1f9;\n          case 0x21:\n          case 0x22:\n          case 0x24:\n          case 0x26:\n          case 0x28:\n          case 0x29:\n          case 0x2a:\n          case 0x3b:\n          case 0x3c:\n          case 0x3d:\n          case 0x3e:\n          case 0x5b:\n          case 0x5e:\n          case 0x60:\n          case 0x7c:\n            goto switchD_00109a78_caseD_21;\n          case 0x23:\n          case 0x7e:\n            goto LAB_0010a1e1;\n          case 0x25:\n          case 0x2b:\n          case 0x2c:\n          case 0x2d:\n          case 0x2e:\n          case 0x2f:\n          case 0x30:\n          case 0x31:\n          case 0x32:\n          case 0x33:\n          case 0x34:\n          case 0x35:\n          case 0x36:\n          case 0x37:\n          case 0x38:\n          case 0x39:\n          case 0x3a:\n          case 0x41:\n          case 0x42:\n          case 0x43:\n          case 0x44:\n          case 0x45:\n          case 0x46:\n          case 0x47:\n          case 0x48:\n          case 0x49:\n          case 0x4a:\n          case 0x4b:\n          case 0x4c:\n          case 0x4d:\n          case 0x4e:\n          case 0x4f:\n          case 0x50:\n          case 0x51:\n          case 0x52:\n          case 0x53:\n          case 0x54:\n          case 0x55:\n          case 0x56:\n          case 0x57:\n          case 0x58:\n          case 0x59:\n          case 0x5a:\n          case 0x5d:\n          case 0x5f:\n          case 0x61:\n          case 0x62:\n          case 99:\n          case 100:\n          case 0x65:\n          case 0x66:\n          case 0x67:\n          case 0x68:\n          case 0x69:\n          case 0x6a:\n          case 0x6b:\n          case 0x6c:\n          case 0x6d:\n          case 0x6e:\n          case 0x6f:\n          case 0x70:\n          case 0x71:\n          case 0x72:\n          case 0x73:\n          case 0x74:\n          case 0x75:\n          case 0x76:\n          case 0x77:\n          case 0x78:\n          case 0x79:\n          case 0x7a:\n            goto LAB_00109a88;\n          case 0x27:\n            goto switchD_0010a080_caseD_27;\n          case 0x3f:\n            goto switchD_0010a080_caseD_3f;\n          case 0x5c:\n            goto switchD_00109a78_caseD_5c;\n          case 0x7b:\n          case 0x7d:\n            goto switchD_0010a080_caseD_7b;\n          }\n        }\n        goto LAB_00109e4e;\n      }\nLAB_0010a1b0:\n      uVar15 = (ulong)*__s1;\n      switch(uVar15) {\n      case 0:\nswitchD_0010a1d0_caseD_0:\n        if (!bVar20) {\n          bVar5 = false;\nswitchD_00109a78_caseD_0:\n          bVar24 = param_5 == 2;\n          bVar3 = (bool)((bVar2 ^ 1U) & bVar24);\n          if (bVar3) {\n            if (uVar18 < param_2) {\n              param_1[uVar18] = 0x27;\n            }\n            if (uVar18 + 1 < param_2) {\n              param_1[uVar18 + 1] = 0x24;\n            }\n            if (uVar18 + 2 < param_2) {\n              param_1[uVar18 + 2] = 0x27;\n            }\n            uVar15 = uVar18 + 3;\n            bVar2 = bVar3;\n            if (param_2 <= uVar18 + 3) {\n              bVar14 = 0x30;\n              uVar18 = uVar18 + 4;\n              bVar22 = bVar3;\n              bVar21 = false;\n              goto joined_r0x00109b6b;\n            }\nLAB_0010a60b:\n            param_1[uVar15] = 0x5c;\n            uVar18 = uVar15;\n          }\n          else {\n            uVar15 = uVar18;\n            if (uVar18 < param_2) goto LAB_0010a60b;\n          }\n          uVar19 = uVar18 + 1;\n          bVar22 = bVar21;\n          if (param_5 != 2) {\n            uVar15 = 0x30;\n            if ((uVar13 + 1 < param_4) && ((byte)(param_3[uVar13 + 1] - 0x30U) < 10)) {\n              if (uVar19 < param_2) {\n                param_1[uVar19] = 0x30;\n              }\n              if (uVar18 + 2 < param_2) {\n                param_1[uVar18 + 2] = 0x30;\n              }\n              uVar19 = uVar18 + 3;\n              uVar15 = 0x30;\n            }\n            goto LAB_0010a648;\n          }\n          bVar14 = 0x30;\n          uVar18 = uVar19;\n          bVar3 = bVar2;\n          bVar21 = false;\n          goto joined_r0x00109b6b;\n        }\n        bVar24 = param_5 == 2;\n        goto LAB_00109e40;\n      default:\n        bVar23 = false;\n        goto switchD_0010a080_caseD_1;\n      case 7:\nswitchD_0010a1d0_caseD_7:\n        bVar14 = 0x61;\n        break;\n      case 8:\nswitchD_0010a1d0_caseD_8:\n        bVar14 = 0x62;\n        break;\n      case 9:\n        bVar23 = false;\nswitchD_00109a78_caseD_9:\n        uVar15 = 9;\n        bVar14 = 0x74;\n        goto LAB_00109f50;\n      case 10:\nswitchD_0010a1d0_caseD_a:\n        bVar14 = 0x6e;\n        goto LAB_00109f90;\n      case 0xb:\nswitchD_0010a1d0_caseD_b:\n        bVar14 = 0x76;\n        goto LAB_00109f90;\n      case 0xc:\nswitchD_0010a1d0_caseD_c:\n        bVar14 = 0x66;\n        break;\n      case 0xd:\nswitchD_0010a1d0_caseD_d:\n        bVar14 = 0x72;\n        goto LAB_00109f90;\n      case 0x20:\n        bVar5 = false;\nLAB_0010a1f9:\n        uVar15 = 0x20;\n        goto LAB_00109a88;\n      case 0x21:\n      case 0x22:\n      case 0x24:\n      case 0x26:\n      case 0x28:\n      case 0x29:\n      case 0x2a:\n      case 0x3b:\n      case 0x3c:\n      case 0x3d:\n      case 0x3e:\n      case 0x5b:\n      case 0x5e:\n      case 0x60:\n      case 0x7c:\n        bVar5 = false;\nswitchD_00109a78_caseD_21:\n        bVar22 = false;\n        goto LAB_00109b45;\n      case 0x23:\n      case 0x7e:\n        bVar5 = false;\nLAB_0010a1e1:\n        if (uVar13 == 0) {\n          bVar22 = false;\n          goto LAB_00109b48;\n        }\n        bVar23 = false;\n        bVar22 = false;\n        goto LAB_00109a90;\n      case 0x25:\n      case 0x2b:\n      case 0x2c:\n      case 0x2d:\n      case 0x2e:\n      case 0x2f:\n      case 0x30:\n      case 0x31:\n      case 0x32:\n      case 0x33:\n      case 0x34:\n      case 0x35:\n      case 0x36:\n      case 0x37:\n      case 0x38:\n      case 0x39:\n      case 0x3a:\n      case 0x41:\n      case 0x42:\n      case 0x43:\n      case 0x44:\n      case 0x45:\n      case 0x46:\n      case 0x47:\n      case 0x48:\n      case 0x49:\n      case 0x4a:\n      case 0x4b:\n      case 0x4c:\n      case 0x4d:\n      case 0x4e:\n      case 0x4f:\n      case 0x50:\n      case 0x51:\n      case 0x52:\n      case 0x53:\n      case 0x54:\n      case 0x55:\n      case 0x56:\n      case 0x57:\n      case 0x58:\n      case 0x59:\n      case 0x5a:\n      case 0x5d:\n      case 0x5f:\n      case 0x61:\n      case 0x62:\n      case 99:\n      case 100:\n      case 0x65:\n      case 0x66:\n      case 0x67:\n      case 0x68:\n      case 0x69:\n      case 0x6a:\n      case 0x6b:\n      case 0x6c:\n      case 0x6d:\n      case 0x6e:\n      case 0x6f:\n      case 0x70:\n      case 0x71:\n      case 0x72:\n      case 0x73:\n      case 0x74:\n      case 0x75:\n      case 0x76:\n      case 0x77:\n      case 0x78:\n      case 0x79:\n      case 0x7a:\n        bVar5 = false;\nLAB_00109a88:\n        bVar22 = false;\n        goto LAB_00109a90;\n      case 0x27:\n        bVar5 = false;\n        goto switchD_0010a080_caseD_27;\n      case 0x3f:\n        bVar5 = false;\n        goto switchD_0010a080_caseD_3f;\n      case 0x5c:\n        bVar23 = false;\nswitchD_00109a78_caseD_5c:\n        if (((bool)(bVar1 & bVar20)) && (local_c8 != 0)) goto LAB_0010a0b8;\n        uVar15 = 0x5c;\n        bVar14 = 0x5c;\n        goto LAB_00109f50;\n      case 0x7b:\n      case 0x7d:\n        bVar5 = false;\n        goto switchD_0010a080_caseD_7b;\n      }\n      if (bVar20) goto LAB_00109fb0;\n      bVar21 = false;\n      goto LAB_00109b06;\n    }\n    if ((uVar18 == 0) && ((bool)(bVar20 & param_5 == 2))) {\nLAB_00109e37:\n      param_5 = 2;\nLAB_00109e40:\n      if (bVar24) {\n        param_5 = 4;\n      }\nLAB_00109e4e:\n      uVar13 = quotearg_buffer_restyled\n                         (param_1,param_2,param_3,param_4,param_5,param_6 & 0xfffffffd,0,local_70,\n                          local_78);\n      goto LAB_00109e88;\n    }\n    bVar21 = (bool)(param_5 == 2 & (bVar20 ^ 1U));\n    bVar20 = (bool)(bVar20 ^ 1U);\n    if ((!bVar21) || (bVar20 = bVar21, !bVar4)) {\nLAB_0010a8d5:\n      uVar13 = uVar18;\n      if (((local_98 != (char *)0x0) && (bVar20)) && (cVar11 = *local_98, cVar11 != '\\0')) {\n        do {\n          if (uVar13 < param_2) {\n            param_1[uVar13] = cVar11;\n          }\n          uVar13 = uVar13 + 1;\n          cVar11 = local_98[uVar13 - uVar18];\n        } while (cVar11 != '\\0');\n      }\n      if (uVar13 < param_2) {\n        param_1[uVar13] = 0;\n      }\nLAB_00109e88:\n      if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n        return uVar13;\n      }\n                    /* WARNING: Subroutine does not return */\n      __stack_chk_fail();\n    }\n    if (bVar6) {\n      uVar13 = quotearg_buffer_restyled\n                         (param_1,local_90,param_3,param_4,5,param_6,param_7,local_70,local_78);\n      goto LAB_00109e88;\n    }\n    local_64 = param_2 == 0 && local_90 != 0;\n    uVar13 = local_90;\n    bVar20 = bVar4;\n    if (param_2 != 0 || local_90 == 0) goto LAB_0010a8d5;\nLAB_0010a266:\n    *param_1 = 0x27;\n    param_2 = local_90;\n    local_90 = uVar13;\nLAB_00109cc9:\n    bVar20 = false;\n    uVar18 = 1;\n    param_5 = 2;\n    local_c8 = 1;\n    local_98 = \"\\'\";\n  } while( true );\ncode_r0x0010a16b:\n  uVar13 = uVar13 + 1;\n  goto LAB_00109970;\nswitchD_0010a7ce_caseD_21:\n  if (!bVar20) {\n    if (uVar18 < param_2) {\n      param_1[uVar18] = 0x3f;\n    }\n    if (uVar18 + 1 < param_2) {\n      param_1[uVar18 + 1] = 0x22;\n    }\n    if (uVar18 + 2 < param_2) {\n      param_1[uVar18 + 2] = 0x22;\n    }\n    if (uVar18 + 3 < param_2) {\n      param_1[uVar18 + 3] = 0x3f;\n    }\n    uVar19 = uVar18 + 4;\n    bVar24 = false;\n    bVar22 = false;\nLAB_0010a648:\n    bVar14 = (byte)uVar15;\n    bVar23 = false;\n    bVar21 = false;\n    uVar13 = uVar17;\n    uVar18 = uVar19;\n    bVar3 = bVar2;\n    if ((bool)(bVar1 ^ 1U | bVar24)) goto joined_r0x00109b6b;\n    goto LAB_00109a90;\n  }\n  goto LAB_00109e4e;\njoined_r0x0010a86a:\n  while ((uVar19 < param_4 && (param_3[uVar19] != '\\0'))) {\n    uVar17 = uVar17 + 1;\n    uVar19 = uVar13 + uVar17;\n  }\n  bVar21 = false;\nLAB_0010a458:\n  if (1 < uVar17) {\nLAB_0010a462:\n    bVar24 = false;\n    uVar17 = uVar17 + uVar13;\n    uVar19 = uVar13;\n    do {\n      bVar14 = (byte)uVar15;\n      if (bVar22) {\n        bVar24 = param_5 == 2;\n        if (bVar20) goto LAB_00109e40;\n        bVar24 = (bool)(bVar24 & (bVar3 ^ 1U));\n        if (bVar24) {\n          if (uVar18 < param_2) {\n            param_1[uVar18] = 0x27;\n          }\n          if (uVar18 + 1 < param_2) {\n            param_1[uVar18 + 1] = 0x24;\n          }\n          if (uVar18 + 2 < param_2) {\n            param_1[uVar18 + 2] = 0x27;\n          }\n          uVar18 = uVar18 + 3;\n          bVar3 = bVar24;\n        }\n        if (uVar18 < param_2) {\n          param_1[uVar18] = 0x5c;\n        }\n        if (uVar18 + 1 < param_2) {\n          param_1[uVar18 + 1] = (char)(uVar15 >> 6) + '0';\n        }\n        if (uVar18 + 2 < param_2) {\n          param_1[uVar18 + 2] = ((byte)(uVar15 >> 3) & 7) + 0x30;\n        }\n        uVar13 = uVar19 + 1;\n        uVar18 = uVar18 + 3;\n        bVar14 = (bVar14 & 7) + 0x30;\n        bVar24 = bVar22;\n        if (uVar17 <= uVar13) goto LAB_00109b18;\n      }\n      else {\n        bVar2 = (bool)((bVar24 ^ 1U) & bVar3);\n        if (bVar23) {\n          if (uVar18 < param_2) {\n            param_1[uVar18] = 0x5c;\n          }\n          uVar18 = uVar18 + 1;\n        }\n        uVar13 = uVar19 + 1;\n        if (uVar17 <= uVar13) goto LAB_0010a0d0;\n        if (bVar2) {\n          if (uVar18 < param_2) {\n            param_1[uVar18] = 0x27;\n          }\n          if (uVar18 + 1 < param_2) {\n            param_1[uVar18 + 1] = 0x27;\n          }\n          uVar18 = uVar18 + 2;\n          bVar23 = false;\n          bVar3 = false;\n        }\n        else {\n          bVar23 = false;\n        }\n      }\n      uVar19 = uVar19 + 1;\n      if (uVar18 < param_2) {\n        param_1[uVar18] = bVar14;\n      }\n      uVar15 = (ulong)(byte)param_3[uVar19];\n      uVar18 = uVar18 + 1;\n    } while( true );\n  }\nLAB_00109be1:\n  bVar5 = bVar23;\n  if (bVar22) {\n    bVar21 = false;\n    bVar22 = bVar1;\n    goto LAB_0010a462;\n  }\nswitchD_0010a080_caseD_25:\n  bVar22 = param_5 == 2;\n  bVar23 = bVar21;\nLAB_00109b48:\n  bVar14 = (byte)uVar15;\n  bVar22 = (bool)(bVar22 | bVar1 ^ 1U);\n  if ((!bVar22) || (bVar22 = false, bVar21 = bVar23, bVar20)) {\nLAB_00109a90:\n    bVar14 = (byte)uVar15;\n    uVar17 = uVar13;\n    bVar3 = bVar2;\n    bVar21 = bVar23;\n    if ((param_7 == 0) || ((*(uint *)(param_7 + (uVar15 >> 5) * 4) >> (bVar14 & 0x1f) & 1) == 0))\n    goto joined_r0x00109b6b;\n  }\n  else {\nLAB_00109b68:\n    uVar17 = uVar13;\n    bVar22 = false;\njoined_r0x00109b6b:\n    uVar13 = uVar17;\n    bVar2 = bVar3;\n    if (!bVar5) {\n      uVar13 = uVar17 + 1;\n      bVar2 = (bool)((bVar22 ^ 1U) & bVar3);\nLAB_0010a0d0:\n      if (bVar2) {\n        if (uVar18 < param_2) {\n          param_1[uVar18] = 0x27;\n        }\n        if (uVar18 + 1 < param_2) {\n          param_1[uVar18 + 1] = 0x27;\n        }\n        uVar18 = uVar18 + 2;\n        bVar3 = false;\n      }\n      goto LAB_00109b18;\n    }\n  }\njoined_r0x00109fa1:\n  if (bVar20) {\nLAB_00109fb0:\n    bVar24 = (bool)(bVar1 & param_5 == 2);\n    goto LAB_00109e40;\n  }\n  bVar24 = (bool)((bVar2 ^ 1U) & param_5 == 2);\n  if (bVar24) {\n    if (uVar18 < param_2) {\n      param_1[uVar18] = 0x27;\n    }\n    if (uVar18 + 1 < param_2) {\n      param_1[uVar18 + 1] = 0x24;\n    }\n    if (uVar18 + 2 < param_2) {\n      param_1[uVar18 + 2] = 0x27;\n    }\n    uVar18 = uVar18 + 3;\n    bVar2 = bVar24;\n  }\nLAB_00109b06:\n  if (uVar18 < param_2) {\n    param_1[uVar18] = 0x5c;\n  }\n  uVar18 = uVar18 + 1;\n  uVar13 = uVar13 + 1;\n  bVar3 = bVar2;\nLAB_00109b18:\n  bVar2 = bVar3;\n  if (uVar18 < param_2) {\n    param_1[uVar18] = bVar14;\n  }\n  uVar18 = uVar18 + 1;\n  if (!bVar21) {\n    bVar6 = false;\n  }\n  goto LAB_00109970;\n}\n\n", 
    "001150c8": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\n__locale_t newlocale(int __category_mask,char *__locale,__locale_t __base)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* newlocale@@GLIBC_2.3 */\n  halt_baddata();\n}\n\n", 
    "00102510": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid _exit(int __status)\n\n{\n  (*(code *)PTR__exit_00113dd0)();\n  return;\n}\n\n", 
    "0010aee0": "\nvoid quotearg_n_mem(void)\n\n{\n  quotearg_n_options();\n  return;\n}\n\n", 
    "00107a90": "\nvoid dir_len(char *param_1)\n\n{\n  char cVar1;\n  long lVar2;\n  ulong uVar3;\n  \n  cVar1 = *param_1;\n  lVar2 = last_component();\n  uVar3 = lVar2 - (long)param_1;\n  do {\n    if (uVar3 <= (cVar1 == '/')) {\n      return;\n    }\n    lVar2 = uVar3 - 1;\n    uVar3 = uVar3 - 1;\n  } while (param_1[lVar2] == '/');\n  return;\n}\n\n", 
    "0010b880": "\nvoid version_etc_va(void)\n\n{\n  uint uVar1;\n  long *plVar2;\n  long lVar3;\n  uint *in_R8;\n  long lVar4;\n  long in_FS_OFFSET;\n  long local_68 [11];\n  long local_10;\n  \n  lVar4 = 0;\n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  do {\n    uVar1 = *in_R8;\n    if (uVar1 < 0x30) {\n      *in_R8 = uVar1 + 8;\n      lVar3 = *(long *)((ulong)uVar1 + *(long *)(in_R8 + 4));\n      local_68[lVar4] = lVar3;\n    }\n    else {\n      plVar2 = *(long **)(in_R8 + 2);\n      *(long **)(in_R8 + 2) = plVar2 + 1;\n      lVar3 = *plVar2;\n      local_68[lVar4] = lVar3;\n    }\n  } while ((lVar3 != 0) && (lVar4 = lVar4 + 1, lVar4 != 10));\n  version_etc_arn();\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n"
}