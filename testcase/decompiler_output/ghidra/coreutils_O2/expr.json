{
    "00103000": "\nundefined * mbs_logical_substr(char *param_1,ulong param_2,ulong param_3)\n\n{\n  char *pcVar1;\n  size_t sVar2;\n  size_t sVar3;\n  size_t sVar4;\n  undefined *__dest;\n  undefined *puVar5;\n  ulong uVar6;\n  long in_FS_OFFSET;\n  undefined local_88 [4];\n  undefined8 local_84;\n  undefined local_7c;\n  char *local_78;\n  size_t local_70;\n  char local_68;\n  int local_64;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  sVar2 = strlen(param_1);\n  sVar3 = __ctype_get_mb_cur_max();\n  sVar4 = sVar2;\n  if (1 < sVar3) {\n    sVar4 = mbslen(param_1);\n  }\n  if (((sVar4 < param_2) || (param_2 == 0)) || (0xfffffffffffffffd < param_3 - 1)) {\n    __dest = (undefined *)xstrdup(\"\");\n  }\n  else {\n    uVar6 = (sVar4 - param_2) + 1;\n    if (uVar6 <= param_3) {\n      param_3 = uVar6;\n    }\n    sVar4 = __ctype_get_mb_cur_max();\n    if (sVar4 == 1) {\n      __dest = (undefined *)xmalloc(param_3 + 1);\n      puVar5 = (undefined *)mempcpy(__dest,param_1 + (param_2 - 1),param_3);\n      *puVar5 = 0;\n    }\n    else {\n      __dest = (undefined *)xmalloc(sVar2 + 1);\n      uVar6 = 1;\n      local_88[0] = 0;\n      local_84 = 0;\n      puVar5 = __dest;\n      local_78 = param_1;\n      while( true ) {\n        local_7c = 0;\n        mbuiter_multi_next(local_88);\n        sVar4 = local_70;\n        pcVar1 = local_78;\n        if (((local_68 != '\\0') && (local_64 == 0)) || (param_3 == 0)) break;\n        if (param_2 <= uVar6) {\n          param_3 = param_3 - 1;\n          puVar5 = (undefined *)mempcpy(puVar5,local_78,local_70);\n        }\n        local_78 = pcVar1 + sVar4;\n        uVar6 = uVar6 + 1;\n      }\n      *puVar5 = 0;\n    }\n  }\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return __dest;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00106630": "\nvoid set_quoting_style(undefined1 *param_1,undefined4 param_2)\n\n{\n  if ((undefined4 *)param_1 == (undefined4 *)0x0) {\n    param_1 = default_quoting_options;\n  }\n  *(undefined4 *)param_1 = param_2;\n  return;\n}\n\n", 
    "00107720": "\nvoid xmalloc(size_t param_1)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = malloc(param_1);\n  if ((pvVar1 == (void *)0x0) && (param_1 != 0)) {\n                    /* WARNING: Subroutine does not return */\n    xalloc_die();\n  }\n  return;\n}\n\n", 
    "00106870": "\nvoid quotearg_free(void)\n\n{\n  void **ppvVar1;\n  void *__ptr;\n  undefined *__ptr_00;\n  void **ppvVar2;\n  \n  __ptr_00 = slotvec;\n  if (1 < nslots) {\n    ppvVar2 = (void **)(slotvec + 0x18);\n    ppvVar1 = (void **)(slotvec + (ulong)(nslots - 2) * 0x10 + 0x28);\n    do {\n      __ptr = *ppvVar2;\n      ppvVar2 = ppvVar2 + 2;\n      free(__ptr);\n    } while (ppvVar2 != ppvVar1);\n  }\n  if (*(undefined1 **)(__ptr_00 + 8) != slot0) {\n    free(*(undefined1 **)(__ptr_00 + 8));\n    slotvec0._8_8_ = slot0;\n    slotvec0._0_8_ = 0x100;\n  }\n  if (__ptr_00 != slotvec0) {\n    free(__ptr_00);\n    slotvec = slotvec0;\n  }\n  nslots = 1;\n  return;\n}\n\n", 
    "00103480": "\nvoid printv(int *param_1)\n\n{\n  if (*param_1 == 0) {\n    mpz_out_str_isra_0(stdout,*(undefined8 *)(param_1 + 2));\n    putchar_unlocked(10);\n    return;\n  }\n  if (*param_1 == 1) {\n    puts(*(char **)(param_1 + 2));\n    return;\n  }\n  printv_cold();\n  return;\n}\n\n", 
    "00104690": "\nbyte * mbschr(byte *param_1,int param_2)\n\n{\n  size_t sVar1;\n  byte *pbVar2;\n  long in_FS_OFFSET;\n  undefined local_68 [4];\n  undefined8 local_64;\n  undefined local_5c;\n  byte *local_58;\n  long local_50;\n  char local_48;\n  int local_44;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  sVar1 = __ctype_get_mb_cur_max();\n  if ((sVar1 < 2) || ((byte)param_2 < 0x30)) {\n    if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n      pbVar2 = (byte *)strchr((char *)param_1,param_2);\n      return pbVar2;\n    }\n  }\n  else {\n    local_68[0] = 0;\n    local_64 = 0;\n    local_58 = param_1;\n    while( true ) {\n      local_5c = 0;\n      mbuiter_multi_next(local_68);\n      if ((local_48 != '\\0') && (local_44 == 0)) break;\n      if ((local_50 == 1) && (pbVar2 = local_58, *local_58 == (byte)param_2)) goto LAB_00104749;\n      local_58 = local_58 + local_50;\n    }\n    pbVar2 = (byte *)0x0;\nLAB_00104749:\n    if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n      return pbVar2;\n    }\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "001039c0": "\nundefined8 eval7(undefined param_1)\n\n{\n  char cVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  \n  require_more_args();\n  cVar1 = nextarg(&DAT_00109032);\n  if (cVar1 == '\\0') {\n    cVar1 = nextarg(&DAT_0010a33d);\n    if (cVar1 == '\\0') {\n      uVar2 = *args;\n      args = args + 1;\n      uVar2 = str_value(uVar2);\n      return uVar2;\n    }\n    uVar2 = dcgettext(0,\"syntax error: unexpected \\')\\'\",5);\n                    /* WARNING: Subroutine does not return */\n    error(2,0,uVar2);\n  }\n  uVar2 = eval(param_1);\n  cVar1 = nomoreargs();\n  if (cVar1 == '\\0') {\n    cVar1 = nextarg(&DAT_0010a33d);\n    if (cVar1 != '\\0') {\n      return uVar2;\n    }\n    uVar2 = quotearg_n_style(0,8,*args);\n    uVar3 = dcgettext(0,\"syntax error: expecting \\')\\' instead of %s\",5);\n                    /* WARNING: Subroutine does not return */\n    error(2,0,uVar3,uVar2);\n  }\n  uVar2 = quotearg_n_style(0,8,args[-1]);\n  uVar3 = dcgettext(0,\"syntax error: expecting \\')\\' after %s\",5);\n                    /* WARNING: Subroutine does not return */\n  error(2,0,uVar3,uVar2);\n}\n\n", 
    "001077c0": "\nvoid xnrealloc(undefined8 param_1,ulong param_2,ulong param_3)\n\n{\n  if ((-1 < SUB168(ZEXT816(param_2) * ZEXT816(param_3),0)) &&\n     (SUB168(ZEXT816(param_2) * ZEXT816(param_3) >> 0x40,0) == 0)) {\n    xrealloc();\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  xalloc_die();\n}\n\n", 
    "0010f090": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __stack_chk_fail(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __stack_chk_fail@@GLIBC_2.4 */\n  halt_baddata();\n}\n\n", 
    "001043d0": "\nvoid initialize_exit_failure_constprop_0(void)\n\n{\n  exit_failure = 3;\n  return;\n}\n\n", 
    "00102700": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint iswprint(wint_t __wc)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_iswprint_0010dfc8)();\n  return iVar1;\n}\n\n", 
    "001080b0": "\nbool hard_locale(int param_1)\n\n{\n  byte *pbVar1;\n  long lVar2;\n  byte *pbVar3;\n  bool bVar4;\n  bool bVar5;\n  byte bVar6;\n  \n  bVar6 = 0;\n  pbVar1 = (byte *)setlocale(param_1,(char *)0x0);\n  bVar4 = true;\n  if (pbVar1 != (byte *)0x0) {\n    bVar4 = *pbVar1 < 0x43;\n    bVar5 = *pbVar1 == 0x43;\n    if (bVar5) {\n      bVar4 = false;\n      bVar5 = pbVar1[1] == 0;\n      if (bVar5) {\n        return false;\n      }\n    }\n    lVar2 = 6;\n    pbVar3 = (byte *)\"POSIX\";\n    do {\n      if (lVar2 == 0) break;\n      lVar2 = lVar2 + -1;\n      bVar4 = *pbVar1 < *pbVar3;\n      bVar5 = *pbVar1 == *pbVar3;\n      pbVar1 = pbVar1 + (ulong)bVar6 * -2 + 1;\n      pbVar3 = pbVar3 + (ulong)bVar6 * -2 + 1;\n    } while (bVar5);\n    bVar4 = (!bVar4 && !bVar5) != bVar4;\n  }\n  return bVar4;\n}\n\n", 
    "001081d0": "\nuint is_basic(byte param_1)\n\n{\n  return *(uint *)(is_basic_table + (ulong)(param_1 >> 5) * 4) >> (param_1 & 0x1f) & 1;\n}\n\n", 
    "001070e0": "\nundefined8\nversion_etc_arn(FILE *param_1,long param_2,undefined8 param_3,undefined8 param_4,undefined8 *param_5\n               ,undefined8 param_6)\n\n{\n  undefined8 uVar1;\n  char *pcVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  undefined8 uVar5;\n  undefined8 uVar6;\n  undefined8 local_60;\n  undefined8 local_58;\n  undefined8 local_50;\n  undefined8 local_48;\n  \n  if (param_2 == 0) {\n    __fprintf_chk(param_1,1,\"%s %s\\n\",param_3,param_4);\n  }\n  else {\n    __fprintf_chk(param_1,1,\"%s (%s) %s\\n\",param_2,param_3,param_4);\n  }\n  uVar1 = dcgettext(0,&DAT_0010a33b,5);\n  __fprintf_chk(param_1,1,\"Copyright %s %d Free Software Foundation, Inc.\",uVar1,0x7e2);\n  pcVar2 = (char *)dcgettext(0,\n                             \"\\nLicense GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>.\\nThis is free software: you are free to change and redistribute it.\\nThere is NO WARRANTY, to the extent permitted by law.\\n\\n\"\n                             ,5);\n  fputs_unlocked(pcVar2,param_1);\n  switch(param_6) {\n  case 0:\n                    /* WARNING: Subroutine does not return */\n    abort();\n  case 1:\n    uVar1 = *param_5;\n    uVar4 = dcgettext(0,\"Written by %s.\\n\",5);\n    uVar1 = __fprintf_chk(param_1,1,uVar4,uVar1);\n    return uVar1;\n  case 2:\n    uVar1 = param_5[1];\n    uVar4 = *param_5;\n    uVar5 = dcgettext(0,\"Written by %s and %s.\\n\",5);\n    uVar1 = __fprintf_chk(param_1,1,uVar5,uVar4,uVar1);\n    return uVar1;\n  case 3:\n    uVar1 = param_5[2];\n    uVar4 = param_5[1];\n    uVar5 = *param_5;\n    uVar6 = dcgettext(0,\"Written by %s, %s, and %s.\\n\",5);\n    uVar1 = __fprintf_chk(param_1,1,uVar6,uVar5,uVar4,uVar1);\n    return uVar1;\n  case 4:\n    uVar1 = param_5[3];\n    uVar4 = param_5[2];\n    uVar5 = param_5[1];\n    uVar6 = *param_5;\n    uVar3 = dcgettext(0,\"Written by %s, %s, %s,\\nand %s.\\n\",5);\n    goto LAB_001073a9;\n  case 5:\n    uVar1 = param_5[3];\n    uVar4 = param_5[2];\n    uVar5 = param_5[1];\n    uVar6 = *param_5;\n    uVar3 = dcgettext(0,\"Written by %s, %s, %s,\\n%s, and %s.\\n\",5);\nLAB_001073a9:\n    __fprintf_chk(param_1,1,uVar3,uVar6,uVar5,uVar4);\n    return uVar1;\n  case 6:\n    local_58 = param_5[5];\n    local_60 = param_5[4];\n    uVar1 = param_5[3];\n    uVar4 = param_5[2];\n    uVar5 = param_5[1];\n    uVar6 = *param_5;\n    uVar3 = dcgettext(0,\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\",5);\n    goto LAB_0010744b;\n  case 7:\n    local_58 = param_5[5];\n    local_60 = param_5[4];\n    uVar1 = param_5[3];\n    uVar4 = param_5[2];\n    uVar5 = param_5[1];\n    uVar6 = *param_5;\n    uVar3 = dcgettext(0,\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\",5);\nLAB_0010744b:\n    uVar1 = __fprintf_chk(param_1,1,uVar3,uVar6,uVar5,uVar4,uVar1,local_60,local_58);\n    return uVar1;\n  case 8:\n    local_48 = param_5[7];\n    local_50 = param_5[6];\n    local_58 = param_5[5];\n    local_60 = param_5[4];\n    uVar1 = param_5[3];\n    uVar4 = param_5[2];\n    uVar5 = param_5[1];\n    uVar6 = *param_5;\n    uVar3 = dcgettext(0,\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\",5);\n    goto LAB_001071fd;\n  case 9:\n    local_48 = param_5[7];\n    pcVar2 = \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\";\n    local_50 = param_5[6];\n    local_58 = param_5[5];\n    local_60 = param_5[4];\n    uVar1 = param_5[3];\n    uVar4 = param_5[2];\n    uVar5 = param_5[1];\n    uVar6 = *param_5;\n    break;\n  default:\n    local_48 = param_5[7];\n    pcVar2 = \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\";\n    local_50 = param_5[6];\n    local_58 = param_5[5];\n    local_60 = param_5[4];\n    uVar1 = param_5[3];\n    uVar4 = param_5[2];\n    uVar5 = param_5[1];\n    uVar6 = *param_5;\n  }\n  uVar3 = dcgettext(0,pcVar2,5);\nLAB_001071fd:\n  uVar1 = __fprintf_chk(param_1,1,uVar3,uVar6,uVar5,uVar4,uVar1,local_60,local_58,local_50,local_48)\n  ;\n  return uVar1;\n}\n\n", 
    "0010f098": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid getopt_long(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* getopt_long@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00104cb0": "\nundefined8\nstrcaseeq5(long param_1,undefined8 param_2,byte param_3,char param_4,char param_5,char param_6)\n\n{\n  char cVar1;\n  byte bVar2;\n  undefined8 uVar3;\n  \n  cVar1 = c_isupper((int)(char)param_3);\n  bVar2 = *(byte *)(param_1 + 5);\n  if (cVar1 != '\\0') {\n    bVar2 = bVar2 & 0xdf;\n  }\n  if (param_3 != bVar2) {\n    return 0;\n  }\n  if (param_3 == 0) {\n    return 1;\n  }\n  uVar3 = strcaseeq6(param_1,param_2,(int)param_4,(int)param_5,(int)param_6);\n  return uVar3;\n}\n\n", 
    "00102bf0": "\nvoid freev(int *param_1)\n\n{\n  if (*param_1 != 1) {\n    free(param_1);\n    return;\n  }\n  free(*(void **)(param_1 + 2));\n  free(param_1);\n  return;\n}\n\n", 
    "00106860": "\nvoid quotearg_alloc(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  quotearg_alloc_mem(param_1,param_2,0,param_3);\n  return;\n}\n\n", 
    "00102020": "\nvoid FUN_00102020(void)\n\n{\n                    /* WARNING: Treating indirect jump as call */\n  (*(code *)PTR_0010de18)();\n  return;\n}\n\n", 
    "00108360": "\nvoid __libc_csu_init(EVP_PKEY_CTX *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  long lVar1;\n  \n  _init(param_1);\n  lVar1 = 0;\n  do {\n    (*(code *)(&__frame_dummy_init_array_entry)[lVar1])((ulong)param_1 & 0xffffffff,param_2,param_3)\n    ;\n    lVar1 = lVar1 + 1;\n  } while (lVar1 != 1);\n  return;\n}\n\n", 
    "001028c0": "\nvoid _start(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 unaff_retaddr;\n  undefined auStack_8 [8];\n  \n  (*(code *)PTR___libc_start_main_0010dfe0)\n            (main,unaff_retaddr,&stack0x00000008,__libc_csu_init,__libc_csu_fini,param_3,auStack_8);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n", 
    "00105090": "\nundefined8\nstrcaseeq0_constprop_0\n          (byte *param_1,undefined8 param_2,byte param_3,char param_4,char param_5,char param_6,\n          char param_7,char param_8,char param_9)\n\n{\n  char cVar1;\n  byte bVar2;\n  undefined8 uVar3;\n  \n  cVar1 = c_isupper((int)(char)param_3);\n  bVar2 = *param_1;\n  if (cVar1 != '\\0') {\n    bVar2 = bVar2 & 0xdf;\n  }\n  uVar3 = 0;\n  if (bVar2 == param_3) {\n    uVar3 = strcaseeq1(param_1,param_2,(int)param_4,(int)param_5,(int)param_6,(int)param_7,\n                       (int)param_8,(int)param_9,0,0);\n  }\n  return uVar3;\n}\n\n", 
    "00102c60": "\nvoid int_value(undefined8 param_1)\n\n{\n  undefined4 *puVar1;\n  \n  puVar1 = (undefined4 *)xmalloc(0x10);\n  *puVar1 = 0;\n  mpz_init_set_ui(puVar1 + 2,param_1);\n  return;\n}\n\n", 
    "00106a60": "\nvoid quotearg_char_mem(undefined8 param_1,undefined8 param_2,char param_3,undefined8 param_4)\n\n{\n  undefined8 *puVar1;\n  long in_FS_OFFSET;\n  undefined8 local_48;\n  undefined8 uStack_40;\n  undefined8 local_38;\n  undefined8 uStack_30;\n  undefined8 local_28;\n  undefined8 uStack_20;\n  undefined8 local_18;\n  long local_10;\n  \n  puVar1 = &local_48;\n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_48 = default_quoting_options._0_8_;\n  uStack_40 = default_quoting_options._8_8_;\n  local_38 = default_quoting_options._16_8_;\n  uStack_30 = default_quoting_options._24_8_;\n  local_28 = default_quoting_options._32_8_;\n  uStack_20 = default_quoting_options._40_8_;\n  local_18 = default_quoting_options._48_8_;\n  set_char_quoting(&local_48,(int)param_3,1,param_4,param_1,param_2);\n  quotearg_n_options(0,param_1,param_2,puVar1);\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "001070d0": "\nvoid strintcmp(void)\n\n{\n  numcompare_constprop_0();\n  return;\n}\n\n", 
    "001082e0": "\nint rpl_fseeko(FILE *param_1,__off_t param_2,int param_3)\n\n{\n  int iVar1;\n  __off_t _Var2;\n  \n  if (((param_1->_IO_read_end == param_1->_IO_read_ptr) &&\n      (param_1->_IO_write_ptr == param_1->_IO_write_base)) &&\n     (param_1->_IO_save_base == (char *)0x0)) {\n    iVar1 = fileno(param_1);\n    _Var2 = lseek(iVar1,param_2,param_3);\n    if (_Var2 == -1) {\n      iVar1 = -1;\n    }\n    else {\n      param_1->_flags = param_1->_flags & 0xffffffef;\n      param_1->_offset = _Var2;\n      iVar1 = 0;\n    }\n    return iVar1;\n  }\n  iVar1 = fseeko(param_1,param_2,param_3);\n  return iVar1;\n}\n\n", 
    "00106650": "\nuint set_char_quoting(undefined1 *param_1,byte param_2,uint param_3)\n\n{\n  uint uVar1;\n  uint uVar2;\n  \n  if (param_1 == (undefined1 *)0x0) {\n    param_1 = default_quoting_options;\n  }\n  uVar1 = *(uint *)(param_1 + (ulong)(param_2 >> 5) * 4 + 8);\n  uVar2 = uVar1 >> (param_2 & 0x1f);\n  *(uint *)(param_1 + (ulong)(param_2 >> 5) * 4 + 8) =\n       ((param_3 ^ uVar2) & 1) << (param_2 & 0x1f) ^ uVar1;\n  return uVar2 & 1;\n}\n\n", 
    "00107740": "\nvoid xnmalloc(ulong param_1,ulong param_2)\n\n{\n  if ((-1 < SUB168(ZEXT816(param_1) * ZEXT816(param_2),0)) &&\n     (SUB168(ZEXT816(param_1) * ZEXT816(param_2) >> 0x40,0) == 0)) {\n    xmalloc();\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  xalloc_die();\n}\n\n", 
    "00107980": "\nundefined8 bkm_scale(long *param_1,int param_2)\n\n{\n  long lVar1;\n  long lVar2;\n  long lVar3;\n  \n  lVar3 = -0x8000000000000000;\n  lVar2 = (long)param_2;\n  lVar1 = *param_1;\n  if ((SUB168((SEXT816(-0x8000000000000000) & (undefined  [16])0xffffffffffffffff |\n              ZEXT816(0x8000000000000000)) / SEXT816(lVar2),0) <= lVar1) &&\n     (lVar3 = 0x7fffffffffffffff,\n     lVar1 <= SUB168((SEXT816(0x7fffffffffffffff) & (undefined  [16])0xffffffffffffffff |\n                     ZEXT816(0x7fffffffffffffff)) / SEXT816(lVar2),0))) {\n    *param_1 = lVar2 * lVar1;\n    return 0;\n  }\n  *param_1 = lVar3;\n  return 1;\n}\n\n", 
    "00106770": "\nundefined8\nquotearg_alloc_mem(undefined8 param_1,undefined8 param_2,long *param_3,undefined1 *param_4)\n\n{\n  int iVar1;\n  int *piVar2;\n  long lVar3;\n  undefined8 uVar4;\n  uint uVar5;\n  \n  if ((undefined4 *)param_4 == (undefined4 *)0x0) {\n    param_4 = default_quoting_options;\n  }\n  piVar2 = __errno_location();\n  iVar1 = *piVar2;\n  uVar5 = (uint)(param_3 == (long *)0x0) | *(uint *)((long)param_4 + 4);\n  lVar3 = quotearg_buffer_restyled\n                    (0,0,param_1,param_2,*(undefined4 *)param_4,uVar5,\n                     (undefined4 *)((long)param_4 + 8),*(undefined8 *)((long)param_4 + 0x28),\n                     *(undefined8 *)((long)param_4 + 0x30));\n  uVar4 = xcharalloc(lVar3 + 1);\n  quotearg_buffer_restyled\n            (uVar4,lVar3 + 1,param_1,param_2,*(undefined4 *)param_4,uVar5,\n             (undefined4 *)((long)param_4 + 8),*(undefined8 *)((long)param_4 + 0x28),\n             *(undefined8 *)((long)param_4 + 0x30));\n  *piVar2 = iVar1;\n  if (param_3 != (long *)0x0) {\n    *param_3 = lVar3;\n  }\n  return uVar4;\n}\n\n", 
    "001026b0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid exit(int __status)\n\n{\n  (*(code *)PTR_exit_0010dfa0)();\n  return;\n}\n\n", 
    "001049b0": "\nvoid mbuiter_multi_reloc(long param_1,long param_2)\n\n{\n  *(long *)(param_1 + 0x10) = *(long *)(param_1 + 0x10) + param_2;\n  return;\n}\n\n", 
    "00104b10": "\nbool strcaseeq9(long param_1,long param_2)\n\n{\n  int iVar1;\n  \n  iVar1 = c_strcasecmp(param_1 + 9,param_2 + 9);\n  return iVar1 == 0;\n}\n\n", 
    "00106e10": "\nuint numcompare_constprop_0(byte *param_1,byte *param_2)\n\n{\n  byte *pbVar1;\n  byte *pbVar2;\n  byte bVar3;\n  byte bVar4;\n  long lVar5;\n  uint uVar6;\n  uint uVar7;\n  ulong uVar8;\n  ulong uVar9;\n  uint uVar10;\n  \n  uVar6 = (uint)*param_1;\n  bVar3 = *param_2;\n  uVar7 = (uint)bVar3;\n  if (*param_1 == 0x2d) {\n    do {\n      bVar4 = param_1[1];\n      param_1 = param_1 + 1;\n    } while (bVar4 == 0x30);\n    uVar6 = (uint)bVar4;\n    uVar10 = bVar4 - 0x30;\n    if (bVar3 != 0x2d) {\n      if (uVar10 < 10) {\n        return 0xffffffff;\n      }\n      while ((char)uVar7 == '0') {\n        param_2 = param_2 + 1;\n        uVar7 = (uint)*param_2;\n      }\n      return -(uint)(uVar7 - 0x30 < 10);\n    }\n    do {\n      bVar3 = param_2[1];\n      uVar7 = (uint)bVar3;\n      param_2 = param_2 + 1;\n    } while (bVar3 == 0x30);\n    if (bVar4 == bVar3) {\n      do {\n        if (9 < uVar10) {\n          uVar6 = uVar7 - uVar6;\n          goto LAB_001070b1;\n        }\n        bVar3 = param_1[1];\n        uVar6 = (uint)bVar3;\n        pbVar1 = param_2 + 1;\n        uVar7 = (uint)*pbVar1;\n        param_1 = param_1 + 1;\n        param_2 = param_2 + 1;\n        uVar10 = bVar3 - 0x30;\n      } while (bVar3 == *pbVar1);\n    }\n    uVar6 = uVar7 - uVar6;\n    if (uVar10 < 10) {\n      uVar9 = 0;\n      do {\n        lVar5 = uVar9 + 1;\n        uVar9 = uVar9 + 1;\n      } while (param_1[lVar5] - 0x30 < 10);\n      if (9 < uVar7 - 0x30) {\n        return -(uint)(uVar9 != 0);\n      }\n    }\n    else {\nLAB_001070b1:\n      uVar9 = 0;\n      if (9 < uVar7 - 0x30) {\n        return 0;\n      }\n    }\n    uVar8 = 0;\n    do {\n      lVar5 = uVar8 + 1;\n      uVar8 = uVar8 + 1;\n    } while (param_2[lVar5] - 0x30 < 10);\n    if (uVar8 == uVar9) {\n      if (uVar8 == 0) {\n        uVar6 = 0;\n      }\n    }\n    else {\n      uVar6 = (-(uint)(uVar9 < uVar8) & 2) - 1;\n    }\n  }\n  else {\n    if (bVar3 == 0x2d) {\n      do {\n        pbVar1 = param_2 + 1;\n        param_2 = param_2 + 1;\n      } while (*pbVar1 == 0x30);\n      if (9 < *pbVar1 - 0x30) {\n        while ((char)uVar6 == '0') {\n          param_1 = param_1 + 1;\n          uVar6 = (uint)*param_1;\n        }\n        return (uint)(uVar6 - 0x30 < 10);\n      }\n      return 1;\n    }\n    while ((char)uVar6 == '0') {\n      param_1 = param_1 + 1;\n      uVar6 = (uint)*param_1;\n    }\n    while ((char)uVar7 == '0') {\n      param_2 = param_2 + 1;\n      uVar7 = (uint)*param_2;\n    }\n    uVar10 = uVar6 - 0x30;\n    if ((char)uVar7 == (char)uVar6) {\n      do {\n        if (9 < uVar10) {\n          uVar6 = uVar6 - uVar7;\n          goto LAB_00107095;\n        }\n        pbVar1 = param_1 + 1;\n        uVar6 = (uint)*pbVar1;\n        pbVar2 = param_2 + 1;\n        uVar7 = (uint)*pbVar2;\n        param_1 = param_1 + 1;\n        param_2 = param_2 + 1;\n        uVar10 = uVar6 - 0x30;\n      } while (*pbVar1 == *pbVar2);\n    }\n    uVar6 = uVar6 - uVar7;\n    if (uVar10 < 10) {\n      uVar9 = 0;\n      do {\n        lVar5 = uVar9 + 1;\n        uVar9 = uVar9 + 1;\n      } while (param_1[lVar5] - 0x30 < 10);\n      if (9 < uVar7 - 0x30) {\n        return (uint)(uVar9 != 0);\n      }\n    }\n    else {\nLAB_00107095:\n      uVar9 = 0;\n      if (9 < uVar7 - 0x30) {\n        return 0;\n      }\n    }\n    uVar8 = 0;\n    do {\n      lVar5 = uVar8 + 1;\n      uVar8 = uVar8 + 1;\n    } while (param_2[lVar5] - 0x30 < 10);\n    if (uVar9 != uVar8) {\n      return -(uint)(uVar9 < uVar8) | 1;\n    }\n    if (uVar9 == 0) {\n      uVar6 = 0;\n    }\n  }\n  return uVar6;\n}\n\n", 
    "001028f0": "\n/* WARNING: Removing unreachable block (ram,0x00102903) */\n/* WARNING: Removing unreachable block (ram,0x0010290f) */\n\nvoid deregister_tm_clones(void)\n\n{\n  return;\n}\n\n", 
    "00102a50": "\nulong nextarg(char *param_1)\n\n{\n  char **ppcVar1;\n  int iVar2;\n  undefined4 extraout_var;\n  ulong uVar3;\n  \n  ppcVar1 = args;\n  uVar3 = 0;\n  if (*args != (char *)0x0) {\n    iVar2 = strcmp(*args,param_1);\n    uVar3 = CONCAT44(extraout_var,iVar2) & 0xffffffffffffff00 | (ulong)(iVar2 == 0);\n    args = ppcVar1 + (iVar2 == 0);\n  }\n  return uVar3;\n}\n\n", 
    "001065d0": "\nvoid clone_quoting_options(undefined1 *param_1)\n\n{\n  int iVar1;\n  int *piVar2;\n  \n  piVar2 = __errno_location();\n  iVar1 = *piVar2;\n  if (param_1 == (undefined1 *)0x0) {\n    param_1 = default_quoting_options;\n  }\n  xmemdup(param_1,0x38);\n  *piVar2 = iVar1;\n  return;\n}\n\n", 
    "001043f0": "\nvoid close_stdout_set_ignore_EPIPE(undefined param_1)\n\n{\n  ignore_EPIPE = param_1;\n  return;\n}\n\n", 
    "0010f190": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __cxa_atexit(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __cxa_atexit@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010f070": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid dcgettext(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* dcgettext@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001066f0": "\nvoid quotearg_buffer(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n                    undefined1 *param_5)\n\n{\n  int iVar1;\n  int *piVar2;\n  \n  if ((undefined4 *)param_5 == (undefined4 *)0x0) {\n    param_5 = default_quoting_options;\n  }\n  piVar2 = __errno_location();\n  iVar1 = *piVar2;\n  quotearg_buffer_restyled\n            (param_1,param_2,param_3,param_4,*(undefined4 *)param_5,\n             *(undefined4 *)((long)param_5 + 4),(undefined4 *)((long)param_5 + 8),\n             *(undefined8 *)((long)param_5 + 0x28),*(undefined8 *)((long)param_5 + 0x30));\n  *piVar2 = iVar1;\n  return;\n}\n\n", 
    "00102c90": "\nulong mpz_sgn_isra_0(long param_1)\n\n{\n  ulong uVar1;\n  \n  uVar1 = (ulong)(0 < param_1);\n  if (param_1 < 0) {\n    uVar1 = 0xffffffff;\n  }\n  return uVar1;\n}\n\n", 
    "00102725": "\nvoid tostring_cold(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "00102960": "\nvoid __do_global_dtors_aux(void)\n\n{\n  if (completed_8061 == '\\0') {\n    if (PTR___cxa_finalize_0010dff8 != (undefined *)0x0) {\n      __cxa_finalize(__dso_handle);\n    }\n    deregister_tm_clones();\n    completed_8061 = 1;\n    return;\n  }\n  return;\n}\n\n", 
    "001081f0": "\nint rpl_fclose(FILE *param_1)\n\n{\n  int iVar1;\n  int iVar2;\n  int *piVar3;\n  __off_t _Var4;\n  \n  iVar1 = fileno(param_1);\n  if (-1 < iVar1) {\n    iVar1 = __freading();\n    if (iVar1 != 0) {\n      iVar1 = fileno(param_1);\n      _Var4 = lseek(iVar1,0,1);\n      if (_Var4 == -1) goto LAB_0010825f;\n    }\n    iVar1 = rpl_fflush(param_1);\n    if (iVar1 != 0) {\n      piVar3 = __errno_location();\n      iVar1 = *piVar3;\n      iVar2 = fclose(param_1);\n      if (iVar1 != 0) {\n        *piVar3 = iVar1;\n        iVar2 = -1;\n      }\n      return iVar2;\n    }\n  }\nLAB_0010825f:\n  iVar1 = fclose(param_1);\n  return iVar1;\n}\n\n", 
    "0010f198": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid exit(int __status)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* exit@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00102720": "\nvoid null_cold(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "0010f078": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid regfree(regex_t *__preg)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* regfree@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00102600": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fflush(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_fflush_0010df48)();\n  return iVar1;\n}\n\n", 
    "00107fa0": "\nint c_tolower(int param_1)\n\n{\n  if (param_1 - 0x41U < 0x1a) {\n    param_1 = param_1 + 0x20;\n  }\n  return param_1;\n}\n\n", 
    "00102af0": "\nvoid mpz_add(long *param_1,long *param_2,long *param_3)\n\n{\n  long lVar1;\n  \n  lVar1 = *param_2 + *param_3;\n  if (lVar1 < *param_2 == (bool)-(char)(*param_3 >> 0x3f)) {\n    *param_1 = lVar1;\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  integer_overflow(0x2b);\n}\n\n", 
    "00108140": "\nuint mb_width_aux(wchar_t param_1)\n\n{\n  uint uVar1;\n  int iVar2;\n  \n  uVar1 = wcwidth(param_1);\n  if (-1 < (int)uVar1) {\n    return uVar1;\n  }\n  iVar2 = iswcntrl(param_1);\n  return (uint)(iVar2 == 0);\n}\n\n", 
    "001026a0": "\nvoid __cxa_atexit(void)\n\n{\n  (*(code *)PTR___cxa_atexit_0010df98)();\n  return;\n}\n\n", 
    "00104c20": "\nundefined8 strcaseeq6(long param_1,undefined8 param_2,byte param_3,char param_4,char param_5)\n\n{\n  char cVar1;\n  byte bVar2;\n  undefined8 uVar3;\n  \n  cVar1 = c_isupper((int)(char)param_3);\n  bVar2 = *(byte *)(param_1 + 6);\n  if (cVar1 != '\\0') {\n    bVar2 = bVar2 & 0xdf;\n  }\n  if (param_3 != bVar2) {\n    return 0;\n  }\n  if (param_3 == 0) {\n    return 1;\n  }\n  uVar3 = strcaseeq7(param_1,param_2,(int)param_4,(int)param_5);\n  return uVar3;\n}\n\n", 
    "00102b60": "\nvoid mpz_tdiv_q(long *param_1,long *param_2,long *param_3)\n\n{\n  if ((*param_2 == -0x8000000000000000) && (*param_3 == -1)) {\n                    /* WARNING: Subroutine does not return */\n    integer_overflow(0x2f);\n  }\n  *param_1 = *param_2 / *param_3;\n  return;\n}\n\n", 
    "001031d0": "\nvoid tostring(int *param_1)\n\n{\n  undefined8 uVar1;\n  \n  if (*param_1 == 0) {\n    uVar1 = mpz_get_str_isra_0(*(undefined8 *)(param_1 + 2));\n    *param_1 = 1;\n    *(undefined8 *)(param_1 + 2) = uVar1;\n  }\n  else if (*param_1 != 1) {\n    tostring_cold();\n    return;\n  }\n  return;\n}\n\n", 
    "001043e0": "\nvoid close_stdout_set_file_name(undefined8 param_1)\n\n{\n  file_name = param_1;\n  return;\n}\n\n", 
    "001078f0": "\nvoid xmemdup(void *param_1,size_t param_2)\n\n{\n  void *__dest;\n  \n  __dest = (void *)xmalloc(param_2);\n  memcpy(__dest,param_1,param_2);\n  return;\n}\n\n", 
    "0010f080": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t __ctype_get_mb_cur_max(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __ctype_get_mb_cur_max@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00102a40": "\nulong nomoreargs(void)\n\n{\n  return (ulong)args & 0xffffffffffffff00 | (ulong)(*args == 0);\n}\n\n", 
    "0010f088": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t strlen(char *__s)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strlen@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00103920": "\nundefined8 eval(char param_1)\n\n{\n  char cVar1;\n  undefined uVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  \n  uVar3 = eval1(param_1);\nLAB_00103938:\n  do {\n    cVar1 = nextarg(&DAT_00109030);\n    while( true ) {\n      if (cVar1 == '\\0') {\n        return uVar3;\n      }\n      uVar2 = 0;\n      if (param_1 != '\\0') {\n        uVar2 = null(uVar3);\n      }\n      uVar4 = eval1(uVar2);\n      cVar1 = null(uVar3);\n      if (cVar1 == '\\0') break;\n      freev(uVar3);\n      cVar1 = null(uVar4);\n      uVar3 = uVar4;\n      if (cVar1 == '\\0') goto LAB_00103938;\n      freev(uVar4);\n      uVar3 = int_value(0);\n      cVar1 = nextarg();\n    }\n    freev(uVar4);\n  } while( true );\n}\n\n", 
    "00102710": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nushort ** __ctype_b_loc(void)\n\n{\n  ushort **ppuVar1;\n  \n  ppuVar1 = (ushort **)(*(code *)PTR___ctype_b_loc_0010dfd0)();\n  return ppuVar1;\n}\n\n", 
    "00107920": "\nvoid xstrdup(char *param_1)\n\n{\n  size_t sVar1;\n  \n  sVar1 = strlen(param_1);\n  xmemdup(param_1,sVar1 + 1);\n  return;\n}\n\n", 
    "00103dd0": "\nlong eval4(char param_1)\n\n{\n  char cVar1;\n  int iVar2;\n  long lVar3;\n  long lVar4;\n  code *pcVar5;\n  undefined8 uVar6;\n  int iVar7;\n  \n  lVar3 = eval5(param_1);\n  do {\n    cVar1 = nextarg(&DAT_0010906d);\n    if (cVar1 == '\\0') {\n      iVar7 = 1;\n      cVar1 = nextarg(&DAT_00109be6);\n      if (cVar1 == '\\0') {\n        cVar1 = nextarg(&DAT_0010906f);\n        if (cVar1 == '\\0') {\n          return lVar3;\n        }\n        iVar7 = 2;\n      }\n    }\n    else {\n      iVar7 = 0;\n    }\n    lVar4 = eval5(param_1);\n    if (param_1 != '\\0') {\n      cVar1 = toarith(lVar3);\n      if ((cVar1 == '\\0') || (cVar1 = toarith(lVar4), cVar1 == '\\0')) {\n        uVar6 = dcgettext(0,\"non-integer argument\",5);\n                    /* WARNING: Subroutine does not return */\n        error(2,0,uVar6);\n      }\n      pcVar5 = mpz_mul;\n      if (iVar7 != 0) {\n        iVar2 = mpz_sgn_isra_0(*(undefined8 *)(lVar4 + 8));\n        if (iVar2 == 0) {\n          uVar6 = dcgettext(0,\"division by zero\",5);\n                    /* WARNING: Subroutine does not return */\n          error(2,0,uVar6);\n        }\n        pcVar5 = mpz_tdiv_r;\n        if (iVar7 == 1) {\n          pcVar5 = mpz_tdiv_q;\n        }\n      }\n      (*pcVar5)(lVar3 + 8,lVar3 + 8,lVar4 + 8);\n    }\n    freev(lVar4);\n  } while( true );\n}\n\n", 
    "00103200": "\nundefined8 docolon(long param_1,long param_2)\n\n{\n  int iVar1;\n  size_t sVar2;\n  char *pcVar3;\n  undefined8 uVar4;\n  int *piVar5;\n  int iVar6;\n  long in_FS_OFFSET;\n  re_registers local_198;\n  undefined local_178 [64];\n  char local_138 [264];\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  tostring();\n  tostring(param_2);\n  pcVar3 = *(char **)(param_2 + 8);\n  local_178._32_8_ = local_138;\n  local_198.num_regs = 0;\n  local_198.start = (regoff_t *)0x0;\n  local_198.end = (regoff_t *)0x0;\n  local_178._0_8_ = (uchar *)0x0;\n  local_178._8_8_ = 0;\n  local_178._40_8_ = (uchar *)0x0;\n  re_syntax_options = 0x2c6;\n  sVar2 = strlen(pcVar3);\n  pcVar3 = re_compile_pattern(pcVar3,sVar2,(re_pattern_buffer *)local_178);\n  if (pcVar3 != (char *)0x0) {\n                    /* WARNING: Subroutine does not return */\n    error(2,0,\"%s\",pcVar3);\n  }\n  pcVar3 = *(char **)(param_1 + 8);\n  local_178[56] = local_178[56] & 0x7f;\n  sVar2 = strlen(pcVar3);\n  iVar1 = re_match((re_pattern_buffer *)local_178,pcVar3,(int)sVar2,0,&local_198);\n  if (iVar1 < 0) {\n    if (iVar1 != -1) {\n      uVar4 = dcgettext(0,\"error in regular expression matcher\",5);\n      iVar6 = 0x4b;\n      if (iVar1 == -2) {\n        piVar5 = __errno_location();\n        iVar6 = *piVar5;\n      }\n                    /* WARNING: Subroutine does not return */\n      error(3,iVar6,uVar4);\n    }\n    if (local_178._48_8_ == 0) {\n      uVar4 = int_value(0);\n    }\n    else {\n      uVar4 = str_value(\"\");\n    }\n  }\n  else if (local_178._48_8_ == 0) {\n    sVar2 = __ctype_get_mb_cur_max();\n    if (sVar2 == 1) {\n      uVar4 = int_value();\n    }\n    else {\n      uVar4 = mbs_offset_to_chars(*(undefined8 *)(param_1 + 8),(long)iVar1);\n      uVar4 = int_value(uVar4);\n    }\n  }\n  else {\n    *(undefined *)(*(long *)(param_1 + 8) + (long)local_198.end[1]) = 0;\n    uVar4 = str_value((long)local_198.start[1] + *(long *)(param_1 + 8));\n  }\n  if (local_198.num_regs != 0) {\n    free(local_198.start);\n    free(local_198.end);\n  }\n  local_178._32_8_ = (char *)0x0;\n  regfree((re_pattern_buffer *)local_178);\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar4;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00106950": "\nvoid quotearg_mem(undefined8 param_1,undefined8 param_2)\n\n{\n  quotearg_n_mem(0,param_1,param_2);\n  return;\n}\n\n", 
    "00102590": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * calloc(size_t __nmemb,size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = (void *)(*(code *)PTR_calloc_0010df10)();\n  return pvVar1;\n}\n\n", 
    "00102470": "\nvoid bindtextdomain(void)\n\n{\n  (*(code *)PTR_bindtextdomain_0010de80)();\n  return;\n}\n\n", 
    "001029b0": "\nvoid mpz_init_set_ui(undefined8 *param_1,undefined8 param_2)\n\n{\n  *param_1 = param_2;\n  return;\n}\n\n", 
    "001044b0": "\nchar * imaxtostr(ulong param_1,long param_2)\n\n{\n  ulong uVar1;\n  char *pcVar2;\n  char *pcVar3;\n  \n  *(undefined *)(param_2 + 0x14) = 0;\n  pcVar2 = (char *)(param_2 + 0x14);\n  if ((long)param_1 < 0) {\n    do {\n      pcVar3 = pcVar2;\n      uVar1 = (long)param_1 / 10;\n      pcVar3[-1] = ((char)uVar1 * '\\n' + '0') - (char)param_1;\n      param_1 = uVar1;\n      pcVar2 = pcVar3 + -1;\n    } while (uVar1 != 0);\n    pcVar3[-2] = '-';\n    return pcVar3 + -2;\n  }\n  do {\n    pcVar2 = pcVar2 + -1;\n    uVar1 = param_1 / 10;\n    *pcVar2 = (char)param_1 + (char)uVar1 * -10 + '0';\n    param_1 = uVar1;\n  } while (uVar1 != 0);\n  return pcVar2;\n}\n\n", 
    "0010f050": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint iswcntrl(wint_t __wc)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* iswcntrl@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00102d50": "\nundefined8 mpz_get_ui_isra_0(undefined8 param_1)\n\n{\n  return param_1;\n}\n\n", 
    "00104e10": "\nundefined8\nstrcaseeq3(long param_1,undefined8 param_2,byte param_3,char param_4,char param_5,char param_6,\n          char param_7)\n\n{\n  char cVar1;\n  byte bVar2;\n  undefined8 uVar3;\n  \n  cVar1 = c_isupper((int)(char)param_3);\n  bVar2 = *(byte *)(param_1 + 3);\n  if (cVar1 != '\\0') {\n    bVar2 = bVar2 & 0xdf;\n  }\n  if (param_3 != bVar2) {\n    return 0;\n  }\n  if (param_3 == 0) {\n    return 1;\n  }\n  uVar3 = strcaseeq4(param_1,param_2,(int)param_4,(int)param_5,(int)param_6,(int)param_7);\n  return uVar3;\n}\n\n", 
    "001023f0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint * __errno_location(void)\n\n{\n  int *piVar1;\n  \n  piVar1 = (int *)(*(code *)PTR___errno_location_0010de40)();\n  return piVar1;\n}\n\n", 
    "00107a00": "\nuint xstrtoimax(char *param_1,char **param_2,uint param_3,intmax_t *param_4,char *param_5)\n\n{\n  char cVar1;\n  char cVar2;\n  uint uVar3;\n  int *piVar4;\n  intmax_t iVar5;\n  char *pcVar6;\n  char *pcVar7;\n  undefined8 uVar8;\n  uint uVar9;\n  int iVar10;\n  long in_FS_OFFSET;\n  char *local_50;\n  intmax_t local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (0x24 < param_3) {\n                    /* WARNING: Subroutine does not return */\n    __assert_fail(\"0 <= strtol_base && strtol_base <= 36\",\"lib/xstrtol.c\",0x60,\"xstrtoimax\");\n  }\n  if (param_2 == (char **)0x0) {\n    param_2 = &local_50;\n  }\n  piVar4 = __errno_location();\n  *piVar4 = 0;\n  iVar5 = strtoimax(param_1,param_2,param_3);\n  pcVar7 = *param_2;\n  local_48 = iVar5;\n  if (pcVar7 == param_1) {\n    if (param_5 == (char *)0x0) {\n      uVar9 = 4;\n      goto LAB_00107a8f;\n    }\n    cVar1 = *pcVar7;\n    uVar9 = 4;\n    if (cVar1 == '\\0') goto LAB_00107a8f;\n    iVar10 = (int)cVar1;\n    pcVar6 = strchr(param_5,iVar10);\n    if (pcVar6 == (char *)0x0) goto LAB_00107a8f;\n    local_48 = 1;\n    uVar9 = 0;\nLAB_00107b12:\n    pcVar6 = strchr(param_5,iVar10);\n    if (pcVar6 == (char *)0x0) {\nswitchD_00107b73_caseD_43:\n      uVar9 = uVar9 | 2;\n      *param_4 = local_48;\n      goto LAB_00107a8f;\n    }\n    switch(cVar1) {\n    case 'E':\n    case 'G':\n    case 'K':\n    case 'M':\n    case 'P':\n    case 'T':\n    case 'Y':\n    case 'Z':\n    case 'g':\n    case 'k':\n    case 'm':\n    case 't':\n      pcVar6 = strchr(param_5,0x30);\n      if (pcVar6 == (char *)0x0) goto switchD_00107b4a_caseD_46;\n      cVar2 = pcVar7[1];\n      if (cVar2 == 'D') {\n        iVar10 = 2;\n        uVar8 = 1000;\n      }\n      else if (cVar2 == 'i') {\n        uVar8 = 0x400;\n        iVar10 = (pcVar7[2] == 'B') + 1 + (uint)(pcVar7[2] == 'B');\n      }\n      else {\n        iVar10 = (cVar2 == 'B') + 1;\n        uVar8 = 1000;\n        if (cVar2 != 'B') {\n          uVar8 = 0x400;\n        }\n      }\n      break;\n    default:\nswitchD_00107b4a_caseD_46:\n      iVar10 = 1;\n      uVar8 = 0x400;\n    }\n    switch(cVar1) {\n    case 'B':\n      uVar3 = bkm_scale(&local_48,0x400);\n      pcVar7 = *param_2;\n      uVar9 = uVar9 | uVar3;\n      break;\n    default:\n      goto switchD_00107b73_caseD_43;\n    case 'E':\n      uVar3 = bkm_scale_by_power(&local_48,uVar8,6);\n      pcVar7 = *param_2;\n      uVar9 = uVar9 | uVar3;\n      break;\n    case 'G':\n    case 'g':\n      uVar3 = bkm_scale_by_power(&local_48,uVar8,3);\n      pcVar7 = *param_2;\n      uVar9 = uVar9 | uVar3;\n      break;\n    case 'K':\n    case 'k':\n      uVar3 = bkm_scale_by_power(&local_48,uVar8,1);\n      pcVar7 = *param_2;\n      uVar9 = uVar9 | uVar3;\n      break;\n    case 'M':\n    case 'm':\n      uVar3 = bkm_scale_by_power(&local_48,uVar8,2);\n      pcVar7 = *param_2;\n      uVar9 = uVar9 | uVar3;\n      break;\n    case 'P':\n      uVar3 = bkm_scale_by_power(&local_48,uVar8,5);\n      pcVar7 = *param_2;\n      uVar9 = uVar9 | uVar3;\n      break;\n    case 'T':\n    case 't':\n      uVar3 = bkm_scale_by_power(&local_48,uVar8,4);\n      pcVar7 = *param_2;\n      uVar9 = uVar9 | uVar3;\n      break;\n    case 'Y':\n      uVar3 = bkm_scale_by_power(&local_48,uVar8,8);\n      pcVar7 = *param_2;\n      uVar9 = uVar9 | uVar3;\n      break;\n    case 'Z':\n      uVar3 = bkm_scale_by_power(&local_48,uVar8,7);\n      pcVar7 = *param_2;\n      uVar9 = uVar9 | uVar3;\n      break;\n    case 'b':\n      uVar3 = bkm_scale(&local_48,0x200);\n      pcVar7 = *param_2;\n      uVar9 = uVar9 | uVar3;\n      break;\n    case 'c':\n      break;\n    case 'w':\n      uVar3 = bkm_scale(&local_48,2);\n      pcVar7 = *param_2;\n      uVar9 = uVar9 | uVar3;\n    }\n    iVar5 = local_48;\n    *param_2 = pcVar7 + iVar10;\n    if (pcVar7[iVar10] != '\\0') {\n      uVar9 = uVar9 | 2;\n    }\n  }\n  else {\n    if (*piVar4 == 0) {\n      uVar9 = 0;\n    }\n    else {\n      uVar9 = 4;\n      if (*piVar4 != 0x22) goto LAB_00107a8f;\n      uVar9 = 1;\n    }\n    if ((param_5 != (char *)0x0) && (cVar1 = *pcVar7, cVar1 != '\\0')) {\n      iVar10 = (int)cVar1;\n      goto LAB_00107b12;\n    }\n  }\n  *param_4 = iVar5;\nLAB_00107a8f:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar9;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "0010f170": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __printf_chk(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __printf_chk@@GLIBC_2.3.4 */\n  halt_baddata();\n}\n\n", 
    "00106a30": "\nvoid quotearg_style(undefined4 param_1,undefined8 param_2)\n\n{\n  quotearg_n_style(0,param_1,param_2);\n  return;\n}\n\n", 
    "0010f058": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid textdomain(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* textdomain@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001083d0": "\nvoid __libc_csu_fini(void)\n\n{\n  return;\n}\n\n", 
    "00106c70": "\nvoid quotearg_n_custom(void)\n\n{\n  quotearg_n_custom_mem();\n  return;\n}\n\n", 
    "0010f178": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * mempcpy(void *__dest,void *__src,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* mempcpy@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00106940": "\nvoid quotearg(undefined8 param_1)\n\n{\n  quotearg_n(0,param_1);\n  return;\n}\n\n", 
    "00104400": "\nvoid close_stdout(void)\n\n{\n  int iVar1;\n  int *piVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  \n  iVar1 = close_stream(stdout);\n  if (iVar1 != 0) {\n    piVar2 = __errno_location();\n    if ((ignore_EPIPE == '\\0') || (*piVar2 != 0x20)) {\n      uVar3 = dcgettext(0,\"write error\",5);\n      if (file_name != 0) {\n        uVar4 = quotearg_colon();\n                    /* WARNING: Subroutine does not return */\n        error(0,*piVar2,\"%s: %s\",uVar4,uVar3);\n      }\n                    /* WARNING: Subroutine does not return */\n      error(0,*piVar2,\"%s\",uVar3);\n    }\n  }\n  iVar1 = close_stream(stderr);\n  if (iVar1 == 0) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  _exit(exit_failure);\n}\n\n", 
    "00102580": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint ferror_unlocked(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_ferror_unlocked_0010df08)();\n  return iVar1;\n}\n\n", 
    "00102460": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fclose(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_fclose_0010de78)();\n  return iVar1;\n}\n\n", 
    "001029a0": "\nvoid frame_dummy(void)\n\n{\n  register_tm_clones();\n  return;\n}\n\n", 
    "00102d40": "\nulong mpz_fits_ulong_p_isra_0(ulong param_1)\n\n{\n  return ~param_1 >> 0x3f;\n}\n\n", 
    "00102c20": "\nundefined4 * str_value(undefined8 param_1)\n\n{\n  undefined4 *puVar1;\n  undefined8 uVar2;\n  \n  puVar1 = (undefined4 *)xmalloc(0x10);\n  *puVar1 = 1;\n  uVar2 = xstrdup(param_1);\n  *(undefined8 *)(puVar1 + 2) = uVar2;\n  return puVar1;\n}\n\n", 
    "0010f180": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid error(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* error@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001023e0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint re_match(re_pattern_buffer *__buffer,char *__string,int __length,int __start,\n            re_registers *__regs)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_re_match_0010de38)();\n  return iVar1;\n}\n\n", 
    "001082a0": "\nvoid rpl_fflush(FILE *param_1)\n\n{\n  int iVar1;\n  \n  if (param_1 != (FILE *)0x0) {\n    iVar1 = __freading();\n    if (iVar1 != 0) {\n      clear_ungetc_buffer_preserving_position(param_1);\n      fflush(param_1);\n      return;\n    }\n  }\n  fflush(param_1);\n  return;\n}\n\n", 
    "0010f060": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fclose(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fclose@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00107e70": "\nuint c_isblank(int param_1,undefined8 param_2,uint param_3)\n\n{\n  uint in_EAX;\n  \n  return in_EAX & 0xffffff00 | (uint)(param_1 == 0x20) | param_3 & 0xffffff00 | (uint)(param_1 == 9)\n  ;\n}\n\n", 
    "0010f188": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fseeko(FILE *__stream,__off_t __off,int __whence)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fseeko@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010f068": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid bindtextdomain(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* bindtextdomain@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00106610": "\nundefined4 get_quoting_style(undefined1 *param_1)\n\n{\n  if ((undefined4 *)param_1 == (undefined4 *)0x0) {\n    param_1 = default_quoting_options;\n  }\n  return *(undefined4 *)param_1;\n}\n\n", 
    "0010f0e0": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __libc_start_main(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __libc_start_main@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00107940": "\nvoid xalloc_die(void)\n\n{\n  undefined8 uVar1;\n  \n  uVar1 = dcgettext(0,\"memory exhausted\",5);\n                    /* WARNING: Subroutine does not return */\n  error(exit_failure,0,\"%s\",uVar1);\n}\n\n", 
    "00102490": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid regfree(regex_t *__preg)\n\n{\n  (*(code *)PTR_regfree_0010de90)();\n  return;\n}\n\n", 
    "00104550": "\nvoid parse_long_options(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n                       undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,\n                       undefined8 param_9,undefined8 param_10,undefined8 param_11,\n                       undefined8 param_12,undefined8 param_13,code *param_14)\n\n{\n  undefined4 uVar1;\n  char in_AL;\n  int iVar2;\n  long in_FS_OFFSET;\n  undefined4 local_f8;\n  undefined4 local_f4;\n  undefined *local_f0;\n  undefined *local_e8;\n  long local_e0;\n  undefined local_d8 [48];\n  undefined4 local_a8;\n  undefined4 local_98;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  \n  uVar1 = opterr;\n  if (in_AL != '\\0') {\n    local_a8 = param_1;\n    local_98 = param_2;\n    local_88 = param_3;\n    local_78 = param_4;\n    local_68 = param_5;\n    local_58 = param_6;\n    local_48 = param_7;\n    local_38 = param_8;\n  }\n  local_e0 = *(long *)(in_FS_OFFSET + 0x28);\n  opterr = 0;\n  if ((int)param_9 == 2) {\n    iVar2 = getopt_long(param_9,param_10,&DAT_00109007,long_options,0);\n    if (iVar2 != -1) {\n      if (iVar2 == 0x68) {\n        (*param_14)(0);\n      }\n      else if (iVar2 == 0x76) {\n        local_f0 = &stack0x00000008;\n        local_f8 = 0x30;\n        local_e8 = local_d8;\n        local_f4 = 0x30;\n        version_etc_va(stdout,param_11,param_12,param_13,&local_f8);\n                    /* WARNING: Subroutine does not return */\n        exit(0);\n      }\n    }\n  }\n  opterr = uVar1;\n  optind = 0;\n  if (local_e0 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00102ac0": "\nvoid mpz_sub(long *param_1,long *param_2,long *param_3)\n\n{\n  long lVar1;\n  \n  lVar1 = *param_2 - *param_3;\n  if (*param_2 < lVar1 == (bool)-(char)(*param_3 >> 0x3f)) {\n    *param_1 = lVar1;\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  integer_overflow(0x2d);\n}\n\n", 
    "0010f0e8": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint memcmp(void *__s1,void *__s2,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* memcmp@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010f150": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint strcoll(char *__s1,char *__s2)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strcoll@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00103d40": "\nundefined8 eval5(char param_1)\n\n{\n  char cVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  \n  uVar2 = eval6(param_1);\n  while( true ) {\n    cVar1 = nextarg(&DAT_0010906b);\n    if (cVar1 == '\\0') break;\n    uVar3 = eval6(param_1);\n    uVar4 = uVar2;\n    if (param_1 != '\\0') {\n      uVar4 = docolon(uVar2,uVar3);\n      freev(uVar2);\n    }\n    freev(uVar3);\n    uVar2 = uVar4;\n  }\n  return uVar2;\n}\n\n", 
    "0010f030": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid _ITM_deregisterTMCloneTable(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n  halt_baddata();\n}\n\n", 
    "001066b0": "\nvoid set_custom_quoting(undefined1 *param_1,long param_2,long param_3)\n\n{\n  if ((undefined4 *)param_1 == (undefined4 *)0x0) {\n    param_1 = default_quoting_options;\n  }\n  *(undefined4 *)param_1 = 10;\n  if ((param_2 != 0) && (param_3 != 0)) {\n    *(long *)((long)param_1 + 0x28) = param_2;\n    *(long *)((long)param_1 + 0x30) = param_3;\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "001083f4": "\nvoid _fini(void)\n\n{\n  return;\n}\n\n", 
    "00102920": "\n/* WARNING: Removing unreachable block (ram,0x00102944) */\n/* WARNING: Removing unreachable block (ram,0x00102950) */\n\nvoid register_tm_clones(void)\n\n{\n  return;\n}\n\n", 
    "0010f158": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __freading(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __freading@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010f038": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid _exit(int __status)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* _exit@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00107d80": "\nsize_t rpl_mbrtowc(wchar_t *param_1,byte *param_2,size_t param_3,mbstate_t *param_4)\n\n{\n  char cVar1;\n  size_t sVar2;\n  long in_FS_OFFSET;\n  wchar_t local_34;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_1 == (wchar_t *)0x0) {\n    param_1 = &local_34;\n  }\n  sVar2 = mbrtowc(param_1,(char *)param_2,param_3,param_4);\n  if ((0xfffffffffffffffd < sVar2) && (param_3 != 0)) {\n    cVar1 = hard_locale(0);\n    if (cVar1 == '\\0') {\n      sVar2 = 1;\n      *param_1 = (uint)*param_2;\n    }\n  }\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return sVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00102000": "\nint _init(EVP_PKEY_CTX *ctx)\n\n{\n  undefined *puVar1;\n  \n  puVar1 = PTR___gmon_start___0010dfe8;\n  if (PTR___gmon_start___0010dfe8 != (undefined *)0x0) {\n    puVar1 = (undefined *)(*(code *)PTR___gmon_start___0010dfe8)();\n  }\n  return (int)puVar1;\n}\n\n", 
    "00104ed0": "\nundefined8\nstrcaseeq2(long param_1,undefined8 param_2,byte param_3,char param_4,char param_5,char param_6,\n          char param_7)\n\n{\n  char cVar1;\n  byte bVar2;\n  undefined8 uVar3;\n  \n  cVar1 = c_isupper((int)(char)param_3);\n  bVar2 = *(byte *)(param_1 + 2);\n  if (cVar1 != '\\0') {\n    bVar2 = bVar2 & 0xdf;\n  }\n  if (param_3 != bVar2) {\n    return 0;\n  }\n  if (param_3 == 0) {\n    return 1;\n  }\n  uVar3 = strcaseeq3(param_1,param_2,(int)param_4,(int)param_5,(int)param_6,(int)param_7);\n  return uVar3;\n}\n\n", 
    "00106960": "\nvoid quotearg_n_style(undefined4 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  long in_FS_OFFSET;\n  undefined auStack_58 [56];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  quoting_options_from_style(auStack_58);\n  quotearg_n_options(param_1,param_3,0xffffffffffffffff,auStack_58);\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00102480": "\nvoid dcgettext(void)\n\n{\n  (*(code *)PTR_dcgettext_0010de88)();\n  return;\n}\n\n", 
    "00104780": "\nsize_t mbslen(char *param_1)\n\n{\n  size_t sVar1;\n  long in_FS_OFFSET;\n  undefined local_68 [4];\n  undefined8 local_64;\n  undefined local_5c;\n  char *local_58;\n  long local_50;\n  char local_48;\n  int local_44;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  sVar1 = __ctype_get_mb_cur_max();\n  if (sVar1 < 2) {\n    sVar1 = strlen(param_1);\n  }\n  else {\n    sVar1 = 0;\n    local_68[0] = 0;\n    local_64 = 0;\n    local_58 = param_1;\n    while( true ) {\n      local_5c = 0;\n      mbuiter_multi_next(local_68);\n      if ((local_48 != '\\0') && (local_44 == 0)) break;\n      local_58 = local_58 + local_50;\n      sVar1 = sVar1 + 1;\n    }\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return sVar1;\n}\n\n", 
    "00103570": "\nlong eval3(char param_1)\n\n{\n  bool bVar1;\n  char cVar2;\n  long lVar3;\n  long lVar4;\n  code *pcVar5;\n  undefined8 uVar6;\n  \n  lVar3 = eval4(param_1);\n  do {\n    cVar2 = nextarg(&DAT_00109007);\n    if (cVar2 == '\\0') {\n      cVar2 = nextarg(&DAT_00109154);\n      if (cVar2 == '\\0') {\n        return lVar3;\n      }\n      bVar1 = true;\n    }\n    else {\n      bVar1 = false;\n    }\n    lVar4 = eval4(param_1);\n    if (param_1 != '\\0') {\n      cVar2 = toarith(lVar3);\n      if (cVar2 == '\\0') {\nLAB_0010362a:\n        uVar6 = dcgettext(0,\"non-integer argument\",5);\n                    /* WARNING: Subroutine does not return */\n        error(2,0,uVar6);\n      }\n      cVar2 = toarith(lVar4);\n      if (cVar2 == '\\0') goto LAB_0010362a;\n      pcVar5 = mpz_sub;\n      if (!bVar1) {\n        pcVar5 = mpz_add;\n      }\n      (*pcVar5)(lVar3 + 8,lVar3 + 8,lVar4 + 8);\n    }\n    freev(lVar4);\n  } while( true );\n}\n\n", 
    "00108100": "\nchar * locale_charset(void)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = nl_langinfo(0xe);\n  if (pcVar1 != (char *)0x0) {\n    if (*pcVar1 == '\\0') {\n      pcVar1 = \"ASCII\";\n    }\n    return pcVar1;\n  }\n  return \"ASCII\";\n}\n\n", 
    "0010f0f0": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fputs_unlocked(char *__s,FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fputs_unlocked@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00106af0": "\nvoid quotearg_char(undefined8 param_1,char param_2)\n\n{\n  quotearg_char_mem(param_1,0xffffffffffffffff,(int)param_2);\n  return;\n}\n\n", 
    "001029c0": "\nlong mpz_tdiv_r(long *param_1,long *param_2,long *param_3)\n\n{\n  long lVar1;\n  long lVar2;\n  \n  lVar1 = *param_2;\n  lVar2 = *param_3;\n  if ((lVar1 == -0x8000000000000000) && (lVar2 == -1)) {\n    *param_1 = 0;\n    return lVar1;\n  }\n  *param_1 = lVar1 % lVar2;\n  return lVar1 / lVar2;\n}\n\n", 
    "0010f0f8": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint ferror_unlocked(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* ferror_unlocked@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00102b20": "\nvoid mpz_mul(long *param_1,long *param_2,long *param_3)\n\n{\n  long lVar1;\n  long lVar2;\n  \n  lVar1 = *param_2;\n  lVar2 = *param_3;\n  if ((lVar1 != 0) && (lVar2 != 0)) {\n    if ((byte)((byte)((byte)((ulong)lVar1 >> 0x38) ^ (byte)((ulong)lVar2 >> 0x38)) >> 7) !=\n        (byte)-(char)(lVar1 * lVar2 >> 0x3f)) {\n                    /* WARNING: Subroutine does not return */\n      integer_overflow(0x2a);\n    }\n  }\n  *param_1 = lVar1 * lVar2;\n  return;\n}\n\n", 
    "0010f160": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * realloc(void *__ptr,size_t __size)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* realloc@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001078b0": "\nvoid xcalloc(size_t param_1,ulong param_2)\n\n{\n  void *pvVar1;\n  \n  if ((-1 < SUB168(ZEXT816(param_1) * ZEXT816(param_2),0)) &&\n     (SUB168(ZEXT816(param_1) * ZEXT816(param_2) >> 0x40,0) == 0)) {\n    pvVar1 = calloc(param_1,param_2);\n    if (pvVar1 != (void *)0x0) {\n      return;\n    }\n  }\n                    /* WARNING: Subroutine does not return */\n  xalloc_die();\n}\n\n", 
    "0010f040": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __fpending(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __fpending@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001079d0": "\nuint bkm_scale_by_power(undefined8 param_1,uint param_2,int param_3)\n\n{\n  uint uVar1;\n  uint uVar2;\n  ulong uVar3;\n  \n  uVar3 = (ulong)param_2;\n  param_3 = param_3 + -1;\n  uVar2 = 0;\n  do {\n    uVar1 = bkm_scale(param_1,uVar3 & 0xffffffff);\n    param_3 = param_3 + -1;\n    uVar2 = uVar2 | uVar1;\n  } while (param_3 != -1);\n  return uVar2;\n}\n\n", 
    "00102a00": "\nundefined8 looks_like_integer(char *param_1)\n\n{\n  char cVar1;\n  \n  param_1 = param_1 + (*param_1 == '-');\n  cVar1 = *param_1;\n  do {\n    if (9 < (int)cVar1 - 0x30U) {\n      return 0;\n    }\n    cVar1 = param_1[1];\n    param_1 = param_1 + 1;\n  } while (cVar1 != '\\0');\n  return 1;\n}\n\n", 
    "00102d60": "\nlong getsize_isra_0(void)\n\n{\n  int iVar1;\n  long lVar2;\n  long lVar3;\n  \n  iVar1 = mpz_sgn_isra_0();\n  if (-1 < iVar1) {\n    iVar1 = mpz_fits_ulong_p_isra_0();\n    lVar3 = -2;\n    if (iVar1 != 0) {\n      lVar2 = mpz_get_ui_isra_0();\n      if (lVar2 != -1) {\n        lVar3 = lVar2;\n      }\n    }\n    return lVar3;\n  }\n  return -1;\n}\n\n", 
    "001034f0": "\nundefined4 toarith(int *param_1)\n\n{\n  void *__ptr;\n  undefined4 uVar1;\n  int iVar2;\n  \n  uVar1 = 1;\n  if (*param_1 != 0) {\n    if (*param_1 != 1) {\n                    /* WARNING: Subroutine does not return */\n      abort();\n    }\n    __ptr = *(void **)(param_1 + 2);\n    uVar1 = looks_like_integer(__ptr);\n    if ((char)uVar1 != '\\0') {\n      iVar2 = mpz_init_set_str_constprop_0(param_1 + 2,__ptr);\n      if (iVar2 == 0) {\n        free(__ptr);\n        *param_1 = 0;\n        return uVar1;\n      }\n                    /* WARNING: Subroutine does not return */\n      error(3,0x22,\"%s\",__ptr);\n    }\n  }\n  return uVar1;\n}\n\n", 
    "0010f168": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * setlocale(int __category,char *__locale)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* setlocale@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00106a40": "\nvoid quotearg_style_mem(undefined4 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  quotearg_n_style_mem(0,param_1,param_2,param_3);\n  return;\n}\n\n", 
    "0010f048": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint puts(char *__s)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* puts@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001083e0": "\nint atexit(__func *__func)\n\n{\n  int iVar1;\n  \n  iVar1 = __cxa_atexit(__func,0,__dso_handle);\n  return iVar1;\n}\n\n", 
    "00106c80": "\nvoid quotearg_custom(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  quotearg_n_custom(0,param_1,param_2,param_3);\n  return;\n}\n\n", 
    "00107e90": "\nulong c_iscntrl(uint param_1)\n\n{\n  ulong in_RAX;\n  \n  if ((int)param_1 < 0x20) {\n    return (ulong)(~param_1 >> 0x1f);\n  }\n  return in_RAX & 0xffffffffffffff00 | (ulong)(param_1 == 0x7f);\n}\n\n", 
    "00102670": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * mempcpy(void *__dest,void *__src,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = (void *)(*(code *)PTR_mempcpy_0010df80)();\n  return pvVar1;\n}\n\n", 
    "00102550": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * memchr(void *__s,int __c,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = (void *)(*(code *)PTR_memchr_0010def0)();\n  return pvVar1;\n}\n\n", 
    "00103880": "\nundefined8 eval1(char param_1)\n\n{\n  char cVar1;\n  byte bVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  \n  uVar3 = eval2(param_1);\n  do {\n    cVar1 = nextarg(&DAT_0010902e);\n    while( true ) {\n      if (cVar1 == '\\0') {\n        return uVar3;\n      }\n      bVar2 = 0;\n      if (param_1 != '\\0') {\n        bVar2 = null(uVar3);\n        bVar2 = bVar2 ^ 1;\n      }\n      uVar4 = eval2(bVar2);\n      cVar1 = null(uVar3);\n      if ((cVar1 == '\\0') && (cVar1 = null(uVar4), cVar1 == '\\0')) break;\n      freev(uVar3);\n      freev(uVar4);\n      uVar3 = int_value(0);\n      cVar1 = nextarg();\n    }\n    freev(uVar4);\n  } while( true );\n}\n\n", 
    "00102430": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint puts(char *__s)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_puts_0010de60)();\n  return iVar1;\n}\n\n", 
    "0010f0c0": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid __assert_fail(char *__assertion,char *__file,uint __line,char *__function)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __assert_fail@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010f018": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint re_match(re_pattern_buffer *__buffer,char *__string,int __length,int __start,\n            re_registers *__regs)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* re_match@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00106ce0": "\nvoid quote_n(undefined8 param_1,undefined8 param_2)\n\n{\n  quote_n_mem(param_1,param_2,0xffffffffffffffff);\n  return;\n}\n\n", 
    "00107ef0": "\nulong c_ispunct(int param_1)\n\n{\n  ulong in_RAX;\n  \n  if (0x60 < param_1) {\n    return in_RAX & 0xffffffffffffff00 | (ulong)(param_1 - 0x7bU < 4);\n  }\n  if (param_1 < 0x5b) {\n    if (param_1 < 0x30) {\n      return in_RAX & 0xffffffffffffff00 | (ulong)(0x20 < param_1);\n    }\n    return in_RAX & 0xffffffffffffff00 | (ulong)(param_1 - 0x3aU < 7);\n  }\n  return 1;\n}\n\n", 
    "00105140": "\nchar * gettext_quote(char *param_1,int param_2)\n\n{\n  int iVar1;\n  char *pcVar2;\n  undefined8 uVar3;\n  \n  pcVar2 = (char *)dcgettext(0,param_1,5);\n  if (param_1 == pcVar2) {\n    uVar3 = locale_charset();\n    iVar1 = strcaseeq0_constprop_0(uVar3,\"UTF-8\",0x55,0x54,0x46,0x2d,0x38,0,0);\n    if (iVar1 == 0) {\n      iVar1 = strcaseeq0_constprop_0(uVar3,\"GB18030\",0x47,0x42,0x31,0x38,0x30,0x33,0x30);\n      if (iVar1 == 0) {\n        pcVar2 = \"\\\"\";\n        if (param_2 != 9) {\n          pcVar2 = \"\\'\";\n        }\n        return pcVar2;\n      }\n      if (*pcVar2 == '`') {\n        pcVar2 = &DAT_00109bf1;\n      }\n      else {\n        pcVar2 = &DAT_00109bee;\n      }\n    }\n    else if (*pcVar2 == '`') {\n      pcVar2 = &DAT_00109bf5;\n    }\n    else {\n      pcVar2 = &DAT_00109bea;\n    }\n  }\n  return pcVar2;\n}\n\n", 
    "0010f0c8": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * memset(void *__s,int __c,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* memset@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001025f0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * malloc(size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = (void *)(*(code *)PTR_malloc_0010df40)();\n  return pvVar1;\n}\n\n", 
    "001024d0": "\nvoid getopt_long(void)\n\n{\n  (*(code *)PTR_getopt_long_0010deb0)();\n  return;\n}\n\n", 
    "001023b0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid free(void *__ptr)\n\n{\n  (*(code *)PTR_free_0010de20)();\n  return;\n}\n\n", 
    "0010f130": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint wcwidth(wchar_t __c)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* wcwidth@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00106b10": "\nvoid quotearg_colon(undefined8 param_1)\n\n{\n  quotearg_char(param_1,0x3a);\n  return;\n}\n\n", 
    "00107e40": "\nbool c_isalpha(int param_1)\n\n{\n  if (param_1 < 0x5b) {\n    return 0x40 < param_1;\n  }\n  return param_1 - 0x61U < 0x1a;\n}\n\n", 
    "00107f60": "\nbool c_isupper(int param_1)\n\n{\n  return param_1 - 0x41U < 0x1a;\n}\n\n", 
    "0010f138": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * malloc(size_t __size)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* malloc@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010f010": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid abort(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* abort@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00102660": "\nvoid __printf_chk(void)\n\n{\n  (*(code *)PTR___printf_chk_0010df78)();\n  return;\n}\n\n", 
    "0010f0d0": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t strcspn(char *__s,char *__reject)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strcspn@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00102540": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t strcspn(char *__s,char *__reject)\n\n{\n  size_t sVar1;\n  \n  sVar1 = (*(code *)PTR_strcspn_0010dee8)();\n  return sVar1;\n}\n\n", 
    "00102420": "\nvoid __fpending(void)\n\n{\n  (*(code *)PTR___fpending_0010de58)();\n  return;\n}\n\n", 
    "00106cd0": "\nvoid quote_mem(undefined8 param_1,undefined8 param_2)\n\n{\n  quote_n_mem(0,param_1,param_2);\n  return;\n}\n\n", 
    "00107550": "\nvoid version_etc_va(void)\n\n{\n  uint uVar1;\n  long *plVar2;\n  long lVar3;\n  uint *in_R8;\n  long lVar4;\n  long in_FS_OFFSET;\n  long local_68 [11];\n  long local_10;\n  \n  lVar4 = 0;\n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  do {\n    uVar1 = *in_R8;\n    if (uVar1 < 0x30) {\n      *in_R8 = uVar1 + 8;\n      lVar3 = *(long *)((ulong)uVar1 + *(long *)(in_R8 + 4));\n      local_68[lVar4] = lVar3;\n    }\n    else {\n      plVar2 = *(long **)(in_R8 + 2);\n      *(long **)(in_R8 + 2) = plVar2 + 1;\n      lVar3 = *plVar2;\n      local_68[lVar4] = lVar3;\n    }\n  } while ((lVar3 != 0) && (lVar4 = lVar4 + 1, lVar4 != 10));\n  version_etc_arn();\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00107ee0": "\nbool c_isprint(int param_1)\n\n{\n  return param_1 - 0x20U < 0x5f;\n}\n\n", 
    "00103190": "\nvoid mpz_get_str_isra_0(undefined8 param_1)\n\n{\n  undefined8 uVar1;\n  long in_FS_OFFSET;\n  undefined auStack_28 [24];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  uVar1 = imaxtostr(param_1,auStack_28);\n  xstrdup(uVar1);\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "0010f0d8": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * memchr(void *__s,int __c,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* memchr@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001025e0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint wcwidth(wchar_t __c)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_wcwidth_0010df38)();\n  return iVar1;\n}\n\n", 
    "001024c0": "\nvoid __stack_chk_fail(void)\n\n{\n  (*(code *)PTR___stack_chk_fail_0010dea8)();\n  return;\n}\n\n", 
    "0010f140": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fflush(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fflush@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001023a0": "\nvoid __cxa_finalize(void)\n\n{\n  (*(code *)PTR___cxa_finalize_0010dff8)();\n  return;\n}\n\n", 
    "0010f020": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint * __errno_location(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __errno_location@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00106d40": "\nuint fraccompare(char *param_1,char *param_2,char param_3)\n\n{\n  uint uVar1;\n  uint uVar2;\n  char *pcVar3;\n  char cVar4;\n  char cVar5;\n  int iVar6;\n  int iVar7;\n  char *pcVar8;\n  \n  if (*param_1 != param_3) {\n    if (param_3 != *param_2) {\n      return 0;\n    }\n    iVar7 = (int)param_2[1];\n    param_2 = param_2 + 1;\nLAB_00106dd8:\n    while ((char)iVar7 == '0') {\n      pcVar8 = param_2 + 1;\n      param_2 = param_2 + 1;\n      iVar7 = (int)*pcVar8;\n    }\n    return -(uint)(iVar7 - 0x30U < 10);\n  }\n  iVar6 = (int)param_1[1];\n  if (param_3 == *param_2) {\n    while( true ) {\n      cVar4 = param_2[1];\n      iVar7 = (int)cVar4;\n      cVar5 = (char)iVar6;\n      param_2 = param_2 + 1;\n      pcVar8 = param_1 + 1;\n      uVar1 = (int)cVar5 - 0x30;\n      if (cVar4 != cVar5) break;\n      if (9 < uVar1) {\n        return 0;\n      }\n      iVar6 = (int)param_1[2];\n      param_1 = pcVar8;\n    }\n    uVar2 = (int)cVar4 - 0x30;\n    if (9 < uVar1) {\n      if (9 < uVar2) {\n        return 0;\n      }\n      goto LAB_00106dd8;\n    }\n    if (uVar2 < 10) {\n      return (int)cVar5 - (int)cVar4;\n    }\n  }\n  else {\n    pcVar8 = param_1 + 1;\n  }\n  while ((char)iVar6 == '0') {\n    pcVar3 = pcVar8 + 1;\n    pcVar8 = pcVar8 + 1;\n    iVar6 = (int)*pcVar3;\n  }\n  return (uint)(iVar6 - 0x30U < 10);\n}\n\n", 
    "0010f148": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * nl_langinfo(nl_item __item)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* nl_langinfo@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010f028": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint strncmp(char *__s1,char *__s2,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strncmp@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00102410": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid _exit(int __status)\n\n{\n  (*(code *)PTR__exit_0010de50)();\n  return;\n}\n\n", 
    "00102da0": "\nlong mbs_logical_cspn(char *param_1,char *param_2)\n\n{\n  size_t sVar1;\n  int iVar2;\n  size_t sVar3;\n  long lVar4;\n  char *pcVar5;\n  long lVar6;\n  long in_FS_OFFSET;\n  undefined local_c8 [4];\n  undefined8 local_c4;\n  undefined local_bc;\n  char *local_b8;\n  size_t local_b0;\n  char local_a8;\n  int local_a4;\n  undefined local_88 [4];\n  undefined8 local_84;\n  undefined local_7c;\n  char *local_78;\n  size_t local_70;\n  char local_68;\n  int local_64;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (*param_2 != '\\0') {\n    sVar3 = __ctype_get_mb_cur_max();\n    if (1 < sVar3) {\n      lVar6 = 0;\n      local_c8[0] = 0;\n      local_c4 = 0;\n      local_bc = 0;\n      local_b8 = param_1;\n      mbuiter_multi_next(local_c8);\n      pcVar5 = local_b8;\n      sVar3 = local_b0;\n      do {\n        local_b8 = pcVar5;\n        if ((local_a8 != '\\0') && (local_a4 == 0)) goto LAB_00102dc9;\n        lVar6 = lVar6 + 1;\n        local_b0 = sVar3;\n        if (sVar3 != 1) {\n          local_88[0] = 0;\n          local_84 = 0;\n          local_78 = param_2;\n          do {\n            local_7c = 0;\n            mbuiter_multi_next(local_88);\n            sVar1 = local_70;\n            if (local_68 == '\\0') {\nLAB_00102ef7:\n              if ((local_70 == local_b0) && (iVar2 = memcmp(local_78,local_b8,local_70), iVar2 == 0)\n                 ) goto LAB_00102dcc;\n            }\n            else {\n              pcVar5 = local_b8;\n              sVar3 = local_b0;\n              if (local_64 == 0) goto LAB_00102e7a;\n              if (local_a8 == '\\0') goto LAB_00102ef7;\n              if (local_a4 == local_64) goto LAB_00102dcc;\n            }\n            local_78 = local_78 + sVar1;\n          } while( true );\n        }\n        lVar4 = mbschr(param_2,(int)*pcVar5);\n        if (lVar4 != 0) goto LAB_00102dcc;\nLAB_00102e7a:\n        local_b8 = pcVar5 + sVar3;\n        local_bc = 0;\n        mbuiter_multi_next(local_c8);\n        pcVar5 = local_b8;\n        sVar3 = local_b0;\n      } while( true );\n    }\n    sVar3 = strcspn(param_1,param_2);\n    if (param_1[sVar3] != '\\0') {\n      lVar6 = sVar3 + 1;\n      goto LAB_00102dcc;\n    }\n  }\nLAB_00102dc9:\n  lVar6 = 0;\nLAB_00102dcc:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return lVar6;\n}\n\n", 
    "00104830": "\nvoid mbuiter_multi_next(char *param_1)\n\n{\n  char *pcVar1;\n  undefined8 uVar2;\n  char cVar3;\n  int iVar4;\n  size_t sVar5;\n  undefined8 uVar6;\n  long lVar7;\n  \n  if (param_1[0xc] != '\\0') {\n    return;\n  }\n  if (*param_1 == '\\0') {\n    pcVar1 = *(char **)(param_1 + 0x10);\n    cVar3 = is_basic((int)*pcVar1);\n    if (cVar3 != '\\0') {\n      *(undefined8 *)(param_1 + 0x18) = 1;\n      cVar3 = *pcVar1;\n      param_1[0x20] = '\\x01';\n      *(int *)(param_1 + 0x24) = (int)cVar3;\n      goto LAB_00104872;\n    }\n    iVar4 = mbsinit((mbstate_t *)(param_1 + 4));\n    if (iVar4 == 0) {\n                    /* WARNING: Subroutine does not return */\n      __assert_fail(\"mbsinit (&iter->state)\",\"lib/mbuiter.h\",0x96,\"mbuiter_multi_next\");\n    }\n    *param_1 = '\\x01';\n  }\n  sVar5 = __ctype_get_mb_cur_max();\n  uVar2 = *(undefined8 *)(param_1 + 0x10);\n  uVar6 = strnlen1(uVar2,sVar5);\n  lVar7 = rpl_mbrtowc(param_1 + 0x24,uVar2,uVar6,(mbstate_t *)(param_1 + 4));\n  *(long *)(param_1 + 0x18) = lVar7;\n  if (lVar7 == -1) {\n    *(undefined8 *)(param_1 + 0x18) = 1;\n    param_1[0x20] = '\\0';\n    param_1[0xc] = '\\x01';\n    return;\n  }\n  if (lVar7 == -2) {\n    sVar5 = strlen(*(char **)(param_1 + 0x10));\n    param_1[0x20] = '\\0';\n    *(size_t *)(param_1 + 0x18) = sVar5;\n  }\n  else {\n    if (lVar7 == 0) {\n      *(undefined8 *)(param_1 + 0x18) = 1;\n      if (**(char **)(param_1 + 0x10) != '\\0') {\n                    /* WARNING: Subroutine does not return */\n        __assert_fail(\"*iter->cur.ptr == \\'\\\\0\\'\",\"lib/mbuiter.h\",0xb2,\"mbuiter_multi_next\");\n      }\n      if (*(int *)(param_1 + 0x24) != 0) {\n                    /* WARNING: Subroutine does not return */\n        __assert_fail(\"iter->cur.wc == 0\",\"lib/mbuiter.h\",0xb3,\"mbuiter_multi_next\");\n      }\n    }\n    param_1[0x20] = '\\x01';\n    iVar4 = mbsinit((mbstate_t *)(param_1 + 4));\n    if (iVar4 != 0) {\n      *param_1 = '\\0';\n    }\n  }\nLAB_00104872:\n  param_1[0xc] = '\\x01';\n  return;\n}\n\n", 
    "00102450": "\nvoid textdomain(void)\n\n{\n  (*(code *)PTR_textdomain_0010de70)();\n  return;\n}\n\n", 
    "00106930": "\nvoid quotearg_n_mem(void)\n\n{\n  quotearg_n_options();\n  return;\n}\n\n", 
    "00102ba0": "\nvoid require_more_args(void)\n\n{\n  char cVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  \n  cVar1 = nomoreargs();\n  if (cVar1 == '\\0') {\n    return;\n  }\n  uVar2 = quotearg_n_style(0,8,*(undefined8 *)(args + -8));\n  uVar3 = dcgettext(0,\"syntax error: missing argument after %s\",5);\n                    /* WARNING: Subroutine does not return */\n  error(2,0,uVar3,uVar2);\n}\n\n", 
    "00103420": "\nbool mpz_out_str_isra_0(FILE *param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  char *__s;\n  long in_FS_OFFSET;\n  undefined auStack_28 [24];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  __s = (char *)imaxtostr(param_2,auStack_28);\n  iVar1 = fputs_unlocked(__s,param_1);\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar1 != -1;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "0010f1c0": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint mbsinit(mbstate_t *__ps)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* mbsinit@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010f118": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * memcpy(void *__dest,void *__src,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* memcpy@@GLIBC_2.14 */\n  halt_baddata();\n}\n\n", 
    "00102690": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fseeko(FILE *__stream,__off_t __off,int __whence)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_fseeko_0010df90)();\n  return iVar1;\n}\n\n", 
    "00102570": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fputs_unlocked(char *__s,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_fputs_unlocked_0010df00)();\n  return iVar1;\n}\n\n", 
    "0010f1c8": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint iswprint(wint_t __wc)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* iswprint@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010f0a0": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t mbrtowc(wchar_t *__pwc,char *__s,size_t __n,mbstate_t *__p)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* mbrtowc@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001023d0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid abort(void)\n\n{\n  (*(code *)PTR_abort_0010de30)();\n  return;\n}\n\n", 
    "001034c0": "\nint mpz_init_set_str_constprop_0(undefined8 param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  \n  iVar1 = xstrtoimax(param_2,0,10,param_1,0);\n  return -(uint)(iVar1 != 0);\n}\n\n", 
    "0010f1b8": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * re_compile_pattern(char *__pattern,size_t __length,re_pattern_buffer *__buffer)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* re_compile_pattern@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001024f0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * strchr(char *__s,int __c)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_strchr_0010dec0)();\n  return pcVar1;\n}\n\n", 
    "00106b30": "\nvoid quotearg_n_style_colon(undefined4 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  long in_FS_OFFSET;\n  undefined8 local_98;\n  undefined8 uStack_90;\n  undefined8 local_88;\n  undefined8 uStack_80;\n  undefined8 local_78;\n  undefined8 uStack_70;\n  undefined8 local_68;\n  undefined8 local_58;\n  undefined8 uStack_50;\n  undefined8 local_48;\n  undefined8 uStack_40;\n  undefined8 local_38;\n  undefined8 uStack_30;\n  undefined8 local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  quoting_options_from_style(&local_98);\n  puVar1 = &local_58;\n  local_58 = local_98;\n  uStack_50 = uStack_90;\n  local_48 = local_88;\n  uStack_40 = uStack_80;\n  local_38 = local_78;\n  uStack_30 = uStack_70;\n  local_28 = local_68;\n  set_char_quoting(puVar1,0x3a,1);\n  quotearg_n_options(param_1,param_3,0xffffffffffffffff,puVar1);\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00107e60": "\nbool c_isascii(uint param_1)\n\n{\n  return param_1 < 0x80;\n}\n\n", 
    "00104b90": "\nundefined8 strcaseeq7(long param_1,undefined8 param_2,byte param_3,char param_4)\n\n{\n  char cVar1;\n  byte bVar2;\n  undefined8 uVar3;\n  \n  cVar1 = c_isupper((int)(char)param_3);\n  bVar2 = *(byte *)(param_1 + 7);\n  if (cVar1 != '\\0') {\n    bVar2 = bVar2 & 0xdf;\n  }\n  if (param_3 != bVar2) {\n    return 0;\n  }\n  if (param_3 == 0) {\n    return 1;\n  }\n  uVar3 = strcaseeq8(param_1,param_2,(int)param_4);\n  return uVar3;\n}\n\n", 
    "0010f110": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __gmon_start__(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n  halt_baddata();\n}\n\n", 
    "00102560": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint memcmp(void *__s1,void *__s2,size_t __n)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_memcmp_0010def8)();\n  return iVar1;\n}\n\n", 
    "00103650": "\nlong eval2(char param_1)\n\n{\n  char *__s1;\n  char *__s2;\n  char cVar1;\n  int iVar2;\n  long lVar3;\n  long lVar4;\n  int *piVar5;\n  undefined8 uVar6;\n  ulong uVar7;\n  \n  lVar3 = eval3(param_1);\n  do {\n    cVar1 = nextarg(&DAT_0010901e);\n    if (cVar1 == '\\0') {\n      cVar1 = nextarg(&DAT_00109020);\n      if (cVar1 == '\\0') {\n        cVar1 = nextarg(&DAT_00109027);\n        if ((cVar1 == '\\0') && (cVar1 = nextarg(&DAT_00109023), cVar1 == '\\0')) {\n          cVar1 = nextarg(&DAT_00109026);\n          if (cVar1 == '\\0') {\n            cVar1 = nextarg(&DAT_00109029);\n            if (cVar1 == '\\0') {\n              cVar1 = nextarg(&DAT_0010902c);\n              if (cVar1 == '\\0') {\n                return lVar3;\n              }\n              uVar6 = 5;\n            }\n            else {\n              uVar6 = 4;\n            }\n          }\n          else {\n            uVar6 = 3;\n          }\n        }\n        else {\n          uVar6 = 2;\n        }\n      }\n      else {\n        uVar6 = 1;\n      }\n    }\n    else {\n      uVar6 = 0;\n    }\n    uVar7 = 0;\n    lVar4 = eval3(param_1);\n    if (param_1 != '\\0') {\n      tostring(lVar3);\n      tostring(lVar4);\n      __s1 = *(char **)(lVar3 + 8);\n      cVar1 = looks_like_integer(__s1);\n      __s2 = *(char **)(lVar4 + 8);\n      if ((cVar1 == '\\0') || (cVar1 = looks_like_integer(__s2), cVar1 == '\\0')) {\n        piVar5 = __errno_location();\n        *piVar5 = 0;\n        iVar2 = strcoll(__s1,__s2);\n      }\n      else {\n        iVar2 = strintcmp(__s1);\n      }\n      switch(uVar6) {\n      default:\n        uVar7 = (ulong)(long)iVar2 >> 0x3f;\n        break;\n      case 1:\n        uVar7 = (ulong)(iVar2 < 1);\n        break;\n      case 2:\n        uVar7 = (ulong)(iVar2 == 0);\n        break;\n      case 3:\n        uVar7 = (ulong)(iVar2 != 0);\n        break;\n      case 4:\n        uVar7 = (ulong)~(long)iVar2 >> 0x3f;\n        break;\n      case 5:\n        uVar7 = (ulong)(0 < iVar2);\n      }\n    }\n    freev(lVar3);\n    freev(lVar4);\n    lVar3 = int_value(uVar7);\n  } while( true );\n}\n\n", 
    "00102440": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint iswcntrl(wint_t __wc)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_iswcntrl_0010de68)();\n  return iVar1;\n}\n\n", 
    "0010f1d0": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nushort ** __ctype_b_loc(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __ctype_b_loc@@GLIBC_2.3 */\n  halt_baddata();\n}\n\n", 
    "00102cb0": "\nulong null(int *param_1)\n\n{\n  int iVar1;\n  char *pcVar2;\n  char cVar3;\n  ulong in_R8;\n  ulong uVar4;\n  \n  if (*param_1 == 0) {\n    iVar1 = mpz_sgn_isra_0(*(undefined8 *)(param_1 + 2));\n    uVar4 = in_R8 & 0xffffffffffffff00 | (ulong)(iVar1 == 0);\n  }\n  else {\n    if (*param_1 != 1) {\n      uVar4 = null_cold();\n      return uVar4;\n    }\n    uVar4 = 1;\n    cVar3 = **(char **)(param_1 + 2);\n    if (cVar3 != '\\0') {\n      pcVar2 = *(char **)(param_1 + 2) + (cVar3 == '-');\n      cVar3 = *pcVar2;\n      do {\n        if (cVar3 != '0') {\n          return 0;\n        }\n        cVar3 = pcVar2[1];\n        pcVar2 = pcVar2 + 1;\n      } while (cVar3 != '\\0');\n      return 1;\n    }\n  }\n  return uVar4 & 0xffffffff;\n}\n\n", 
    "0010f0b0": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * strrchr(char *__s,int __c)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strrchr@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010f128": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fileno(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fileno@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010f008": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nintmax_t strtoimax(char *__nptr,char **__endptr,int __base)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strtoimax@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00102680": "\nvoid error(void)\n\n{\n  (*(code *)PTR_error_0010df88)();\n  return;\n}\n\n", 
    "00106bd0": "\nvoid quotearg_n_custom_mem\n               (undefined4 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n               undefined8 param_5)\n\n{\n  long in_FS_OFFSET;\n  undefined8 local_68;\n  undefined8 uStack_60;\n  undefined8 local_58;\n  undefined8 uStack_50;\n  undefined8 local_48;\n  undefined8 uStack_40;\n  undefined8 local_38;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  local_68 = default_quoting_options._0_8_;\n  uStack_60 = default_quoting_options._8_8_;\n  local_38 = default_quoting_options._48_8_;\n  local_58 = default_quoting_options._16_8_;\n  uStack_50 = default_quoting_options._24_8_;\n  local_48 = default_quoting_options._32_8_;\n  uStack_40 = default_quoting_options._40_8_;\n  set_custom_quoting(&local_68);\n  quotearg_n_options(param_1,param_4,param_5,&local_68);\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00106cf0": "\nvoid quote(undefined8 param_1)\n\n{\n  quote_n(0,param_1);\n  return;\n}\n\n", 
    "00107690": "\nvoid emit_bug_reporting_address(void)\n\n{\n  FILE *__stream;\n  undefined8 uVar1;\n  char *__s;\n  \n  uVar1 = dcgettext(0,\"\\nReport bugs to: %s\\n\",5);\n  __printf_chk(1,uVar1,\"bug-coreutils@gnu.org\");\n  uVar1 = dcgettext(0,\"%s home page: <%s>\\n\",5);\n  __printf_chk(1,uVar1,\"GNU coreutils\",\"https://www.gnu.org/software/coreutils/\");\n  __stream = stdout;\n  __s = (char *)dcgettext(0,\"General help using GNU software: <https://www.gnu.org/gethelp/>\\n\",5);\n  fputs_unlocked(__s,__stream);\n  return;\n}\n\n", 
    "0010f1d8": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __cxa_finalize(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __cxa_finalize@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00105270": "\nulong quotearg_buffer_restyled\n                (undefined *param_1,ulong param_2,char *param_3,ulong param_4,int param_5,\n                uint param_6,long param_7,char *param_8,char *param_9)\n\n{\n  byte *__s1;\n  bool bVar1;\n  bool bVar2;\n  bool bVar3;\n  bool bVar4;\n  bool bVar5;\n  bool bVar6;\n  int iVar7;\n  size_t sVar8;\n  ushort **ppuVar9;\n  long lVar10;\n  char cVar11;\n  uint uVar12;\n  ulong uVar13;\n  byte bVar14;\n  ulong uVar15;\n  char *pcVar16;\n  ulong uVar17;\n  ulong uVar18;\n  ulong uVar19;\n  long in_FS_OFFSET;\n  bool bVar20;\n  bool bVar21;\n  bool bVar22;\n  bool bVar23;\n  bool bVar24;\n  size_t local_c8;\n  char *local_98;\n  ulong local_90;\n  char *local_78;\n  char *local_70;\n  bool local_64;\n  wint_t local_4c;\n  mbstate_t local_48;\n  long local_40;\n  \n  local_70 = param_8;\n  local_78 = param_9;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  sVar8 = __ctype_get_mb_cur_max();\n  uVar12 = param_6 & 2;\n  bVar20 = uVar12 != 0;\n  switch(param_5) {\n  case 0:\n    bVar6 = true;\n    bVar2 = false;\n    uVar18 = 0;\n    local_64 = false;\n    local_90 = 0;\n    bVar20 = false;\n    bVar1 = false;\n    local_c8 = 0;\n    local_98 = (char *)0x0;\n    break;\n  case 2:\n    if (uVar12 == 0) {\n      bVar1 = false;\nLAB_001056f7:\n      if (param_2 == 0) {\n        local_90 = 0;\n        bVar2 = false;\n        bVar6 = true;\n        local_64 = false;\n        goto LAB_00105719;\n      }\n      bVar2 = false;\n      local_64 = false;\n      bVar6 = true;\n      uVar13 = 0;\n      local_90 = param_2;\n      goto LAB_00105cb6;\n    }\n    bVar2 = false;\n    uVar18 = 0;\n    bVar6 = true;\n    local_64 = false;\n    local_90 = 0;\n    bVar20 = true;\n    bVar1 = false;\n    local_c8 = 1;\n    local_98 = \"\\'\";\n    break;\n  case 3:\n    bVar1 = true;\n    goto LAB_0010566f;\n  case 4:\n    if (uVar12 == 0) {\n      bVar1 = true;\n      goto LAB_001056f7;\n    }\n  case 1:\n    bVar1 = false;\nLAB_0010566f:\n    bVar6 = true;\n    local_64 = false;\n    bVar20 = true;\n    local_90 = 0;\n    bVar2 = false;\n    uVar18 = 0;\n    param_5 = 2;\n    local_c8 = 1;\n    local_98 = \"\\'\";\n    break;\n  case 5:\n    if (uVar12 == 0) {\n      if (param_2 != 0) {\n        *param_1 = 0x22;\n      }\n      bVar6 = true;\n      local_64 = false;\n      local_90 = 0;\n      bVar2 = false;\n      bVar20 = false;\n      uVar18 = 1;\n      bVar1 = true;\n      local_c8 = 1;\n      local_98 = \"\\\"\";\n    }\n    else {\n      bVar2 = false;\n      uVar18 = 0;\n      bVar6 = true;\n      local_64 = false;\n      local_90 = 0;\n      bVar20 = true;\n      bVar1 = true;\n      local_c8 = 1;\n      local_98 = \"\\\"\";\n    }\n    break;\n  case 6:\n    bVar2 = false;\n    uVar18 = 0;\n    bVar6 = true;\n    local_64 = false;\n    param_5 = 5;\n    local_90 = 0;\n    bVar20 = true;\n    bVar1 = true;\n    local_c8 = 1;\n    local_98 = \"\\\"\";\n    break;\n  case 7:\n    bVar6 = true;\n    bVar2 = false;\n    uVar18 = 0;\n    local_64 = false;\n    local_90 = 0;\n    bVar20 = false;\n    bVar1 = true;\n    local_c8 = 0;\n    local_98 = (char *)0x0;\n    break;\n  case 8:\n  case 9:\n  case 10:\n    if (param_5 != 10) {\n      local_70 = (char *)gettext_quote(&DAT_00109c07,param_5);\n      local_78 = (char *)gettext_quote(\"\\'\");\n    }\n    uVar18 = 0;\n    if (uVar12 == 0) {\n      cVar11 = *local_70;\n      while (cVar11 != '\\0') {\n        if (uVar18 < param_2) {\n          param_1[uVar18] = cVar11;\n        }\n        uVar18 = uVar18 + 1;\n        cVar11 = local_70[uVar18];\n      }\n    }\n    bVar2 = false;\n    local_c8 = strlen(local_78);\n    local_98 = local_78;\n    bVar6 = true;\n    local_64 = false;\n    local_90 = 0;\n    bVar1 = true;\n    break;\n  default:\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  do {\n    uVar13 = 0;\n    bVar4 = local_64;\nLAB_001053c0:\n    bVar21 = param_4 != uVar13;\n    if (param_4 == 0xffffffffffffffff) {\n      bVar21 = param_3[uVar13] != '\\0';\n    }\n    bVar24 = bVar1;\n    if (bVar21) {\n      bVar23 = (bool)(param_5 != 2 & bVar1);\n      __s1 = (byte *)(param_3 + uVar13);\n      uVar17 = uVar13;\n      bVar3 = bVar2;\n      bVar5 = bVar23;\n      if (!bVar23) {\n        uVar15 = (ulong)*__s1;\n        switch(uVar15) {\n        case 0:\n          if (bVar1) goto switchD_00105c20_caseD_0;\n          bVar5 = false;\n          uVar15 = 0;\n          if ((param_6 & 1) != 0) goto code_r0x00105bbb;\n          goto LAB_001059ab;\n        default:\nswitchD_00105ad0_caseD_1:\n          bVar22 = bVar1;\n          if (sVar8 != 1) {\n            local_48 = (mbstate_t)0x0;\n            if (param_4 == 0xffffffffffffffff) {\n              param_4 = strlen(param_3);\n            }\n            uVar17 = 0;\n            do {\n              uVar19 = uVar13 + uVar17;\n              lVar10 = rpl_mbrtowc(&local_4c,param_3 + uVar19,param_4 - uVar19,&local_48);\n              if (lVar10 == 0) break;\n              if (lVar10 == -1) {\n                bVar21 = false;\n                goto LAB_00105ea8;\n              }\n              if (lVar10 == -2) goto joined_r0x001062ba;\n              if (((param_5 == 2) && (bVar20)) && (lVar10 != 1)) {\n                pcVar16 = param_3 + uVar19 + 1;\n                do {\n                  if (((byte)(*pcVar16 + 0xa5U) < 0x22) &&\n                     ((1L << (*pcVar16 + 0xa5U & 0x3f) & 0x20000002bU) != 0)) {\n                    param_5 = 2;\n                    goto LAB_00105890;\n                  }\n                  pcVar16 = pcVar16 + 1;\n                } while (param_3 + uVar19 + lVar10 != pcVar16);\n              }\n              iVar7 = iswprint(local_4c);\n              if (iVar7 == 0) {\n                bVar21 = false;\n              }\n              uVar17 = uVar17 + lVar10;\n              iVar7 = mbsinit(&local_48);\n            } while (iVar7 == 0);\n            bVar22 = (bool)((bVar21 ^ 1U) & bVar1);\n            goto LAB_00105ea8;\n          }\n          ppuVar9 = __ctype_b_loc();\n          uVar17 = 1;\n          bVar22 = ((*ppuVar9)[uVar15] & 0x4000) == 0;\n          bVar21 = !bVar22;\n          bVar22 = (bool)(bVar22 & bVar1);\n          goto LAB_00105631;\n        case 7:\n          uVar15 = 7;\n          bVar14 = 0x61;\n          break;\n        case 8:\n          uVar15 = 8;\n          bVar14 = 0x62;\n          break;\n        case 9:\n          uVar15 = 9;\n          bVar14 = 0x74;\n          goto LAB_00105b78;\n        case 10:\n          uVar15 = 10;\n          bVar14 = 0x6e;\n          goto LAB_00105b78;\n        case 0xb:\n          uVar15 = 0xb;\n          bVar14 = 0x76;\n          break;\n        case 0xc:\n          uVar15 = 0xc;\n          bVar14 = 0x66;\n          break;\n        case 0xd:\n          uVar15 = 0xd;\n          bVar14 = 0x72;\nLAB_00105b78:\n          bVar23 = (bool)(param_5 == 2 & bVar20);\n          if (bVar23) goto LAB_00105887;\n          break;\n        case 0x20:\n          uVar15 = 0x20;\n          goto LAB_00105874;\n        case 0x21:\n        case 0x22:\n        case 0x24:\n        case 0x26:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x3b:\n        case 0x3c:\n        case 0x3d:\n        case 0x3e:\n        case 0x5b:\n        case 0x5e:\n        case 0x60:\n        case 0x7c:\n          bVar21 = false;\nLAB_00105874:\n          bVar22 = param_5 == 2;\n          bVar23 = bVar21;\n          if ((!bVar20) || (!bVar22)) goto LAB_00105598;\n          goto LAB_00105887;\n        case 0x23:\n        case 0x7e:\nLAB_0010586b:\n          bVar22 = param_5 == 2;\n          if (uVar13 == 0) goto LAB_00105874;\n          goto LAB_00105595;\n        case 0x25:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x2f:\n        case 0x30:\n        case 0x31:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x41:\n        case 0x42:\n        case 0x43:\n        case 0x44:\n        case 0x45:\n        case 0x46:\n        case 0x47:\n        case 0x48:\n        case 0x49:\n        case 0x4a:\n        case 0x4b:\n        case 0x4c:\n        case 0x4d:\n        case 0x4e:\n        case 0x4f:\n        case 0x50:\n        case 0x51:\n        case 0x52:\n        case 0x53:\n        case 0x54:\n        case 0x55:\n        case 0x56:\n        case 0x57:\n        case 0x58:\n        case 0x59:\n        case 0x5a:\n        case 0x5d:\n        case 0x5f:\n        case 0x61:\n        case 0x62:\n        case 99:\n        case 100:\n        case 0x65:\n        case 0x66:\n        case 0x67:\n        case 0x68:\n        case 0x69:\n        case 0x6a:\n        case 0x6b:\n        case 0x6c:\n        case 0x6d:\n        case 0x6e:\n        case 0x6f:\n        case 0x70:\n        case 0x71:\n        case 0x72:\n        case 0x73:\n        case 0x74:\n        case 0x75:\n        case 0x76:\n        case 0x77:\n        case 0x78:\n        case 0x79:\n        case 0x7a:\n          goto switchD_00105ad0_caseD_25;\n        case 0x27:\nswitchD_00105ad0_caseD_27:\n          bVar4 = bVar21;\n          if (param_5 != 2) {\n            bVar22 = false;\n            uVar15 = 0x27;\n            bVar23 = bVar21;\n            goto LAB_00105598;\n          }\n          if (!bVar20) {\n            if ((param_2 == 0) || (uVar13 = 0, uVar15 = param_2, local_90 != 0)) {\n              if (uVar18 < param_2) {\n                param_1[uVar18] = 0x27;\n              }\n              if (uVar18 + 1 < param_2) {\n                param_1[uVar18 + 1] = 0x5c;\n              }\n              uVar13 = param_2;\n              uVar15 = local_90;\n              if (uVar18 + 2 < param_2) {\n                param_1[uVar18 + 2] = 0x27;\n              }\n            }\n            bVar14 = 0x27;\n            uVar18 = uVar18 + 3;\n            param_2 = uVar13;\n            local_90 = uVar15;\n            bVar3 = false;\n            bVar22 = false;\n            goto joined_r0x001055bb;\n          }\n          goto LAB_00105890;\n        case 0x3f:\nswitchD_00105ad0_caseD_3f:\n          if (param_5 != 2) {\n            if ((((param_5 == 5) && ((param_6 & 4) != 0)) && (uVar17 = uVar13 + 2, uVar17 < param_4)\n                ) && (param_3[uVar13 + 1] == '?')) {\n              uVar15 = (ulong)(byte)param_3[uVar17];\n              switch(param_3[uVar17]) {\n              case '!':\n              case '\\'':\n              case '(':\n              case ')':\n              case '-':\n              case '/':\n              case '<':\n              case '=':\n              case '>':\n                goto switchD_0010621e_caseD_21;\n              default:\n                break;\n              }\n            }\n            bVar22 = false;\n            uVar15 = 0x3f;\n            bVar23 = false;\n            goto LAB_00105598;\n          }\n          if (!bVar20) {\n            bVar14 = 0x3f;\n            bVar22 = false;\n            bVar21 = false;\n            goto joined_r0x001055bb;\n          }\n          goto LAB_00105890;\n        case 0x5c:\n          if (param_5 != 2) goto switchD_001054c8_caseD_5c;\n          if (!bVar20) {\nLAB_00105b08:\n            uVar13 = uVar13 + 1;\n            bVar21 = false;\n            bVar14 = 0x5c;\n            goto LAB_00105b20;\n          }\n          goto LAB_00105890;\n        case 0x7b:\n        case 0x7d:\nswitchD_00105ad0_caseD_7b:\n          bVar23 = param_4 != 1;\n          if (param_4 == 0xffffffffffffffff) {\n            bVar23 = param_3[1] != '\\0';\n          }\n          bVar22 = param_5 == 2;\n          if (!bVar23) goto LAB_0010586b;\nLAB_00105595:\n          bVar23 = false;\n          goto LAB_00105598;\n        }\nLAB_001059a0:\n        bVar5 = bVar23;\n        if (!bVar1) {\nLAB_001059ab:\n          bVar14 = (byte)uVar15;\n          bVar23 = false;\n          bVar21 = false;\n          bVar22 = false;\n          if (!bVar20) goto LAB_001055b8;\n          goto LAB_001054e0;\n        }\nLAB_001059e0:\n        bVar21 = false;\n        goto joined_r0x001059f1;\n      }\n      if (local_c8 != 0) {\n        if ((param_4 == 0xffffffffffffffff) && (1 < local_c8)) {\n          param_4 = strlen(param_3);\n        }\n        if ((param_4 < uVar13 + local_c8) || (iVar7 = memcmp(__s1,local_98,local_c8), iVar7 != 0))\n        goto LAB_00105c00;\n        if (!bVar20) {\n          uVar15 = (ulong)*__s1;\n          switch(uVar15) {\n          case 0:\n            goto switchD_001054c8_caseD_0;\n          default:\n            goto switchD_00105ad0_caseD_1;\n          case 7:\n            goto switchD_00105c20_caseD_7;\n          case 8:\n            goto switchD_00105c20_caseD_8;\n          case 9:\n            goto switchD_001054c8_caseD_9;\n          case 10:\n            goto switchD_00105c20_caseD_a;\n          case 0xb:\n            goto switchD_00105c20_caseD_b;\n          case 0xc:\n            goto switchD_00105c20_caseD_c;\n          case 0xd:\n            goto switchD_00105c20_caseD_d;\n          case 0x20:\n            goto LAB_00105c49;\n          case 0x21:\n          case 0x22:\n          case 0x24:\n          case 0x26:\n          case 0x28:\n          case 0x29:\n          case 0x2a:\n          case 0x3b:\n          case 0x3c:\n          case 0x3d:\n          case 0x3e:\n          case 0x5b:\n          case 0x5e:\n          case 0x60:\n          case 0x7c:\n            goto switchD_001054c8_caseD_21;\n          case 0x23:\n          case 0x7e:\n            goto LAB_00105c31;\n          case 0x25:\n          case 0x2b:\n          case 0x2c:\n          case 0x2d:\n          case 0x2e:\n          case 0x2f:\n          case 0x30:\n          case 0x31:\n          case 0x32:\n          case 0x33:\n          case 0x34:\n          case 0x35:\n          case 0x36:\n          case 0x37:\n          case 0x38:\n          case 0x39:\n          case 0x3a:\n          case 0x41:\n          case 0x42:\n          case 0x43:\n          case 0x44:\n          case 0x45:\n          case 0x46:\n          case 0x47:\n          case 0x48:\n          case 0x49:\n          case 0x4a:\n          case 0x4b:\n          case 0x4c:\n          case 0x4d:\n          case 0x4e:\n          case 0x4f:\n          case 0x50:\n          case 0x51:\n          case 0x52:\n          case 0x53:\n          case 0x54:\n          case 0x55:\n          case 0x56:\n          case 0x57:\n          case 0x58:\n          case 0x59:\n          case 0x5a:\n          case 0x5d:\n          case 0x5f:\n          case 0x61:\n          case 0x62:\n          case 99:\n          case 100:\n          case 0x65:\n          case 0x66:\n          case 0x67:\n          case 0x68:\n          case 0x69:\n          case 0x6a:\n          case 0x6b:\n          case 0x6c:\n          case 0x6d:\n          case 0x6e:\n          case 0x6f:\n          case 0x70:\n          case 0x71:\n          case 0x72:\n          case 0x73:\n          case 0x74:\n          case 0x75:\n          case 0x76:\n          case 0x77:\n          case 0x78:\n          case 0x79:\n          case 0x7a:\n            goto LAB_001054d8;\n          case 0x27:\n            goto switchD_00105ad0_caseD_27;\n          case 0x3f:\n            goto switchD_00105ad0_caseD_3f;\n          case 0x5c:\n            goto switchD_001054c8_caseD_5c;\n          case 0x7b:\n          case 0x7d:\n            goto switchD_00105ad0_caseD_7b;\n          }\n        }\n        goto LAB_0010589e;\n      }\nLAB_00105c00:\n      uVar15 = (ulong)*__s1;\n      switch(uVar15) {\n      case 0:\nswitchD_00105c20_caseD_0:\n        if (!bVar20) {\n          bVar5 = false;\nswitchD_001054c8_caseD_0:\n          bVar24 = param_5 == 2;\n          bVar3 = (bool)((bVar2 ^ 1U) & bVar24);\n          if (bVar3) {\n            if (uVar18 < param_2) {\n              param_1[uVar18] = 0x27;\n            }\n            if (uVar18 + 1 < param_2) {\n              param_1[uVar18 + 1] = 0x24;\n            }\n            if (uVar18 + 2 < param_2) {\n              param_1[uVar18 + 2] = 0x27;\n            }\n            uVar15 = uVar18 + 3;\n            bVar2 = bVar3;\n            if (param_2 <= uVar18 + 3) {\n              bVar14 = 0x30;\n              uVar18 = uVar18 + 4;\n              bVar22 = bVar3;\n              bVar21 = false;\n              goto joined_r0x001055bb;\n            }\nLAB_0010605b:\n            param_1[uVar15] = 0x5c;\n            uVar18 = uVar15;\n          }\n          else {\n            uVar15 = uVar18;\n            if (uVar18 < param_2) goto LAB_0010605b;\n          }\n          uVar19 = uVar18 + 1;\n          bVar22 = bVar21;\n          if (param_5 != 2) {\n            uVar15 = 0x30;\n            if ((uVar13 + 1 < param_4) && ((byte)(param_3[uVar13 + 1] - 0x30U) < 10)) {\n              if (uVar19 < param_2) {\n                param_1[uVar19] = 0x30;\n              }\n              if (uVar18 + 2 < param_2) {\n                param_1[uVar18 + 2] = 0x30;\n              }\n              uVar19 = uVar18 + 3;\n              uVar15 = 0x30;\n            }\n            goto LAB_00106098;\n          }\n          bVar14 = 0x30;\n          uVar18 = uVar19;\n          bVar3 = bVar2;\n          bVar21 = false;\n          goto joined_r0x001055bb;\n        }\n        bVar24 = param_5 == 2;\n        goto LAB_00105890;\n      default:\n        bVar23 = false;\n        goto switchD_00105ad0_caseD_1;\n      case 7:\nswitchD_00105c20_caseD_7:\n        bVar14 = 0x61;\n        break;\n      case 8:\nswitchD_00105c20_caseD_8:\n        bVar14 = 0x62;\n        break;\n      case 9:\n        bVar23 = false;\nswitchD_001054c8_caseD_9:\n        uVar15 = 9;\n        bVar14 = 0x74;\n        goto LAB_001059a0;\n      case 10:\nswitchD_00105c20_caseD_a:\n        bVar14 = 0x6e;\n        goto LAB_001059e0;\n      case 0xb:\nswitchD_00105c20_caseD_b:\n        bVar14 = 0x76;\n        goto LAB_001059e0;\n      case 0xc:\nswitchD_00105c20_caseD_c:\n        bVar14 = 0x66;\n        break;\n      case 0xd:\nswitchD_00105c20_caseD_d:\n        bVar14 = 0x72;\n        goto LAB_001059e0;\n      case 0x20:\n        bVar5 = false;\nLAB_00105c49:\n        uVar15 = 0x20;\n        goto LAB_001054d8;\n      case 0x21:\n      case 0x22:\n      case 0x24:\n      case 0x26:\n      case 0x28:\n      case 0x29:\n      case 0x2a:\n      case 0x3b:\n      case 0x3c:\n      case 0x3d:\n      case 0x3e:\n      case 0x5b:\n      case 0x5e:\n      case 0x60:\n      case 0x7c:\n        bVar5 = false;\nswitchD_001054c8_caseD_21:\n        bVar22 = false;\n        goto LAB_00105595;\n      case 0x23:\n      case 0x7e:\n        bVar5 = false;\nLAB_00105c31:\n        if (uVar13 == 0) {\n          bVar22 = false;\n          goto LAB_00105598;\n        }\n        bVar23 = false;\n        bVar22 = false;\n        goto LAB_001054e0;\n      case 0x25:\n      case 0x2b:\n      case 0x2c:\n      case 0x2d:\n      case 0x2e:\n      case 0x2f:\n      case 0x30:\n      case 0x31:\n      case 0x32:\n      case 0x33:\n      case 0x34:\n      case 0x35:\n      case 0x36:\n      case 0x37:\n      case 0x38:\n      case 0x39:\n      case 0x3a:\n      case 0x41:\n      case 0x42:\n      case 0x43:\n      case 0x44:\n      case 0x45:\n      case 0x46:\n      case 0x47:\n      case 0x48:\n      case 0x49:\n      case 0x4a:\n      case 0x4b:\n      case 0x4c:\n      case 0x4d:\n      case 0x4e:\n      case 0x4f:\n      case 0x50:\n      case 0x51:\n      case 0x52:\n      case 0x53:\n      case 0x54:\n      case 0x55:\n      case 0x56:\n      case 0x57:\n      case 0x58:\n      case 0x59:\n      case 0x5a:\n      case 0x5d:\n      case 0x5f:\n      case 0x61:\n      case 0x62:\n      case 99:\n      case 100:\n      case 0x65:\n      case 0x66:\n      case 0x67:\n      case 0x68:\n      case 0x69:\n      case 0x6a:\n      case 0x6b:\n      case 0x6c:\n      case 0x6d:\n      case 0x6e:\n      case 0x6f:\n      case 0x70:\n      case 0x71:\n      case 0x72:\n      case 0x73:\n      case 0x74:\n      case 0x75:\n      case 0x76:\n      case 0x77:\n      case 0x78:\n      case 0x79:\n      case 0x7a:\n        bVar5 = false;\nLAB_001054d8:\n        bVar22 = false;\n        goto LAB_001054e0;\n      case 0x27:\n        bVar5 = false;\n        goto switchD_00105ad0_caseD_27;\n      case 0x3f:\n        bVar5 = false;\n        goto switchD_00105ad0_caseD_3f;\n      case 0x5c:\n        bVar23 = false;\nswitchD_001054c8_caseD_5c:\n        if (((bool)(bVar1 & bVar20)) && (local_c8 != 0)) goto LAB_00105b08;\n        uVar15 = 0x5c;\n        bVar14 = 0x5c;\n        goto LAB_001059a0;\n      case 0x7b:\n      case 0x7d:\n        bVar5 = false;\n        goto switchD_00105ad0_caseD_7b;\n      }\n      if (bVar20) goto LAB_00105a00;\n      bVar21 = false;\n      goto LAB_00105556;\n    }\n    if ((uVar18 == 0) && ((bool)(bVar20 & param_5 == 2))) {\nLAB_00105887:\n      param_5 = 2;\nLAB_00105890:\n      if (bVar24) {\n        param_5 = 4;\n      }\nLAB_0010589e:\n      uVar13 = quotearg_buffer_restyled\n                         (param_1,param_2,param_3,param_4,param_5,param_6 & 0xfffffffd,0,local_70,\n                          local_78);\n      goto LAB_001058d8;\n    }\n    bVar21 = (bool)(param_5 == 2 & (bVar20 ^ 1U));\n    bVar20 = (bool)(bVar20 ^ 1U);\n    if ((!bVar21) || (bVar20 = bVar21, !bVar4)) {\nLAB_00106325:\n      uVar13 = uVar18;\n      if (((local_98 != (char *)0x0) && (bVar20)) && (cVar11 = *local_98, cVar11 != '\\0')) {\n        do {\n          if (uVar13 < param_2) {\n            param_1[uVar13] = cVar11;\n          }\n          uVar13 = uVar13 + 1;\n          cVar11 = local_98[uVar13 - uVar18];\n        } while (cVar11 != '\\0');\n      }\n      if (uVar13 < param_2) {\n        param_1[uVar13] = 0;\n      }\nLAB_001058d8:\n      if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n        return uVar13;\n      }\n                    /* WARNING: Subroutine does not return */\n      __stack_chk_fail();\n    }\n    if (bVar6) {\n      uVar13 = quotearg_buffer_restyled\n                         (param_1,local_90,param_3,param_4,5,param_6,param_7,local_70,local_78);\n      goto LAB_001058d8;\n    }\n    local_64 = param_2 == 0 && local_90 != 0;\n    uVar13 = local_90;\n    bVar20 = bVar4;\n    if (param_2 != 0 || local_90 == 0) goto LAB_00106325;\nLAB_00105cb6:\n    *param_1 = 0x27;\n    param_2 = local_90;\n    local_90 = uVar13;\nLAB_00105719:\n    bVar20 = false;\n    uVar18 = 1;\n    param_5 = 2;\n    local_c8 = 1;\n    local_98 = \"\\'\";\n  } while( true );\ncode_r0x00105bbb:\n  uVar13 = uVar13 + 1;\n  goto LAB_001053c0;\nswitchD_0010621e_caseD_21:\n  if (!bVar20) {\n    if (uVar18 < param_2) {\n      param_1[uVar18] = 0x3f;\n    }\n    if (uVar18 + 1 < param_2) {\n      param_1[uVar18 + 1] = 0x22;\n    }\n    if (uVar18 + 2 < param_2) {\n      param_1[uVar18 + 2] = 0x22;\n    }\n    if (uVar18 + 3 < param_2) {\n      param_1[uVar18 + 3] = 0x3f;\n    }\n    uVar19 = uVar18 + 4;\n    bVar24 = false;\n    bVar22 = false;\nLAB_00106098:\n    bVar14 = (byte)uVar15;\n    bVar23 = false;\n    bVar21 = false;\n    uVar13 = uVar17;\n    uVar18 = uVar19;\n    bVar3 = bVar2;\n    if ((bool)(bVar1 ^ 1U | bVar24)) goto joined_r0x001055bb;\n    goto LAB_001054e0;\n  }\n  goto LAB_0010589e;\njoined_r0x001062ba:\n  while ((uVar19 < param_4 && (param_3[uVar19] != '\\0'))) {\n    uVar17 = uVar17 + 1;\n    uVar19 = uVar13 + uVar17;\n  }\n  bVar21 = false;\nLAB_00105ea8:\n  if (1 < uVar17) {\nLAB_00105eb2:\n    bVar24 = false;\n    uVar17 = uVar17 + uVar13;\n    uVar19 = uVar13;\n    do {\n      bVar14 = (byte)uVar15;\n      if (bVar22) {\n        bVar24 = param_5 == 2;\n        if (bVar20) goto LAB_00105890;\n        bVar24 = (bool)(bVar24 & (bVar3 ^ 1U));\n        if (bVar24) {\n          if (uVar18 < param_2) {\n            param_1[uVar18] = 0x27;\n          }\n          if (uVar18 + 1 < param_2) {\n            param_1[uVar18 + 1] = 0x24;\n          }\n          if (uVar18 + 2 < param_2) {\n            param_1[uVar18 + 2] = 0x27;\n          }\n          uVar18 = uVar18 + 3;\n          bVar3 = bVar24;\n        }\n        if (uVar18 < param_2) {\n          param_1[uVar18] = 0x5c;\n        }\n        if (uVar18 + 1 < param_2) {\n          param_1[uVar18 + 1] = (char)(uVar15 >> 6) + '0';\n        }\n        if (uVar18 + 2 < param_2) {\n          param_1[uVar18 + 2] = ((byte)(uVar15 >> 3) & 7) + 0x30;\n        }\n        uVar13 = uVar19 + 1;\n        uVar18 = uVar18 + 3;\n        bVar14 = (bVar14 & 7) + 0x30;\n        bVar24 = bVar22;\n        if (uVar17 <= uVar13) goto LAB_00105568;\n      }\n      else {\n        bVar2 = (bool)((bVar24 ^ 1U) & bVar3);\n        if (bVar23) {\n          if (uVar18 < param_2) {\n            param_1[uVar18] = 0x5c;\n          }\n          uVar18 = uVar18 + 1;\n        }\n        uVar13 = uVar19 + 1;\n        if (uVar17 <= uVar13) goto LAB_00105b20;\n        if (bVar2) {\n          if (uVar18 < param_2) {\n            param_1[uVar18] = 0x27;\n          }\n          if (uVar18 + 1 < param_2) {\n            param_1[uVar18 + 1] = 0x27;\n          }\n          uVar18 = uVar18 + 2;\n          bVar23 = false;\n          bVar3 = false;\n        }\n        else {\n          bVar23 = false;\n        }\n      }\n      uVar19 = uVar19 + 1;\n      if (uVar18 < param_2) {\n        param_1[uVar18] = bVar14;\n      }\n      uVar15 = (ulong)(byte)param_3[uVar19];\n      uVar18 = uVar18 + 1;\n    } while( true );\n  }\nLAB_00105631:\n  bVar5 = bVar23;\n  if (bVar22) {\n    bVar21 = false;\n    bVar22 = bVar1;\n    goto LAB_00105eb2;\n  }\nswitchD_00105ad0_caseD_25:\n  bVar22 = param_5 == 2;\n  bVar23 = bVar21;\nLAB_00105598:\n  bVar14 = (byte)uVar15;\n  bVar22 = (bool)(bVar22 | bVar1 ^ 1U);\n  if ((!bVar22) || (bVar22 = false, bVar21 = bVar23, bVar20)) {\nLAB_001054e0:\n    bVar14 = (byte)uVar15;\n    uVar17 = uVar13;\n    bVar3 = bVar2;\n    bVar21 = bVar23;\n    if ((param_7 == 0) || ((*(uint *)(param_7 + (uVar15 >> 5) * 4) >> (bVar14 & 0x1f) & 1) == 0))\n    goto joined_r0x001055bb;\n  }\n  else {\nLAB_001055b8:\n    uVar17 = uVar13;\n    bVar22 = false;\njoined_r0x001055bb:\n    uVar13 = uVar17;\n    bVar2 = bVar3;\n    if (!bVar5) {\n      uVar13 = uVar17 + 1;\n      bVar2 = (bool)((bVar22 ^ 1U) & bVar3);\nLAB_00105b20:\n      if (bVar2) {\n        if (uVar18 < param_2) {\n          param_1[uVar18] = 0x27;\n        }\n        if (uVar18 + 1 < param_2) {\n          param_1[uVar18 + 1] = 0x27;\n        }\n        uVar18 = uVar18 + 2;\n        bVar3 = false;\n      }\n      goto LAB_00105568;\n    }\n  }\njoined_r0x001059f1:\n  if (bVar20) {\nLAB_00105a00:\n    bVar24 = (bool)(bVar1 & param_5 == 2);\n    goto LAB_00105890;\n  }\n  bVar24 = (bool)((bVar2 ^ 1U) & param_5 == 2);\n  if (bVar24) {\n    if (uVar18 < param_2) {\n      param_1[uVar18] = 0x27;\n    }\n    if (uVar18 + 1 < param_2) {\n      param_1[uVar18 + 1] = 0x24;\n    }\n    if (uVar18 + 2 < param_2) {\n      param_1[uVar18 + 2] = 0x27;\n    }\n    uVar18 = uVar18 + 3;\n    bVar2 = bVar24;\n  }\nLAB_00105556:\n  if (uVar18 < param_2) {\n    param_1[uVar18] = 0x5c;\n  }\n  uVar18 = uVar18 + 1;\n  uVar13 = uVar13 + 1;\n  bVar3 = bVar2;\nLAB_00105568:\n  bVar2 = bVar3;\n  if (uVar18 < param_2) {\n    param_1[uVar18] = bVar14;\n  }\n  uVar18 = uVar18 + 1;\n  if (!bVar21) {\n    bVar6 = false;\n  }\n  goto LAB_001053c0;\n}\n\n", 
    "0010f0b8": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\n__off_t lseek(int __fd,__off_t __offset,int __whence)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* lseek@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001024e0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t mbrtowc(wchar_t *__pwc,char *__s,size_t __n,mbstate_t *__p)\n\n{\n  size_t sVar1;\n  \n  sVar1 = (*(code *)PTR_mbrtowc_0010deb8)();\n  return sVar1;\n}\n\n", 
    "00102f60": "\nlong mbs_offset_to_chars(long param_1,ulong param_2)\n\n{\n  long lVar1;\n  long in_FS_OFFSET;\n  undefined local_78 [4];\n  undefined8 local_74;\n  undefined local_6c;\n  long local_68;\n  long local_60;\n  char local_58;\n  int local_54;\n  long local_30;\n  \n  lVar1 = 0;\n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  local_78[0] = 0;\n  local_74 = 0;\n  local_68 = param_1;\n  while( true ) {\n    local_6c = 0;\n    mbuiter_multi_next(local_78);\n    if ((local_58 != '\\0') && (local_54 == 0)) break;\n    if (param_2 <= (ulong)(local_68 - param_1)) break;\n    local_68 = local_68 + local_60;\n    lVar1 = lVar1 + 1;\n  }\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return lVar1;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "001023c0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nintmax_t strtoimax(char *__nptr,char **__endptr,int __base)\n\n{\n  intmax_t iVar1;\n  \n  iVar1 = (*(code *)PTR_strtoimax_0010de28)();\n  return iVar1;\n}\n\n", 
    "00103f30": "\nvoid emit_ancillary_info_constprop_0(void)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  char *pcVar3;\n  long lVar4;\n  undefined **ppuVar5;\n  byte *pbVar6;\n  byte *pbVar7;\n  undefined1 *puVar8;\n  long in_FS_OFFSET;\n  bool bVar9;\n  bool bVar10;\n  undefined *local_98;\n  char *local_90;\n  char *local_88;\n  char *local_80 [5];\n  char *local_58;\n  char *local_50;\n  char *local_48;\n  char *local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  long local_20;\n  \n  pbVar7 = (byte *)0x109101;\n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_80[3] = \"sha256sum\";\n  local_98 = &DAT_00109087;\n  local_90 = \"test invocation\";\n  local_80[0] = \"Multi-call invocation\";\n  local_80[1] = \"sha224sum\";\n  local_58 = \"sha384sum\";\n  local_48 = \"sha512sum\";\n  local_88 = \"coreutils\";\n  local_80[2] = \"sha2 utilities\";\n  local_80[4] = \"sha2 utilities\";\n  local_50 = \"sha2 utilities\";\n  local_40 = \"sha2 utilities\";\n  local_38 = 0;\n  local_30 = 0;\n  ppuVar5 = &local_98;\n  while( true ) {\n    bVar9 = false;\n    bVar10 = pbVar7 == (byte *)0x0;\n    if (bVar10) break;\n    lVar4 = 5;\n    pbVar6 = &DAT_00109082;\n    do {\n      if (lVar4 == 0) break;\n      lVar4 = lVar4 + -1;\n      bVar9 = *pbVar6 < *pbVar7;\n      bVar10 = *pbVar6 == *pbVar7;\n      pbVar6 = pbVar6 + 1;\n      pbVar7 = pbVar7 + 1;\n    } while (bVar10);\n    if ((!bVar9 && !bVar10) == bVar9) break;\n    pbVar7 = *(byte **)((long)ppuVar5 + 0x20);\n    ppuVar5 = (undefined **)((long)ppuVar5 + 0x10);\n  }\n  puVar8 = *(undefined1 **)((long)ppuVar5 + 0x18);\n  if (puVar8 == (undefined1 *)0x0) {\n    uVar2 = dcgettext(0,\"\\n%s online help: <%s>\\n\",5);\n    __printf_chk(1,uVar2,\"GNU coreutils\",\"https://www.gnu.org/software/coreutils/\");\n    pcVar3 = setlocale(5,(char *)0x0);\n    if (pcVar3 != (char *)0x0) {\n      iVar1 = strncmp(pcVar3,\"en_\",3);\n      if (iVar1 != 0) {\n        puVar8 = &DAT_00109082;\n        goto LAB_0010414e;\n      }\n    }\n    uVar2 = dcgettext(0,\"Full documentation at: <%s%s>\\n\",5);\n    puVar8 = &DAT_00109082;\n    __printf_chk(1,uVar2,\"https://www.gnu.org/software/coreutils/\",&DAT_00109082);\n    pcVar3 = \" invocation\";\n  }\n  else {\n    uVar2 = dcgettext(0,\"\\n%s online help: <%s>\\n\",5);\n    __printf_chk(1,uVar2,\"GNU coreutils\",\"https://www.gnu.org/software/coreutils/\");\n    pcVar3 = setlocale(5,(char *)0x0);\n    if (pcVar3 != (char *)0x0) {\n      iVar1 = strncmp(pcVar3,\"en_\",3);\n      if (iVar1 != 0) {\nLAB_0010414e:\n        uVar2 = dcgettext(0,\"Report %s translation bugs to <https://translationproject.org/team/>\\n\"\n                          ,5);\n        __printf_chk(1,uVar2,&DAT_00109082);\n      }\n    }\n    uVar2 = dcgettext(0,\"Full documentation at: <%s%s>\\n\",5);\n    pcVar3 = \" invocation\";\n    __printf_chk(1,uVar2,\"https://www.gnu.org/software/coreutils/\",&DAT_00109082);\n    if (puVar8 != &DAT_00109082) {\n      pcVar3 = \"\";\n    }\n  }\n  uVar2 = dcgettext(0,\"or available locally via: info \\'(coreutils) %s%s\\'\\n\",5);\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    __printf_chk(1,uVar2,puVar8,pcVar3);\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "001069c0": "\nvoid quotearg_n_style_mem\n               (undefined4 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  long in_FS_OFFSET;\n  undefined auStack_68 [56];\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  quoting_options_from_style(auStack_68);\n  quotearg_n_options(param_1,param_3,param_4,auStack_68);\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "0010f0a8": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * strchr(char *__s,int __c)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strchr@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00106b20": "\nvoid quotearg_colon_mem(undefined8 param_1,undefined8 param_2)\n\n{\n  quotearg_char_mem(param_1,param_2,0x3a);\n  return;\n}\n\n", 
    "00107f70": "\nulong c_isxdigit(int param_1)\n\n{\n  ulong uVar1;\n  \n  if (param_1 - 0x30U < 0x37) {\n    uVar1 = 1L << ((byte)(param_1 - 0x30U) & 0x3f);\n    return uVar1 & 0xffffffffffffff00 | (ulong)((uVar1 & 0x7e0000007e03ff) != 0);\n  }\n  return 0;\n}\n\n", 
    "0010f120": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint putchar_unlocked(int __c)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* putchar_unlocked@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010f000": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid free(void *__ptr)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* free@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00104fa0": "\nundefined8\nstrcaseeq1(long param_1,undefined8 param_2,byte param_3,char param_4,char param_5,char param_6,\n          char param_7)\n\n{\n  char cVar1;\n  byte bVar2;\n  undefined8 uVar3;\n  \n  cVar1 = c_isupper((int)(char)param_3);\n  bVar2 = *(byte *)(param_1 + 1);\n  if (cVar1 != '\\0') {\n    bVar2 = bVar2 & 0xdf;\n  }\n  if (param_3 != bVar2) {\n    return 0;\n  }\n  if (param_3 == 0) {\n    return 1;\n  }\n  uVar3 = strcaseeq2(param_1,param_2,(int)param_4,(int)param_5,(int)param_6,(int)param_7);\n  return uVar3;\n}\n\n", 
    "00106910": "\nvoid quotearg_n(undefined8 param_1,undefined8 param_2)\n\n{\n  quotearg_n_options(param_1,param_2,0xffffffffffffffff,default_quoting_options);\n  return;\n}\n\n", 
    "00102750": "\nundefined main(uint param_1,undefined8 *param_2)\n\n{\n  char cVar1;\n  undefined uVar2;\n  int iVar3;\n  undefined8 uVar4;\n  undefined8 uVar5;\n  \n  set_program_name(*param_2);\n  setlocale(6,\"\");\n  bindtextdomain(\"coreutils\",\"/usr/local/share/locale\");\n  textdomain(\"coreutils\");\n  initialize_exit_failure_constprop_0();\n  atexit(close_stdout);\n  parse_long_options(param_1,param_2,&DAT_00109082,\"GNU coreutils\",&DAT_00109127,usage,\"Mike Parker\"\n                     ,\"James Youngman\",\"Paul Eggert\",0);\n  if (1 < param_1) {\n    iVar3 = strcmp((char *)param_2[1],\"--\");\n    if ((iVar3 != 0) || (param_2 = param_2 + 1, param_1 != 2)) {\n      args = param_2 + 1;\n      uVar4 = eval(1);\n      cVar1 = nomoreargs();\n      if (cVar1 == '\\0') {\n        uVar4 = quotearg_n_style(0,8,*args);\n        uVar5 = dcgettext(0,\"syntax error: unexpected argument %s\",5);\n                    /* WARNING: Subroutine does not return */\n        error(2,0,uVar5,uVar4);\n      }\n      printv(uVar4);\n      uVar2 = null(uVar4);\n      return uVar2;\n    }\n  }\n  uVar4 = dcgettext(0,\"missing operand\",5);\n                    /* WARNING: Subroutine does not return */\n  error(0,0,uVar4);\n}\n\n", 
    "00106430": "\nundefined1 *\nquotearg_n_options(int param_1,undefined8 param_2,undefined8 param_3,undefined4 *param_4)\n\n{\n  long lVar1;\n  int iVar2;\n  uint uVar3;\n  undefined4 uVar4;\n  ulong uVar5;\n  int *piVar6;\n  undefined1 (*pauVar7) [16];\n  ulong uVar8;\n  undefined1 *__ptr;\n  \n  piVar6 = __errno_location();\n  iVar2 = *piVar6;\n  if (param_1 < 0) {\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  pauVar7 = (undefined1 (*) [16])slotvec;\n  if (nslots <= param_1) {\n    if (param_1 == 0x7fffffff) {\n                    /* WARNING: Subroutine does not return */\n      xalloc_die();\n    }\n    if (slotvec == slotvec0) {\n      pauVar7 = (undefined1 (*) [16])xrealloc(0);\n      slotvec = (undefined *)pauVar7;\n      *pauVar7 = slotvec0;\n    }\n    else {\n      pauVar7 = (undefined1 (*) [16])xrealloc(slotvec);\n      slotvec = (undefined *)pauVar7;\n    }\n    memset(pauVar7[nslots],0,(long)((param_1 + 1) - nslots) << 4);\n    nslots = param_1 + 1;\n  }\n  uVar3 = param_4[1];\n  pauVar7 = pauVar7[param_1];\n  uVar5 = *(ulong *)*pauVar7;\n  __ptr = *(undefined1 **)(*pauVar7 + 8);\n  uVar8 = quotearg_buffer_restyled\n                    (__ptr,uVar5,param_2,param_3,*param_4,uVar3 | 1,param_4 + 2,\n                     *(undefined8 *)(param_4 + 10),*(undefined8 *)(param_4 + 0xc));\n  if (uVar5 <= uVar8) {\n    lVar1 = uVar8 + 1;\n    *(long *)*pauVar7 = lVar1;\n    if (__ptr != slot0) {\n      free(__ptr);\n    }\n    __ptr = (undefined1 *)xcharalloc(lVar1);\n    uVar4 = *param_4;\n    *(undefined1 **)(*pauVar7 + 8) = __ptr;\n    quotearg_buffer_restyled\n              (__ptr,lVar1,param_2,param_3,uVar4,uVar3 | 1,param_4 + 2,*(undefined8 *)(param_4 + 10)\n               ,*(undefined8 *)(param_4 + 0xc));\n  }\n  *piVar6 = iVar2;\n  return __ptr;\n}\n\n", 
    "00106ca0": "\nvoid quotearg_custom_mem(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4\n                        )\n\n{\n  quotearg_n_custom_mem(0,param_1,param_2,param_3,param_4);\n  return;\n}\n\n", 
    "00107eb0": "\nbool c_isdigit(int param_1)\n\n{\n  return param_1 - 0x30U < 10;\n}\n\n", 
    "00104ac0": "\nint * quoting_options_from_style(int *param_1,int param_2)\n\n{\n  if (param_2 != 10) {\n    *param_1 = param_2;\n    param_1[1] = 0;\n    *(undefined8 *)(param_1 + 2) = 0;\n    *(undefined8 *)(param_1 + 4) = 0;\n    *(undefined8 *)(param_1 + 6) = 0;\n    *(undefined8 *)(param_1 + 8) = 0;\n    *(undefined8 *)(param_1 + 10) = 0;\n    *(undefined8 *)(param_1 + 0xc) = 0;\n    return param_1;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "00107880": "\nvoid x2realloc(undefined8 param_1,undefined8 param_2)\n\n{\n  x2nrealloc(param_1,param_2,1);\n  return;\n}\n\n", 
    "00103af0": "\nundefined8 eval6(char param_1)\n\n{\n  char cVar1;\n  long lVar2;\n  long lVar3;\n  long lVar4;\n  undefined8 uVar5;\n  undefined8 uVar6;\n  void *__ptr;\n  \n  cVar1 = nextarg(&DAT_00109007);\n  if (cVar1 != '\\0') {\n    require_more_args();\n    uVar5 = *args;\n    args = args + 1;\n    uVar5 = str_value(uVar5);\n    return uVar5;\n  }\n  cVar1 = nextarg(\"length\");\n  if (cVar1 == '\\0') {\n    cVar1 = nextarg(\"match\");\n    if (cVar1 == '\\0') {\n      cVar1 = nextarg(\"index\");\n      if (cVar1 == '\\0') {\n        cVar1 = nextarg(\"substr\");\n        if (cVar1 != '\\0') {\n          lVar2 = eval6();\n          lVar3 = eval6(param_1);\n          lVar4 = eval6(param_1);\n          tostring(lVar2);\n          cVar1 = toarith(lVar3);\n          if ((cVar1 == '\\0') || (cVar1 = toarith(lVar4), cVar1 == '\\0')) {\n            uVar5 = str_value(\"\");\n          }\n          else {\n            uVar5 = getsize_isra_0(*(undefined8 *)(lVar3 + 8));\n            getsize_isra_0(*(undefined8 *)(lVar4 + 8),uVar5);\n            __ptr = (void *)mbs_logical_substr(*(undefined8 *)(lVar2 + 8));\n            uVar5 = str_value(__ptr);\n            free(__ptr);\n          }\n          freev(lVar2);\n          freev(lVar3);\n          freev(lVar4);\n          return uVar5;\n        }\n        uVar5 = eval7(param_1);\n        return uVar5;\n      }\n      lVar3 = eval6(param_1);\n      lVar2 = eval6(param_1);\n      tostring(lVar3);\n      tostring(lVar2);\n      uVar5 = mbs_logical_cspn(*(undefined8 *)(lVar3 + 8),*(undefined8 *)(lVar2 + 8));\n      uVar5 = int_value(uVar5);\n      freev(lVar3);\n    }\n    else {\n      uVar6 = eval6(param_1);\n      lVar2 = eval6(param_1);\n      uVar5 = uVar6;\n      if (param_1 != '\\0') {\n        uVar5 = docolon(uVar6,lVar2);\n        freev(uVar6);\n      }\n    }\n    freev(lVar2);\n    return uVar5;\n  }\n  lVar2 = eval6(param_1);\n  tostring(lVar2);\n  uVar5 = mbslen(*(undefined8 *)(lVar2 + 8));\n  uVar5 = int_value(uVar5);\n  freev(lVar2);\n  return uVar5;\n}\n\n", 
    "0010273e": "\nvoid quotearg_n_options_cold(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "001025b0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * memcpy(void *__dest,void *__src,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = (void *)(*(code *)PTR_memcpy_0010df20)();\n  return pvVar1;\n}\n\n", 
    "0010f1a0": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t fwrite(void *__ptr,size_t __size,size_t __n,FILE *__s)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fwrite@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00108170": "\nvoid mb_copy(void **param_1,void **param_2)\n\n{\n  char cVar1;\n  void **__src;\n  void *pvVar2;\n  void *__n;\n  \n  __src = (void **)*param_2;\n  __n = param_2[1];\n  if (__src == param_2 + 3) {\n    pvVar2 = memcpy(param_1 + 3,__src,(size_t)__n);\n    __n = param_2[1];\n    *param_1 = pvVar2;\n  }\n  else {\n    *param_1 = __src;\n  }\n  cVar1 = *(char *)(param_2 + 2);\n  param_1[1] = __n;\n  *(char *)(param_1 + 2) = cVar1;\n  if (cVar1 != '\\0') {\n    *(undefined4 *)((long)param_1 + 0x14) = *(undefined4 *)((long)param_2 + 0x14);\n  }\n  return;\n}\n\n", 
    "001026d0": "\nvoid __fprintf_chk(void)\n\n{\n  (*(code *)PTR___fprintf_chk_0010dfb0)();\n  return;\n}\n\n", 
    "00102748": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid version_etc_arn_cold(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "00104b30": "\nundefined8 strcaseeq8(long param_1,undefined8 param_2,byte param_3)\n\n{\n  char cVar1;\n  byte bVar2;\n  undefined8 uVar3;\n  \n  cVar1 = c_isupper((int)(char)param_3);\n  bVar2 = *(byte *)(param_1 + 8);\n  if (cVar1 != '\\0') {\n    bVar2 = bVar2 & 0xdf;\n  }\n  if (param_3 != bVar2) {\n    return 0;\n  }\n  if (param_3 == 0) {\n    return 1;\n  }\n  uVar3 = strcaseeq9(param_1,param_2);\n  return uVar3;\n}\n\n", 
    "001041d0": "\nvoid usage(int param_1)\n\n{\n  FILE *pFVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  char *pcVar4;\n  \n  uVar2 = program_name;\n  if (param_1 == 0) {\n    uVar3 = dcgettext(0,\"Usage: %s EXPRESSION\\n  or:  %s OPTION\\n\",5);\n    __printf_chk(1,uVar3,uVar2,uVar2);\n    putchar_unlocked(10);\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\"      --help     display this help and exit\\n\",5);\n    fputs_unlocked(pcVar4,pFVar1);\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\"      --version  output version information and exit\\n\",5);\n    fputs_unlocked(pcVar4,pFVar1);\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\n                               \"\\nPrint the value of EXPRESSION to standard output.  A blank line below\\nseparates increasing precedence groups.  EXPRESSION may be:\\n\\n  ARG1 | ARG2       ARG1 if it is neither null nor 0, otherwise ARG2\\n\\n  ARG1 & ARG2       ARG1 if neither argument is null or 0, otherwise 0\\n\"\n                               ,5);\n    fputs_unlocked(pcVar4,pFVar1);\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\n                               \"\\n  ARG1 < ARG2       ARG1 is less than ARG2\\n  ARG1 <= ARG2      ARG1 is less than or equal to ARG2\\n  ARG1 = ARG2       ARG1 is equal to ARG2\\n  ARG1 != ARG2      ARG1 is unequal to ARG2\\n  ARG1 >= ARG2      ARG1 is greater than or equal to ARG2\\n  ARG1 > ARG2       ARG1 is greater than ARG2\\n\"\n                               ,5);\n    fputs_unlocked(pcVar4,pFVar1);\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\n                               \"\\n  ARG1 + ARG2       arithmetic sum of ARG1 and ARG2\\n  ARG1 - ARG2       arithmetic difference of ARG1 and ARG2\\n\"\n                               ,5);\n    fputs_unlocked(pcVar4,pFVar1);\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\n                               \"\\n  ARG1 * ARG2       arithmetic product of ARG1 and ARG2\\n  ARG1 / ARG2       arithmetic quotient of ARG1 divided by ARG2\\n  ARG1 % ARG2       arithmetic remainder of ARG1 divided by ARG2\\n\"\n                               ,5);\n    fputs_unlocked(pcVar4,pFVar1);\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\n                               \"\\n  STRING : REGEXP   anchored pattern match of REGEXP in STRING\\n\\n  match STRING REGEXP        same as STRING : REGEXP\\n  substr STRING POS LENGTH   substring of STRING, POS counted from 1\\n  index STRING CHARS         index in STRING where any CHARS is found, or 0\\n  length STRING              length of STRING\\n\"\n                               ,5);\n    fputs_unlocked(pcVar4,pFVar1);\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\n                               \"  + TOKEN                    interpret TOKEN as a string, even if it is a\\n                               keyword like \\'match\\' or an operator like \\'/\\'\\n\\n  ( EXPRESSION )             value of EXPRESSION\\n\"\n                               ,5);\n    fputs_unlocked(pcVar4,pFVar1);\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\n                               \"\\nBeware that many operators need to be escaped or quoted for shells.\\nComparisons are arithmetic if both ARGs are numbers, else lexicographical.\\nPattern matches return the string matched between \\\\( and \\\\) or null; if\\n\\\\( and \\\\) are not used, they return the number of characters matched or 0.\\n\"\n                               ,5);\n    fputs_unlocked(pcVar4,pFVar1);\n    pFVar1 = stdout;\n    pcVar4 = (char *)dcgettext(0,\n                               \"\\nExit status is 0 if EXPRESSION is neither null nor 0, 1 if EXPRESSION is null\\nor 0, 2 if EXPRESSION is syntactically invalid, and 3 if an error occurred.\\n\"\n                               ,5);\n    fputs_unlocked(pcVar4,pFVar1);\n    emit_ancillary_info_constprop_0();\n  }\n  else {\n    uVar3 = dcgettext(0,\"Try \\'%s --help\\' for more information.\\n\",5);\n    __fprintf_chk(stderr,1,uVar3,uVar2);\n  }\n                    /* WARNING: Subroutine does not return */\n  exit(param_1);\n}\n\n", 
    "00102620": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint strcoll(char *__s1,char *__s2)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_strcoll_0010df58)();\n  return iVar1;\n}\n\n", 
    "00102500": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * strrchr(char *__s,int __c)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_strrchr_0010dec8)();\n  return pcVar1;\n}\n\n", 
    "00102743": "\nvoid set_custom_quoting_cold(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "0010272f": "\nvoid toarith_cold(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "00107fc0": "\nint c_toupper(int param_1)\n\n{\n  if (param_1 - 0x61U < 0x1a) {\n    param_1 = param_1 + -0x20;\n  }\n  return param_1;\n}\n\n", 
    "0010f108": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint strcmp(char *__s1,char *__s2)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strcmp@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001026c0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t fwrite(void *__ptr,size_t __size,size_t __n,FILE *__s)\n\n{\n  size_t sVar1;\n  \n  sVar1 = (*(code *)PTR_fwrite_0010dfa8)();\n  return sVar1;\n}\n\n", 
    "001049c0": "\nvoid mbuiter_multi_copy(char *param_1,char *param_2)\n\n{\n  char cVar1;\n  \n  cVar1 = *param_2;\n  *param_1 = cVar1;\n  if (cVar1 == '\\0') {\n    *(undefined8 *)(param_1 + 4) = 0;\n  }\n  else {\n    *(undefined8 *)(param_1 + 4) = *(undefined8 *)(param_2 + 4);\n  }\n  param_1[0xc] = param_2[0xc];\n  mb_copy(param_1 + 0x10,param_2 + 0x10);\n  return;\n}\n\n", 
    "00108040": "\nulong close_stream(FILE *param_1)\n\n{\n  int iVar1;\n  long lVar2;\n  ulong uVar3;\n  int *piVar4;\n  \n  lVar2 = __fpending();\n  iVar1 = ferror_unlocked(param_1);\n  uVar3 = rpl_fclose(param_1);\n  if (iVar1 == 0) {\n    if ((int)uVar3 == 0) {\n      return uVar3;\n    }\n    if (lVar2 == 0) {\n      piVar4 = __errno_location();\n      return (ulong)-(uint)(*piVar4 != 9);\n    }\n  }\n  else if ((int)uVar3 == 0) {\n    piVar4 = __errno_location();\n    *piVar4 = 0;\n    return 0xffffffff;\n  }\n  return 0xffffffff;\n}\n\n", 
    "0010f1b0": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid _ITM_registerTMCloneTable(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n  halt_baddata();\n}\n\n", 
    "001025a0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint strcmp(char *__s1,char *__s2)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_strcmp_0010df18)();\n  return iVar1;\n}\n\n", 
    "00108280": "\nvoid clear_ungetc_buffer_preserving_position(uint *param_1)\n\n{\n  if ((*param_1 & 0x100) == 0) {\n    return;\n  }\n  rpl_fseeko(param_1,0,1);\n  return;\n}\n\n", 
    "0010272a": "\nvoid printv_cold(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "00104a00": "\nvoid set_program_name(char *param_1)\n\n{\n  char *pcVar1;\n  long lVar2;\n  ulong uVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  bool bVar6;\n  bool bVar7;\n  byte bVar8;\n  \n  bVar8 = 0;\n  if (param_1 == (char *)0x0) {\n    fwrite(\"A NULL argv[0] was passed through an exec system call.\\n\",1,0x37,stderr);\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  pcVar1 = strrchr(param_1,0x2f);\n  if (pcVar1 != (char *)0x0) {\n    program_name = pcVar1 + 1;\n    uVar3 = (long)program_name - (long)param_1;\n    bVar6 = uVar3 < 6;\n    bVar7 = uVar3 == 6;\n    if (6 < (long)uVar3) {\n      lVar2 = 7;\n      pbVar4 = (byte *)(pcVar1 + -6);\n      pbVar5 = &DAT_00109be0;\n      do {\n        if (lVar2 == 0) break;\n        lVar2 = lVar2 + -1;\n        bVar6 = *pbVar4 < *pbVar5;\n        bVar7 = *pbVar4 == *pbVar5;\n        pbVar4 = pbVar4 + (ulong)bVar8 * -2 + 1;\n        pbVar5 = pbVar5 + (ulong)bVar8 * -2 + 1;\n      } while (bVar7);\n      if ((!bVar6 && !bVar7) == bVar6) {\n        if (((pcVar1[1] != 'l') || (pcVar1[2] != 't')) || (pcVar1[3] != '-')) {\n          program_invocation_name = program_name;\n          return;\n        }\n        param_1 = pcVar1 + 4;\n        program_invocation_short_name = param_1;\n      }\n    }\n  }\n  program_name = param_1;\n  program_invocation_name = param_1;\n  return;\n}\n\n", 
    "00106d00": "\nsize_t strnlen1(void *param_1,size_t param_2)\n\n{\n  void *pvVar1;\n  size_t sVar2;\n  \n  pvVar1 = memchr(param_1,0,param_2);\n  sVar2 = (long)pvVar1 + (1 - (long)param_1);\n  if (pvVar1 == (void *)0x0) {\n    sVar2 = param_2;\n  }\n  return sVar2;\n}\n\n", 
    "0010f1a8": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __fprintf_chk(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __fprintf_chk@@GLIBC_2.3.4 */\n  halt_baddata();\n}\n\n", 
    "00102739": "\nvoid quotearg_buffer_restyled_cold(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "001077f0": "\nvoid x2nrealloc(long param_1,ulong *param_2,ulong param_3)\n\n{\n  undefined auVar1 [16];\n  ulong uVar2;\n  ulong uVar3;\n  \n  uVar3 = *param_2;\n  if (param_1 == 0) {\n    if (uVar3 == 0) {\n      uVar3 = (ulong)(0x80 < param_3) +\n              SUB168((ZEXT816(0) << 0x40 | ZEXT816(0x80)) / ZEXT816(param_3),0);\n    }\n    uVar2 = (ulong)(SUB168(ZEXT816(uVar3) * ZEXT816(param_3) >> 0x40,0) != 0);\n    if ((SUB168(ZEXT816(uVar3) * ZEXT816(param_3),0) < 0) || (uVar2 != 0)) goto LAB_0010784b;\n  }\n  else {\n    auVar1 = ZEXT816(0) << 0x40 | ZEXT816(0x5555555555555554);\n    uVar2 = SUB168(auVar1 % ZEXT816(param_3),0);\n    if (SUB168(auVar1 / ZEXT816(param_3),0) <= uVar3) {\nLAB_0010784b:\n                    /* WARNING: Subroutine does not return */\n      xalloc_die(param_1,uVar3,uVar2);\n    }\n    uVar3 = (uVar3 >> 1) + 1 + uVar3;\n  }\n  *param_2 = uVar3;\n  xrealloc(param_1,uVar3 * param_3);\n  return;\n}\n\n", 
    "00104d60": "\nundefined8\nstrcaseeq4(long param_1,undefined8 param_2,byte param_3,char param_4,char param_5,char param_6,\n          char param_7)\n\n{\n  char cVar1;\n  byte bVar2;\n  undefined8 uVar3;\n  \n  cVar1 = c_isupper((int)(char)param_3);\n  bVar2 = *(byte *)(param_1 + 4);\n  if (cVar1 != '\\0') {\n    bVar2 = bVar2 & 0xdf;\n  }\n  if (param_3 != bVar2) {\n    return 0;\n  }\n  if (param_3 == 0) {\n    return 1;\n  }\n  uVar3 = strcaseeq5(param_1,param_2,(int)param_4,(int)param_5,(int)param_6,(int)param_7);\n  return uVar3;\n}\n\n", 
    "00102734": "\nvoid quoting_options_from_style_cold(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "00102610": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * nl_langinfo(nl_item __item)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_nl_langinfo_0010df50)();\n  return pcVar1;\n}\n\n", 
    "0010f100": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * calloc(size_t __nmemb,size_t __size)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* calloc@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00102650": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * setlocale(int __category,char *__locale)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_setlocale_0010df70)();\n  return pcVar1;\n}\n\n", 
    "00102530": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * memset(void *__s,int __c,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = (void *)(*(code *)PTR_memset_0010dee0)();\n  return pvVar1;\n}\n\n", 
    "00106cc0": "\nvoid quote_n_mem(void)\n\n{\n  quotearg_n_options();\n  return;\n}\n\n", 
    "00107ed0": "\nbool c_islower(int param_1)\n\n{\n  return param_1 - 0x61U < 0x1a;\n}\n\n", 
    "00106690": "\nundefined4 set_quoting_flags(undefined1 *param_1,undefined4 param_2)\n\n{\n  undefined4 uVar1;\n  \n  if (param_1 == (undefined1 *)0x0) {\n    param_1 = default_quoting_options;\n  }\n  uVar1 = *(undefined4 *)(param_1 + 4);\n  *(undefined4 *)(param_1 + 4) = param_2;\n  return uVar1;\n}\n\n", 
    "00107780": "\nvoid * xrealloc(void *param_1,size_t param_2)\n\n{\n  void *pvVar1;\n  \n  if ((param_2 == 0) && (param_1 != (void *)0x0)) {\n    free(param_1);\n    return (void *)0x0;\n  }\n  pvVar1 = realloc(param_1,param_2);\n  if ((pvVar1 == (void *)0x0) && (param_2 != 0)) {\n                    /* WARNING: Subroutine does not return */\n    xalloc_die();\n  }\n  return pvVar1;\n}\n\n", 
    "001026f0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint mbsinit(mbstate_t *__ps)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_mbsinit_0010dfc0)();\n  return iVar1;\n}\n\n", 
    "001025d0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fileno(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_fileno_0010df30)();\n  return iVar1;\n}\n\n", 
    "001024b0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t strlen(char *__s)\n\n{\n  size_t sVar1;\n  \n  sVar1 = (*(code *)PTR_strlen_0010dea0)();\n  return sVar1;\n}\n\n", 
    "00107f40": "\nbool c_isspace(int param_1)\n\n{\n  if (param_1 < 0xe) {\n    return 8 < param_1;\n  }\n  return param_1 == 0x20;\n}\n\n", 
    "001075e0": "\nvoid version_etc(void)\n\n{\n  long lVar1;\n  long in_FS_OFFSET;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  version_etc_va();\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00102a90": "\nvoid integer_overflow(char param_1)\n\n{\n                    /* WARNING: Subroutine does not return */\n  error(3,0x22,&DAT_00109004,(int)param_1);\n}\n\n", 
    "00102520": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid __assert_fail(char *__assertion,char *__file,uint __line,char *__function)\n\n{\n  (*(code *)PTR___assert_fail_0010ded8)();\n  return;\n}\n\n", 
    "00102400": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint strncmp(char *__s1,char *__s2,size_t __n)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_strncmp_0010de48)();\n  return iVar1;\n}\n\n", 
    "00102640": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * realloc(void *__ptr,size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = (void *)(*(code *)PTR_realloc_0010df68)();\n  return pvVar1;\n}\n\n", 
    "00107530": "\nvoid version_etc_ar(void)\n\n{\n  long lVar1;\n  long *in_R8;\n  long lVar2;\n  \n  lVar2 = 0;\n  lVar1 = *in_R8;\n  while (lVar1 != 0) {\n    lVar2 = lVar2 + 1;\n    lVar1 = in_R8[lVar2];\n  }\n  version_etc_arn();\n  return;\n}\n\n", 
    "00107ec0": "\nbool c_isgraph(int param_1)\n\n{\n  return param_1 - 0x21U < 0x5e;\n}\n\n", 
    "00107fe0": "\nint c_strcasecmp(undefined *param_1,undefined *param_2)\n\n{\n  byte bVar1;\n  byte bVar2;\n  int iVar3;\n  \n  iVar3 = 0;\n  if (param_1 != param_2) {\n    do {\n      bVar1 = c_tolower(*param_1);\n      bVar2 = c_tolower(*param_2);\n      if (bVar1 == 0) break;\n      param_1 = param_1 + 1;\n      param_2 = param_2 + 1;\n    } while (bVar1 == bVar2);\n    iVar3 = (uint)bVar1 - (uint)bVar2;\n  }\n  return iVar3;\n}\n\n", 
    "00107770": "\nvoid xcharalloc(void)\n\n{\n  xmalloc();\n  return;\n}\n\n", 
    "00107890": "\nvoid xzalloc(size_t param_1)\n\n{\n  void *__s;\n  \n  __s = (void *)xmalloc();\n  memset(__s,0,param_1);\n  return;\n}\n\n", 
    "001024a0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t __ctype_get_mb_cur_max(void)\n\n{\n  size_t sVar1;\n  \n  sVar1 = (*(code *)PTR___ctype_get_mb_cur_max_0010de98)();\n  return sVar1;\n}\n\n", 
    "001026e0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * re_compile_pattern(char *__pattern,size_t __length,re_pattern_buffer *__buffer)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_re_compile_pattern_0010dfb8)();\n  return pcVar1;\n}\n\n", 
    "001025c0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint putchar_unlocked(int __c)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_putchar_unlocked_0010df28)();\n  return iVar1;\n}\n\n", 
    "00107e10": "\nulong c_isalnum(int param_1)\n\n{\n  ulong in_RAX;\n  ulong uVar1;\n  \n  if (param_1 < 0x5b) {\n    uVar1 = 1;\n    if (param_1 < 0x41) {\n      return (ulong)(param_1 - 0x30U < 10);\n    }\n  }\n  else {\n    uVar1 = in_RAX & 0xffffffffffffff00 | (ulong)(param_1 - 0x61U < 0x1a);\n  }\n  return uVar1;\n}\n\n", 
    "00102630": "\nvoid __freading(void)\n\n{\n  (*(code *)PTR___freading_0010df60)();\n  return;\n}\n\n", 
    "00102510": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\n__off_t lseek(int __fd,__off_t __offset,int __whence)\n\n{\n  __off_t _Var1;\n  \n  _Var1 = (*(code *)PTR_lseek_0010ded0)();\n  return _Var1;\n}\n\n"
}