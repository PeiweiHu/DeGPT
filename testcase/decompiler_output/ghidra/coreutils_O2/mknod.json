{
    "00104ba0": "\nlong hash_find_entry(long param_1,long param_2,long **param_3,char param_4)\n\n{\n  long *plVar1;\n  long lVar2;\n  char cVar3;\n  long *plVar4;\n  long lVar5;\n  \n  plVar4 = (long *)safe_hasher();\n  *param_3 = plVar4;\n  lVar5 = *plVar4;\n  if (lVar5 == 0) {\nLAB_00104c41:\n    lVar5 = 0;\n  }\n  else {\n    if (lVar5 != param_2) {\n      cVar3 = (**(code **)(param_1 + 0x38))(param_2);\n      if (cVar3 == '\\0') {\n        for (; (long *)plVar4[1] != (long *)0x0; plVar4 = (long *)plVar4[1]) {\n          if ((*(long *)plVar4[1] == param_2) ||\n             (cVar3 = (**(code **)(param_1 + 0x38))(param_2), cVar3 != '\\0')) {\n            lVar5 = *(long *)plVar4[1];\n            if (param_4 == '\\0') {\n              return lVar5;\n            }\n            plVar4[1] = ((long *)plVar4[1])[1];\n            free_entry_isra_0(param_1 + 0x48);\n            return lVar5;\n          }\n        }\n        goto LAB_00104c41;\n      }\n      lVar5 = *plVar4;\n    }\n    if (param_4 != '\\0') {\n      plVar1 = (long *)plVar4[1];\n      if (plVar1 != (long *)0x0) {\n        lVar2 = plVar1[1];\n        *plVar4 = *plVar1;\n        plVar4[1] = lVar2;\n        free_entry_isra_0(param_1 + 0x48);\n        return lVar5;\n      }\n      *plVar4 = 0;\n    }\n  }\n  return lVar5;\n}\n\n", 
    "001140c0": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid context_type_set(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n  halt_baddata();\n}\n\n", 
    "00108d80": "\nvoid xcharalloc(void)\n\n{\n  xmalloc();\n  return;\n}\n\n", 
    "001141e0": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint __fxstat(int __ver,int __fildes,stat *__stat_buf)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __fxstat@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00102ae0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nushort ** __ctype_b_loc(void)\n\n{\n  ushort **ppuVar1;\n  \n  ppuVar1 = (ushort **)(*(code *)PTR___ctype_b_loc_00112fb0)();\n  return ppuVar1;\n}\n\n", 
    "00104cc0": "\nundefined8 transfer_entries(long param_1,long **param_2,char param_3)\n\n{\n  long lVar1;\n  long *plVar2;\n  long *plVar3;\n  long *plVar4;\n  long *plVar5;\n  long lVar6;\n  \n  plVar5 = *param_2;\n  if (param_2[1] <= plVar5) {\n    return 1;\n  }\n  do {\n    while (lVar6 = *plVar5, lVar6 == 0) {\nLAB_00104cf0:\n      plVar5 = plVar5 + 2;\n      if (param_2[1] < plVar5 || param_2[1] == plVar5) {\n        return 1;\n      }\n    }\n    plVar3 = (long *)plVar5[1];\n    if ((long *)plVar5[1] != (long *)0x0) {\n      do {\n        while( true ) {\n          lVar6 = *plVar3;\n          plVar2 = (long *)safe_hasher(param_1,lVar6);\n          plVar4 = (long *)plVar3[1];\n          if (*plVar2 != 0) break;\n          *plVar2 = lVar6;\n          *(long *)(param_1 + 0x18) = *(long *)(param_1 + 0x18) + 1;\n          free_entry_isra_0(param_1 + 0x48);\n          plVar3 = plVar4;\n          if (plVar4 == (long *)0x0) goto LAB_00104d60;\n        }\n        plVar3[1] = plVar2[1];\n        plVar2[1] = (long)plVar3;\n        plVar3 = plVar4;\n      } while (plVar4 != (long *)0x0);\nLAB_00104d60:\n      lVar6 = *plVar5;\n    }\n    plVar5[1] = 0;\n    if (param_3 != '\\0') goto LAB_00104cf0;\n    plVar3 = (long *)safe_hasher(param_1,lVar6);\n    if (*plVar3 == 0) {\n      *plVar3 = lVar6;\n      *(long *)(param_1 + 0x18) = *(long *)(param_1 + 0x18) + 1;\n    }\n    else {\n      plVar4 = (long *)allocate_entry_isra_0(param_1 + 0x48);\n      if (plVar4 == (long *)0x0) {\n        return 0;\n      }\n      lVar1 = plVar3[1];\n      *plVar4 = lVar6;\n      plVar4[1] = lVar1;\n      plVar3[1] = (long)plVar4;\n    }\n    *plVar5 = 0;\n    plVar5 = plVar5 + 2;\n    param_2[3] = (long *)((long)param_2[3] + -1);\n    if (param_2[1] < plVar5 || param_2[1] == plVar5) {\n      return 1;\n    }\n  } while( true );\n}\n\n", 
    "00108b40": "\nvoid version_etc_ar(void)\n\n{\n  long lVar1;\n  long *in_R8;\n  long lVar2;\n  \n  lVar2 = 0;\n  lVar1 = *in_R8;\n  while (lVar1 != 0) {\n    lVar2 = lVar2 + 1;\n    lVar1 = in_R8[lVar2];\n  }\n  version_etc_arn();\n  return;\n}\n\n", 
    "00108130": "\nvoid quotearg_n(undefined8 param_1,undefined8 param_2)\n\n{\n  quotearg_n_options(param_1,param_2,0xffffffffffffffff,default_quoting_options);\n  return;\n}\n\n", 
    "00108250": "\nvoid quotearg_style(undefined4 param_1,undefined8 param_2)\n\n{\n  quotearg_n_style(0,param_1,param_2);\n  return;\n}\n\n", 
    "00108490": "\nvoid quotearg_n_custom(void)\n\n{\n  quotearg_n_custom_mem();\n  return;\n}\n\n", 
    "001099b0": "\nlong filesystem_type(long param_1,int param_2)\n\n{\n  undefined8 uVar1;\n  int iVar2;\n  long lVar3;\n  long lVar4;\n  undefined8 *__ptr;\n  undefined8 *puVar5;\n  long in_FS_OFFSET;\n  undefined8 local_b8 [2];\n  statfs local_a8;\n  long local_30;\n  \n  lVar3 = *(long *)(param_1 + 0x50);\n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((*(byte *)(lVar3 + 0x49) & 2) != 0) {\n    lVar4 = *(long *)(lVar3 + 0x50);\n    if (lVar4 == 0) {\n      lVar4 = hash_initialize(0xd,0,dev_type_hash,dev_type_compare,PTR_free_00112fb8);\n      *(long *)(lVar3 + 0x50) = lVar4;\n      if (lVar4 != 0) goto LAB_001099ec;\n    }\n    else {\nLAB_001099ec:\n      local_b8[0] = *(undefined8 *)(param_1 + 0x78);\n      lVar3 = hash_lookup(lVar4,local_b8);\n      if (lVar3 != 0) {\n        lVar3 = *(long *)(lVar3 + 8);\n        goto LAB_00109a5b;\n      }\n    }\n    if ((-1 < param_2) && (iVar2 = fstatfs(param_2,&local_a8), lVar3 = local_a8.f_type, iVar2 == 0))\n    {\n      if ((lVar4 != 0) && (__ptr = (undefined8 *)malloc(0x10), __ptr != (undefined8 *)0x0)) {\n        uVar1 = *(undefined8 *)(param_1 + 0x78);\n        __ptr[1] = lVar3;\n        *__ptr = uVar1;\n        puVar5 = (undefined8 *)hash_insert(lVar4,__ptr);\n        if (puVar5 == (undefined8 *)0x0) {\n          free(__ptr);\n          lVar3 = local_a8.f_type;\n        }\n        else {\n          lVar3 = local_a8.f_type;\n          if (__ptr != puVar5) {\n                    /* WARNING: Subroutine does not return */\n            abort();\n          }\n        }\n      }\n      goto LAB_00109a5b;\n    }\n  }\n  lVar3 = 0;\nLAB_00109a5b:\n  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return lVar3;\n}\n\n", 
    "0010c7a0": "\nint atexit(__func *__func)\n\n{\n  int iVar1;\n  \n  iVar1 = __cxa_atexit(__func,0,__dso_handle);\n  return iVar1;\n}\n\n", 
    "00109470": "\nulong AD_hash(long param_1,ulong param_2)\n\n{\n  return *(ulong *)(param_1 + 8) % param_2;\n}\n\n", 
    "00102700": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t mbrtowc(wchar_t *__pwc,char *__s,size_t __n,mbstate_t *__p)\n\n{\n  size_t sVar1;\n  \n  sVar1 = (*(code *)PTR_mbrtowc_00112dc0)();\n  return sVar1;\n}\n\n", 
    "00103910": "\nint restorecon_private(char *param_1,char param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  long lVar3;\n  long lVar4;\n  long lVar5;\n  int *piVar6;\n  long in_FS_OFFSET;\n  undefined8 local_d8;\n  long local_d0;\n  stat local_c8;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  local_d8 = 0;\n  local_d0 = 0;\n  if (param_2 != '\\0') {\n    iVar1 = getfscreatecon(&local_d0);\n    if (iVar1 < 0) {\n      iVar1 = -1;\n    }\n    else if (local_d0 == 0) {\n      piVar6 = __errno_location();\n      iVar1 = -1;\n      *piVar6 = 0x3d;\n    }\n    else {\n      iVar1 = lsetfilecon(param_1);\n      freecon(local_d0);\n    }\n    goto LAB_0010397f;\n  }\n  iVar1 = open(param_1,0x20000);\n  if (iVar1 == -1) {\n    piVar6 = __errno_location();\n    if ((*piVar6 == 0x28) && (iVar2 = lstat(param_1,&local_c8), -1 < iVar2)) goto LAB_001039dc;\n    lVar4 = 0;\n    lVar3 = 0;\n  }\n  else {\n    iVar2 = fstat(iVar1,&local_c8);\n    if (iVar2 < 0) {\n      lVar4 = 0;\n      lVar3 = 0;\n      iVar2 = -1;\n    }\n    else {\nLAB_001039dc:\n      iVar2 = matchpathcon(param_1,local_c8.st_mode,&local_d8);\n      if (iVar2 < 0) {\n        piVar6 = __errno_location();\n        if (*piVar6 != 2) goto LAB_00103ace;\n        *piVar6 = 0x3d;\n        lVar4 = 0;\n        lVar3 = 0;\nLAB_00103ad3:\n        if (iVar1 == -1) goto LAB_00103a97;\n      }\n      else {\n        lVar3 = context_new(local_d8);\n        if (lVar3 == 0) {\nLAB_00103ace:\n          lVar4 = 0;\n          lVar3 = 0;\n          goto LAB_00103ad3;\n        }\n        if (iVar1 == -1) {\n          lVar4 = 0;\n          iVar2 = rpl_lgetfilecon(param_1,&local_d0);\n          if ((((iVar2 < 0) || (lVar4 = context_new(local_d0), lVar4 == 0)) ||\n              (lVar5 = context_type_get(lVar3), lVar5 == 0)) ||\n             (iVar2 = context_type_set(lVar4,lVar5), iVar2 != 0)) goto LAB_00103a97;\nLAB_00103a5d:\n          lVar5 = context_str(lVar4);\n          if (lVar5 == 0) goto LAB_00103ad3;\n          if (iVar1 == -1) {\n            iVar1 = lsetfilecon(param_1,lVar5);\n            goto LAB_00103a97;\n          }\n          iVar2 = fsetfilecon(iVar1);\n          goto LAB_00103adf;\n        }\n        iVar2 = rpl_fgetfilecon(iVar1);\n        if (iVar2 < 0) {\n          lVar4 = 0;\n          iVar2 = -1;\n          goto LAB_00103adf;\n        }\n        lVar4 = context_new(local_d0);\n        if (((lVar4 != 0) && (lVar5 = context_type_get(lVar3), lVar5 != 0)) &&\n           (iVar2 = context_type_set(lVar4,lVar5), iVar2 == 0)) goto LAB_00103a5d;\n      }\n      iVar2 = -1;\n    }\nLAB_00103adf:\n    close(iVar1);\n    iVar1 = iVar2;\n  }\nLAB_00103a97:\n  context_free(lVar3);\n  context_free(lVar4);\n  freecon(local_d8);\n  freecon(local_d0);\nLAB_0010397f:\n  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return iVar1;\n}\n\n", 
    "001140c8": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * strchr(char *__s,int __c)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strchr@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010c260": "\nundefined i_ring_empty(long param_1)\n\n{\n  return *(undefined *)(param_1 + 0x1c);\n}\n\n", 
    "001141e8": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __freading(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __freading@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00102940": "\nvoid __freading(void)\n\n{\n  (*(code *)PTR___freading_00112ee0)();\n  return;\n}\n\n", 
    "00102820": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * calloc(size_t __nmemb,size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = (void *)(*(code *)PTR_calloc_00112e50)();\n  return pvVar1;\n}\n\n", 
    "00108d90": "\nvoid * xrealloc(void *param_1,size_t param_2)\n\n{\n  void *pvVar1;\n  \n  if ((param_2 == 0) && (param_1 != (void *)0x0)) {\n    free(param_1);\n    return (void *)0x0;\n  }\n  pvVar1 = realloc(param_1,param_2);\n  if ((pvVar1 == (void *)0x0) && (param_2 != 0)) {\n                    /* WARNING: Subroutine does not return */\n    xalloc_die();\n  }\n  return pvVar1;\n}\n\n", 
    "001140d0": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint __fxstatat(int __ver,int __fildes,char *__filename,stat *__stat_buf,int __flag)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __fxstatat@@GLIBC_2.4 */\n  halt_baddata();\n}\n\n", 
    "001141f8": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * realloc(void *__ptr,size_t __size)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* realloc@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010bb90": "\nsize_t rpl_mbrtowc(wchar_t *param_1,byte *param_2,size_t param_3,mbstate_t *param_4)\n\n{\n  char cVar1;\n  size_t sVar2;\n  long in_FS_OFFSET;\n  wchar_t local_34;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_1 == (wchar_t *)0x0) {\n    param_1 = &local_34;\n  }\n  sVar2 = mbrtowc(param_1,(char *)param_2,param_3,param_4);\n  if ((0xfffffffffffffffd < sVar2) && (param_3 != 0)) {\n    cVar1 = hard_locale(0);\n    if (cVar1 == '\\0') {\n      sVar2 = 1;\n      *param_1 = (uint)*param_2;\n    }\n  }\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return sVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00109b20": "\nundefined leaf_optimization(void)\n\n{\n  long lVar1;\n  undefined uVar2;\n  \n  lVar1 = filesystem_type();\n  if (lVar1 == 0x52654973) {\n    uVar2 = 2;\n  }\n  else if (lVar1 < 0x52654974) {\n    uVar2 = 0;\n    if ((lVar1 != 0x6969) && (lVar1 != 0x9fa0)) {\n      return lVar1 != 0;\n    }\n  }\n  else {\n    uVar2 = 2;\n    if ((lVar1 != 0x58465342) && (uVar2 = 0, lVar1 != 0xff534d42)) {\n      uVar2 = lVar1 != 0x5346414f;\n    }\n  }\n  return uVar2;\n}\n\n", 
    "00102ad0": "\nvoid mode_to_security_class(void)\n\n{\n  (*(code *)PTR_mode_to_security_class_00112fa8)();\n  return;\n}\n\n", 
    "001141f0": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fchdir(int __fd)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fchdir@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001033f0": "\nvoid emit_ancillary_info_constprop_0(void)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  char *pcVar3;\n  char *pcVar4;\n  long lVar5;\n  undefined **ppuVar6;\n  byte *pbVar7;\n  byte *pbVar8;\n  long in_FS_OFFSET;\n  bool bVar9;\n  bool bVar10;\n  undefined *local_98;\n  char *local_90;\n  char *local_88;\n  char *local_80 [5];\n  char *local_58;\n  char *local_50;\n  char *local_48;\n  char *local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  long local_20;\n  \n  pbVar8 = (byte *)0x10d767;\n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_80[3] = \"sha256sum\";\n  local_98 = &DAT_0010d6ed;\n  local_90 = \"test invocation\";\n  local_80[0] = \"Multi-call invocation\";\n  local_80[1] = \"sha224sum\";\n  local_58 = \"sha384sum\";\n  local_48 = \"sha512sum\";\n  local_88 = \"coreutils\";\n  local_80[2] = \"sha2 utilities\";\n  local_80[4] = \"sha2 utilities\";\n  local_50 = \"sha2 utilities\";\n  local_40 = \"sha2 utilities\";\n  local_38 = 0;\n  local_30 = 0;\n  ppuVar6 = &local_98;\n  while( true ) {\n    bVar9 = false;\n    bVar10 = pbVar8 == (byte *)0x0;\n    if (bVar10) break;\n    lVar5 = 6;\n    pbVar7 = (byte *)\"mknod\";\n    do {\n      if (lVar5 == 0) break;\n      lVar5 = lVar5 + -1;\n      bVar9 = *pbVar7 < *pbVar8;\n      bVar10 = *pbVar7 == *pbVar8;\n      pbVar7 = pbVar7 + 1;\n      pbVar8 = pbVar8 + 1;\n    } while (bVar10);\n    if ((!bVar9 && !bVar10) == bVar9) break;\n    pbVar8 = *(byte **)((long)ppuVar6 + 0x20);\n    ppuVar6 = (undefined **)((long)ppuVar6 + 0x10);\n  }\n  pcVar4 = *(char **)((long)ppuVar6 + 0x18);\n  if (pcVar4 == (char *)0x0) {\n    uVar2 = dcgettext(0,\"\\n%s online help: <%s>\\n\",5);\n    __printf_chk(1,uVar2,\"GNU coreutils\",\"https://www.gnu.org/software/coreutils/\");\n    pcVar4 = setlocale(5,(char *)0x0);\n    if (pcVar4 != (char *)0x0) {\n      iVar1 = strncmp(pcVar4,\"en_\",3);\n      if (iVar1 != 0) {\n        pcVar4 = \"mknod\";\n        goto LAB_0010360e;\n      }\n    }\n    uVar2 = dcgettext(0,\"Full documentation at: <%s%s>\\n\",5);\n    pcVar4 = \"mknod\";\n    __printf_chk(1,uVar2,\"https://www.gnu.org/software/coreutils/\",\"mknod\");\n    pcVar3 = \" invocation\";\n  }\n  else {\n    uVar2 = dcgettext(0,\"\\n%s online help: <%s>\\n\",5);\n    __printf_chk(1,uVar2,\"GNU coreutils\",\"https://www.gnu.org/software/coreutils/\");\n    pcVar3 = setlocale(5,(char *)0x0);\n    if (pcVar3 != (char *)0x0) {\n      iVar1 = strncmp(pcVar3,\"en_\",3);\n      if (iVar1 != 0) {\nLAB_0010360e:\n        uVar2 = dcgettext(0,\"Report %s translation bugs to <https://translationproject.org/team/>\\n\"\n                          ,5);\n        __printf_chk(1,uVar2,\"mknod\");\n      }\n    }\n    uVar2 = dcgettext(0,\"Full documentation at: <%s%s>\\n\",5);\n    pcVar3 = \" invocation\";\n    __printf_chk(1,uVar2,\"https://www.gnu.org/software/coreutils/\",\"mknod\");\n    if (pcVar4 != \"mknod\") {\n      pcVar3 = \"\";\n    }\n  }\n  uVar2 = dcgettext(0,\"or available locally via: info \\'(coreutils) %s%s\\'\\n\",5);\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    __printf_chk(1,uVar2,pcVar4,pcVar3);\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "0010c270": "\nundefined4 i_ring_push(long param_1,undefined4 param_2)\n\n{\n  undefined4 *puVar1;\n  undefined4 uVar2;\n  uint uVar3;\n  uint uVar4;\n  \n  uVar3 = (uint)(*(byte *)(param_1 + 0x1c) ^ 1);\n  uVar4 = *(int *)(param_1 + 0x14) + uVar3 & 3;\n  puVar1 = (undefined4 *)(param_1 + (ulong)uVar4 * 4);\n  uVar2 = *puVar1;\n  *puVar1 = param_2;\n  *(uint *)(param_1 + 0x14) = uVar4;\n  if (*(uint *)(param_1 + 0x18) == uVar4) {\n    *(uint *)(param_1 + 0x18) = uVar3 + *(uint *)(param_1 + 0x18) & 3;\n  }\n  *(undefined *)(param_1 + 0x1c) = 0;\n  return uVar2;\n}\n\n", 
    "001032d0": "\n/* WARNING: Removing unreachable block (ram,0x001032e3) */\n/* WARNING: Removing unreachable block (ram,0x001032ef) */\n\nvoid deregister_tm_clones(void)\n\n{\n  return;\n}\n\n", 
    "00102810": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint ferror_unlocked(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_ferror_unlocked_00112e48)();\n  return iVar1;\n}\n\n", 
    "001140d8": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * strrchr(char *__s,int __c)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strrchr@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00102930": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint __fxstat(int __ver,int __fildes,stat *__stat_buf)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR___fxstat_00112ed8)();\n  return iVar1;\n}\n\n", 
    "001140a0": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint openat(int __fd,char *__file,int __oflag,...)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* openat@@GLIBC_2.4 */\n  halt_baddata();\n}\n\n", 
    "001141c0": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid setfscreatecon(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n  halt_baddata();\n}\n\n", 
    "00102970": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * setlocale(int __category,char *__locale)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_setlocale_00112ef8)();\n  return pcVar1;\n}\n\n", 
    "00109e50": "\nint fts_safe_changedir(long param_1,long param_2,int param_3,char *param_4)\n\n{\n  char cVar1;\n  byte bVar2;\n  int iVar3;\n  int iVar4;\n  int iVar5;\n  int *piVar6;\n  byte bVar7;\n  uint uVar8;\n  long in_FS_OFFSET;\n  stat local_d8;\n  long local_40;\n  \n  uVar8 = *(uint *)(param_1 + 0x48);\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar4 = param_3;\n  if ((((param_4 == (char *)0x0) || (cVar1 = *param_4, cVar1 != '.')) || (param_4[1] != '.')) ||\n     (param_4[2] != '\\0')) {\n    if ((uVar8 & 4) == 0) {\n      if (param_3 < 0) {\n        bVar2 = 0;\nLAB_00109f67:\n        iVar4 = diropen_isra_0(*(undefined4 *)(param_1 + 0x2c),uVar8,param_4);\n        if (iVar4 < 0) {\n          iVar3 = -1;\n          goto LAB_00109ef0;\n        }\n        uVar8 = *(uint *)(param_1 + 0x48);\n      }\n      else {\n        bVar2 = 0;\n      }\n      iVar3 = param_3;\n      if ((uVar8 & 2) == 0) {\n        bVar7 = bVar2;\n        if (param_4 != (char *)0x0) {\n          cVar1 = *param_4;\nLAB_00109ec1:\n          bVar2 = bVar7;\n          bVar7 = bVar2;\n          if (((cVar1 == '.') && (param_4[1] == '.')) && (iVar3 = param_3, param_4[2] == '\\0'))\n          goto LAB_00109fa0;\n        }\nLAB_00109eca:\n        if ((uVar8 & 0x200) != 0) {\n          iVar3 = 0;\n          cwd_advance_fd(param_1,iVar4,bVar7 ^ 1);\n          goto LAB_00109ef0;\n        }\n        iVar3 = fchdir(iVar4);\n      }\n      else {\nLAB_00109fa0:\n        iVar5 = fstat(iVar4,&local_d8);\n        param_3 = iVar3;\n        if (iVar5 == 0) {\n          if ((*(__dev_t *)(param_2 + 0x78) == local_d8.st_dev) &&\n             (*(__ino_t *)(param_2 + 0x80) == local_d8.st_ino)) {\n            uVar8 = *(uint *)(param_1 + 0x48);\n            bVar7 = bVar2;\n            goto LAB_00109eca;\n          }\n          piVar6 = __errno_location();\n          *piVar6 = 2;\n        }\n        iVar3 = -1;\n      }\n      if (param_3 < 0) {\n        piVar6 = __errno_location();\n        iVar5 = *piVar6;\n        close(iVar4);\n        *piVar6 = iVar5;\n      }\n      goto LAB_00109ef0;\n    }\n  }\n  else if ((uVar8 & 4) == 0) {\n    if (param_3 < 0) {\n      if ((uVar8 & 0x200) == 0) {\nLAB_0010a078:\n        bVar2 = 1;\n        goto LAB_00109f67;\n      }\n      bVar2 = i_ring_empty(param_1 + 0x60);\n      if (bVar2 != 0) goto LAB_00109f67;\n      iVar3 = i_ring_pop(param_1 + 0x60);\n      uVar8 = *(uint *)(param_1 + 0x48);\n      if (iVar3 < 0) goto LAB_0010a078;\n      bVar2 = 1;\n      param_3 = iVar3;\n      iVar4 = iVar3;\n      bVar7 = 1;\n      if ((uVar8 & 2) != 0) goto LAB_00109fa0;\n      goto LAB_00109eca;\n    }\n    bVar2 = 1;\n    iVar3 = param_3;\n    bVar7 = 1;\n    if ((uVar8 & 2) == 0) goto LAB_00109ec1;\n    goto LAB_00109fa0;\n  }\n  if (((uVar8 & 0x200) == 0) || (param_3 < 0)) {\n    iVar3 = 0;\n  }\n  else {\n    iVar3 = 0;\n    close(param_3);\n  }\nLAB_00109ef0:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return iVar3;\n}\n\n", 
    "00109c10": "\nuint restore_initial_cwd(long param_1)\n\n{\n  int iVar1;\n  uint uVar2;\n  \n  uVar2 = *(uint *)(param_1 + 0x48) & 4;\n  if (uVar2 == 0) {\n    if ((*(uint *)(param_1 + 0x48) & 0x200) == 0) {\n      iVar1 = fchdir(*(int *)(param_1 + 0x28));\n      uVar2 = (uint)(iVar1 != 0);\n    }\n    else {\n      cwd_advance_fd(param_1,0xffffff9c,1);\n    }\n  }\n  else {\n    uVar2 = 0;\n  }\n  fd_ring_clear(param_1 + 0x60);\n  return uVar2;\n}\n\n", 
    "00108150": "\nvoid quotearg_n_mem(void)\n\n{\n  quotearg_n_options();\n  return;\n}\n\n", 
    "00106090": "\nvoid mode_adjust(uint param_1,char param_2,uint param_3,char *param_4,uint *param_5)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  char cVar6;\n  uint uVar7;\n  \n  cVar6 = param_4[1];\n  param_1 = param_1 & 0xfff;\n  uVar2 = 0;\n  if (cVar6 != '\\0') {\nLAB_0010614d:\n    do {\n      uVar1 = *(uint *)(param_4 + 4);\n      uVar4 = *(uint *)(param_4 + 8);\n      if (param_2 == '\\0') {\n        if (cVar6 != '\\x02') {\n          uVar5 = 0xffffffff;\n          uVar3 = 0;\n          goto LAB_001060d2;\n        }\n        uVar5 = 0xffffffff;\n        uVar3 = param_1 & 0x49;\n        if (uVar3 != 0) {\n          uVar3 = 0;\n          goto LAB_0010617d;\n        }\nLAB_00106117:\n        cVar6 = *param_4;\n        uVar4 = uVar4 & uVar5;\n        if (uVar1 != 0) goto LAB_00106190;\nLAB_00106122:\n        uVar4 = uVar4 & ~param_3;\n        if (cVar6 != '-') {\n          if (cVar6 != '=') goto LAB_00106135;\n          goto LAB_001061a9;\n        }\nLAB_001061d8:\n        uVar2 = uVar2 | uVar4;\n        param_1 = param_1 & ~uVar4;\n      }\n      else {\n        uVar5 = *(uint *)(param_4 + 0xc) | 0xfffff3ff;\n        uVar3 = ~*(uint *)(param_4 + 0xc) & 0xc00;\n        if (cVar6 != '\\x02') {\nLAB_001060d2:\n          if (cVar6 == '\\x03') {\n            uVar4 = uVar4 & param_1;\n            uVar7 = ~-(uint)((uVar4 & 0x124) == 0) & 0x124;\n            if ((uVar4 & 0x92) != 0) {\n              uVar7 = uVar7 | 0x92;\n            }\n            if ((uVar4 & 0x49) != 0) {\n              uVar7 = uVar7 | 0x49;\n            }\n            uVar4 = uVar4 | uVar7;\n          }\n          goto LAB_00106117;\n        }\nLAB_0010617d:\n        cVar6 = *param_4;\n        uVar4 = (uVar4 | 0x49) & uVar5;\n        if (uVar1 == 0) goto LAB_00106122;\nLAB_00106190:\n        uVar4 = uVar4 & uVar1;\n        if (cVar6 == '-') goto LAB_001061d8;\n        if (cVar6 == '=') {\n          uVar3 = uVar3 | ~uVar1;\n          uVar5 = ~uVar3;\nLAB_001061a9:\n          cVar6 = param_4[0x11];\n          param_4 = param_4 + 0x10;\n          uVar2 = uVar2 | uVar5 & 0xfff;\n          param_1 = param_1 & uVar3 | uVar4;\n          if (cVar6 == '\\0') break;\n          goto LAB_0010614d;\n        }\nLAB_00106135:\n        if (cVar6 == '+') {\n          uVar2 = uVar2 | uVar4;\n          param_1 = param_1 | uVar4;\n        }\n      }\n      cVar6 = param_4[0x11];\n      param_4 = param_4 + 0x10;\n    } while (cVar6 != '\\0');\n  }\n  if (param_5 != (uint *)0x0) {\n    *param_5 = uVar2;\n  }\n  return;\n}\n\n", 
    "001066f0": "\nundefined8\nstrcaseeq2(long param_1,undefined8 param_2,byte param_3,char param_4,char param_5,char param_6,\n          char param_7)\n\n{\n  char cVar1;\n  byte bVar2;\n  undefined8 uVar3;\n  \n  cVar1 = c_isupper((int)(char)param_3);\n  bVar2 = *(byte *)(param_1 + 2);\n  if (cVar1 != '\\0') {\n    bVar2 = bVar2 & 0xdf;\n  }\n  if (param_3 != bVar2) {\n    return 0;\n  }\n  if (param_3 == 0) {\n    return 1;\n  }\n  uVar3 = strcaseeq3(param_1,param_2,(int)param_4,(int)param_5,(int)param_6,(int)param_7);\n  return uVar3;\n}\n\n", 
    "001140a8": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __stack_chk_fail(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __stack_chk_fail@@GLIBC_2.4 */\n  halt_baddata();\n}\n\n", 
    "00104900": "\nulong seen_file(long param_1,undefined8 param_2,undefined8 *param_3)\n\n{\n  ulong uVar1;\n  long in_FS_OFFSET;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  uVar1 = 0;\n  if (param_1 != 0) {\n    local_20 = param_3[1];\n    local_18 = *param_3;\n    local_28 = param_2;\n    uVar1 = hash_lookup(param_1,&local_28);\n    uVar1 = uVar1 & 0xffffffffffffff00 | (ulong)(uVar1 != 0);\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar1;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "0010c240": "\nvoid i_ring_init(undefined4 *param_1,undefined4 param_2)\n\n{\n  *(undefined8 *)(param_1 + 5) = 0;\n  *(undefined *)(param_1 + 7) = 1;\n  *param_1 = param_2;\n  param_1[1] = param_2;\n  param_1[2] = param_2;\n  param_1[3] = param_2;\n  param_1[4] = param_2;\n  return;\n}\n\n", 
    "001141c8": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * malloc(size_t __size)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* malloc@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00102960": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * realloc(void *__ptr,size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = (void *)(*(code *)PTR_realloc_00112ef0)();\n  return pvVar1;\n}\n\n", 
    "00102840": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint strcmp(char *__s1,char *__s2)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_strcmp_00112e60)();\n  return iVar1;\n}\n\n", 
    "00102720": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * strchr(char *__s,int __c)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_strchr_00112dd0)();\n  return pcVar1;\n}\n\n", 
    "00106a90": "\nulong quotearg_buffer_restyled\n                (undefined *param_1,ulong param_2,char *param_3,ulong param_4,int param_5,\n                uint param_6,long param_7,char *param_8,char *param_9)\n\n{\n  byte *__s1;\n  bool bVar1;\n  bool bVar2;\n  bool bVar3;\n  bool bVar4;\n  bool bVar5;\n  bool bVar6;\n  int iVar7;\n  size_t sVar8;\n  ushort **ppuVar9;\n  long lVar10;\n  char cVar11;\n  uint uVar12;\n  ulong uVar13;\n  byte bVar14;\n  ulong uVar15;\n  char *pcVar16;\n  ulong uVar17;\n  ulong uVar18;\n  ulong uVar19;\n  long in_FS_OFFSET;\n  bool bVar20;\n  bool bVar21;\n  bool bVar22;\n  bool bVar23;\n  bool bVar24;\n  size_t local_c8;\n  char *local_98;\n  ulong local_90;\n  char *local_78;\n  char *local_70;\n  bool local_64;\n  wint_t local_4c;\n  mbstate_t local_48;\n  long local_40;\n  \n  local_70 = param_8;\n  local_78 = param_9;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  sVar8 = __ctype_get_mb_cur_max();\n  uVar12 = param_6 & 2;\n  bVar20 = uVar12 != 0;\n  switch(param_5) {\n  case 0:\n    bVar6 = true;\n    bVar2 = false;\n    uVar18 = 0;\n    local_64 = false;\n    local_90 = 0;\n    bVar20 = false;\n    bVar1 = false;\n    local_c8 = 0;\n    local_98 = (char *)0x0;\n    break;\n  case 2:\n    if (uVar12 == 0) {\n      bVar1 = false;\nLAB_00106f17:\n      if (param_2 == 0) {\n        local_90 = 0;\n        bVar2 = false;\n        bVar6 = true;\n        local_64 = false;\n        goto LAB_00106f39;\n      }\n      bVar2 = false;\n      local_64 = false;\n      bVar6 = true;\n      uVar13 = 0;\n      local_90 = param_2;\n      goto LAB_001074d6;\n    }\n    bVar2 = false;\n    uVar18 = 0;\n    bVar6 = true;\n    local_64 = false;\n    local_90 = 0;\n    bVar20 = true;\n    bVar1 = false;\n    local_c8 = 1;\n    local_98 = \"\\'\";\n    break;\n  case 3:\n    bVar1 = true;\n    goto LAB_00106e8f;\n  case 4:\n    if (uVar12 == 0) {\n      bVar1 = true;\n      goto LAB_00106f17;\n    }\n  case 1:\n    bVar1 = false;\nLAB_00106e8f:\n    bVar6 = true;\n    local_64 = false;\n    bVar20 = true;\n    local_90 = 0;\n    bVar2 = false;\n    uVar18 = 0;\n    param_5 = 2;\n    local_c8 = 1;\n    local_98 = \"\\'\";\n    break;\n  case 5:\n    if (uVar12 == 0) {\n      if (param_2 != 0) {\n        *param_1 = 0x22;\n      }\n      bVar6 = true;\n      local_64 = false;\n      local_90 = 0;\n      bVar2 = false;\n      bVar20 = false;\n      uVar18 = 1;\n      bVar1 = true;\n      local_c8 = 1;\n      local_98 = \"\\\"\";\n    }\n    else {\n      bVar2 = false;\n      uVar18 = 0;\n      bVar6 = true;\n      local_64 = false;\n      local_90 = 0;\n      bVar20 = true;\n      bVar1 = true;\n      local_c8 = 1;\n      local_98 = \"\\\"\";\n    }\n    break;\n  case 6:\n    bVar2 = false;\n    uVar18 = 0;\n    bVar6 = true;\n    local_64 = false;\n    param_5 = 5;\n    local_90 = 0;\n    bVar20 = true;\n    bVar1 = true;\n    local_c8 = 1;\n    local_98 = \"\\\"\";\n    break;\n  case 7:\n    bVar6 = true;\n    bVar2 = false;\n    uVar18 = 0;\n    local_64 = false;\n    local_90 = 0;\n    bVar20 = false;\n    bVar1 = true;\n    local_c8 = 0;\n    local_98 = (char *)0x0;\n    break;\n  case 8:\n  case 9:\n  case 10:\n    if (param_5 != 10) {\n      local_70 = (char *)gettext_quote(&DAT_0010da31,param_5);\n      local_78 = (char *)gettext_quote(&DAT_0010da21);\n    }\n    uVar18 = 0;\n    if (uVar12 == 0) {\n      cVar11 = *local_70;\n      while (cVar11 != '\\0') {\n        if (uVar18 < param_2) {\n          param_1[uVar18] = cVar11;\n        }\n        uVar18 = uVar18 + 1;\n        cVar11 = local_70[uVar18];\n      }\n    }\n    bVar2 = false;\n    local_c8 = strlen(local_78);\n    local_98 = local_78;\n    bVar6 = true;\n    local_64 = false;\n    local_90 = 0;\n    bVar1 = true;\n    break;\n  default:\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  do {\n    uVar13 = 0;\n    bVar4 = local_64;\nLAB_00106be0:\n    bVar21 = param_4 != uVar13;\n    if (param_4 == 0xffffffffffffffff) {\n      bVar21 = param_3[uVar13] != '\\0';\n    }\n    bVar24 = bVar1;\n    if (bVar21) {\n      bVar23 = (bool)(param_5 != 2 & bVar1);\n      __s1 = (byte *)(param_3 + uVar13);\n      uVar17 = uVar13;\n      bVar3 = bVar2;\n      bVar5 = bVar23;\n      if (!bVar23) {\n        uVar15 = (ulong)*__s1;\n        switch(uVar15) {\n        case 0:\n          if (bVar1) goto switchD_00107440_caseD_0;\n          bVar5 = false;\n          uVar15 = 0;\n          if ((param_6 & 1) != 0) goto code_r0x001073db;\n          goto LAB_001071cb;\n        default:\nswitchD_001072f0_caseD_1:\n          bVar22 = bVar1;\n          if (sVar8 != 1) {\n            local_48 = (mbstate_t)0x0;\n            if (param_4 == 0xffffffffffffffff) {\n              param_4 = strlen(param_3);\n            }\n            uVar17 = 0;\n            do {\n              uVar19 = uVar13 + uVar17;\n              lVar10 = rpl_mbrtowc(&local_4c,param_3 + uVar19,param_4 - uVar19,&local_48);\n              if (lVar10 == 0) break;\n              if (lVar10 == -1) {\n                bVar21 = false;\n                goto LAB_001076c8;\n              }\n              if (lVar10 == -2) goto joined_r0x00107ada;\n              if (((param_5 == 2) && (bVar20)) && (lVar10 != 1)) {\n                pcVar16 = param_3 + uVar19 + 1;\n                do {\n                  if (((byte)(*pcVar16 + 0xa5U) < 0x22) &&\n                     ((1L << (*pcVar16 + 0xa5U & 0x3f) & 0x20000002bU) != 0)) {\n                    param_5 = 2;\n                    goto LAB_001070b0;\n                  }\n                  pcVar16 = pcVar16 + 1;\n                } while (param_3 + uVar19 + lVar10 != pcVar16);\n              }\n              iVar7 = iswprint(local_4c);\n              if (iVar7 == 0) {\n                bVar21 = false;\n              }\n              uVar17 = uVar17 + lVar10;\n              iVar7 = mbsinit(&local_48);\n            } while (iVar7 == 0);\n            bVar22 = (bool)((bVar21 ^ 1U) & bVar1);\n            goto LAB_001076c8;\n          }\n          ppuVar9 = __ctype_b_loc();\n          uVar17 = 1;\n          bVar22 = ((*ppuVar9)[uVar15] & 0x4000) == 0;\n          bVar21 = !bVar22;\n          bVar22 = (bool)(bVar22 & bVar1);\n          goto LAB_00106e51;\n        case 7:\n          uVar15 = 7;\n          bVar14 = 0x61;\n          break;\n        case 8:\n          uVar15 = 8;\n          bVar14 = 0x62;\n          break;\n        case 9:\n          uVar15 = 9;\n          bVar14 = 0x74;\n          goto LAB_00107398;\n        case 10:\n          uVar15 = 10;\n          bVar14 = 0x6e;\n          goto LAB_00107398;\n        case 0xb:\n          uVar15 = 0xb;\n          bVar14 = 0x76;\n          break;\n        case 0xc:\n          uVar15 = 0xc;\n          bVar14 = 0x66;\n          break;\n        case 0xd:\n          uVar15 = 0xd;\n          bVar14 = 0x72;\nLAB_00107398:\n          bVar23 = (bool)(param_5 == 2 & bVar20);\n          if (bVar23) goto LAB_001070a7;\n          break;\n        case 0x20:\n          uVar15 = 0x20;\n          goto LAB_00107094;\n        case 0x21:\n        case 0x22:\n        case 0x24:\n        case 0x26:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x3b:\n        case 0x3c:\n        case 0x3d:\n        case 0x3e:\n        case 0x5b:\n        case 0x5e:\n        case 0x60:\n        case 0x7c:\n          bVar21 = false;\nLAB_00107094:\n          bVar22 = param_5 == 2;\n          bVar23 = bVar21;\n          if ((!bVar20) || (!bVar22)) goto LAB_00106db8;\n          goto LAB_001070a7;\n        case 0x23:\n        case 0x7e:\nLAB_0010708b:\n          bVar22 = param_5 == 2;\n          if (uVar13 == 0) goto LAB_00107094;\n          goto LAB_00106db5;\n        case 0x25:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x2f:\n        case 0x30:\n        case 0x31:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x41:\n        case 0x42:\n        case 0x43:\n        case 0x44:\n        case 0x45:\n        case 0x46:\n        case 0x47:\n        case 0x48:\n        case 0x49:\n        case 0x4a:\n        case 0x4b:\n        case 0x4c:\n        case 0x4d:\n        case 0x4e:\n        case 0x4f:\n        case 0x50:\n        case 0x51:\n        case 0x52:\n        case 0x53:\n        case 0x54:\n        case 0x55:\n        case 0x56:\n        case 0x57:\n        case 0x58:\n        case 0x59:\n        case 0x5a:\n        case 0x5d:\n        case 0x5f:\n        case 0x61:\n        case 0x62:\n        case 99:\n        case 100:\n        case 0x65:\n        case 0x66:\n        case 0x67:\n        case 0x68:\n        case 0x69:\n        case 0x6a:\n        case 0x6b:\n        case 0x6c:\n        case 0x6d:\n        case 0x6e:\n        case 0x6f:\n        case 0x70:\n        case 0x71:\n        case 0x72:\n        case 0x73:\n        case 0x74:\n        case 0x75:\n        case 0x76:\n        case 0x77:\n        case 0x78:\n        case 0x79:\n        case 0x7a:\n          goto switchD_001072f0_caseD_25;\n        case 0x27:\nswitchD_001072f0_caseD_27:\n          bVar4 = bVar21;\n          if (param_5 != 2) {\n            bVar22 = false;\n            uVar15 = 0x27;\n            bVar23 = bVar21;\n            goto LAB_00106db8;\n          }\n          if (!bVar20) {\n            if ((param_2 == 0) || (uVar13 = 0, uVar15 = param_2, local_90 != 0)) {\n              if (uVar18 < param_2) {\n                param_1[uVar18] = 0x27;\n              }\n              if (uVar18 + 1 < param_2) {\n                param_1[uVar18 + 1] = 0x5c;\n              }\n              uVar13 = param_2;\n              uVar15 = local_90;\n              if (uVar18 + 2 < param_2) {\n                param_1[uVar18 + 2] = 0x27;\n              }\n            }\n            bVar14 = 0x27;\n            uVar18 = uVar18 + 3;\n            param_2 = uVar13;\n            local_90 = uVar15;\n            bVar3 = false;\n            bVar22 = false;\n            goto joined_r0x00106ddb;\n          }\n          goto LAB_001070b0;\n        case 0x3f:\nswitchD_001072f0_caseD_3f:\n          if (param_5 != 2) {\n            if ((((param_5 == 5) && ((param_6 & 4) != 0)) && (uVar17 = uVar13 + 2, uVar17 < param_4)\n                ) && (param_3[uVar13 + 1] == '?')) {\n              uVar15 = (ulong)(byte)param_3[uVar17];\n              switch(param_3[uVar17]) {\n              case '!':\n              case '\\'':\n              case '(':\n              case ')':\n              case '-':\n              case '/':\n              case '<':\n              case '=':\n              case '>':\n                goto switchD_00107a3e_caseD_21;\n              default:\n                break;\n              }\n            }\n            bVar22 = false;\n            uVar15 = 0x3f;\n            bVar23 = false;\n            goto LAB_00106db8;\n          }\n          if (!bVar20) {\n            bVar14 = 0x3f;\n            bVar22 = false;\n            bVar21 = false;\n            goto joined_r0x00106ddb;\n          }\n          goto LAB_001070b0;\n        case 0x5c:\n          if (param_5 != 2) goto switchD_00106ce8_caseD_5c;\n          if (!bVar20) {\nLAB_00107328:\n            uVar13 = uVar13 + 1;\n            bVar21 = false;\n            bVar14 = 0x5c;\n            goto LAB_00107340;\n          }\n          goto LAB_001070b0;\n        case 0x7b:\n        case 0x7d:\nswitchD_001072f0_caseD_7b:\n          bVar23 = param_4 != 1;\n          if (param_4 == 0xffffffffffffffff) {\n            bVar23 = param_3[1] != '\\0';\n          }\n          bVar22 = param_5 == 2;\n          if (!bVar23) goto LAB_0010708b;\nLAB_00106db5:\n          bVar23 = false;\n          goto LAB_00106db8;\n        }\nLAB_001071c0:\n        bVar5 = bVar23;\n        if (!bVar1) {\nLAB_001071cb:\n          bVar14 = (byte)uVar15;\n          bVar23 = false;\n          bVar21 = false;\n          bVar22 = false;\n          if (!bVar20) goto LAB_00106dd8;\n          goto LAB_00106d00;\n        }\nLAB_00107200:\n        bVar21 = false;\n        goto joined_r0x00107211;\n      }\n      if (local_c8 != 0) {\n        if ((param_4 == 0xffffffffffffffff) && (1 < local_c8)) {\n          param_4 = strlen(param_3);\n        }\n        if ((param_4 < uVar13 + local_c8) || (iVar7 = memcmp(__s1,local_98,local_c8), iVar7 != 0))\n        goto LAB_00107420;\n        if (!bVar20) {\n          uVar15 = (ulong)*__s1;\n          switch(uVar15) {\n          case 0:\n            goto switchD_00106ce8_caseD_0;\n          default:\n            goto switchD_001072f0_caseD_1;\n          case 7:\n            goto switchD_00107440_caseD_7;\n          case 8:\n            goto switchD_00107440_caseD_8;\n          case 9:\n            goto switchD_00106ce8_caseD_9;\n          case 10:\n            goto switchD_00107440_caseD_a;\n          case 0xb:\n            goto switchD_00107440_caseD_b;\n          case 0xc:\n            goto switchD_00107440_caseD_c;\n          case 0xd:\n            goto switchD_00107440_caseD_d;\n          case 0x20:\n            goto LAB_00107469;\n          case 0x21:\n          case 0x22:\n          case 0x24:\n          case 0x26:\n          case 0x28:\n          case 0x29:\n          case 0x2a:\n          case 0x3b:\n          case 0x3c:\n          case 0x3d:\n          case 0x3e:\n          case 0x5b:\n          case 0x5e:\n          case 0x60:\n          case 0x7c:\n            goto switchD_00106ce8_caseD_21;\n          case 0x23:\n          case 0x7e:\n            goto LAB_00107451;\n          case 0x25:\n          case 0x2b:\n          case 0x2c:\n          case 0x2d:\n          case 0x2e:\n          case 0x2f:\n          case 0x30:\n          case 0x31:\n          case 0x32:\n          case 0x33:\n          case 0x34:\n          case 0x35:\n          case 0x36:\n          case 0x37:\n          case 0x38:\n          case 0x39:\n          case 0x3a:\n          case 0x41:\n          case 0x42:\n          case 0x43:\n          case 0x44:\n          case 0x45:\n          case 0x46:\n          case 0x47:\n          case 0x48:\n          case 0x49:\n          case 0x4a:\n          case 0x4b:\n          case 0x4c:\n          case 0x4d:\n          case 0x4e:\n          case 0x4f:\n          case 0x50:\n          case 0x51:\n          case 0x52:\n          case 0x53:\n          case 0x54:\n          case 0x55:\n          case 0x56:\n          case 0x57:\n          case 0x58:\n          case 0x59:\n          case 0x5a:\n          case 0x5d:\n          case 0x5f:\n          case 0x61:\n          case 0x62:\n          case 99:\n          case 100:\n          case 0x65:\n          case 0x66:\n          case 0x67:\n          case 0x68:\n          case 0x69:\n          case 0x6a:\n          case 0x6b:\n          case 0x6c:\n          case 0x6d:\n          case 0x6e:\n          case 0x6f:\n          case 0x70:\n          case 0x71:\n          case 0x72:\n          case 0x73:\n          case 0x74:\n          case 0x75:\n          case 0x76:\n          case 0x77:\n          case 0x78:\n          case 0x79:\n          case 0x7a:\n            goto LAB_00106cf8;\n          case 0x27:\n            goto switchD_001072f0_caseD_27;\n          case 0x3f:\n            goto switchD_001072f0_caseD_3f;\n          case 0x5c:\n            goto switchD_00106ce8_caseD_5c;\n          case 0x7b:\n          case 0x7d:\n            goto switchD_001072f0_caseD_7b;\n          }\n        }\n        goto LAB_001070be;\n      }\nLAB_00107420:\n      uVar15 = (ulong)*__s1;\n      switch(uVar15) {\n      case 0:\nswitchD_00107440_caseD_0:\n        if (!bVar20) {\n          bVar5 = false;\nswitchD_00106ce8_caseD_0:\n          bVar24 = param_5 == 2;\n          bVar3 = (bool)((bVar2 ^ 1U) & bVar24);\n          if (bVar3) {\n            if (uVar18 < param_2) {\n              param_1[uVar18] = 0x27;\n            }\n            if (uVar18 + 1 < param_2) {\n              param_1[uVar18 + 1] = 0x24;\n            }\n            if (uVar18 + 2 < param_2) {\n              param_1[uVar18 + 2] = 0x27;\n            }\n            uVar15 = uVar18 + 3;\n            bVar2 = bVar3;\n            if (param_2 <= uVar18 + 3) {\n              bVar14 = 0x30;\n              uVar18 = uVar18 + 4;\n              bVar22 = bVar3;\n              bVar21 = false;\n              goto joined_r0x00106ddb;\n            }\nLAB_0010787b:\n            param_1[uVar15] = 0x5c;\n            uVar18 = uVar15;\n          }\n          else {\n            uVar15 = uVar18;\n            if (uVar18 < param_2) goto LAB_0010787b;\n          }\n          uVar19 = uVar18 + 1;\n          bVar22 = bVar21;\n          if (param_5 != 2) {\n            uVar15 = 0x30;\n            if ((uVar13 + 1 < param_4) && ((byte)(param_3[uVar13 + 1] - 0x30U) < 10)) {\n              if (uVar19 < param_2) {\n                param_1[uVar19] = 0x30;\n              }\n              if (uVar18 + 2 < param_2) {\n                param_1[uVar18 + 2] = 0x30;\n              }\n              uVar19 = uVar18 + 3;\n              uVar15 = 0x30;\n            }\n            goto LAB_001078b8;\n          }\n          bVar14 = 0x30;\n          uVar18 = uVar19;\n          bVar3 = bVar2;\n          bVar21 = false;\n          goto joined_r0x00106ddb;\n        }\n        bVar24 = param_5 == 2;\n        goto LAB_001070b0;\n      default:\n        bVar23 = false;\n        goto switchD_001072f0_caseD_1;\n      case 7:\nswitchD_00107440_caseD_7:\n        bVar14 = 0x61;\n        break;\n      case 8:\nswitchD_00107440_caseD_8:\n        bVar14 = 0x62;\n        break;\n      case 9:\n        bVar23 = false;\nswitchD_00106ce8_caseD_9:\n        uVar15 = 9;\n        bVar14 = 0x74;\n        goto LAB_001071c0;\n      case 10:\nswitchD_00107440_caseD_a:\n        bVar14 = 0x6e;\n        goto LAB_00107200;\n      case 0xb:\nswitchD_00107440_caseD_b:\n        bVar14 = 0x76;\n        goto LAB_00107200;\n      case 0xc:\nswitchD_00107440_caseD_c:\n        bVar14 = 0x66;\n        break;\n      case 0xd:\nswitchD_00107440_caseD_d:\n        bVar14 = 0x72;\n        goto LAB_00107200;\n      case 0x20:\n        bVar5 = false;\nLAB_00107469:\n        uVar15 = 0x20;\n        goto LAB_00106cf8;\n      case 0x21:\n      case 0x22:\n      case 0x24:\n      case 0x26:\n      case 0x28:\n      case 0x29:\n      case 0x2a:\n      case 0x3b:\n      case 0x3c:\n      case 0x3d:\n      case 0x3e:\n      case 0x5b:\n      case 0x5e:\n      case 0x60:\n      case 0x7c:\n        bVar5 = false;\nswitchD_00106ce8_caseD_21:\n        bVar22 = false;\n        goto LAB_00106db5;\n      case 0x23:\n      case 0x7e:\n        bVar5 = false;\nLAB_00107451:\n        if (uVar13 == 0) {\n          bVar22 = false;\n          goto LAB_00106db8;\n        }\n        bVar23 = false;\n        bVar22 = false;\n        goto LAB_00106d00;\n      case 0x25:\n      case 0x2b:\n      case 0x2c:\n      case 0x2d:\n      case 0x2e:\n      case 0x2f:\n      case 0x30:\n      case 0x31:\n      case 0x32:\n      case 0x33:\n      case 0x34:\n      case 0x35:\n      case 0x36:\n      case 0x37:\n      case 0x38:\n      case 0x39:\n      case 0x3a:\n      case 0x41:\n      case 0x42:\n      case 0x43:\n      case 0x44:\n      case 0x45:\n      case 0x46:\n      case 0x47:\n      case 0x48:\n      case 0x49:\n      case 0x4a:\n      case 0x4b:\n      case 0x4c:\n      case 0x4d:\n      case 0x4e:\n      case 0x4f:\n      case 0x50:\n      case 0x51:\n      case 0x52:\n      case 0x53:\n      case 0x54:\n      case 0x55:\n      case 0x56:\n      case 0x57:\n      case 0x58:\n      case 0x59:\n      case 0x5a:\n      case 0x5d:\n      case 0x5f:\n      case 0x61:\n      case 0x62:\n      case 99:\n      case 100:\n      case 0x65:\n      case 0x66:\n      case 0x67:\n      case 0x68:\n      case 0x69:\n      case 0x6a:\n      case 0x6b:\n      case 0x6c:\n      case 0x6d:\n      case 0x6e:\n      case 0x6f:\n      case 0x70:\n      case 0x71:\n      case 0x72:\n      case 0x73:\n      case 0x74:\n      case 0x75:\n      case 0x76:\n      case 0x77:\n      case 0x78:\n      case 0x79:\n      case 0x7a:\n        bVar5 = false;\nLAB_00106cf8:\n        bVar22 = false;\n        goto LAB_00106d00;\n      case 0x27:\n        bVar5 = false;\n        goto switchD_001072f0_caseD_27;\n      case 0x3f:\n        bVar5 = false;\n        goto switchD_001072f0_caseD_3f;\n      case 0x5c:\n        bVar23 = false;\nswitchD_00106ce8_caseD_5c:\n        if (((bool)(bVar1 & bVar20)) && (local_c8 != 0)) goto LAB_00107328;\n        uVar15 = 0x5c;\n        bVar14 = 0x5c;\n        goto LAB_001071c0;\n      case 0x7b:\n      case 0x7d:\n        bVar5 = false;\n        goto switchD_001072f0_caseD_7b;\n      }\n      if (bVar20) goto LAB_00107220;\n      bVar21 = false;\n      goto LAB_00106d76;\n    }\n    if ((uVar18 == 0) && ((bool)(bVar20 & param_5 == 2))) {\nLAB_001070a7:\n      param_5 = 2;\nLAB_001070b0:\n      if (bVar24) {\n        param_5 = 4;\n      }\nLAB_001070be:\n      uVar13 = quotearg_buffer_restyled\n                         (param_1,param_2,param_3,param_4,param_5,param_6 & 0xfffffffd,0,local_70,\n                          local_78);\n      goto LAB_001070f8;\n    }\n    bVar21 = (bool)(param_5 == 2 & (bVar20 ^ 1U));\n    bVar20 = (bool)(bVar20 ^ 1U);\n    if ((!bVar21) || (bVar20 = bVar21, !bVar4)) {\nLAB_00107b45:\n      uVar13 = uVar18;\n      if (((local_98 != (char *)0x0) && (bVar20)) && (cVar11 = *local_98, cVar11 != '\\0')) {\n        do {\n          if (uVar13 < param_2) {\n            param_1[uVar13] = cVar11;\n          }\n          uVar13 = uVar13 + 1;\n          cVar11 = local_98[uVar13 - uVar18];\n        } while (cVar11 != '\\0');\n      }\n      if (uVar13 < param_2) {\n        param_1[uVar13] = 0;\n      }\nLAB_001070f8:\n      if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n        return uVar13;\n      }\n                    /* WARNING: Subroutine does not return */\n      __stack_chk_fail();\n    }\n    if (bVar6) {\n      uVar13 = quotearg_buffer_restyled\n                         (param_1,local_90,param_3,param_4,5,param_6,param_7,local_70,local_78);\n      goto LAB_001070f8;\n    }\n    local_64 = param_2 == 0 && local_90 != 0;\n    uVar13 = local_90;\n    bVar20 = bVar4;\n    if (param_2 != 0 || local_90 == 0) goto LAB_00107b45;\nLAB_001074d6:\n    *param_1 = 0x27;\n    param_2 = local_90;\n    local_90 = uVar13;\nLAB_00106f39:\n    bVar20 = false;\n    uVar18 = 1;\n    param_5 = 2;\n    local_c8 = 1;\n    local_98 = \"\\'\";\n  } while( true );\ncode_r0x001073db:\n  uVar13 = uVar13 + 1;\n  goto LAB_00106be0;\nswitchD_00107a3e_caseD_21:\n  if (!bVar20) {\n    if (uVar18 < param_2) {\n      param_1[uVar18] = 0x3f;\n    }\n    if (uVar18 + 1 < param_2) {\n      param_1[uVar18 + 1] = 0x22;\n    }\n    if (uVar18 + 2 < param_2) {\n      param_1[uVar18 + 2] = 0x22;\n    }\n    if (uVar18 + 3 < param_2) {\n      param_1[uVar18 + 3] = 0x3f;\n    }\n    uVar19 = uVar18 + 4;\n    bVar24 = false;\n    bVar22 = false;\nLAB_001078b8:\n    bVar14 = (byte)uVar15;\n    bVar23 = false;\n    bVar21 = false;\n    uVar13 = uVar17;\n    uVar18 = uVar19;\n    bVar3 = bVar2;\n    if ((bool)(bVar1 ^ 1U | bVar24)) goto joined_r0x00106ddb;\n    goto LAB_00106d00;\n  }\n  goto LAB_001070be;\njoined_r0x00107ada:\n  while ((uVar19 < param_4 && (param_3[uVar19] != '\\0'))) {\n    uVar17 = uVar17 + 1;\n    uVar19 = uVar13 + uVar17;\n  }\n  bVar21 = false;\nLAB_001076c8:\n  if (1 < uVar17) {\nLAB_001076d2:\n    bVar24 = false;\n    uVar17 = uVar17 + uVar13;\n    uVar19 = uVar13;\n    do {\n      bVar14 = (byte)uVar15;\n      if (bVar22) {\n        bVar24 = param_5 == 2;\n        if (bVar20) goto LAB_001070b0;\n        bVar24 = (bool)(bVar24 & (bVar3 ^ 1U));\n        if (bVar24) {\n          if (uVar18 < param_2) {\n            param_1[uVar18] = 0x27;\n          }\n          if (uVar18 + 1 < param_2) {\n            param_1[uVar18 + 1] = 0x24;\n          }\n          if (uVar18 + 2 < param_2) {\n            param_1[uVar18 + 2] = 0x27;\n          }\n          uVar18 = uVar18 + 3;\n          bVar3 = bVar24;\n        }\n        if (uVar18 < param_2) {\n          param_1[uVar18] = 0x5c;\n        }\n        if (uVar18 + 1 < param_2) {\n          param_1[uVar18 + 1] = (char)(uVar15 >> 6) + '0';\n        }\n        if (uVar18 + 2 < param_2) {\n          param_1[uVar18 + 2] = ((byte)(uVar15 >> 3) & 7) + 0x30;\n        }\n        uVar13 = uVar19 + 1;\n        uVar18 = uVar18 + 3;\n        bVar14 = (bVar14 & 7) + 0x30;\n        bVar24 = bVar22;\n        if (uVar17 <= uVar13) goto LAB_00106d88;\n      }\n      else {\n        bVar2 = (bool)((bVar24 ^ 1U) & bVar3);\n        if (bVar23) {\n          if (uVar18 < param_2) {\n            param_1[uVar18] = 0x5c;\n          }\n          uVar18 = uVar18 + 1;\n        }\n        uVar13 = uVar19 + 1;\n        if (uVar17 <= uVar13) goto LAB_00107340;\n        if (bVar2) {\n          if (uVar18 < param_2) {\n            param_1[uVar18] = 0x27;\n          }\n          if (uVar18 + 1 < param_2) {\n            param_1[uVar18 + 1] = 0x27;\n          }\n          uVar18 = uVar18 + 2;\n          bVar23 = false;\n          bVar3 = false;\n        }\n        else {\n          bVar23 = false;\n        }\n      }\n      uVar19 = uVar19 + 1;\n      if (uVar18 < param_2) {\n        param_1[uVar18] = bVar14;\n      }\n      uVar15 = (ulong)(byte)param_3[uVar19];\n      uVar18 = uVar18 + 1;\n    } while( true );\n  }\nLAB_00106e51:\n  bVar5 = bVar23;\n  if (bVar22) {\n    bVar21 = false;\n    bVar22 = bVar1;\n    goto LAB_001076d2;\n  }\nswitchD_001072f0_caseD_25:\n  bVar22 = param_5 == 2;\n  bVar23 = bVar21;\nLAB_00106db8:\n  bVar14 = (byte)uVar15;\n  bVar22 = (bool)(bVar22 | bVar1 ^ 1U);\n  if ((!bVar22) || (bVar22 = false, bVar21 = bVar23, bVar20)) {\nLAB_00106d00:\n    bVar14 = (byte)uVar15;\n    uVar17 = uVar13;\n    bVar3 = bVar2;\n    bVar21 = bVar23;\n    if ((param_7 == 0) || ((*(uint *)(param_7 + (uVar15 >> 5) * 4) >> (bVar14 & 0x1f) & 1) == 0))\n    goto joined_r0x00106ddb;\n  }\n  else {\nLAB_00106dd8:\n    uVar17 = uVar13;\n    bVar22 = false;\njoined_r0x00106ddb:\n    uVar13 = uVar17;\n    bVar2 = bVar3;\n    if (!bVar5) {\n      uVar13 = uVar17 + 1;\n      bVar2 = (bool)((bVar22 ^ 1U) & bVar3);\nLAB_00107340:\n      if (bVar2) {\n        if (uVar18 < param_2) {\n          param_1[uVar18] = 0x27;\n        }\n        if (uVar18 + 1 < param_2) {\n          param_1[uVar18 + 1] = 0x27;\n        }\n        uVar18 = uVar18 + 2;\n        bVar3 = false;\n      }\n      goto LAB_00106d88;\n    }\n  }\njoined_r0x00107211:\n  if (bVar20) {\nLAB_00107220:\n    bVar24 = (bool)(bVar1 & param_5 == 2);\n    goto LAB_001070b0;\n  }\n  bVar24 = (bool)((bVar2 ^ 1U) & param_5 == 2);\n  if (bVar24) {\n    if (uVar18 < param_2) {\n      param_1[uVar18] = 0x27;\n    }\n    if (uVar18 + 1 < param_2) {\n      param_1[uVar18 + 1] = 0x24;\n    }\n    if (uVar18 + 2 < param_2) {\n      param_1[uVar18 + 2] = 0x27;\n    }\n    uVar18 = uVar18 + 3;\n    bVar2 = bVar24;\n  }\nLAB_00106d76:\n  if (uVar18 < param_2) {\n    param_1[uVar18] = 0x5c;\n  }\n  uVar18 = uVar18 + 1;\n  uVar13 = uVar13 + 1;\n  bVar3 = bVar2;\nLAB_00106d88:\n  bVar2 = bVar3;\n  if (uVar18 < param_2) {\n    param_1[uVar18] = bVar14;\n  }\n  uVar18 = uVar18 + 1;\n  if (!bVar21) {\n    bVar6 = false;\n  }\n  goto LAB_00106be0;\n}\n\n", 
    "00102600": "\nvoid context_type_get(void)\n\n{\n  (*(code *)PTR_context_type_get_00112d40)();\n  return;\n}\n\n", 
    "00102af5": "\nvoid hash_get_first_cold(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "001140b0": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid getopt_long(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* getopt_long@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001141d0": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fflush(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fflush@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00108e90": "\nvoid x2realloc(undefined8 param_1,undefined8 param_2)\n\n{\n  x2nrealloc(param_1,param_2,1);\n  return;\n}\n\n", 
    "00102af0": "\nvoid safe_hasher_cold(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "00103be0": "\nuint defaultcon(char *param_1,undefined4 param_2)\n\n{\n  int iVar1;\n  uint uVar2;\n  uint uVar3;\n  char *pcVar4;\n  long lVar5;\n  long lVar6;\n  long lVar7;\n  int *piVar8;\n  undefined8 uVar9;\n  undefined8 uVar10;\n  uint *puVar11;\n  ulong extraout_RDX;\n  undefined8 extraout_RDX_00;\n  ulong uVar12;\n  long *plVar13;\n  char *pcVar14;\n  long in_FS_OFFSET;\n  char *pcStack_90;\n  undefined8 uStack_88;\n  long lStack_78;\n  undefined8 local_40;\n  undefined8 local_38;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  local_40 = 0;\n  local_38 = 0;\n  if (*param_1 == '/') {\n    pcVar4 = param_1;\n    pcVar14 = (char *)0x0;\n  }\n  else {\n    pcVar4 = (char *)canonicalize_filename_mode(param_1,2);\n    pcVar14 = pcVar4;\n    if (pcVar4 == (char *)0x0) {\n      uVar9 = quotearg_style(4,param_1);\n      uVar10 = dcgettext(0,\"error canonicalizing %s\",5);\n      puVar11 = (uint *)__errno_location();\n      pcVar4 = (char *)0x1;\n      uVar2 = *puVar11;\n      error(1,uVar2,uVar10,uVar9);\n      lStack_78 = *(long *)(in_FS_OFFSET + 0x28);\n      if ((*pcVar4 == '/') || ((char)extraout_RDX != '\\0')) {\n        pcStack_90 = pcVar4;\n        pcVar14 = (char *)0x0;\n      }\n      else {\n        pcStack_90 = (char *)canonicalize_filename_mode();\n        pcVar14 = pcStack_90;\n        if (pcStack_90 == (char *)0x0) {\n          uVar9 = quotearg_style(4,pcVar4);\n          uVar10 = dcgettext(0,\"error canonicalizing %s\",5);\n          puVar11 = (uint *)__errno_location();\n          plVar13 = (long *)0x1;\n          uVar12 = (ulong)*puVar11;\n          error(1,uVar12,uVar10,uVar9);\n          lVar5 = *plVar13;\n          if (lVar5 == 0) {\n            lVar5 = hash_initialize(7,0,triple_hash,triple_compare_ino_str,triple_free);\n            *plVar13 = lVar5;\n            if (lVar5 == 0) {\n                    /* WARNING: Subroutine does not return */\n              xalloc_die(0);\n            }\n          }\n          uVar2 = seen_file(lVar5,uVar12,extraout_RDX_00);\n          if ((char)uVar2 == '\\0') {\n            record_file(*plVar13,uVar12,extraout_RDX_00);\n          }\n          return uVar2;\n        }\n      }\n      uStack_88 = 0;\n      if ((char)uVar2 == '\\0') {\n        iVar1 = restorecon_private();\n        uVar2 = uVar2 & 0xffffff00 | (uint)(iVar1 != -1);\n        free(pcVar14);\n      }\n      else {\n        lVar5 = xfts_open(&pcStack_90,0x10,0);\n        while (lVar6 = fts_read(lVar5), lVar6 != 0) {\n          uVar3 = restorecon_private(*(undefined8 *)(lVar5 + 0x20),extraout_RDX & 0xff);\n          uVar2 = uVar2 & (uVar3 & 0xffffff00 | (uint)(uVar3 != 0xffffffff));\n        }\n        piVar8 = __errno_location();\n        if (*piVar8 == 0) {\n          iVar1 = fts_close(lVar5);\n        }\n        else {\n          uVar2 = 0;\n          uVar9 = dcgettext(0,\"fts_read failed\",5);\n          error(0,*piVar8,uVar9);\n          iVar1 = fts_close(lVar5);\n        }\n        if (iVar1 != 0) {\n          uVar2 = 0;\n          uVar9 = dcgettext(0,\"fts_close failed\",5);\n          error(0,*piVar8,uVar9);\n        }\n        free(pcVar14);\n      }\n      if (lStack_78 == *(long *)(in_FS_OFFSET + 0x28)) {\n        return uVar2;\n      }\n                    /* WARNING: Subroutine does not return */\n      __stack_chk_fail();\n    }\n  }\n  iVar1 = matchpathcon(pcVar4,param_2,&local_40);\n  if (iVar1 < 0) {\n    piVar8 = __errno_location();\n    if (*piVar8 == 2) {\n      *piVar8 = 0x3d;\n    }\n  }\n  else {\n    iVar1 = computecon(pcVar4,param_2,&local_38);\n    if ((-1 < iVar1) && (lVar5 = context_new(local_40), lVar5 != 0)) {\n      lVar6 = context_new(local_38);\n      if ((lVar6 == 0) ||\n         (((lVar7 = context_type_get(lVar5), lVar7 == 0 ||\n           (iVar1 = context_type_set(lVar6,lVar7), iVar1 != 0)) ||\n          (lVar7 = context_str(lVar6), lVar7 == 0)))) {\n        uVar2 = 0xffffffff;\n      }\n      else {\n        uVar2 = setfscreatecon(lVar7);\n      }\n      goto LAB_00103ccd;\n    }\n  }\n  lVar6 = 0;\n  lVar5 = 0;\n  uVar2 = 0xffffffff;\nLAB_00103ccd:\n  context_free(lVar5);\n  context_free(lVar6);\n  freecon(local_40);\n  freecon(local_38);\n  free(pcVar14);\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "0010bb70": "\nvoid rpl_fgetfilecon(undefined8 param_1,undefined8 param_2)\n\n{\n  undefined4 uVar1;\n  \n  uVar1 = fgetfilecon();\n  map_to_failure(uVar1,param_2);\n  return;\n}\n\n", 
    "00108260": "\nvoid quotearg_style_mem(undefined4 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  quotearg_n_style_mem(0,param_1,param_2,param_3);\n  return;\n}\n\n", 
    "0010c130": "\nvoid open_safer(char *param_1,uint param_2,ulong param_3)\n\n{\n  long lVar1;\n  int iVar2;\n  ulong uVar3;\n  long in_FS_OFFSET;\n  \n  uVar3 = 0;\n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((param_2 & 0x40) != 0) {\n    uVar3 = param_3 & 0xffffffff;\n  }\n  iVar2 = open(param_1,param_2,uVar3);\n  fd_safer(iVar2);\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "001140b8": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t mbrtowc(wchar_t *__pwc,char *__s,size_t __n,mbstate_t *__p)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* mbrtowc@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001141d8": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * nl_langinfo(nl_item __item)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* nl_langinfo@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00102950": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fchdir(int __fd)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_fchdir_00112ee8)();\n  return iVar1;\n}\n\n", 
    "00102830": "\nvoid lgetfilecon(void)\n\n{\n  (*(code *)PTR_lgetfilecon_00112e58)();\n  return;\n}\n\n", 
    "00102710": "\nvoid context_type_set(void)\n\n{\n  (*(code *)PTR_context_type_set_00112dc8)();\n  return;\n}\n\n", 
    "00102aa0": "\nvoid context_str(void)\n\n{\n  (*(code *)PTR_context_str_00112f90)();\n  return;\n}\n\n", 
    "001142c0": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nushort ** __ctype_b_loc(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __ctype_b_loc@@GLIBC_2.3 */\n  halt_baddata();\n}\n\n", 
    "001141a0": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint __xmknod(int __ver,char *__path,__mode_t __mode,__dev_t *__dev)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __xmknod@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00108330": "\nvoid quotearg_colon(undefined8 param_1)\n\n{\n  quotearg_char(param_1,0x3a);\n  return;\n}\n\n", 
    "00106030": "\nundefined8 mode_create_from_ref(char *param_1)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  long in_FS_OFFSET;\n  stat sStack_a8;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = stat(param_1,&sStack_a8);\n  uVar2 = 0;\n  if (iVar1 == 0) {\n    uVar2 = make_node_op_equals(sStack_a8.st_mode,0xfff);\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "0010ac90": "\nlong * fts_open(char **param_1,uint param_2,long param_3)\n\n{\n  undefined4 uVar1;\n  char cVar2;\n  undefined2 uVar3;\n  uint uVar4;\n  int iVar5;\n  long *__ptr;\n  ulong uVar6;\n  char *__ptr_00;\n  long lVar7;\n  size_t sVar8;\n  long lVar9;\n  long lVar10;\n  int *piVar11;\n  char *__s;\n  ulong uVar12;\n  byte local_42;\n  long local_40;\n  \n  if ((((param_2 & 0xffffe000) != 0) || ((param_2 & 0x204) == 0x204)) || ((param_2 & 0x12) == 0)) {\n    piVar11 = __errno_location();\n    *piVar11 = 0x16;\n    return (long *)0x0;\n  }\n  __ptr = (long *)calloc(0x80,1);\n  if (__ptr == (long *)0x0) {\n    return (long *)0x0;\n  }\n  __ptr[8] = param_3;\n  *(undefined4 *)((long)__ptr + 0x2c) = 0xffffff9c;\n  uVar4 = param_2 & 0xfffffdff | 4;\n  if ((param_2 & 2) == 0) {\n    uVar4 = param_2;\n  }\n  *(uint *)(__ptr + 9) = uVar4;\n  uVar6 = fts_maxarglen(param_1);\n  uVar12 = 0x1000;\n  if (0xfff < uVar6) {\n    uVar12 = uVar6;\n  }\n  local_42 = fts_palloc_isra_0(__ptr + 4,__ptr + 6,uVar12);\n  if (local_42 == 0) goto LAB_0010af42;\n  __ptr_00 = *param_1;\n  if (__ptr_00 == (char *)0x0) {\n    if (param_3 != 0) {\n      __s = (char *)0x0;\nLAB_0010ad88:\n      local_42 = (byte)(*(uint *)(__ptr + 9) >> 10) & 1;\n      goto LAB_0010ad97;\n    }\nLAB_0010afd7:\n    lVar9 = 0;\nLAB_0010aeaf:\n    lVar10 = fts_alloc(__ptr,\"\",0);\n    *__ptr = lVar10;\n    if (lVar10 != 0) {\n      *(long *)(lVar10 + 0x10) = lVar9;\n      uVar1 = *(undefined4 *)(__ptr + 9);\n      *(undefined2 *)(lVar10 + 0x70) = 9;\n      *(undefined8 *)(lVar10 + 0x58) = 1;\n      cVar2 = setup_dir_isra_0(uVar1,__ptr + 0xb);\n      if (cVar2 != '\\0') {\n        if ((*(uint *)(__ptr + 9) & 0x204) == 0) {\n          iVar5 = diropen_isra_0(*(undefined4 *)((long)__ptr + 0x2c),*(uint *)(__ptr + 9),\n                                 &DAT_0010e6c4);\n          *(int *)(__ptr + 5) = iVar5;\n          if (iVar5 < 0) {\n            *(uint *)(__ptr + 9) = *(uint *)(__ptr + 9) | 4;\n          }\n        }\n        i_ring_init(__ptr + 0xc,0xffffffff);\n        return __ptr;\n      }\n    }\nLAB_0010af28:\n    fts_lfree(lVar9);\n    free(__ptr_00);\n  }\n  else {\n    __ptr_00 = (char *)fts_alloc(__ptr,\"\",0);\n    if (__ptr_00 != (char *)0x0) {\n      *(undefined8 *)(__ptr_00 + 0x58) = 0xffffffffffffffff;\n      __s = *param_1;\n      *(undefined8 *)(__ptr_00 + 0x68) = 0xffffffffffffffff;\n      if (param_3 != 0) goto LAB_0010ad88;\nLAB_0010ad97:\n      if (__s == (char *)0x0) goto LAB_0010afd7;\n      local_40 = 0;\n      uVar12 = 0;\n      lVar10 = 0;\n      do {\n        sVar8 = strlen(__s);\n        if (((2 < sVar8) && ((((byte)(param_2 >> 0xc) ^ 1) & 1) != 0)) && (__s[sVar8 - 1] == '/')) {\n          do {\n            if (__s[sVar8 - 2] != '/') break;\n            sVar8 = sVar8 - 1;\n          } while (sVar8 != 1);\n        }\n        lVar7 = fts_alloc(__ptr);\n        lVar9 = lVar10;\n        if (lVar7 == 0) goto LAB_0010af28;\n        *(undefined8 *)(lVar7 + 0x58) = 0;\n        *(char **)(lVar7 + 8) = __ptr_00;\n        *(long *)(lVar7 + 0x30) = lVar7 + 0x108;\n        lVar9 = lVar7;\n        if ((lVar10 == 0) || (local_42 == 0)) {\n          uVar3 = fts_stat(__ptr,lVar7,0);\n          *(undefined2 *)(lVar7 + 0x70) = uVar3;\n          if (param_3 != 0) goto LAB_0010ae25;\n          *(undefined8 *)(lVar7 + 0x10) = 0;\n          if (lVar10 != 0) goto LAB_0010af98;\n        }\n        else {\n          *(undefined2 *)(lVar7 + 0x70) = 0xb;\n          fts_set_stat_required(lVar7,1);\n          if (param_3 == 0) {\n            *(undefined8 *)(lVar7 + 0x10) = 0;\nLAB_0010af98:\n            *(long *)(local_40 + 0x10) = lVar7;\n            lVar9 = lVar10;\n          }\n          else {\nLAB_0010ae25:\n            *(long *)(lVar7 + 0x10) = lVar10;\n            lVar7 = local_40;\n          }\n        }\n        local_40 = lVar7;\n        uVar12 = uVar12 + 1;\n        __s = param_1[uVar12];\n        lVar10 = lVar9;\n      } while (__s != (char *)0x0);\n      if ((param_3 != 0) && (1 < uVar12)) {\n        lVar9 = fts_sort(__ptr,lVar9,uVar12);\n      }\n      goto LAB_0010aeaf;\n    }\n  }\n  free((void *)__ptr[4]);\nLAB_0010af42:\n  free(__ptr);\n  return (long *)0x0;\n}\n\n", 
    "0010bd80": "\nuint rotr16(uint param_1,byte param_2)\n\n{\n  return param_1 & 0xffff0000 |\n         (uint)(ushort)((ushort)param_1 >> (param_2 & 0xf) |\n                       (ushort)param_1 << 0x10 - (param_2 & 0xf));\n}\n\n", 
    "001032a0": "\nvoid _start(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 unaff_retaddr;\n  undefined auStack_8 [8];\n  \n  (*(code *)PTR___libc_start_main_00112fc8)\n            (main,unaff_retaddr,&stack0x00000008,__libc_csu_init,__libc_csu_fini,param_3,auStack_8);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n", 
    "001056c0": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined8 hash_insert_if_absent(long param_1,long param_2,long *param_3)\n\n{\n  char cVar1;\n  long lVar2;\n  long *plVar3;\n  ulong uVar4;\n  undefined8 uVar5;\n  long in_FS_OFFSET;\n  float fVar6;\n  float fVar7;\n  undefined local_38;\n  undefined7 uStack_37;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_2 == 0) {\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  lVar2 = hash_find_entry(param_1,param_2,&local_38,0);\n  if (lVar2 != 0) {\n    uVar5 = 0;\n    if (param_3 != (long *)0x0) {\n      *param_3 = lVar2;\n    }\n    goto LAB_0010570e;\n  }\n  uVar4 = *(ulong *)(param_1 + 0x18);\n  if ((long)uVar4 < 0) {\n    fVar7 = (float)(uVar4 >> 1 | (ulong)((uint)uVar4 & 1));\n    fVar7 = fVar7 + fVar7;\n  }\n  else {\n    fVar7 = (float)uVar4;\n  }\n  uVar4 = *(ulong *)(param_1 + 0x10);\n  if ((long)uVar4 < 0) {\n    fVar6 = (float)(uVar4 >> 1 | (ulong)((uint)uVar4 & 1));\n    fVar6 = fVar6 + fVar6;\n  }\n  else {\n    fVar6 = (float)uVar4;\n  }\n  if (fVar6 * *(float *)(*(long *)(param_1 + 0x28) + 8) < fVar7) {\n    check_tuning_isra_0(param_1 + 0x28);\n    lVar2 = *(long *)(param_1 + 0x28);\n    uVar4 = *(ulong *)(param_1 + 0x10);\n    if ((long)uVar4 < 0) {\n      fVar7 = (float)(uVar4 >> 1 | (ulong)((uint)uVar4 & 1));\n      fVar7 = fVar7 + fVar7;\n    }\n    else {\n      fVar7 = (float)uVar4;\n    }\n    uVar4 = *(ulong *)(param_1 + 0x18);\n    if ((long)uVar4 < 0) {\n      fVar6 = (float)(uVar4 >> 1 | (ulong)((uint)uVar4 & 1));\n      fVar6 = fVar6 + fVar6;\n    }\n    else {\n      fVar6 = (float)uVar4;\n    }\n    if (fVar6 <= *(float *)(lVar2 + 8) * fVar7) goto LAB_0010576a;\n    fVar7 = fVar7 * *(float *)(lVar2 + 0xc);\n    if (*(char *)(lVar2 + 0x10) == '\\0') {\n      fVar7 = fVar7 * *(float *)(lVar2 + 8);\n    }\n    if (fVar7 < _DAT_0010d938) {\n      if (_DAT_0010d93c <= fVar7) {\n        uVar4 = (long)(fVar7 - _DAT_0010d93c) ^ 0x8000000000000000;\n      }\n      else {\n        uVar4 = (ulong)fVar7;\n      }\n      cVar1 = hash_rehash(param_1,uVar4);\n      if (cVar1 != '\\0') {\n        lVar2 = hash_find_entry(param_1,param_2,&local_38,0);\n        if (lVar2 != 0) {\n          uVar5 = hash_insert_if_absent_cold();\n          return uVar5;\n        }\n        goto LAB_0010576a;\n      }\n    }\n  }\n  else {\nLAB_0010576a:\n    if (*(long *)CONCAT71(uStack_37,local_38) == 0) {\n      *(long *)CONCAT71(uStack_37,local_38) = param_2;\n      uVar5 = 1;\n      *(long *)(param_1 + 0x20) = *(long *)(param_1 + 0x20) + 1;\n      *(long *)(param_1 + 0x18) = *(long *)(param_1 + 0x18) + 1;\n      goto LAB_0010570e;\n    }\n    plVar3 = (long *)allocate_entry_isra_0(param_1 + 0x48);\n    if (plVar3 != (long *)0x0) {\n      *plVar3 = param_2;\n      uVar5 = 1;\n      plVar3[1] = *(long *)(CONCAT71(uStack_37,local_38) + 8);\n      *(long **)(CONCAT71(uStack_37,local_38) + 8) = plVar3;\n      *(long *)(param_1 + 0x20) = *(long *)(param_1 + 0x20) + 1;\n      goto LAB_0010570e;\n    }\n  }\n  uVar5 = 0xffffffff;\nLAB_0010570e:\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar5;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "0010c340": "\nvoid openat_safer(int param_1,char *param_2,uint param_3,ulong param_4)\n\n{\n  long lVar1;\n  int iVar2;\n  ulong uVar3;\n  long in_FS_OFFSET;\n  \n  uVar3 = 0;\n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((param_3 & 0x40) != 0) {\n    uVar3 = param_4 & 0xffffffff;\n  }\n  iVar2 = openat(param_1,param_2,param_3,uVar3);\n  fd_safer(iVar2);\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "001142c8": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __cxa_finalize(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __cxa_finalize@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00102900": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * malloc(size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = (void *)(*(code *)PTR_malloc_00112ec0)();\n  return pvVar1;\n}\n\n", 
    "0010b010": "\nundefined4 fts_close(void **param_1)\n\n{\n  void **ppvVar1;\n  void *__ptr;\n  void *pvVar2;\n  long lVar3;\n  int iVar4;\n  int iVar5;\n  int *piVar6;\n  \n  __ptr = *param_1;\n  if (__ptr != (void *)0x0) {\n    lVar3 = *(long *)((long)__ptr + 0x58);\n    while (-1 < lVar3) {\n      pvVar2 = *(void **)((long)__ptr + 0x10);\n      if (pvVar2 == (void *)0x0) {\n        pvVar2 = *(void **)((long)__ptr + 8);\n        free(__ptr);\n        lVar3 = *(long *)((long)pvVar2 + 0x58);\n        __ptr = pvVar2;\n      }\n      else {\n        free(__ptr);\n        lVar3 = *(long *)((long)pvVar2 + 0x58);\n        __ptr = pvVar2;\n      }\n    }\n    free(__ptr);\n  }\n  if (param_1[1] != (void *)0x0) {\n    fts_lfree();\n  }\n  ppvVar1 = param_1 + 0xc;\n  free(param_1[2]);\n  free(param_1[4]);\n  if ((*(uint *)(param_1 + 9) & 0x200) == 0) {\n    if ((*(uint *)(param_1 + 9) & 4) == 0) {\n      iVar4 = fchdir(*(int *)(param_1 + 5));\n      if (iVar4 != 0) {\n        piVar6 = __errno_location();\n        iVar4 = *piVar6;\n        iVar5 = close(*(int *)(param_1 + 5));\n        if (iVar5 == 0) goto LAB_0010b15d;\n        if (iVar4 == 0) goto LAB_0010b118;\n        fd_ring_clear(ppvVar1);\n        if (param_1[10] == (void *)0x0) {\n          free_dir_isra_0(*(undefined4 *)(param_1 + 9),param_1[0xb]);\n          free(param_1);\n          goto LAB_0010b1cf;\n        }\n        goto LAB_0010b0bc;\n      }\n      iVar4 = close(*(int *)(param_1 + 5));\n      if (iVar4 != 0) {\n        piVar6 = __errno_location();\nLAB_0010b118:\n        iVar4 = *piVar6;\n        goto LAB_0010b15d;\n      }\n    }\nLAB_0010b0a7:\n    iVar4 = 0;\n    fd_ring_clear(ppvVar1);\n    if (param_1[10] == (void *)0x0) {\n      free_dir_isra_0(*(undefined4 *)(param_1 + 9),param_1[0xb]);\n      free(param_1);\n      return 0;\n    }\nLAB_0010b0bc:\n    hash_free();\n  }\n  else {\n    if ((*(int *)((long)param_1 + 0x2c) < 0) ||\n       (iVar4 = close(*(int *)((long)param_1 + 0x2c)), iVar4 == 0)) goto LAB_0010b0a7;\n    piVar6 = __errno_location();\n    iVar4 = *piVar6;\nLAB_0010b15d:\n    fd_ring_clear(ppvVar1);\n    if (param_1[10] != (void *)0x0) goto LAB_0010b0bc;\n  }\n  free_dir_isra_0(*(undefined4 *)(param_1 + 9),param_1[0xb]);\n  free(param_1);\n  if (iVar4 == 0) {\n    return 0;\n  }\n  piVar6 = __errno_location();\nLAB_0010b1cf:\n  *piVar6 = iVar4;\n  return 0xffffffff;\n}\n\n", 
    "001141a8": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fileno(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fileno@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001141b0": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint __xstat(int __ver,char *__filename,stat *__stat_buf)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __xstat@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001142d0": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid free(void *__ptr)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* free@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00108f90": "\nvoid xfts_open(undefined8 param_1,uint param_2)\n\n{\n  long lVar1;\n  int *piVar2;\n  \n  lVar1 = fts_open(param_1,param_2 | 0x200);\n  if (lVar1 != 0) {\n    return;\n  }\n  piVar2 = __errno_location();\n  if (*piVar2 != 0x16) {\n                    /* WARNING: Subroutine does not return */\n    xalloc_die();\n  }\n                    /* WARNING: Subroutine does not return */\n  __assert_fail(\"errno != EINVAL\",\"lib/xfts.c\",0x29,\"xfts_open\");\n}\n\n", 
    "00108d50": "\nvoid xnmalloc(ulong param_1,ulong param_2)\n\n{\n  if ((-1 < SUB168(ZEXT816(param_1) * ZEXT816(param_2),0)) &&\n     (SUB168(ZEXT816(param_1) * ZEXT816(param_2) >> 0x40,0) == 0)) {\n    xmalloc();\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  xalloc_die();\n}\n\n", 
    "00109d20": "\nundefined8 fts_palloc_isra_0(void **param_1,size_t *param_2,long param_3)\n\n{\n  size_t __size;\n  void *pvVar1;\n  int *piVar2;\n  \n  pvVar1 = *param_1;\n  __size = *param_2 + 0x100 + param_3;\n  if (__size < *param_2) {\n    free(pvVar1);\n    *param_1 = (void *)0x0;\n    piVar2 = __errno_location();\n    *piVar2 = 0x24;\n    return 0;\n  }\n  *param_2 = __size;\n  pvVar1 = realloc(pvVar1,__size);\n  if (pvVar1 != (void *)0x0) {\n    *param_1 = pvVar1;\n    return 1;\n  }\n  free(*param_1);\n  *param_1 = (void *)0x0;\n  return 0;\n}\n\n", 
    "0010bb50": "\nvoid rpl_lgetfilecon(undefined8 param_1,undefined8 param_2)\n\n{\n  undefined4 uVar1;\n  \n  uVar1 = lgetfilecon();\n  map_to_failure(uVar1,param_2);\n  return;\n}\n\n", 
    "0010bd90": "\nuint rotl8(uint param_1,byte param_2)\n\n{\n  return param_1 & 0xffffff00 |\n         (uint)(byte)((byte)param_1 << (param_2 & 7) | (byte)param_1 >> 8 - (param_2 & 7));\n}\n\n", 
    "001033b0": "\nvoid emit_mandatory_arg_note(void)\n\n{\n  char *__s;\n  FILE *__stream;\n  \n  __stream = stdout;\n  __s = (char *)dcgettext(0,\n                          \"\\nMandatory arguments to long options are mandatory for short options too.\\n\"\n                          ,5);\n  fputs_unlocked(__s,__stream);\n  return;\n}\n\n", 
    "00109560": "\nint fts_stat(long param_1,long param_2,char param_3)\n\n{\n  stat *__buf;\n  int iVar1;\n  uint uVar2;\n  int *piVar3;\n  ulong uVar4;\n  undefined8 *puVar5;\n  byte bVar6;\n  \n  bVar6 = 0;\n  __buf = (stat *)(param_2 + 0x78);\n  if ((((*(long *)(param_2 + 0x58) == 0) && ((*(uint *)(param_1 + 0x48) & 1) != 0)) ||\n      ((*(uint *)(param_1 + 0x48) & 2) != 0)) || (param_3 != '\\0')) {\n    iVar1 = stat(*(char **)(param_2 + 0x30),__buf);\n    if (iVar1 == 0) {\nLAB_001095ec:\n      uVar2 = *(uint *)(param_2 + 0x90) & 0xf000;\n      if (uVar2 == 0x4000) {\n        uVar4 = *(ulong *)(param_2 + 0x88);\n        if ((uVar4 < 2) || (*(long *)(param_2 + 0x58) < 1)) {\n          uVar4 = 0xffffffffffffffff;\n        }\n        else if ((*(byte *)(param_1 + 0x48) & 0x20) == 0) {\n          uVar4 = uVar4 - 2;\n        }\n        *(ulong *)(param_2 + 0x68) = uVar4;\n        iVar1 = 1;\n        if ((*(char *)(param_2 + 0x108) == '.') &&\n           ((*(char *)(param_2 + 0x109) == '\\0' ||\n            ((*(uint *)(param_2 + 0x108) & 0xffff00) == 0x2e00)))) {\n          iVar1 = (-(uint)(*(long *)(param_2 + 0x58) == 0) & 0xfffffffc) + 5;\n        }\n      }\n      else if (uVar2 == 0xa000) {\n        iVar1 = 0xc;\n      }\n      else {\n        iVar1 = (uint)(uVar2 == 0x8000) * 5 + 3;\n      }\n      return iVar1;\n    }\n    piVar3 = __errno_location();\n    iVar1 = *piVar3;\n    if (iVar1 == 2) {\n      iVar1 = lstat(*(char **)(param_2 + 0x30),__buf);\n      if (iVar1 == 0) {\n        *piVar3 = 0;\n        return 0xd;\n      }\n      iVar1 = *piVar3;\n    }\n  }\n  else {\n    iVar1 = fstatat(*(int *)(param_1 + 0x2c),*(char **)(param_2 + 0x30),__buf,0x100);\n    if (iVar1 == 0) goto LAB_001095ec;\n    piVar3 = __errno_location();\n    iVar1 = *piVar3;\n  }\n  *(int *)(param_2 + 0x40) = iVar1;\n  puVar5 = (undefined8 *)(param_2 + 0x80U & 0xfffffffffffffff8);\n  *(undefined8 *)(param_2 + 0x78) = 0;\n  *(undefined8 *)(param_2 + 0x100) = 0;\n  uVar4 = (ulong)(((int)__buf - (int)puVar5) + 0x90U >> 3);\n  for (; uVar4 != 0; uVar4 = uVar4 - 1) {\n    *puVar5 = 0;\n    puVar5 = puVar5 + (ulong)bVar6 * -2 + 1;\n  }\n  return 10;\n}\n\n", 
    "00109440": "\nulong AD_compare(ulong *param_1,ulong *param_2)\n\n{\n  if (param_1[1] != param_2[1]) {\n    return 0;\n  }\n  return *param_2 & 0xffffffffffffff00 | (ulong)(*param_1 == *param_2);\n}\n\n", 
    "001141b8": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\ndirent * readdir(DIR *__dirp)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* readdir@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00107e70": "\nuint set_char_quoting(undefined1 *param_1,byte param_2,uint param_3)\n\n{\n  uint uVar1;\n  uint uVar2;\n  \n  if (param_1 == (undefined1 *)0x0) {\n    param_1 = default_quoting_options;\n  }\n  uVar1 = *(uint *)(param_1 + (ulong)(param_2 >> 5) * 4 + 8);\n  uVar2 = uVar1 >> (param_2 & 0x1f);\n  *(uint *)(param_1 + (ulong)(param_2 >> 5) * 4 + 8) =\n       ((param_3 ^ uVar2) & 1) << (param_2 & 0x1f) ^ uVar1;\n  return uVar2 & 1;\n}\n\n", 
    "00107f90": "\nundefined8\nquotearg_alloc_mem(undefined8 param_1,undefined8 param_2,long *param_3,undefined1 *param_4)\n\n{\n  int iVar1;\n  int *piVar2;\n  long lVar3;\n  undefined8 uVar4;\n  uint uVar5;\n  \n  if ((undefined4 *)param_4 == (undefined4 *)0x0) {\n    param_4 = default_quoting_options;\n  }\n  piVar2 = __errno_location();\n  iVar1 = *piVar2;\n  uVar5 = (uint)(param_3 == (long *)0x0) | *(uint *)((long)param_4 + 4);\n  lVar3 = quotearg_buffer_restyled\n                    (0,0,param_1,param_2,*(undefined4 *)param_4,uVar5,\n                     (undefined4 *)((long)param_4 + 8),*(undefined8 *)((long)param_4 + 0x28),\n                     *(undefined8 *)((long)param_4 + 0x30));\n  uVar4 = xcharalloc(lVar3 + 1);\n  quotearg_buffer_restyled\n            (uVar4,lVar3 + 1,param_1,param_2,*(undefined4 *)param_4,uVar5,\n             (undefined4 *)((long)param_4 + 8),*(undefined8 *)((long)param_4 + 0x28),\n             *(undefined8 *)((long)param_4 + 0x30));\n  *piVar2 = iVar1;\n  if (param_3 != (long *)0x0) {\n    *param_3 = lVar3;\n  }\n  return uVar4;\n}\n\n", 
    "00104ca0": "\nvoid allocate_entry_isra_0(long *param_1)\n\n{\n  if (*param_1 != 0) {\n    *param_1 = *(long *)(*param_1 + 8);\n    return;\n  }\n  malloc(0x10);\n  return;\n}\n\n", 
    "00102ac0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nulonglong gnu_dev_makedev(uint __major,uint __minor)\n\n{\n  ulonglong uVar1;\n  \n  uVar1 = (*(code *)PTR_gnu_dev_makedev_00112fa0)();\n  return uVar1;\n}\n\n", 
    "001142a0": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid context_str(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n  halt_baddata();\n}\n\n", 
    "0010bd60": "\nvoid rotr_sz(void)\n\n{\n  rotr64();\n  return;\n}\n\n", 
    "0010be80": "\nbool c_isprint(int param_1)\n\n{\n  return param_1 - 0x20U < 0x5f;\n}\n\n", 
    "00108350": "\nvoid quotearg_n_style_colon(undefined4 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  long in_FS_OFFSET;\n  undefined8 local_98;\n  undefined8 uStack_90;\n  undefined8 local_88;\n  undefined8 uStack_80;\n  undefined8 local_78;\n  undefined8 uStack_70;\n  undefined8 local_68;\n  undefined8 local_58;\n  undefined8 uStack_50;\n  undefined8 local_48;\n  undefined8 uStack_40;\n  undefined8 local_38;\n  undefined8 uStack_30;\n  undefined8 local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  quoting_options_from_style(&local_98);\n  puVar1 = &local_58;\n  local_58 = local_98;\n  uStack_50 = uStack_90;\n  local_48 = local_88;\n  uStack_40 = uStack_80;\n  local_38 = local_78;\n  uStack_30 = uStack_70;\n  local_28 = local_68;\n  set_char_quoting(puVar1,0x3a,1);\n  quotearg_n_options(param_1,param_3,0xffffffffffffffff,puVar1);\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00105080": "\nlong hash_get_first(long **param_1)\n\n{\n  long lVar1;\n  long *plVar2;\n  \n  if (param_1[4] == (long *)0x0) {\n    return 0;\n  }\n  plVar2 = *param_1;\n  if (param_1[1] <= plVar2) {\n    lVar1 = hash_get_first_cold();\n    return lVar1;\n  }\n  do {\n    if (*plVar2 != 0) {\n      return *plVar2;\n    }\n    plVar2 = plVar2 + 2;\n  } while (plVar2 < param_1[1]);\n  lVar1 = hash_get_first_cold();\n  return lVar1;\n}\n\n", 
    "001033e0": "\nundefined8 smack_set_label_for_self_isra_0(void)\n\n{\n  return 0xffffffff;\n}\n\n", 
    "00102920": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * nl_langinfo(nl_item __item)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_nl_langinfo_00112ed0)();\n  return pcVar1;\n}\n\n", 
    "00109530": "\nvoid fts_set_stat_required(long param_1,char param_2)\n\n{\n  if (*(short *)(param_1 + 0x70) == 0xb) {\n    *(ulong *)(param_1 + 0xa8) = (ulong)(param_2 != '\\0') + 1;\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "0010a260": "\nvoid leave_dir_isra_0(uint param_1,long **param_2,long param_3)\n\n{\n  long lVar1;\n  long *plVar2;\n  void *__ptr;\n  long in_FS_OFFSET;\n  undefined8 local_28;\n  undefined8 local_20;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((param_1 & 0x102) == 0) {\n    lVar1 = *(long *)(param_3 + 8);\n    if ((lVar1 != 0) && (-1 < *(long *)(lVar1 + 0x58))) {\n      plVar2 = *param_2;\n      if (plVar2[2] == 0) goto leave_dir_isra_0_cold;\n      if ((*plVar2 == *(long *)(param_3 + 0x80)) && (plVar2[1] == *(long *)(param_3 + 0x78))) {\n        plVar2[1] = *(long *)(lVar1 + 0x78);\n        *plVar2 = *(long *)(lVar1 + 0x80);\n      }\n    }\n  }\n  else {\n    local_28 = *(undefined8 *)(param_3 + 0x78);\n    local_20 = *(undefined8 *)(param_3 + 0x80);\n    __ptr = (void *)hash_delete(*param_2,&local_28);\n    if (__ptr == (void *)0x0) {\nleave_dir_isra_0_cold:\n                    /* WARNING: Subroutine does not return */\n      abort();\n    }\n    free(__ptr);\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00102800": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fputs_unlocked(char *__s,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_fputs_unlocked_00112e40)();\n  return iVar1;\n}\n\n", 
    "0010c680": "\nint rpl_fseeko(FILE *param_1,__off_t param_2,int param_3)\n\n{\n  int iVar1;\n  __off_t _Var2;\n  \n  if (((param_1->_IO_read_end == param_1->_IO_read_ptr) &&\n      (param_1->_IO_write_ptr == param_1->_IO_write_base)) &&\n     (param_1->_IO_save_base == (char *)0x0)) {\n    iVar1 = fileno(param_1);\n    _Var2 = lseek(iVar1,param_2,param_3);\n    if (_Var2 == -1) {\n      iVar1 = -1;\n    }\n    else {\n      param_1->_flags = param_1->_flags & 0xffffffef;\n      param_1->_offset = _Var2;\n      iVar1 = 0;\n    }\n    return iVar1;\n  }\n  iVar1 = fseeko(param_1,param_2,param_3);\n  return iVar1;\n}\n\n", 
    "0010c200": "\nulong hash_pjw(char *param_1,ulong param_2)\n\n{\n  char cVar1;\n  ulong uVar2;\n  \n  cVar1 = *param_1;\n  if (cVar1 != '\\0') {\n    uVar2 = 0;\n    do {\n      param_1 = param_1 + 1;\n      uVar2 = (uVar2 << 9 | uVar2 >> 0x37) + (long)cVar1;\n      cVar1 = *param_1;\n    } while (cVar1 != '\\0');\n    return uVar2 % param_2;\n  }\n  return 0;\n}\n\n", 
    "001142a8": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint iswprint(wint_t __wc)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* iswprint@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00102ab0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint iswprint(wint_t __wc)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_iswprint_00112f98)();\n  return iVar1;\n}\n\n", 
    "001142b0": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nulonglong gnu_dev_makedev(uint __major,uint __minor)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* gnu_dev_makedev@@GLIBC_2.3.3 */\n  halt_baddata();\n}\n\n", 
    "00108d30": "\nvoid xmalloc(size_t param_1)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = malloc(param_1);\n  if ((pvVar1 == (void *)0x0) && (param_1 != 0)) {\n                    /* WARNING: Subroutine does not return */\n    xalloc_die();\n  }\n  return;\n}\n\n", 
    "00108340": "\nvoid quotearg_colon_mem(undefined8 param_1,undefined8 param_2)\n\n{\n  quotearg_char_mem(param_1,param_2,0x3a);\n  return;\n}\n\n", 
    "0010bd70": "\nuint rotl16(uint param_1,byte param_2)\n\n{\n  return param_1 & 0xffff0000 |\n         (uint)(ushort)((ushort)param_1 << (param_2 & 0xf) |\n                       (ushort)param_1 >> 0x10 - (param_2 & 0xf));\n}\n\n", 
    "0010be90": "\nulong c_ispunct(int param_1)\n\n{\n  ulong in_RAX;\n  \n  if (0x60 < param_1) {\n    return in_RAX & 0xffffffffffffff00 | (ulong)(param_1 - 0x7bU < 4);\n  }\n  if (param_1 < 0x5b) {\n    if (param_1 < 0x30) {\n      return in_RAX & 0xffffffffffffff00 | (ulong)(0x20 < param_1);\n    }\n    return in_RAX & 0xffffffffffffff00 | (ulong)(param_1 - 0x3aU < 7);\n  }\n  return 1;\n}\n\n", 
    "00105190": "\nlong hash_do_for_each(long **param_1,code *param_2,undefined8 param_3)\n\n{\n  char cVar1;\n  long *plVar2;\n  long lVar3;\n  long lVar4;\n  long *plVar5;\n  \n  plVar5 = *param_1;\n  if (param_1[1] < plVar5 || param_1[1] == plVar5) {\n    lVar4 = 0;\n  }\n  else {\n    lVar4 = 0;\n    do {\n      lVar3 = *plVar5;\n      plVar2 = plVar5;\n      if (lVar3 != 0) {\n        while( true ) {\n          cVar1 = (*param_2)(lVar3,param_3);\n          if (cVar1 == '\\0') {\n            return lVar4;\n          }\n          plVar2 = (long *)plVar2[1];\n          lVar4 = lVar4 + 1;\n          if (plVar2 == (long *)0x0) break;\n          lVar3 = *plVar2;\n        }\n      }\n      plVar5 = plVar5 + 2;\n    } while (plVar5 <= param_1[1] && param_1[1] != plVar5);\n  }\n  return lVar4;\n}\n\n", 
    "0010bb30": "\nvoid rpl_getfilecon(undefined8 param_1,undefined8 param_2)\n\n{\n  undefined4 uVar1;\n  \n  uVar1 = getfilecon();\n  map_to_failure(uVar1,param_2);\n  return;\n}\n\n", 
    "001067c0": "\nundefined8\nstrcaseeq1(long param_1,undefined8 param_2,byte param_3,char param_4,char param_5,char param_6,\n          char param_7)\n\n{\n  char cVar1;\n  byte bVar2;\n  undefined8 uVar3;\n  \n  cVar1 = c_isupper((int)(char)param_3);\n  bVar2 = *(byte *)(param_1 + 1);\n  if (cVar1 != '\\0') {\n    bVar2 = bVar2 & 0xdf;\n  }\n  if (param_3 != bVar2) {\n    return 0;\n  }\n  if (param_3 == 0) {\n    return 1;\n  }\n  uVar3 = strcaseeq2(param_1,param_2,(int)param_4,(int)param_5,(int)param_6,(int)param_7);\n  return uVar3;\n}\n\n", 
    "00102910": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fflush(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_fflush_00112ec8)();\n  return iVar1;\n}\n\n", 
    "00107c50": "\nundefined1 *\nquotearg_n_options(int param_1,undefined8 param_2,undefined8 param_3,undefined4 *param_4)\n\n{\n  long lVar1;\n  int iVar2;\n  uint uVar3;\n  undefined4 uVar4;\n  ulong uVar5;\n  int *piVar6;\n  undefined1 (*pauVar7) [16];\n  ulong uVar8;\n  undefined1 *__ptr;\n  \n  piVar6 = __errno_location();\n  iVar2 = *piVar6;\n  if (param_1 < 0) {\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  pauVar7 = (undefined1 (*) [16])slotvec;\n  if (nslots <= param_1) {\n    if (param_1 == 0x7fffffff) {\n                    /* WARNING: Subroutine does not return */\n      xalloc_die();\n    }\n    if (slotvec == slotvec0) {\n      pauVar7 = (undefined1 (*) [16])xrealloc(0);\n      slotvec = (undefined *)pauVar7;\n      *pauVar7 = slotvec0;\n    }\n    else {\n      pauVar7 = (undefined1 (*) [16])xrealloc(slotvec);\n      slotvec = (undefined *)pauVar7;\n    }\n    memset(pauVar7[nslots],0,(long)((param_1 + 1) - nslots) << 4);\n    nslots = param_1 + 1;\n  }\n  uVar3 = param_4[1];\n  pauVar7 = pauVar7[param_1];\n  uVar5 = *(ulong *)*pauVar7;\n  __ptr = *(undefined1 **)(*pauVar7 + 8);\n  uVar8 = quotearg_buffer_restyled\n                    (__ptr,uVar5,param_2,param_3,*param_4,uVar3 | 1,param_4 + 2,\n                     *(undefined8 *)(param_4 + 10),*(undefined8 *)(param_4 + 0xc));\n  if (uVar5 <= uVar8) {\n    lVar1 = uVar8 + 1;\n    *(long *)*pauVar7 = lVar1;\n    if (__ptr != slot0) {\n      free(__ptr);\n    }\n    __ptr = (undefined1 *)xcharalloc(lVar1);\n    uVar4 = *param_4;\n    *(undefined1 **)(*pauVar7 + 8) = __ptr;\n    quotearg_buffer_restyled\n              (__ptr,lVar1,param_2,param_3,uVar4,uVar3 | 1,param_4 + 2,*(undefined8 *)(param_4 + 10)\n               ,*(undefined8 *)(param_4 + 0xc));\n  }\n  *piVar6 = iVar2;\n  return __ptr;\n}\n\n", 
    "00105b90": "\nulong triple_hash(undefined8 *param_1,ulong param_2)\n\n{\n  ulong uVar1;\n  \n  uVar1 = hash_pjw(*param_1);\n  return (uVar1 ^ param_1[1]) % param_2;\n}\n\n", 
    "001142b8": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid mode_to_security_class(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n  halt_baddata();\n}\n\n", 
    "00105020": "\nlong hash_lookup(long param_1,long param_2)\n\n{\n  char cVar1;\n  long *plVar2;\n  long lVar3;\n  \n  plVar2 = (long *)safe_hasher();\n  lVar3 = *plVar2;\n  if (lVar3 == 0) {\n    return 0;\n  }\n  while( true ) {\n    if (lVar3 == param_2) {\n      return param_2;\n    }\n    cVar1 = (**(code **)(param_1 + 0x38))(param_2);\n    if (cVar1 != '\\0') break;\n    plVar2 = (long *)plVar2[1];\n    if (plVar2 == (long *)0x0) {\n      return 0;\n    }\n    lVar3 = *plVar2;\n  }\n  return *plVar2;\n}\n\n", 
    "0010bf80": "\nint c_strcasecmp(undefined *param_1,undefined *param_2)\n\n{\n  byte bVar1;\n  byte bVar2;\n  int iVar3;\n  \n  iVar3 = 0;\n  if (param_1 != param_2) {\n    do {\n      bVar1 = c_tolower(*param_1);\n      bVar2 = c_tolower(*param_2);\n      if (bVar1 == 0) break;\n      param_1 = param_1 + 1;\n      param_2 = param_2 + 1;\n    } while (bVar1 == bVar2);\n    iVar3 = (uint)bVar1 - (uint)bVar2;\n  }\n  return iVar3;\n}\n\n", 
    "00105140": "\nvoid hash_get_entries(ulong **param_1,long param_2,ulong param_3)\n\n{\n  ulong **ppuVar1;\n  ulong *puVar2;\n  ulong uVar3;\n  ulong **ppuVar4;\n  \n  ppuVar4 = (ulong **)*param_1;\n  uVar3 = 0;\n  if (param_1[1] < ppuVar4 || (ulong **)param_1[1] == ppuVar4) {\n    return;\n  }\n  do {\n    ppuVar1 = ppuVar4;\n    puVar2 = *ppuVar4;\n    while (puVar2 != (ulong *)0x0) {\n      if (param_3 <= uVar3) {\n        return;\n      }\n      uVar3 = uVar3 + 1;\n      *(ulong **)(param_2 + -8 + uVar3 * 8) = *ppuVar1;\n      ppuVar1 = (ulong **)ppuVar1[1];\n      puVar2 = (ulong *)ppuVar1;\n    }\n    ppuVar4 = ppuVar4 + 2;\n  } while (ppuVar4 <= param_1[1] && (ulong **)param_1[1] != ppuVar4);\n  return;\n}\n\n", 
    "00106350": "\nundefined8 strcaseeq8(long param_1,undefined8 param_2,byte param_3)\n\n{\n  char cVar1;\n  byte bVar2;\n  undefined8 uVar3;\n  \n  cVar1 = c_isupper((int)(char)param_3);\n  bVar2 = *(byte *)(param_1 + 8);\n  if (cVar1 != '\\0') {\n    bVar2 = bVar2 & 0xdf;\n  }\n  if (param_3 != bVar2) {\n    return 0;\n  }\n  if (param_3 == 0) {\n    return 1;\n  }\n  uVar3 = strcaseeq9(param_1,param_2);\n  return uVar3;\n}\n\n", 
    "0010bc20": "\nchar * areadlink_with_size(char *param_1,ulong param_2)\n\n{\n  char *__buf;\n  ulong uVar1;\n  int *piVar2;\n  size_t __size;\n  \n  __size = param_2 + 1;\n  if (0x400 < param_2) {\n    __size = 0x401;\n  }\n  do {\n    __buf = (char *)malloc(__size);\n    while( true ) {\n      if (__buf == (char *)0x0) {\n        return (char *)0x0;\n      }\n      uVar1 = readlink(param_1,__buf,__size);\n      if (((long)uVar1 < 0) && (piVar2 = __errno_location(), *piVar2 != 0x22)) {\n        free(__buf);\n        return (char *)0x0;\n      }\n      if (uVar1 < __size) {\n        __buf[uVar1] = '\\0';\n        return __buf;\n      }\n      free(__buf);\n      if (0x3fffffffffffffff < __size) break;\n      __size = __size * 2;\n      __buf = (char *)malloc(__size);\n    }\n    if (0x7ffffffffffffffe < __size) {\n      piVar2 = __errno_location();\n      *piVar2 = 0xc;\n      return (char *)0x0;\n    }\n    __size = 0x7fffffffffffffff;\n  } while( true );\n}\n\n", 
    "0010bd40": "\nuint rotr32(uint param_1,byte param_2)\n\n{\n  return param_1 >> (param_2 & 0x1f) | param_1 << 0x20 - (param_2 & 0x1f);\n}\n\n", 
    "0010be60": "\nbool c_isgraph(int param_1)\n\n{\n  return param_1 - 0x21U < 0x5e;\n}\n\n", 
    "001025f0": "\nvoid __fpending(void)\n\n{\n  (*(code *)PTR___fpending_00112d38)();\n  return;\n}\n\n", 
    "0010c300": "\nchar * locale_charset(void)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = nl_langinfo(0xe);\n  if (pcVar1 != (char *)0x0) {\n    if (*pcVar1 == '\\0') {\n      pcVar1 = \"ASCII\";\n    }\n    return pcVar1;\n  }\n  return \"ASCII\";\n}\n\n", 
    "0010c420": "\nint rpl_fclose(FILE *param_1)\n\n{\n  int iVar1;\n  int iVar2;\n  int *piVar3;\n  __off_t _Var4;\n  \n  iVar1 = fileno(param_1);\n  if (-1 < iVar1) {\n    iVar1 = __freading();\n    if (iVar1 != 0) {\n      iVar1 = fileno(param_1);\n      _Var4 = lseek(iVar1,0,1);\n      if (_Var4 == -1) goto LAB_0010c48f;\n    }\n    iVar1 = rpl_fflush(param_1);\n    if (iVar1 != 0) {\n      piVar3 = __errno_location();\n      iVar1 = *piVar3;\n      iVar2 = fclose(param_1);\n      if (iVar1 != 0) {\n        *piVar3 = iVar1;\n        iVar2 = -1;\n      }\n      return iVar2;\n    }\n  }\nLAB_0010c48f:\n  iVar1 = fclose(param_1);\n  return iVar1;\n}\n\n", 
    "0010a120": "\nvoid fts_load_isra_0(void **param_1,long param_2)\n\n{\n  char *__s;\n  void *pvVar1;\n  char *pcVar2;\n  size_t sVar3;\n  \n  __s = (char *)(param_2 + 0x108);\n  pvVar1 = *param_1;\n  *(long *)(param_2 + 0x48) = *(long *)(param_2 + 0x60);\n  memmove(pvVar1,__s,*(long *)(param_2 + 0x60) + 1);\n  pcVar2 = strrchr(__s,0x2f);\n  if ((pcVar2 != (char *)0x0) && ((__s != pcVar2 || (*(char *)(param_2 + 0x109) != '\\0')))) {\n    sVar3 = strlen(pcVar2 + 1);\n    memmove(__s,pcVar2 + 1,sVar3 + 1);\n    *(size_t *)(param_2 + 0x60) = sVar3;\n  }\n  pvVar1 = *param_1;\n  *(void **)(param_2 + 0x38) = pvVar1;\n  *(void **)(param_2 + 0x30) = pvVar1;\n  return;\n}\n\n", 
    "00108520": "\nbool same_nameat(int param_1,undefined8 param_2,int param_3,undefined8 param_4)\n\n{\n  int iVar1;\n  void *__s1;\n  void *__s2;\n  size_t __n;\n  size_t sVar2;\n  char *pcVar3;\n  int *piVar4;\n  bool bVar5;\n  long in_FS_OFFSET;\n  stat local_168;\n  stat local_d8;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  __s1 = (void *)last_component(param_2);\n  __s2 = (void *)last_component(param_4);\n  __n = base_len(__s1);\n  sVar2 = base_len(__s2);\n  bVar5 = false;\n  if (__n == sVar2) {\n    iVar1 = memcmp(__s1,__s2,__n);\n    if (iVar1 == 0) {\n      pcVar3 = (char *)dir_name(param_2);\n      iVar1 = fstatat(param_1,pcVar3,&local_168,0x100);\n      if (iVar1 != 0) {\n        piVar4 = __errno_location();\n        error(1,*piVar4,\"%s\",pcVar3);\n      }\n      free(pcVar3);\n      pcVar3 = (char *)dir_name(param_4);\n      iVar1 = fstatat(param_3,pcVar3,&local_d8,0x100);\n      if (iVar1 != 0) {\n        piVar4 = __errno_location();\n        error(1,*piVar4,\"%s\",pcVar3);\n      }\n      bVar5 = local_168.st_ino == local_d8.st_ino && local_168.st_dev == local_d8.st_dev;\n      free(pcVar3);\n    }\n    else {\n      bVar5 = false;\n    }\n  }\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return bVar5;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00106220": "\nvoid set_program_name(char *param_1)\n\n{\n  char *pcVar1;\n  long lVar2;\n  ulong uVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  bool bVar6;\n  bool bVar7;\n  byte bVar8;\n  \n  bVar8 = 0;\n  if (param_1 == (char *)0x0) {\n    fwrite(\"A NULL argv[0] was passed through an exec system call.\\n\",1,0x37,stderr);\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  pcVar1 = strrchr(param_1,0x2f);\n  if (pcVar1 != (char *)0x0) {\n    program_name = pcVar1 + 1;\n    uVar3 = (long)program_name - (long)param_1;\n    bVar6 = uVar3 < 6;\n    bVar7 = uVar3 == 6;\n    if (6 < (long)uVar3) {\n      lVar2 = 7;\n      pbVar4 = (byte *)(pcVar1 + -6);\n      pbVar5 = &DAT_0010da08;\n      do {\n        if (lVar2 == 0) break;\n        lVar2 = lVar2 + -1;\n        bVar6 = *pbVar4 < *pbVar5;\n        bVar7 = *pbVar4 == *pbVar5;\n        pbVar4 = pbVar4 + (ulong)bVar8 * -2 + 1;\n        pbVar5 = pbVar5 + (ulong)bVar8 * -2 + 1;\n      } while (bVar7);\n      if ((!bVar6 && !bVar7) == bVar6) {\n        if (((pcVar1[1] != 'l') || (pcVar1[2] != 't')) || (pcVar1[3] != '-')) {\n          program_invocation_name = program_name;\n          return;\n        }\n        param_1 = pcVar1 + 4;\n        program_invocation_short_name = param_1;\n      }\n    }\n  }\n  program_name = param_1;\n  program_invocation_name = param_1;\n  return;\n}\n\n", 
    "00106580": "\nundefined8\nstrcaseeq4(long param_1,undefined8 param_2,byte param_3,char param_4,char param_5,char param_6,\n          char param_7)\n\n{\n  char cVar1;\n  byte bVar2;\n  undefined8 uVar3;\n  \n  cVar1 = c_isupper((int)(char)param_3);\n  bVar2 = *(byte *)(param_1 + 4);\n  if (cVar1 != '\\0') {\n    bVar2 = bVar2 & 0xdf;\n  }\n  if (param_3 != bVar2) {\n    return 0;\n  }\n  if (param_3 == 0) {\n    return 1;\n  }\n  uVar3 = strcaseeq5(param_1,param_2,(int)param_4,(int)param_5,(int)param_6,(int)param_7);\n  return uVar3;\n}\n\n", 
    "00108f50": "\nvoid xalloc_die(void)\n\n{\n  undefined8 uVar1;\n  \n  uVar1 = dcgettext(0,\"memory exhausted\",5);\n  error(exit_failure,0,\"%s\",uVar1);\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "0010be70": "\nbool c_islower(int param_1)\n\n{\n  return param_1 - 0x61U < 0x1a;\n}\n\n", 
    "00105250": "\nvoid hash_reset_tuning(undefined8 *param_1)\n\n{\n  *(undefined *)(param_1 + 2) = 0;\n  *param_1 = 0x3f80000000000000;\n  param_1[1] = 0x3fb4fdf43f4ccccd;\n  return;\n}\n\n", 
    "00109e00": "\nvoid diropen_isra_0(undefined4 param_1,uint param_2,undefined8 param_3)\n\n{\n  if ((param_2 & 0x200) != 0) {\n    openat_safer(param_1,param_3);\n    return;\n  }\n  open_safer(param_3,(param_2 & 0x10) << 0xd | (param_2 & 0x800) << 7 | 0x90900);\n  return;\n}\n\n", 
    "0010bd50": "\nvoid rotl_sz(void)\n\n{\n  rotl64();\n  return;\n}\n\n", 
    "001025e0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid _exit(int __status)\n\n{\n  (*(code *)PTR__exit_00112d30)();\n  return;\n}\n\n", 
    "00107e30": "\nundefined4 get_quoting_style(undefined1 *param_1)\n\n{\n  if ((undefined4 *)param_1 == (undefined4 *)0x0) {\n    param_1 = default_quoting_options;\n  }\n  return *(undefined4 *)param_1;\n}\n\n", 
    "00104a40": "\nlong safe_hasher(long *param_1,undefined8 param_2)\n\n{\n  ulong uVar1;\n  \n  uVar1 = (*(code *)param_1[6])(param_2,param_1[2]);\n  if (uVar1 <= (ulong)param_1[2] && param_1[2] != uVar1) {\n    return uVar1 * 0x10 + *param_1;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "00105c50": "\nvoid triple_free(void **param_1)\n\n{\n  free(*param_1);\n  (*(code *)PTR_free_00112fb8)(param_1);\n  return;\n}\n\n", 
    "0010c790": "\nvoid __libc_csu_fini(void)\n\n{\n  return;\n}\n\n", 
    "00103db0": "\nuint restorecon(char *param_1,uint param_2,char param_3)\n\n{\n  uint uVar1;\n  int iVar2;\n  long lVar3;\n  long lVar4;\n  int *piVar5;\n  undefined8 uVar6;\n  undefined8 uVar7;\n  uint *puVar8;\n  undefined8 extraout_RDX;\n  ulong uVar9;\n  long *plVar10;\n  char *__ptr;\n  long in_FS_OFFSET;\n  char *local_48;\n  undefined8 local_40;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((*param_1 == '/') || (param_3 != '\\0')) {\n    local_48 = param_1;\n    __ptr = (char *)0x0;\n  }\n  else {\n    local_48 = (char *)canonicalize_filename_mode(param_1,2);\n    __ptr = local_48;\n    if (local_48 == (char *)0x0) {\n      uVar6 = quotearg_style(4,param_1);\n      uVar7 = dcgettext(0,\"error canonicalizing %s\",5);\n      puVar8 = (uint *)__errno_location();\n      plVar10 = (long *)0x1;\n      uVar9 = (ulong)*puVar8;\n      error(1,uVar9,uVar7,uVar6);\n      lVar3 = *plVar10;\n      if (lVar3 == 0) {\n        lVar3 = hash_initialize(7,0,triple_hash,triple_compare_ino_str,triple_free);\n        *plVar10 = lVar3;\n        if (lVar3 == 0) {\n                    /* WARNING: Subroutine does not return */\n          xalloc_die(0);\n        }\n      }\n      uVar1 = seen_file(lVar3,uVar9,extraout_RDX);\n      if ((char)uVar1 == '\\0') {\n        record_file(*plVar10,uVar9,extraout_RDX);\n      }\n      return uVar1;\n    }\n  }\n  local_40 = 0;\n  if ((char)param_2 == '\\0') {\n    iVar2 = restorecon_private(local_48,param_3);\n    param_2 = param_2 & 0xffffff00 | (uint)(iVar2 != -1);\n    free(__ptr);\n  }\n  else {\n    lVar3 = xfts_open(&local_48,0x10,0);\n    while (lVar4 = fts_read(lVar3), lVar4 != 0) {\n      uVar1 = restorecon_private(*(undefined8 *)(lVar3 + 0x20),param_3);\n      param_2 = param_2 & (uVar1 & 0xffffff00 | (uint)(uVar1 != 0xffffffff));\n    }\n    piVar5 = __errno_location();\n    if (*piVar5 == 0) {\n      iVar2 = fts_close(lVar3);\n    }\n    else {\n      param_2 = 0;\n      uVar6 = dcgettext(0,\"fts_read failed\",5);\n      error(0,*piVar5,uVar6);\n      iVar2 = fts_close(lVar3);\n    }\n    if (iVar2 != 0) {\n      param_2 = 0;\n      uVar6 = dcgettext(0,\"fts_close failed\",5);\n      error(0,*piVar5,uVar6);\n    }\n    free(__ptr);\n  }\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return param_2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00108310": "\nvoid quotearg_char(undefined8 param_1,char param_2)\n\n{\n  quotearg_char_mem(param_1,0xffffffffffffffff,(int)param_2);\n  return;\n}\n\n", 
    "00105280": "\nvoid ** hash_initialize(undefined8 param_1,undefined1 *param_2,code *param_3,code *param_4,\n                       void *param_5)\n\n{\n  char cVar1;\n  void **__ptr;\n  void *__nmemb;\n  void *pvVar2;\n  void **ppvVar3;\n  \n  if (param_3 == (code *)0x0) {\n    param_3 = raw_hasher;\n  }\n  if (param_4 == (code *)0x0) {\n    param_4 = raw_comparator;\n  }\n  __ptr = (void **)malloc(0x50);\n  ppvVar3 = __ptr;\n  if (__ptr != (void **)0x0) {\n    if (param_2 == (undefined1 *)0x0) {\n      param_2 = default_tuning;\n    }\n    __ptr[5] = param_2;\n    cVar1 = check_tuning_isra_0(__ptr + 5);\n    if (cVar1 != '\\0') {\n      __nmemb = (void *)compute_bucket_size_isra_0\n                                  (*(undefined4 *)(param_2 + 8),param_1,param_2[0x10]);\n      __ptr[2] = __nmemb;\n      if (__nmemb != (void *)0x0) {\n        pvVar2 = calloc((size_t)__nmemb,0x10);\n        *__ptr = pvVar2;\n        if (pvVar2 != (void *)0x0) {\n          __ptr[6] = param_3;\n          __ptr[7] = param_4;\n          __ptr[1] = (void *)((long)__nmemb * 0x10 + (long)pvVar2);\n          __ptr[3] = (void *)0x0;\n          __ptr[4] = (void *)0x0;\n          __ptr[8] = param_5;\n          __ptr[9] = (void *)0x0;\n          return __ptr;\n        }\n      }\n    }\n    ppvVar3 = (void **)0x0;\n    free(__ptr);\n  }\n  return ppvVar3;\n}\n\n", 
    "00108e00": "\nvoid x2nrealloc(long param_1,ulong *param_2,ulong param_3)\n\n{\n  undefined auVar1 [16];\n  ulong uVar2;\n  ulong uVar3;\n  \n  uVar3 = *param_2;\n  if (param_1 == 0) {\n    if (uVar3 == 0) {\n      uVar3 = (ulong)(0x80 < param_3) +\n              SUB168((ZEXT816(0) << 0x40 | ZEXT816(0x80)) / ZEXT816(param_3),0);\n    }\n    uVar2 = (ulong)(SUB168(ZEXT816(uVar3) * ZEXT816(param_3) >> 0x40,0) != 0);\n    if ((SUB168(ZEXT816(uVar3) * ZEXT816(param_3),0) < 0) || (uVar2 != 0)) goto LAB_00108e5b;\n  }\n  else {\n    auVar1 = ZEXT816(0) << 0x40 | ZEXT816(0x5555555555555554);\n    uVar2 = SUB168(auVar1 % ZEXT816(param_3),0);\n    if (SUB168(auVar1 / ZEXT816(param_3),0) <= uVar3) {\nLAB_00108e5b:\n                    /* WARNING: Subroutine does not return */\n      xalloc_die(param_1,uVar3,uVar2);\n    }\n    uVar3 = (uVar3 >> 1) + 1 + uVar3;\n  }\n  *param_2 = uVar3;\n  xrealloc(param_1,uVar3 * param_3);\n  return;\n}\n\n", 
    "0010bd20": "\nulong rotr64(ulong param_1,byte param_2)\n\n{\n  return param_1 >> (param_2 & 0x3f) | param_1 << 0x40 - (param_2 & 0x3f);\n}\n\n", 
    "0010bf60": "\nint c_toupper(int param_1)\n\n{\n  if (param_1 - 0x61U < 0x1a) {\n    param_1 = param_1 + -0x20;\n  }\n  return param_1;\n}\n\n", 
    "001068b0": "\nundefined8\nstrcaseeq0_constprop_0\n          (byte *param_1,undefined8 param_2,byte param_3,char param_4,char param_5,char param_6,\n          char param_7,char param_8,char param_9)\n\n{\n  char cVar1;\n  byte bVar2;\n  undefined8 uVar3;\n  \n  cVar1 = c_isupper((int)(char)param_3);\n  bVar2 = *param_1;\n  if (cVar1 != '\\0') {\n    bVar2 = bVar2 & 0xdf;\n  }\n  uVar3 = 0;\n  if (bVar2 == param_3) {\n    uVar3 = strcaseeq1(param_1,param_2,(int)param_4,(int)param_5,(int)param_6,(int)param_7,\n                       (int)param_8,(int)param_9,0,0);\n  }\n  return uVar3;\n}\n\n", 
    "001033a0": "\nundefined8 is_smack_enabled(void)\n\n{\n  return 0;\n}\n\n", 
    "0010bd10": "\nulong rotl64(ulong param_1,byte param_2)\n\n{\n  return param_1 << (param_2 & 0x3f) | param_1 >> 0x40 - (param_2 & 0x3f);\n}\n\n", 
    "00114088": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t __ctype_get_mb_cur_max(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __ctype_get_mb_cur_max@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00104a70": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined8 check_tuning_isra_0(float **param_1)\n\n{\n  float fVar1;\n  float *pfVar2;\n  float fVar3;\n  \n  pfVar2 = *param_1;\n  if (pfVar2 == (float *)default_tuning) {\n    return 1;\n  }\n  fVar1 = pfVar2[2];\n  if ((((_DAT_0010d924 < fVar1) && (fVar1 < DAT_0010d928)) && (_DAT_0010d92c < pfVar2[3])) &&\n     (_DAT_0010d930 <= *pfVar2)) {\n    fVar3 = *pfVar2 + _DAT_0010d924;\n    if (((fVar3 < pfVar2[1]) && (pfVar2[1] <= DAT_0010d934)) && (fVar3 < fVar1)) {\n      return 1;\n    }\n  }\n  *param_1 = (float *)default_tuning;\n  return 0;\n}\n\n", 
    "00105c80": "\nvoid make_node_op_equals(undefined4 param_1,undefined4 param_2)\n\n{\n  undefined2 *puVar1;\n  \n  puVar1 = (undefined2 *)xmalloc(0x20);\n  *puVar1 = 0x13d;\n  *(undefined4 *)(puVar1 + 2) = 0xfff;\n  *(undefined4 *)(puVar1 + 4) = param_1;\n  *(undefined4 *)(puVar1 + 6) = param_2;\n  *(undefined *)((long)puVar1 + 0x11) = 0;\n  return;\n}\n\n", 
    "0010c640": "\nvoid rpl_fflush(FILE *param_1)\n\n{\n  int iVar1;\n  \n  if (param_1 != (FILE *)0x0) {\n    iVar1 = __freading();\n    if (iVar1 != 0) {\n      clear_ungetc_buffer_preserving_position(param_1);\n      fflush(param_1);\n      return;\n    }\n  }\n  fflush(param_1);\n  return;\n}\n\n", 
    "00114080": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid dcgettext(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* dcgettext@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00105390": "\nvoid hash_clear(long **param_1)\n\n{\n  long *plVar1;\n  long *plVar2;\n  long *plVar3;\n  long *plVar4;\n  long *plVar5;\n  \n  plVar5 = *param_1;\n  if (*param_1 < param_1[1]) {\n    do {\n      while (*plVar5 != 0) {\n        plVar4 = param_1[8];\n        plVar3 = (long *)plVar5[1];\n        while (plVar3 != (long *)0x0) {\n          if (plVar4 != (long *)0x0) {\n            (*(code *)plVar4)(*plVar3);\n            plVar4 = param_1[8];\n          }\n          plVar1 = (long *)plVar3[1];\n          plVar2 = param_1[9];\n          *plVar3 = 0;\n          plVar3[1] = (long)plVar2;\n          param_1[9] = plVar3;\n          plVar3 = plVar1;\n        }\n        if (plVar4 != (long *)0x0) {\n          (*(code *)plVar4)(*plVar5);\n        }\n        *plVar5 = 0;\n        plVar4 = plVar5 + 2;\n        plVar5[1] = 0;\n        plVar5 = plVar4;\n        if (param_1[1] < plVar4 || param_1[1] == plVar4) goto LAB_0010542b;\n      }\n      plVar5 = plVar5 + 2;\n    } while (plVar5 <= param_1[1] && param_1[1] != plVar5);\n  }\nLAB_0010542b:\n  param_1[3] = (long *)0x0;\n  param_1[4] = (long *)0x0;\n  return;\n}\n\n", 
    "00108f30": "\nvoid xstrdup(char *param_1)\n\n{\n  size_t sVar1;\n  \n  sVar1 = strlen(param_1);\n  xmemdup(param_1,sVar1 + 1);\n  return;\n}\n\n", 
    "0010bd30": "\nuint rotl32(uint param_1,byte param_2)\n\n{\n  return param_1 << (param_2 & 0x1f) | param_1 >> 0x20 - (param_2 & 0x1f);\n}\n\n", 
    "0010be50": "\nbool c_isdigit(int param_1)\n\n{\n  return param_1 - 0x30U < 10;\n}\n\n", 
    "001047e0": "\nchar * last_component(char *param_1)\n\n{\n  bool bVar1;\n  char *pcVar2;\n  char cVar3;\n  \n  cVar3 = *param_1;\n  while (cVar3 == '/') {\n    pcVar2 = param_1 + 1;\n    param_1 = param_1 + 1;\n    cVar3 = *pcVar2;\n  }\n  if (cVar3 != '\\0') {\n    bVar1 = false;\n    pcVar2 = param_1;\n    do {\n      while (cVar3 != '/') {\n        if (bVar1) {\n          bVar1 = false;\n          param_1 = pcVar2;\n        }\n        cVar3 = pcVar2[1];\n        pcVar2 = pcVar2 + 1;\n        if (cVar3 == '\\0') {\n          return param_1;\n        }\n      }\n      cVar3 = pcVar2[1];\n      pcVar2 = pcVar2 + 1;\n      bVar1 = true;\n    } while (cVar3 != '\\0');\n  }\n  return param_1;\n}\n\n", 
    "00114098": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint __lxstat(int __ver,char *__filename,stat *__stat_buf)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __lxstat@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00107e50": "\nvoid set_quoting_style(undefined1 *param_1,undefined4 param_2)\n\n{\n  if ((undefined4 *)param_1 == (undefined4 *)0x0) {\n    param_1 = default_quoting_options;\n  }\n  *(undefined4 *)param_1 = param_2;\n  return;\n}\n\n", 
    "00105c70": "\nundefined4 octal_to_mode(undefined4 param_1)\n\n{\n  return param_1;\n}\n\n", 
    "00114090": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t strlen(char *__s)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strlen@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00104b80": "\nvoid free_entry_isra_0(undefined8 *param_1,undefined8 *param_2)\n\n{\n  *param_2 = 0;\n  param_2[1] = *param_1;\n  *param_1 = param_2;\n  return;\n}\n\n", 
    "0010b200": "\nvoid * fts_read(void **param_1)\n\n{\n  ulong uVar1;\n  short sVar2;\n  undefined4 uVar3;\n  long lVar4;\n  char cVar5;\n  undefined2 uVar6;\n  short sVar7;\n  int iVar8;\n  int *piVar9;\n  long lVar10;\n  void *pvVar11;\n  void *pvVar12;\n  uint uVar13;\n  \n  pvVar11 = *param_1;\n  if (pvVar11 == (void *)0x0) {\n    return (void *)0x0;\n  }\n  uVar13 = *(uint *)(param_1 + 9);\n  if ((uVar13 & 0x4000) != 0) {\n    return (void *)0x0;\n  }\n  sVar7 = *(short *)((long)pvVar11 + 0x74);\n  *(undefined2 *)((long)pvVar11 + 0x74) = 3;\n  if (sVar7 == 1) {\n    uVar6 = fts_stat(param_1,pvVar11,0);\n    *(undefined2 *)((long)pvVar11 + 0x70) = uVar6;\n    return pvVar11;\n  }\n  sVar2 = *(short *)((long)pvVar11 + 0x70);\n  if (sVar7 == 2) {\n    if (1 < (ushort)(sVar2 - 0xcU)) {\n      if (sVar2 == 1) goto LAB_0010b36f;\n      goto LAB_0010b290;\n    }\n    sVar7 = fts_stat(param_1,pvVar11,1);\n    *(short *)((long)pvVar11 + 0x70) = sVar7;\n    if (sVar7 != 1) {\n      *param_1 = pvVar11;\n      if (sVar7 != 0xb) {\n        return pvVar11;\n      }\n      goto LAB_0010b539;\n    }\n    if ((*(uint *)(param_1 + 9) & 4) == 0) {\n      iVar8 = diropen_isra_0(*(undefined4 *)((long)param_1 + 0x2c),*(uint *)(param_1 + 9),\n                             &DAT_0010e6c4);\n      *(int *)((long)pvVar11 + 0x44) = iVar8;\n      if (iVar8 < 0) {\n        piVar9 = __errno_location();\n        iVar8 = *piVar9;\n        *(undefined2 *)((long)pvVar11 + 0x70) = 7;\n        *(int *)((long)pvVar11 + 0x40) = iVar8;\n        *param_1 = pvVar11;\n        return pvVar11;\n      }\n      *(ushort *)((long)pvVar11 + 0x72) = *(ushort *)((long)pvVar11 + 0x72) | 2;\n      sVar7 = *(short *)((long)pvVar11 + 0x70);\nLAB_0010b48a:\n      *param_1 = pvVar11;\n      if (sVar7 == 0xb) goto LAB_0010b539;\n      goto LAB_0010b498;\n    }\n    *param_1 = pvVar11;\nLAB_0010b4a2:\n    if (*(long *)((long)pvVar11 + 0x58) != 0) goto LAB_0010b4b3;\n  }\n  else {\n    if (sVar2 == 1) {\n      if (sVar7 == 4) goto LAB_0010b40a;\nLAB_0010b36f:\n      if (((uVar13 & 0x40) != 0) && (*(void **)((long)pvVar11 + 0x78) != param_1[3])) {\nLAB_0010b40a:\n        if ((*(byte *)((long)pvVar11 + 0x72) & 2) != 0) {\n          close(*(int *)((long)pvVar11 + 0x44));\n        }\n        if (param_1[1] != (void *)0x0) {\n          fts_lfree();\n          param_1[1] = (void *)0x0;\n        }\n        uVar3 = *(undefined4 *)(param_1 + 9);\n        *(undefined2 *)((long)pvVar11 + 0x70) = 6;\n        leave_dir_isra_0(uVar3,param_1 + 0xb,pvVar11);\n        return pvVar11;\n      }\n      if (param_1[1] == (void *)0x0) {\nLAB_0010b588:\n        pvVar12 = (void *)fts_build(param_1,3);\n        param_1[1] = pvVar12;\n        if (pvVar12 == (void *)0x0) {\n          uVar13 = *(uint *)(param_1 + 9);\n          if ((uVar13 & 0x4000) != 0) {\n            return (void *)0x0;\n          }\n          if ((*(int *)((long)pvVar11 + 0x40) != 0) && (*(short *)((long)pvVar11 + 0x70) != 4)) {\n            *(undefined2 *)((long)pvVar11 + 0x70) = 7;\n          }\n          leave_dir_isra_0(uVar13,param_1 + 0xb,pvVar11);\n          return pvVar11;\n        }\n      }\n      else {\n        if ((uVar13 & 0x2000) != 0) {\n          *(uint *)(param_1 + 9) = uVar13 & 0xffffdfff;\n          fts_lfree();\n          param_1[1] = (void *)0x0;\n          goto LAB_0010b588;\n        }\n        iVar8 = fts_safe_changedir(param_1,pvVar11,0xffffffff,*(undefined8 *)((long)pvVar11 + 0x30))\n        ;\n        if (iVar8 == 0) {\n          pvVar12 = param_1[1];\n        }\n        else {\n          piVar9 = __errno_location();\n          iVar8 = *piVar9;\n          *(ushort *)((long)pvVar11 + 0x72) = *(ushort *)((long)pvVar11 + 0x72) | 1;\n          *(int *)((long)pvVar11 + 0x40) = iVar8;\n          pvVar12 = param_1[1];\n          for (pvVar11 = pvVar12; pvVar11 != (void *)0x0; pvVar11 = *(void **)((long)pvVar11 + 0x10)\n              ) {\n            *(undefined8 *)((long)pvVar11 + 0x30) =\n                 *(undefined8 *)(*(long *)((long)pvVar11 + 8) + 0x30);\n          }\n        }\n      }\n      param_1[1] = (void *)0x0;\n    }\n    else {\nLAB_0010b290:\n      do {\n        pvVar12 = *(void **)((long)pvVar11 + 0x10);\n        if (pvVar12 == (void *)0x0) {\n          pvVar12 = *(void **)((long)pvVar11 + 8);\n          if (*(long *)((long)pvVar12 + 0x18) != 0) {\n            lVar4 = *(long *)((long)pvVar12 + 0x48);\n            *param_1 = pvVar12;\n            *(undefined *)((long)param_1[4] + lVar4) = 0;\n            pvVar12 = (void *)fts_build(param_1,3);\n            if (pvVar12 != (void *)0x0) {\n              free(pvVar11);\n              goto LAB_0010b4ea;\n            }\n            if ((*(byte *)((long)param_1 + 0x49) & 0x40) != 0) {\n              return (void *)0x0;\n            }\n            pvVar12 = *(void **)((long)pvVar11 + 8);\n          }\n          *param_1 = pvVar12;\n          free(pvVar11);\n          if (*(long *)((long)pvVar12 + 0x58) == -1) {\n            free(pvVar12);\n            piVar9 = __errno_location();\n            *piVar9 = 0;\n            *param_1 = (void *)0x0;\n            return (void *)0x0;\n          }\n          if (*(short *)((long)pvVar12 + 0x70) == 0xb) {\n                    /* WARNING: Subroutine does not return */\n            abort();\n          }\n          *(undefined *)((long)param_1[4] + *(long *)((long)pvVar12 + 0x48)) = 0;\n          if (*(long *)((long)pvVar12 + 0x58) == 0) {\n            iVar8 = restore_initial_cwd(param_1);\n            if (iVar8 == 0) goto LAB_0010b2fb;\nLAB_0010b6af:\n            piVar9 = __errno_location();\n            uVar13 = *(uint *)(param_1 + 9) | 0x4000;\n            sVar7 = *(short *)((long)pvVar12 + 0x70);\n            *(int *)((long)pvVar12 + 0x40) = *piVar9;\n            *(uint *)(param_1 + 9) = uVar13;\n            if (sVar7 == 2) {\n              return (void *)0x0;\n            }\n          }\n          else {\n            if ((*(ushort *)((long)pvVar12 + 0x72) & 2) == 0) {\n              if (((*(ushort *)((long)pvVar12 + 0x72) & 1) == 0) &&\n                 (iVar8 = fts_safe_changedir(param_1,*(undefined8 *)((long)pvVar12 + 8),0xffffffff,\n                                             &DAT_0010e6c3), iVar8 != 0)) goto LAB_0010b6af;\nLAB_0010b2fb:\n              uVar13 = *(uint *)(param_1 + 9);\n            }\n            else {\n              iVar8 = *(int *)((long)pvVar12 + 0x44);\n              if ((*(uint *)(param_1 + 9) & 4) == 0) {\n                if ((*(uint *)(param_1 + 9) & 0x200) == 0) {\n                  iVar8 = fchdir(iVar8);\n                  if (iVar8 != 0) {\n                    piVar9 = __errno_location();\n                    *(int *)((long)pvVar12 + 0x40) = *piVar9;\n                    *(uint *)(param_1 + 9) = *(uint *)(param_1 + 9) | 0x4000;\n                  }\n                  iVar8 = *(int *)((long)pvVar12 + 0x44);\n                }\n                else {\n                  cwd_advance_fd(param_1,iVar8,1);\n                  iVar8 = *(int *)((long)pvVar12 + 0x44);\n                }\n              }\n              close(iVar8);\n              uVar13 = *(uint *)(param_1 + 9);\n            }\n            if (*(short *)((long)pvVar12 + 0x70) == 2) goto LAB_0010b32b;\n          }\n          if (*(int *)((long)pvVar12 + 0x40) == 0) {\n            *(undefined2 *)((long)pvVar12 + 0x70) = 6;\n            leave_dir_isra_0(uVar13,param_1 + 0xb,pvVar12);\n            uVar13 = *(uint *)(param_1 + 9);\n          }\n          else {\n            *(undefined2 *)((long)pvVar12 + 0x70) = 7;\n          }\nLAB_0010b32b:\n          if ((uVar13 & 0x4000) != 0) {\n            return (void *)0x0;\n          }\n          return pvVar12;\n        }\n        *param_1 = pvVar12;\n        free(pvVar11);\n        pvVar11 = pvVar12;\n        if (*(long *)((long)pvVar12 + 0x58) == 0) {\n          iVar8 = restore_initial_cwd(param_1);\n          if (iVar8 != 0) {\n            *(uint *)(param_1 + 9) = *(uint *)(param_1 + 9) | 0x4000;\n            return (void *)0x0;\n          }\n          free_dir_isra_0(*(undefined4 *)(param_1 + 9),param_1[0xb]);\n          fts_load_isra_0(param_1 + 4,pvVar12);\n          setup_dir_isra_0(*(undefined4 *)(param_1 + 9),param_1 + 0xb);\n          sVar7 = *(short *)((long)pvVar12 + 0x70);\n          goto LAB_0010b48a;\n        }\n      } while (*(short *)((long)pvVar12 + 0x74) == 4);\n      if (*(short *)((long)pvVar12 + 0x74) == 2) {\n        sVar7 = fts_stat(param_1,pvVar12,1);\n        *(short *)((long)pvVar12 + 0x70) = sVar7;\n        if ((sVar7 == 1) && ((*(uint *)(param_1 + 9) & 4) == 0)) {\n          iVar8 = diropen_isra_0(*(undefined4 *)((long)param_1 + 0x2c),*(uint *)(param_1 + 9),\n                                 &DAT_0010e6c4);\n          *(int *)((long)pvVar12 + 0x44) = iVar8;\n          if (iVar8 < 0) {\n            piVar9 = __errno_location();\n            iVar8 = *piVar9;\n            *(undefined2 *)((long)pvVar12 + 0x70) = 7;\n            *(int *)((long)pvVar12 + 0x40) = iVar8;\n          }\n          else {\n            *(ushort *)((long)pvVar12 + 0x72) = *(ushort *)((long)pvVar12 + 0x72) | 2;\n          }\n        }\n        *(undefined2 *)((long)pvVar12 + 0x74) = 3;\n      }\n    }\nLAB_0010b4ea:\n    lVar4 = *(long *)(*(long *)((long)pvVar12 + 8) + 0x48);\n    lVar10 = lVar4 + -1;\n    if (*(char *)(*(long *)(*(long *)((long)pvVar12 + 8) + 0x38) + -1 + lVar4) != '/') {\n      lVar10 = lVar4;\n    }\n    pvVar11 = param_1[4];\n    *(undefined *)(lVar10 + (long)pvVar11) = 0x2f;\n    memmove((undefined *)(lVar10 + (long)pvVar11) + 1,(void *)((long)pvVar12 + 0x108),\n            *(long *)((long)pvVar12 + 0x60) + 1);\n    sVar7 = *(short *)((long)pvVar12 + 0x70);\n    *param_1 = pvVar12;\n    pvVar11 = pvVar12;\n    if (sVar7 != 0xb) {\nLAB_0010b498:\n      if (sVar7 != 1) {\n        return pvVar11;\n      }\n      goto LAB_0010b4a2;\n    }\nLAB_0010b539:\n    if (*(long *)((long)pvVar11 + 0xa8) != 2) {\n      if (*(long *)((long)pvVar11 + 0xa8) != 1) {\n        pvVar11 = (void *)fts_read_cold();\n        return pvVar11;\n      }\n      return pvVar11;\n    }\n    lVar4 = *(long *)((long)pvVar11 + 8);\n    if (((*(long *)(lVar4 + 0x68) == 0) && ((*(uint *)(param_1 + 9) & 0x18) == 0x18)) &&\n       (iVar8 = leaf_optimization(lVar4,*(undefined4 *)((long)param_1 + 0x2c)), iVar8 == 2)) {\n      sVar7 = *(short *)((long)pvVar11 + 0x70);\n      goto LAB_0010b498;\n    }\n    sVar7 = fts_stat(param_1,pvVar11,0);\n    *(short *)((long)pvVar11 + 0x70) = sVar7;\n    if ((*(uint *)((long)pvVar11 + 0x90) & 0xf000) != 0x4000) goto LAB_0010b498;\n    if (*(long *)((long)pvVar11 + 0x58) != 0) {\n      uVar1 = *(long *)(lVar4 + 0x68) - 1;\n      if (uVar1 < 0xfffffffffffffffe) {\n        *(ulong *)(lVar4 + 0x68) = uVar1;\n      }\n      if (sVar7 != 1) {\n        return pvVar11;\n      }\n      goto LAB_0010b4b3;\n    }\n    if (sVar7 != 1) {\n      return pvVar11;\n    }\n  }\n  param_1[3] = *(void **)((long)pvVar11 + 0x78);\nLAB_0010b4b3:\n  cVar5 = enter_dir_isra_0(*(undefined4 *)(param_1 + 9),param_1 + 0xb,pvVar11);\n  if (cVar5 == '\\0') {\n    piVar9 = __errno_location();\n    pvVar11 = (void *)0x0;\n    *piVar9 = 0xc;\n  }\n  return pvVar11;\n}\n\n", 
    "0010c864": "\nvoid _fini(void)\n\n{\n  return;\n}\n\n", 
    "0010c620": "\nvoid clear_ungetc_buffer_preserving_position(uint *param_1)\n\n{\n  if ((*param_1 & 0x100) == 0) {\n    return;\n  }\n  rpl_fseeko(param_1,0,1);\n  return;\n}\n\n", 
    "001025b0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid abort(void)\n\n{\n  (*(code *)PTR_abort_00112d18)();\n  return;\n}\n\n", 
    "0010bf40": "\nint c_tolower(int param_1)\n\n{\n  if (param_1 - 0x41U < 0x1a) {\n    param_1 = param_1 + 0x20;\n  }\n  return param_1;\n}\n\n", 
    "001049d0": "\nulong next_prime(ulong param_1)\n\n{\n  char cVar1;\n  ulong uVar2;\n  \n  uVar2 = 10;\n  if (9 < param_1) {\n    uVar2 = param_1;\n  }\n  uVar2 = uVar2 | 1;\n  while ((uVar2 != 0xffffffffffffffff && (cVar1 = is_prime(uVar2), cVar1 == '\\0'))) {\n    uVar2 = uVar2 + 2;\n  }\n  return uVar2;\n}\n\n", 
    "00108f00": "\nvoid xmemdup(void *param_1,size_t param_2)\n\n{\n  void *__dest;\n  \n  __dest = (void *)xmalloc(param_2);\n  memcpy(__dest,param_1,param_2);\n  return;\n}\n\n", 
    "001027f0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint memcmp(void *__s1,void *__s2,size_t __n)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_memcmp_00112e38)();\n  return iVar1;\n}\n\n", 
    "00109ae0": "\nulong dirent_inode_sort_may_be_useful(void)\n\n{\n  ulong uVar1;\n  \n  uVar1 = filesystem_type();\n  if ((uVar1 != 0x1021994) && (uVar1 != 0xff534d42)) {\n    return uVar1 & 0xffffffffffffff00 | (ulong)(uVar1 != 0x6969);\n  }\n  return 0;\n}\n\n", 
    "0010be10": "\nuint c_isblank(int param_1,undefined8 param_2,uint param_3)\n\n{\n  uint in_EAX;\n  \n  return in_EAX & 0xffffff00 | (uint)(param_1 == 0x20) | param_3 & 0xffffff00 | (uint)(param_1 == 9)\n  ;\n}\n\n", 
    "001026d0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint openat(int __fd,char *__file,int __oflag,...)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_openat_00112da8)();\n  return iVar1;\n}\n\n", 
    "00104a10": "\nulong raw_hasher(undefined8 param_1,ulong param_2)\n\n{\n  ulong uVar1;\n  \n  uVar1 = rotr_sz(param_1,3);\n  return uVar1 % param_2;\n}\n\n", 
    "00114068": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid context_new(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n  halt_baddata();\n}\n\n", 
    "00114188": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid context_free(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n  halt_baddata();\n}\n\n", 
    "00104e90": "\nbool hash_table_ok(long **param_1)\n\n{\n  long lVar1;\n  long *plVar2;\n  long *plVar3;\n  long *plVar4;\n  \n  plVar2 = *param_1;\n  plVar3 = (long *)0x0;\n  plVar4 = (long *)0x0;\n  do {\n    while( true ) {\n      if (param_1[1] <= plVar2) {\n        if (param_1[3] != plVar4) {\n          return false;\n        }\n        return param_1[4] == plVar3;\n      }\n      if (*plVar2 != 0) break;\nLAB_00104eb0:\n      plVar2 = plVar2 + 2;\n    }\n    lVar1 = plVar2[1];\n    plVar4 = (long *)((long)plVar4 + 1);\n    plVar3 = (long *)((long)plVar3 + 1);\n    if (lVar1 == 0) goto LAB_00104eb0;\n    do {\n      lVar1 = *(long *)(lVar1 + 8);\n      plVar3 = (long *)((long)plVar3 + 1);\n    } while (lVar1 != 0);\n    plVar2 = plVar2 + 2;\n  } while( true );\n}\n\n", 
    "00102a70": "\nvoid __fprintf_chk(void)\n\n{\n  (*(code *)PTR___fprintf_chk_00112f78)();\n  return;\n}\n\n", 
    "00109710": "\nlong fts_sort(long param_1,long param_2,ulong param_3)\n\n{\n  ulong uVar1;\n  long *plVar2;\n  __compar_fn_t __compar;\n  long *plVar3;\n  long lVar4;\n  long lVar5;\n  long *plVar6;\n  long lVar7;\n  \n  __compar = *(__compar_fn_t *)(param_1 + 0x40);\n  plVar3 = *(long **)(param_1 + 0x10);\n  if (param_3 <= *(ulong *)(param_1 + 0x38)) {\nLAB_00109765:\n    plVar6 = plVar3;\n    if (param_2 != 0) {\n      do {\n        *plVar6 = param_2;\n        param_2 = *(long *)(param_2 + 0x10);\n        plVar6 = plVar6 + 1;\n      } while (param_2 != 0);\n    }\n    qsort(plVar3,param_3,8,__compar);\n    plVar3 = *(long **)(param_1 + 0x10);\n    lVar7 = *plVar3;\n    lVar4 = lVar7;\n    lVar5 = param_3 - 1;\n    plVar6 = plVar3;\n    if (lVar5 != 0) {\n      while( true ) {\n        plVar2 = plVar6 + 1;\n        plVar6 = plVar6 + 1;\n        *(long *)(lVar7 + 0x10) = *plVar2;\n        lVar5 = lVar5 + -1;\n        if (lVar5 == 0) break;\n        lVar7 = *plVar6;\n      }\n      lVar7 = plVar3[param_3 - 1];\n    }\n    *(undefined8 *)(lVar7 + 0x10) = 0;\n    return lVar4;\n  }\n  uVar1 = param_3 + 0x28;\n  *(ulong *)(param_1 + 0x38) = uVar1;\n  if (uVar1 < 0x2000000000000000) {\n    plVar3 = (long *)realloc(plVar3,uVar1 * 8);\n    if (plVar3 != (long *)0x0) {\n      *(long **)(param_1 + 0x10) = plVar3;\n      goto LAB_00109765;\n    }\n    plVar3 = *(long **)(param_1 + 0x10);\n  }\n  free(plVar3);\n  *(undefined8 *)(param_1 + 0x10) = 0;\n  *(undefined8 *)(param_1 + 0x38) = 0;\n  return param_2;\n}\n\n", 
    "00114060": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid textdomain(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* textdomain@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00114180": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\n__mode_t umask(__mode_t __mask)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* umask@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00105210": "\nulong hash_string(byte *param_1,ulong param_2)\n\n{\n  byte bVar1;\n  ulong uVar2;\n  \n  uVar2 = 0;\n  bVar1 = *param_1;\n  while (bVar1 != 0) {\n    param_1 = param_1 + 1;\n    uVar2 = (uVar2 * 0x1f + (ulong)bVar1) % param_2;\n    bVar1 = *param_1;\n  }\n  return uVar2;\n}\n\n", 
    "00103390": "\nundefined8 se_const(undefined8 param_1)\n\n{\n  return param_1;\n}\n\n", 
    "001026c0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint __lxstat(int __ver,char *__filename,stat *__stat_buf)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR___lxstat_00112da0)();\n  return iVar1;\n}\n\n", 
    "0010be30": "\nulong c_iscntrl(uint param_1)\n\n{\n  ulong in_RAX;\n  \n  if ((int)param_1 < 0x20) {\n    return (ulong)(~param_1 >> 0x1f);\n  }\n  return in_RAX & 0xffffffffffffff00 | (ulong)(param_1 == 0x7f);\n}\n\n", 
    "001025a0": "\nvoid is_selinux_enabled(void)\n\n{\n  (*(code *)PTR_is_selinux_enabled_00112d10)();\n  return;\n}\n\n", 
    "00105c10": "\nulong triple_compare_ino_str(char **param_1,char **param_2)\n\n{\n  int iVar1;\n  undefined4 extraout_var;\n  \n  if ((param_1[1] == param_2[1]) && (param_1[2] == param_2[2])) {\n    iVar1 = strcmp(*param_1,*param_2);\n    return CONCAT44(extraout_var,iVar1) & 0xffffffffffffff00 | (ulong)(iVar1 == 0);\n  }\n  return 0;\n}\n\n", 
    "00107f10": "\nvoid quotearg_buffer(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n                    undefined1 *param_5)\n\n{\n  int iVar1;\n  int *piVar2;\n  \n  if ((undefined4 *)param_5 == (undefined4 *)0x0) {\n    param_5 = default_quoting_options;\n  }\n  piVar2 = __errno_location();\n  iVar1 = *piVar2;\n  quotearg_buffer_restyled\n            (param_1,param_2,param_3,param_4,*(undefined4 *)param_5,\n             *(undefined4 *)((long)param_5 + 4),(undefined4 *)((long)param_5 + 8),\n             *(undefined8 *)((long)param_5 + 0x28),*(undefined8 *)((long)param_5 + 0x30));\n  *piVar2 = iVar1;\n  return;\n}\n\n", 
    "001027e0": "\nvoid getcon(void)\n\n{\n  (*(code *)PTR_getcon_00112e30)();\n  return;\n}\n\n", 
    "00102a60": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t fwrite(void *__ptr,size_t __size,size_t __n,FILE *__s)\n\n{\n  size_t sVar1;\n  \n  sVar1 = (*(code *)PTR_fwrite_00112f70)();\n  return sVar1;\n}\n\n", 
    "00114078": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid bindtextdomain(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* bindtextdomain@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00114198": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid getfilecon(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n  halt_baddata();\n}\n\n", 
    "0010a330": "\nvoid * fts_build(long *param_1,int param_2)\n\n{\n  long lVar1;\n  DIR *__dirp;\n  long lVar2;\n  long lVar3;\n  bool bVar4;\n  void *pvVar5;\n  undefined *puVar6;\n  char cVar7;\n  undefined2 uVar8;\n  int iVar9;\n  int *piVar10;\n  dirent *pdVar11;\n  size_t sVar12;\n  void *__ptr;\n  uint uVar13;\n  uint uVar14;\n  undefined4 uVar15;\n  DIR *__dirp_00;\n  ulong uVar16;\n  ulong uVar17;\n  ulong uVar18;\n  long in_FS_OFFSET;\n  bool bVar19;\n  ulong local_a0;\n  void *local_98;\n  void *local_90;\n  undefined *local_70;\n  ulong local_68;\n  ulong local_60;\n  char local_4b;\n  char local_4a;\n  int local_44;\n  long local_40;\n  \n  lVar1 = *param_1;\n  __dirp = *(DIR **)(lVar1 + 0x18);\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (__dirp == (DIR *)0x0) {\n    uVar14 = *(uint *)(param_1 + 9);\n    uVar13 = uVar14 & 0x10;\n    if ((uVar13 != 0) && (uVar13 = 0x20000, (uVar14 & 1) != 0)) {\n      uVar13 = (uint)(*(long *)(lVar1 + 0x58) != 0) << 0x11;\n    }\n    uVar15 = 0xffffff9c;\n    if ((uVar14 & 0x204) == 0x200) {\n      uVar15 = *(undefined4 *)((long)param_1 + 0x2c);\n    }\n    local_90 = (void *)opendirat(uVar15,*(undefined8 *)(lVar1 + 0x30),(uVar14 & 0x800) << 7 | uVar13\n                                 ,&local_44);\n    *(void **)(lVar1 + 0x18) = local_90;\n    if (local_90 == (void *)0x0) {\n      if (param_2 == 3) {\n        *(undefined2 *)(lVar1 + 0x70) = 4;\n        piVar10 = __errno_location();\n        *(int *)(lVar1 + 0x40) = *piVar10;\n        goto LAB_0010a843;\n      }\n      goto LAB_0010ab3d;\n    }\n    if (*(short *)(lVar1 + 0x70) == 0xb) {\n      uVar8 = fts_stat(param_1,lVar1,0);\n      *(undefined2 *)(lVar1 + 0x70) = uVar8;\n    }\n    else if ((*(uint *)(param_1 + 9) & 0x100) != 0) {\n      leave_dir_isra_0(*(uint *)(param_1 + 9),param_1 + 0xb,lVar1);\n      fts_stat(param_1,lVar1,0);\n      cVar7 = enter_dir_isra_0(*(undefined4 *)(param_1 + 9),param_1 + 0xb,lVar1);\n      if (cVar7 == '\\0') {\n        piVar10 = __errno_location();\n        local_90 = (void *)0x0;\n        *piVar10 = 0xc;\n        goto LAB_0010a843;\n      }\n    }\n    local_68 = (ulong)(-(uint)(param_1[8] == 0) & 0x186a1) - 1;\n    if (param_2 == 2) {\nLAB_0010aa60:\n      bVar19 = false;\n      uVar14 = *(uint *)(param_1 + 9);\n    }\n    else {\n      if ((((*(uint *)(param_1 + 9) & 0x38) == 0x18) && (*(long *)(lVar1 + 0x88) == 2)) &&\n         (iVar9 = leaf_optimization(lVar1,local_44), iVar9 != 0)) {\n        if (param_2 != 3) goto LAB_0010aa60;\n        bVar4 = false;\n        bVar19 = true;\n      }\n      else {\n        bVar19 = param_2 == 3;\n        bVar4 = true;\n      }\n      if ((*(byte *)((long)param_1 + 0x49) & 2) != 0) {\n        local_44 = rpl_fcntl(local_44,0x406,3);\n      }\n      if ((-1 < local_44) && (iVar9 = fts_safe_changedir(param_1,lVar1,local_44,0), iVar9 == 0))\n      goto LAB_0010a38f;\n      if ((bVar19) && (bVar4)) {\n        piVar10 = __errno_location();\n        *(int *)(lVar1 + 0x40) = *piVar10;\n      }\n      *(ushort *)(lVar1 + 0x72) = *(ushort *)(lVar1 + 0x72) | 1;\n      closedir(*(DIR **)(lVar1 + 0x18));\n      uVar14 = *(uint *)(param_1 + 9);\n      *(undefined8 *)(lVar1 + 0x18) = 0;\n      if (((uVar14 & 0x200) != 0) && (-1 < local_44)) {\n        close(local_44);\n        uVar14 = *(uint *)(param_1 + 9);\n      }\n      *(undefined8 *)(lVar1 + 0x18) = 0;\n      bVar19 = false;\n    }\n  }\n  else {\n    local_44 = dirfd(__dirp);\n    if (local_44 < 0) {\n      closedir(*(DIR **)(lVar1 + 0x18));\n      *(undefined8 *)(lVar1 + 0x18) = 0;\n      if (param_2 == 3) {\n        *(undefined2 *)(lVar1 + 0x70) = 4;\n        piVar10 = __errno_location();\n        *(int *)(lVar1 + 0x40) = *piVar10;\n      }\nLAB_0010ab3d:\n      local_90 = (void *)0x0;\n      goto LAB_0010a843;\n    }\n    if (param_1[8] == 0) {\n      local_68 = 100000;\n      uVar14 = *(uint *)(param_1 + 9);\n      bVar19 = true;\n    }\n    else {\n      local_68 = 0xffffffffffffffff;\nLAB_0010a38f:\n      bVar19 = true;\n      uVar14 = *(uint *)(param_1 + 9);\n    }\n  }\n  uVar18 = *(ulong *)(lVar1 + 0x48);\n  local_a0 = uVar18;\n  local_60 = uVar18 - 1;\n  if (*(char *)(*(long *)(lVar1 + 0x38) + -1 + uVar18) != '/') {\n    local_a0 = uVar18 + 1;\n    local_60 = uVar18;\n  }\n  local_70 = (undefined *)0x0;\n  if ((uVar14 & 4) != 0) {\n    local_70 = (undefined *)(local_60 + param_1[4]) + 1;\n    *(undefined *)(local_60 + param_1[4]) = 0x2f;\n  }\n  __dirp_00 = *(DIR **)(lVar1 + 0x18);\n  lVar2 = *(long *)(lVar1 + 0x58);\n  uVar18 = param_1[6] - local_a0;\n  if (__dirp_00 == (DIR *)0x0) {\n    if ((*(byte *)(param_1 + 9) & 4) != 0) {\n      local_90 = (void *)0x0;\n      uVar16 = 0;\n      local_4a = '\\0';\nLAB_0010a924:\n      local_70 = local_70 + -1;\n      goto LAB_0010a92a;\n    }\n    local_90 = (void *)0x0;\n    if ((bool)(bVar19 & __dirp == (DIR *)0x0)) {\n      local_4a = '\\0';\n      uVar16 = 0;\n      goto LAB_0010a9b0;\n    }\nLAB_0010a9d9:\n    if (((param_2 == 3) && (*(short *)(lVar1 + 0x70) != 7)) && (*(short *)(lVar1 + 0x70) != 4)) {\n      *(undefined2 *)(lVar1 + 0x70) = 6;\n    }\n    fts_lfree(local_90);\n    local_90 = (void *)0x0;\n  }\n  else {\n    piVar10 = __errno_location();\n    local_4a = '\\0';\n    local_4b = '\\0';\n    local_98 = (void *)0x0;\n    local_90 = (void *)0x0;\n    uVar17 = 0;\n    do {\n      while( true ) {\n        *piVar10 = 0;\n        pdVar11 = readdir(__dirp_00);\n        uVar16 = uVar17;\n        if (pdVar11 == (dirent *)0x0) {\n          if (*piVar10 != 0) {\n            *(int *)(lVar1 + 0x40) = *piVar10;\n            *(ushort *)(lVar1 + 0x70) = (-(ushort)(((ulong)__dirp | uVar17) == 0) & 0xfffd) + 7;\n          }\n          if (*(DIR **)(lVar1 + 0x18) != (DIR *)0x0) {\n            closedir(*(DIR **)(lVar1 + 0x18));\n            *(undefined8 *)(lVar1 + 0x18) = 0;\n          }\n          goto LAB_0010a8f4;\n        }\n        if ((((*(byte *)(param_1 + 9) & 0x20) != 0) || (pdVar11->d_name[0] != '.')) ||\n           ((pdVar11->d_name[1] != '\\0' && (*(short *)(pdVar11->d_name + 1) != 0x2e)))) break;\nLAB_0010a463:\n        __dirp_00 = *(DIR **)(lVar1 + 0x18);\n        uVar17 = uVar16;\n        if (__dirp_00 == (DIR *)0x0) goto LAB_0010a8f4;\n      }\n      sVar12 = strlen(pdVar11->d_name);\n      __ptr = (void *)fts_alloc(param_1,pdVar11->d_name,sVar12);\n      if (__ptr == (void *)0x0) {\nLAB_0010a7f0:\n        iVar9 = *piVar10;\n        free(__ptr);\n        fts_lfree(local_90);\n        closedir(*(DIR **)(lVar1 + 0x18));\n        *(undefined8 *)(lVar1 + 0x18) = 0;\n        *(undefined2 *)(lVar1 + 0x70) = 7;\n        local_90 = (void *)0x0;\n        *(uint *)(param_1 + 9) = *(uint *)(param_1 + 9) | 0x4000;\n        *piVar10 = iVar9;\n        goto LAB_0010a843;\n      }\n      if (uVar18 <= sVar12) {\n        lVar3 = param_1[4];\n        cVar7 = fts_palloc_isra_0(param_1 + 4,param_1 + 6,local_60 + 2 + sVar12);\n        if (cVar7 == '\\0') goto LAB_0010a7f0;\n        puVar6 = local_70;\n        if ((param_1[4] != lVar3) &&\n           (local_4b = cVar7, puVar6 = (undefined *)(param_1[4] + local_a0),\n           (*(byte *)(param_1 + 9) & 4) == 0)) {\n          puVar6 = local_70;\n        }\n        local_70 = puVar6;\n        uVar18 = param_1[6] - local_a0;\n      }\n      if (CARRY8(sVar12,local_a0)) {\n        free(__ptr);\n        fts_lfree(local_90);\n        closedir(*(DIR **)(lVar1 + 0x18));\n        *(undefined8 *)(lVar1 + 0x18) = 0;\n        *(undefined2 *)(lVar1 + 0x70) = 7;\n        local_90 = (void *)0x0;\n        *(uint *)(param_1 + 9) = *(uint *)(param_1 + 9) | 0x4000;\n        *piVar10 = 0x24;\n        goto LAB_0010a843;\n      }\n      *(long *)((long)__ptr + 0x58) = lVar2 + 1;\n      lVar3 = *param_1;\n      *(size_t *)((long)__ptr + 0x48) = sVar12 + local_a0;\n      *(long *)((long)__ptr + 8) = lVar3;\n      *(__ino_t *)((long)__ptr + 0x80) = pdVar11->d_ino;\n      uVar14 = *(uint *)(param_1 + 9);\n      if ((uVar14 & 4) == 0) {\n        *(void **)((long)__ptr + 0x30) = (void *)((long)__ptr + 0x108);\n      }\n      else {\n        *(undefined8 *)((long)__ptr + 0x30) = *(undefined8 *)((long)__ptr + 0x38);\n        memmove(local_70,(void *)((long)__ptr + 0x108),*(long *)((long)__ptr + 0x60) + 1);\n        uVar14 = *(uint *)(param_1 + 9);\n      }\n      if ((param_1[8] == 0) || ((uVar14 & 0x400) != 0)) {\n        uVar16 = 1;\n        if ((uVar14 & 0x18) == 0x18) {\n          uVar16 = (ulong)((pdVar11->d_type & 0xfb) == 0);\n        }\n        *(undefined2 *)((long)__ptr + 0x70) = 0xb;\n        set_stat_type_isra_0((long)__ptr + 0x90);\n        fts_set_stat_required(__ptr,uVar16 & 0xffffffff);\n      }\n      else {\n        uVar8 = fts_stat(param_1,__ptr,0);\n        *(undefined2 *)((long)__ptr + 0x70) = uVar8;\n      }\n      *(undefined8 *)((long)__ptr + 0x10) = 0;\n      pvVar5 = __ptr;\n      if (local_90 != (void *)0x0) {\n        *(void **)((long)local_98 + 0x10) = __ptr;\n        pvVar5 = local_90;\n      }\n      local_90 = pvVar5;\n      uVar16 = uVar17 + 1;\n      local_98 = __ptr;\n      if (uVar17 != 10000) {\n        if (uVar16 < local_68) goto LAB_0010a463;\n        break;\n      }\n      if (param_1[8] == 0) {\n        local_4a = dirent_inode_sort_may_be_useful(lVar1,local_44);\n      }\n      uVar16 = 0x2711;\n      __dirp_00 = *(DIR **)(lVar1 + 0x18);\n      uVar17 = uVar16;\n    } while (__dirp_00 != (DIR *)0x0);\nLAB_0010a8f4:\n    if (local_4b != '\\0') {\n      fts_padjust_isra_0(param_1[1],param_1[4],local_90);\n    }\n    if ((*(byte *)(param_1 + 9) & 4) != 0) {\n      if ((param_1[6] == local_a0) || (uVar16 == 0)) goto LAB_0010a924;\nLAB_0010a92a:\n      *local_70 = 0;\n    }\n    if ((__dirp == (DIR *)0x0) && (bVar19)) {\n      if ((param_2 == 1) || (uVar16 == 0)) {\nLAB_0010a9b0:\n        if (*(long *)(lVar1 + 0x58) == 0) {\n          iVar9 = restore_initial_cwd(param_1);\n        }\n        else {\n          iVar9 = fts_safe_changedir(param_1,*(undefined8 *)(lVar1 + 8),0xffffffff,&DAT_0010e6c3);\n        }\n        if (iVar9 != 0) {\n          *(undefined2 *)(lVar1 + 0x70) = 7;\n          *(uint *)(param_1 + 9) = *(uint *)(param_1 + 9) | 0x4000;\n          fts_lfree(local_90);\n          local_90 = (void *)0x0;\n          goto LAB_0010a843;\n        }\n        goto LAB_0010a9d0;\n      }\n    }\n    else {\nLAB_0010a9d0:\n      if (uVar16 == 0) goto LAB_0010a9d9;\n    }\n    if (local_4a == '\\0') {\n      if ((param_1[8] != 0) && (uVar16 != 1)) {\n        local_90 = (void *)fts_sort(param_1,local_90,uVar16);\n      }\n    }\n    else {\n      param_1[8] = (long)fts_compare_ino;\n      local_90 = (void *)fts_sort(param_1,local_90,uVar16);\n      param_1[8] = 0;\n    }\n  }\nLAB_0010a843:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_90;\n}\n\n", 
    "00114070": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fclose(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fclose@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00114190": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * memcpy(void *__dest,void *__src,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* memcpy@@GLIBC_2.14 */\n  halt_baddata();\n}\n\n", 
    "0010c720": "\nvoid __libc_csu_init(EVP_PKEY_CTX *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  long lVar1;\n  \n  _init(param_1);\n  lVar1 = 0;\n  do {\n    (*(code *)(&__frame_dummy_init_array_entry)[lVar1])((ulong)param_1 & 0xffffffff,param_2,param_3)\n    ;\n    lVar1 = lVar1 + 1;\n  } while (lVar1 != 1);\n  return;\n}\n\n", 
    "0010c840": "\nint mknod(char *__path,__mode_t __mode,__dev_t __dev)\n\n{\n  int iVar1;\n  __dev_t local_10 [2];\n  \n  local_10[0] = __dev;\n  iVar1 = __xmknod(0,__path,__mode,local_10);\n  return iVar1;\n}\n\n", 
    "001090b0": "\nuint xstrtoumax(byte *param_1,byte **param_2,uint param_3,uintmax_t *param_4,char *param_5)\n\n{\n  byte bVar1;\n  uint uVar2;\n  int *piVar3;\n  ushort **ppuVar4;\n  byte *pbVar5;\n  uintmax_t uVar6;\n  char *pcVar7;\n  int iVar8;\n  undefined8 uVar9;\n  uint uVar10;\n  byte bVar11;\n  long in_FS_OFFSET;\n  byte *local_50;\n  uintmax_t local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (0x24 < param_3) {\n                    /* WARNING: Subroutine does not return */\n    __assert_fail(\"0 <= strtol_base && strtol_base <= 36\",\"lib/xstrtol.c\",0x60,\"xstrtoumax\");\n  }\n  if (param_2 == (byte **)0x0) {\n    param_2 = &local_50;\n  }\n  piVar3 = __errno_location();\n  *piVar3 = 0;\n  bVar11 = *param_1;\n  ppuVar4 = __ctype_b_loc();\n  pbVar5 = param_1;\n  while ((*(byte *)((long)*ppuVar4 + (ulong)bVar11 * 2 + 1) & 0x20) != 0) {\n    bVar11 = pbVar5[1];\n    pbVar5 = pbVar5 + 1;\n  }\n  if (bVar11 != 0x2d) {\n    uVar6 = strtoumax((char *)param_1,(char **)param_2,param_3);\n    pbVar5 = *param_2;\n    local_48 = uVar6;\n    if (pbVar5 != param_1) {\n      if (*piVar3 == 0) {\n        uVar10 = 0;\n      }\n      else {\n        uVar10 = 1;\n        if (*piVar3 != 0x22) goto LAB_001091ab;\n      }\n      if ((param_5 != (char *)0x0) && (bVar11 = *pbVar5, bVar11 != 0)) {\n        iVar8 = (int)(char)bVar11;\nLAB_001091ec:\n        pcVar7 = strchr(param_5,iVar8);\n        if (pcVar7 == (char *)0x0) {\nswitchD_00109240_caseD_43:\n          uVar10 = uVar10 | 2;\n          *param_4 = local_48;\n          goto LAB_00109172;\n        }\n        switch(bVar11) {\n        case 0x45:\n        case 0x47:\n        case 0x4b:\n        case 0x4d:\n        case 0x50:\n        case 0x54:\n        case 0x59:\n        case 0x5a:\n        case 0x67:\n        case 0x6b:\n        case 0x6d:\n        case 0x74:\n          pcVar7 = strchr(param_5,0x30);\n          if (pcVar7 == (char *)0x0) goto switchD_00109216_caseD_46;\n          bVar1 = pbVar5[1];\n          if (bVar1 == 0x44) {\n            iVar8 = 2;\n            uVar9 = 1000;\n          }\n          else if (bVar1 == 0x69) {\n            uVar9 = 0x400;\n            iVar8 = (pbVar5[2] == 0x42) + 1 + (uint)(pbVar5[2] == 0x42);\n          }\n          else {\n            iVar8 = (bVar1 == 0x42) + 1;\n            uVar9 = 0x400;\n            if (bVar1 == 0x42) {\n              uVar9 = 1000;\n            }\n          }\n          break;\n        default:\nswitchD_00109216_caseD_46:\n          iVar8 = 1;\n          uVar9 = 0x400;\n        }\n        switch(bVar11) {\n        case 0x42:\n          uVar2 = bkm_scale(&local_48,0x400);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n          break;\n        default:\n          goto switchD_00109240_caseD_43;\n        case 0x45:\n          uVar2 = bkm_scale_by_power(&local_48,uVar9,6);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n          break;\n        case 0x47:\n        case 0x67:\n          uVar2 = bkm_scale_by_power(&local_48,uVar9,3);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n          break;\n        case 0x4b:\n        case 0x6b:\n          uVar2 = bkm_scale_by_power(&local_48,uVar9,1);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n          break;\n        case 0x4d:\n        case 0x6d:\n          uVar2 = bkm_scale_by_power(&local_48,uVar9,2);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n          break;\n        case 0x50:\n          uVar2 = bkm_scale_by_power(&local_48,uVar9,5);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n          break;\n        case 0x54:\n        case 0x74:\n          uVar2 = bkm_scale_by_power(&local_48,uVar9,4);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n          break;\n        case 0x59:\n          uVar2 = bkm_scale_by_power(&local_48,uVar9,8);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n          break;\n        case 0x5a:\n          uVar2 = bkm_scale_by_power(&local_48,uVar9,7);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n          break;\n        case 0x62:\n          uVar2 = bkm_scale(&local_48,0x200);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n          break;\n        case 99:\n          break;\n        case 0x77:\n          uVar2 = bkm_scale(&local_48,2);\n          pbVar5 = *param_2;\n          uVar10 = uVar10 | uVar2;\n        }\n        uVar6 = local_48;\n        *param_2 = pbVar5 + iVar8;\n        if (pbVar5[iVar8] != 0) {\n          uVar10 = uVar10 | 2;\n        }\n      }\n      *param_4 = uVar6;\n      goto LAB_00109172;\n    }\n    if ((param_5 != (char *)0x0) && (bVar11 = *param_1, bVar11 != 0)) {\n      iVar8 = (int)(char)bVar11;\n      pcVar7 = strchr(param_5,iVar8);\n      if (pcVar7 != (char *)0x0) {\n        local_48 = 1;\n        uVar10 = 0;\n        goto LAB_001091ec;\n      }\n    }\n  }\nLAB_001091ab:\n  uVar10 = 4;\nLAB_00109172:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar10;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00108510": "\nvoid quote(undefined8 param_1)\n\n{\n  quote_n(0,param_1);\n  return;\n}\n\n", 
    "00106330": "\nbool strcaseeq9(long param_1,long param_2)\n\n{\n  int iVar1;\n  \n  iVar1 = c_strcasecmp(param_1 + 9,param_2 + 9);\n  return iVar1 == 0;\n}\n\n", 
    "00114038": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid context_type_get(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n  halt_baddata();\n}\n\n", 
    "00114158": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid lgetfilecon(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n  halt_baddata();\n}\n\n", 
    "001026f0": "\nvoid getopt_long(void)\n\n{\n  (*(code *)PTR_getopt_long_00112db8)();\n  return;\n}\n\n", 
    "0010bf10": "\nulong c_isxdigit(int param_1)\n\n{\n  ulong uVar1;\n  \n  if (param_1 - 0x30U < 0x37) {\n    uVar1 = 1L << ((byte)(param_1 - 0x30U) & 0x3f);\n    return uVar1 & 0xffffffffffffff00 | (ulong)((uVar1 & 0x7e0000007e03ff) != 0);\n  }\n  return 0;\n}\n\n", 
    "001025d0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint strncmp(char *__s1,char *__s2,size_t __n)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_strncmp_00112d28)();\n  return iVar1;\n}\n\n", 
    "00114040": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid lsetfilecon(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n  halt_baddata();\n}\n\n", 
    "00114168": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint dirfd(DIR *__dirp)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* dirfd@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00114288": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid _ITM_registerTMCloneTable(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n  halt_baddata();\n}\n\n", 
    "00104a30": "\nbool raw_comparator(long param_1,long param_2)\n\n{\n  return param_2 == param_1;\n}\n\n", 
    "00102a90": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint mbsinit(mbstate_t *__ps)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_mbsinit_00112f88)();\n  return iVar1;\n}\n\n", 
    "00114160": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint strcmp(char *__s1,char *__s2)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strcmp@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00109810": "\nvoid * fts_alloc(long param_1,void *param_2,size_t param_3)\n\n{\n  undefined8 uVar1;\n  void *pvVar2;\n  \n  pvVar2 = malloc(param_3 + 0x110 & 0xfffffffffffffff8);\n  if (pvVar2 != (void *)0x0) {\n    memcpy((void *)((long)pvVar2 + 0x108),param_2,param_3);\n    uVar1 = *(undefined8 *)(param_1 + 0x20);\n    *(undefined *)((long)pvVar2 + param_3 + 0x108) = 0;\n    *(size_t *)((long)pvVar2 + 0x60) = param_3;\n    *(long *)((long)pvVar2 + 0x50) = param_1;\n    *(undefined8 *)((long)pvVar2 + 0x38) = uVar1;\n    *(undefined4 *)((long)pvVar2 + 0x40) = 0;\n    *(undefined8 *)((long)pvVar2 + 0x18) = 0;\n    *(undefined4 *)((long)pvVar2 + 0x72) = 0x30000;\n    *(undefined8 *)((long)pvVar2 + 0x20) = 0;\n    *(undefined8 *)((long)pvVar2 + 0x28) = 0;\n  }\n  return pvVar2;\n}\n\n", 
    "00114280": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __fprintf_chk(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __fprintf_chk@@GLIBC_2.3.4 */\n  halt_baddata();\n}\n\n", 
    "00108500": "\nvoid quote_n(undefined8 param_1,undefined8 param_2)\n\n{\n  quote_n_mem(param_1,param_2,0xffffffffffffffff);\n  return;\n}\n\n", 
    "00104020": "\nchar * canonicalize_filename_mode(char *param_1,uint param_2)\n\n{\n  ulong uVar1;\n  bool bVar2;\n  long lVar3;\n  char cVar4;\n  int iVar5;\n  char *__s;\n  size_t sVar6;\n  char *__s_00;\n  size_t sVar7;\n  int *piVar8;\n  uint uVar9;\n  char *__dest;\n  long lVar10;\n  char *pcVar11;\n  char *pcVar12;\n  char cVar13;\n  char *pcVar14;\n  long in_FS_OFFSET;\n  void *local_108;\n  char *local_100;\n  ulong local_f0;\n  long local_e0;\n  stat local_d8;\n  long local_40;\n  \n  uVar9 = param_2 & 3;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_e0 = 0;\n  if (((uVar9 & uVar9 - 1) != 0) || (param_1 == (char *)0x0)) {\n    piVar8 = __errno_location();\n    __s = (char *)0x0;\n    *piVar8 = 0x16;\n    goto LAB_00104260;\n  }\n  if (*param_1 == '\\0') {\n    piVar8 = __errno_location();\n    __s = (char *)0x0;\n    *piVar8 = 2;\n    goto LAB_00104260;\n  }\n  if (*param_1 == '/') {\n    __s = (char *)xmalloc(0x1000);\n    *__s = '/';\n    pcVar12 = __s + 0x1000;\n    __dest = __s + 1;\n    cVar4 = *param_1;\n    if (cVar4 != '\\0') {\nLAB_001040c1:\n      local_f0 = 0;\n      local_108 = (void *)0x0;\n      local_100 = param_1;\n      do {\n        pcVar11 = param_1;\n        cVar13 = cVar4;\n        if (cVar4 == '/') {\n          do {\n            cVar13 = param_1[1];\n            param_1 = param_1 + 1;\n          } while (cVar13 == '/');\n          pcVar11 = param_1;\n          if (cVar13 == '\\0') break;\n        }\n        do {\n          pcVar14 = param_1;\n          cVar4 = pcVar14[1];\n          param_1 = pcVar14 + 1;\n          if (cVar4 == '\\0') break;\n        } while (cVar4 != '/');\n        if (param_1 == pcVar11) break;\n        sVar6 = (long)param_1 - (long)pcVar11;\n        if (sVar6 == 1) {\n          if (cVar13 != '.') goto LAB_0010415d;\n        }\n        else {\n          if (((sVar6 != 2) || (cVar13 != '.')) || (pcVar11[1] != '.')) {\nLAB_0010415d:\n            if (__dest[-1] != '/') {\n              *__dest = '/';\n              __dest = __dest + 1;\n            }\n            if (pcVar12 <= __dest + sVar6) {\n              lVar10 = (long)__dest - (long)__s;\n              lVar3 = 0x1000 - (long)__s;\n              if (0xfff < (long)sVar6) {\n                lVar3 = (sVar6 + 1) - (long)__s;\n              }\n              __s = (char *)xrealloc(__s,pcVar12 + lVar3);\n              pcVar12 = __s + (long)(pcVar12 + lVar3);\n              __dest = __s + lVar10;\n            }\n            memcpy(__dest,pcVar11,sVar6);\n            __dest = __dest + sVar6;\n            *__dest = '\\0';\n            pcVar11 = __dest;\n            if ((uVar9 == 2) && ((param_2 & 4) != 0)) {\nLAB_001041e0:\n              local_d8.st_mode = 0;\nLAB_001041e8:\n              if ((*param_1 == '\\0') || (uVar9 == 2)) {\nLAB_001041fa:\n                cVar4 = *param_1;\n                __dest = pcVar11;\n                goto LAB_00104202;\n              }\n              piVar8 = __errno_location();\n              iVar5 = 0x14;\n            }\n            else {\n              if ((param_2 & 4) == 0) {\n                iVar5 = lstat(__s,&local_d8);\n              }\n              else {\n                iVar5 = stat(__s,&local_d8);\n              }\n              if (iVar5 == 0) {\n                if ((local_d8.st_mode & 0xf000) != 0xa000) {\n                  if ((local_d8.st_mode & 0xf000) != 0x4000) goto LAB_001041e8;\n                  goto LAB_001041fa;\n                }\n                cVar4 = seen_triple(&local_e0,local_100,&local_d8);\n                if (cVar4 == '\\0') {\n                  __s_00 = (char *)areadlink_with_size(__s,local_d8.st_size);\n                  if (__s_00 != (char *)0x0) {\n                    sVar6 = strlen(__s_00);\n                    sVar7 = strlen(param_1);\n                    uVar1 = sVar6 + 1 + sVar7;\n                    if (local_f0 == 0) {\n                      local_f0 = 0x1000;\n                      if (0xfff < uVar1) {\n                        local_f0 = uVar1;\n                      }\n                      local_108 = (void *)xmalloc(local_f0);\n                    }\n                    else if (local_f0 < uVar1) {\n                      local_108 = (void *)xrealloc(local_108,uVar1);\n                      local_f0 = uVar1;\n                    }\n                    memmove((void *)((long)local_108 + sVar6),param_1,sVar7 + 1);\n                    param_1 = (char *)memcpy(local_108,__s_00,sVar6);\n                    pcVar11 = __s + 1;\n                    if (*__s_00 == '/') {\n                      *__s = '/';\n                    }\n                    else {\n                      bVar2 = pcVar11 < __dest;\n                      pcVar11 = __dest;\n                      if ((bVar2) && (pcVar11 = __dest + -1, __s < pcVar11)) {\n                        do {\n                          if (pcVar11[-1] == '/') break;\n                          pcVar11 = pcVar11 + -1;\n                        } while (__s != pcVar11);\n                      }\n                    }\n                    free(__s_00);\n                    local_100 = param_1;\n                    goto LAB_001041fa;\n                  }\n                  piVar8 = __errno_location();\n                  iVar5 = *piVar8;\n                  if ((uVar9 == 2) && (iVar5 != 0xc)) goto LAB_0010433c;\n                }\n                else {\n                  if (uVar9 == 2) {\nLAB_0010433c:\n                    cVar4 = pcVar14[1];\n                    goto LAB_00104202;\n                  }\n                  piVar8 = __errno_location();\n                  iVar5 = 0x28;\n                }\n              }\n              else {\n                piVar8 = __errno_location();\n                iVar5 = *piVar8;\n                if ((param_2 & 3) != 0) {\n                  if (uVar9 != 1) goto LAB_001041e0;\n                  sVar6 = strspn(param_1,\"/\");\n                  if ((param_1[sVar6] == '\\0') && (iVar5 == 2)) goto LAB_0010433c;\n                }\n              }\n            }\n            free(local_108);\n            free(__s);\n            if (local_e0 != 0) {\n              hash_free();\n            }\n            *piVar8 = iVar5;\n            __s = (char *)0x0;\n            goto LAB_00104260;\n          }\n          if ((__s + 1 < __dest) && (__dest = __dest + -1, __s < __dest)) {\n            do {\n              if (__dest[-1] == '/') break;\n              __dest = __dest + -1;\n            } while (__dest != __s);\n          }\n        }\nLAB_00104202:\n      } while (cVar4 != '\\0');\n      goto LAB_00104210;\n    }\n    local_108 = (void *)0x0;\n    pcVar11 = __dest;\nLAB_00104223:\n    __dest = pcVar11 + 1;\n  }\n  else {\n    __s = (char *)xgetcwd();\n    if (__s == (char *)0x0) goto LAB_00104260;\n    sVar6 = strlen(__s);\n    if (sVar6 < 0x1000) {\n      __s = (char *)xrealloc(__s,0x1000);\n      __dest = __s + sVar6;\n      pcVar12 = __s + 0x1000;\n    }\n    else {\n      __dest = __s + sVar6;\n      pcVar12 = __dest;\n    }\n    cVar4 = *param_1;\n    if (cVar4 != '\\0') goto LAB_001040c1;\n    local_108 = (void *)0x0;\nLAB_00104210:\n    pcVar11 = __dest;\n    if ((__dest <= __s + 1) || (__dest[-1] != '/')) goto LAB_00104223;\n    pcVar11 = __dest + -1;\n  }\n  *pcVar11 = '\\0';\n  if (__dest != pcVar12) {\n    __s = (char *)xrealloc(__s,pcVar11 + (1 - (long)__s));\n  }\n  free(local_108);\n  if (local_e0 != 0) {\n    hash_free();\n  }\nLAB_00104260:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return __s;\n}\n\n", 
    "00106440": "\nundefined8 strcaseeq6(long param_1,undefined8 param_2,byte param_3,char param_4,char param_5)\n\n{\n  char cVar1;\n  byte bVar2;\n  undefined8 uVar3;\n  \n  cVar1 = c_isupper((int)(char)param_3);\n  bVar2 = *(byte *)(param_1 + 6);\n  if (cVar1 != '\\0') {\n    bVar2 = bVar2 & 0xdf;\n  }\n  if (param_3 != bVar2) {\n    return 0;\n  }\n  if (param_3 == 0) {\n    return 1;\n  }\n  uVar3 = strcaseeq7(param_1,param_2,(int)param_4,(int)param_5);\n  return uVar3;\n}\n\n", 
    "00114048": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid qsort(void *__base,size_t __nmemb,size_t __size,__compar_fn_t __compar)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* qsort@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010be00": "\nbool c_isascii(uint param_1)\n\n{\n  return param_1 < 0x80;\n}\n\n", 
    "001026e0": "\nvoid __stack_chk_fail(void)\n\n{\n  (*(code *)PTR___stack_chk_fail_00112db0)();\n  return;\n}\n\n", 
    "001025c0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint * __errno_location(void)\n\n{\n  int *piVar1;\n  \n  piVar1 = (int *)(*(code *)PTR___errno_location_00112d20)();\n  return piVar1;\n}\n\n", 
    "00114058": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fcntl(int __fd,int __cmd,...)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fcntl@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00114178": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __gmon_start__(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n  halt_baddata();\n}\n\n", 
    "00114298": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint mbsinit(mbstate_t *__ps)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* mbsinit@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00102a80": "\nvoid getfscreatecon(void)\n\n{\n  (*(code *)PTR_getfscreatecon_00112f80)();\n  return;\n}\n\n", 
    "00109940": "\nDIR * opendirat(undefined8 param_1,undefined8 param_2,uint param_3,int *param_4)\n\n{\n  int iVar1;\n  int __fd;\n  DIR *pDVar2;\n  int *piVar3;\n  \n  pDVar2 = (DIR *)0x0;\n  __fd = openat_safer(param_1,param_2,param_3 | 0x90900);\n  if (-1 < __fd) {\n    pDVar2 = fdopendir(__fd);\n    if (pDVar2 == (DIR *)0x0) {\n      piVar3 = __errno_location();\n      iVar1 = *piVar3;\n      close(__fd);\n      *piVar3 = iVar1;\n      return (DIR *)0x0;\n    }\n    *param_4 = __fd;\n  }\n  return pDVar2;\n}\n\n", 
    "00114050": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nssize_t readlink(char *__path,char *__buf,size_t __len)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* readlink@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00114170": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint mkfifo(char *__path,__mode_t __mode)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* mkfifo@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00114290": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid getfscreatecon(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n  halt_baddata();\n}\n\n", 
    "0010c700": "\nvoid dup_safer(undefined8 param_1)\n\n{\n  rpl_fcntl(param_1,0,3);\n  return;\n}\n\n", 
    "0010c820": "\nint fstatat(int __fd,char *__file,stat *__buf,int __flag)\n\n{\n  int iVar1;\n  \n  iVar1 = __fxstatat(1,__fd,__file,__buf,__flag);\n  return iVar1;\n}\n\n", 
    "00106630": "\nundefined8\nstrcaseeq3(long param_1,undefined8 param_2,byte param_3,char param_4,char param_5,char param_6,\n          char param_7)\n\n{\n  char cVar1;\n  byte bVar2;\n  undefined8 uVar3;\n  \n  cVar1 = c_isupper((int)(char)param_3);\n  bVar2 = *(byte *)(param_1 + 3);\n  if (cVar1 != '\\0') {\n    bVar2 = bVar2 & 0xdf;\n  }\n  if (param_3 != bVar2) {\n    return 0;\n  }\n  if (param_3 == 0) {\n    return 1;\n  }\n  uVar3 = strcaseeq4(param_1,param_2,(int)param_4,(int)param_5,(int)param_6,(int)param_7);\n  return uVar3;\n}\n\n", 
    "00109ccb": "\nvoid FUN_00109ccb(long param_1,long param_2,long param_3)\n\n{\n  long lVar1;\n  \n  for (; param_1 != 0; param_1 = *(long *)(param_1 + 0x10)) {\n    if (*(long *)(param_1 + 0x30) != param_1 + 0x108) {\n      *(long *)(param_1 + 0x30) = (*(long *)(param_1 + 0x30) - *(long *)(param_1 + 0x38)) + param_2;\n    }\n    *(long *)(param_1 + 0x38) = param_2;\n  }\n  do {\n    if (*(long *)(param_3 + 0x58) < 0) {\n      return;\n    }\n    while( true ) {\n      if (*(long *)(param_3 + 0x30) != param_3 + 0x108) {\n        *(long *)(param_3 + 0x30) =\n             (*(long *)(param_3 + 0x30) - *(long *)(param_3 + 0x38)) + param_2;\n      }\n      lVar1 = *(long *)(param_3 + 0x10);\n      *(long *)(param_3 + 0x38) = param_2;\n      if (lVar1 == 0) break;\n      param_3 = lVar1;\n      if (*(long *)(lVar1 + 0x58) < 0) {\n        return;\n      }\n    }\n    param_3 = *(long *)(param_3 + 8);\n  } while( true );\n}\n\n", 
    "00114018": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint strncmp(char *__s1,char *__s2,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strncmp@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00114138": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint memcmp(void *__s1,void *__s2,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* memcmp@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00114258": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid security_compute_create(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n  halt_baddata();\n}\n\n", 
    "001029f0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nuintmax_t strtoumax(char *__nptr,char **__endptr,int __base)\n\n{\n  uintmax_t uVar1;\n  \n  uVar1 = (*(code *)PTR_strtoumax_00112f38)();\n  return uVar1;\n}\n\n", 
    "001028d0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint __xstat(int __ver,char *__filename,stat *__stat_buf)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR___xstat_00112ea8)();\n  return iVar1;\n}\n\n", 
    "001027b0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t strspn(char *__s,char *__accept)\n\n{\n  size_t sVar1;\n  \n  sVar1 = (*(code *)PTR_strspn_00112e18)();\n  return sVar1;\n}\n\n", 
    "00114020": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid _ITM_deregisterTMCloneTable(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n  halt_baddata();\n}\n\n", 
    "00114140": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fputs_unlocked(char *__s,FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fputs_unlocked@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00108bf0": "\nvoid version_etc(void)\n\n{\n  long lVar1;\n  long in_FS_OFFSET;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  version_etc_va();\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00114260": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __cxa_atexit(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __cxa_atexit@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00102a30": "\nvoid __cxa_atexit(void)\n\n{\n  (*(code *)PTR___cxa_atexit_00112f58)();\n  return;\n}\n\n", 
    "00105530": "\nundefined4 hash_rehash(void **param_1,undefined8 param_2)\n\n{\n  void *pvVar1;\n  char cVar2;\n  undefined4 uVar3;\n  void *__nmemb;\n  long in_FS_OFFSET;\n  void *local_88;\n  void *local_80;\n  void *local_78;\n  void *local_70;\n  undefined8 local_68;\n  void *local_60;\n  void *local_58;\n  void *local_50;\n  void *local_48;\n  void *local_40;\n  long local_30;\n  \n  pvVar1 = param_1[5];\n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  __nmemb = (void *)compute_bucket_size_isra_0\n                              (*(undefined4 *)((long)pvVar1 + 8),param_2,\n                               *(undefined *)((long)pvVar1 + 0x10));\n  if (__nmemb != (void *)0x0) {\n    if (param_1[2] == __nmemb) {\n      uVar3 = 1;\n      goto LAB_0010563c;\n    }\n    local_88 = calloc((size_t)__nmemb,0x10);\n    if (local_88 != (void *)0x0) {\n      local_80 = (void *)((long)__nmemb * 0x10 + (long)local_88);\n      local_58 = param_1[6];\n      local_50 = param_1[7];\n      local_48 = param_1[8];\n      local_70 = (void *)0x0;\n      local_40 = param_1[9];\n      local_68 = 0;\n      local_78 = __nmemb;\n      local_60 = pvVar1;\n      uVar3 = transfer_entries(&local_88,param_1,0);\n      if ((char)uVar3 == '\\0') {\n        param_1[9] = local_40;\n        cVar2 = transfer_entries(param_1,&local_88,1);\n        if (cVar2 != '\\0') {\n          cVar2 = transfer_entries(param_1,&local_88,0);\n          if (cVar2 != '\\0') {\n            free(local_88);\n            goto LAB_0010563c;\n          }\n        }\n                    /* WARNING: Subroutine does not return */\n        abort();\n      }\n      free(*param_1);\n      *param_1 = local_88;\n      param_1[1] = local_80;\n      param_1[2] = local_78;\n      param_1[3] = local_70;\n      param_1[9] = local_40;\n      goto LAB_0010563c;\n    }\n  }\n  uVar3 = 0;\nLAB_0010563c:\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar3;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00102020": "\nvoid FUN_00102020(void)\n\n{\n                    /* WARNING: Treating indirect jump as call */\n  (*(code *)PTR_00112d08)();\n  return;\n}\n\n", 
    "00114028": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid _exit(int __status)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* _exit@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00114148": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint ferror_unlocked(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* ferror_unlocked@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00114268": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid freecon(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n  halt_baddata();\n}\n\n", 
    "001029e0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fseeko(FILE *__stream,__off_t __off,int __whence)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_fseeko_00112f30)();\n  return iVar1;\n}\n\n", 
    "001028c0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fileno(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_fileno_00112ea0)();\n  return iVar1;\n}\n\n", 
    "001027a0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint close(int __fd)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_close_00112e10)();\n  return iVar1;\n}\n\n", 
    "0010bf00": "\nbool c_isupper(int param_1)\n\n{\n  return param_1 - 0x41U < 0x1a;\n}\n\n", 
    "00102a20": "\nvoid security_compute_create(void)\n\n{\n  (*(code *)PTR_security_compute_create_00112f50)();\n  return;\n}\n\n", 
    "00114030": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __fpending(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __fpending@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00114150": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * calloc(size_t __nmemb,size_t __size)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* calloc@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00114278": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t fwrite(void *__ptr,size_t __size,size_t __n,FILE *__s)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fwrite@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00102b40": "\nundefined8 main(int param_1,undefined8 *param_2)\n\n{\n  char cVar1;\n  char cVar2;\n  int iVar3;\n  __mode_t __mask;\n  uint __mode;\n  uint uVar4;\n  undefined8 uVar5;\n  undefined1 *__ptr;\n  long lVar6;\n  undefined1 *puVar7;\n  undefined8 uVar8;\n  int *piVar9;\n  undefined1 *puVar10;\n  long lVar11;\n  long extraout_RDX;\n  long lVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  long in_FS_OFFSET;\n  undefined1 *local_60;\n  uint local_50;\n  undefined4 uStack_4c;\n  ulong local_48;\n  long local_40;\n  \n  __mode = 1;\n  uVar14 = (ulong)param_1;\n  puVar7 = (undefined1 *)0x0;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  set_program_name(*param_2);\n  setlocale(6,\"\");\n  bindtextdomain(\"coreutils\",\"/usr/local/share/locale\");\n  textdomain(\"coreutils\");\n  atexit(close_stdout);\n  lVar11 = 0;\n  lVar6 = 0;\n  while( true ) {\n    lVar15 = lVar6;\n    lVar12 = lVar11;\n    cVar1 = (char)puVar7;\n    puVar10 = longopts;\n    iVar3 = getopt_long(uVar14 & 0xffffffff,param_2,&DAT_0010d79d,longopts,0);\n    if (iVar3 == -1) break;\n    if (iVar3 == 0x5a) {\nLAB_00102c50:\n      cVar1 = is_smack_enabled();\n      lVar11 = lVar12;\n      lVar6 = optarg;\n      if (cVar1 == '\\0') {\n        iVar3 = is_selinux_enabled();\n        if (iVar3 < 1) {\n          lVar6 = lVar15;\n          if (optarg != 0) {\n            uVar5 = dcgettext(0,\n                              \"warning: ignoring --context; it requires an SELinux/SMACK-enabled kernel\"\n                              ,5);\n            error(0,0,uVar5);\n          }\n        }\n        else {\n          lVar6 = optarg;\n          if (optarg == 0) {\n            puVar7 = (undefined1 *)0x1;\n            lVar6 = lVar15;\n          }\n        }\n      }\n    }\n    else {\n      if (iVar3 < 0x5b) {\n        if (iVar3 == -0x83) {\n          version_etc(stdout,\"mknod\",\"GNU coreutils\",Version,\"David MacKenzie\",0);\n                    /* WARNING: Subroutine does not return */\n          exit(0);\n        }\n        if (iVar3 != -0x82) goto LAB_00102ee7;\n        usage(0);\n        goto LAB_00102c50;\n      }\n      lVar11 = optarg;\n      lVar6 = lVar15;\n      if (iVar3 != 0x6d) goto LAB_00102ee7;\n    }\n  }\n  if (lVar12 == 0) {\n    __mode = 0x1b6;\nLAB_00102d20:\n    lVar11 = (long)optind;\n    uVar4 = param_1 - optind;\n    if (optind < param_1) {\n      if ((optind + 1 < param_1) && (*(char *)param_2[(long)optind + 1] == 'p')) {\n        if (uVar4 < 2) goto LAB_001030f9;\n        if (uVar4 != 2) {\n          uVar5 = param_2[(long)optind + 2];\n          goto LAB_00102f19;\n        }\n      }\n      else {\n        if (uVar4 < 4) {\n          puVar7 = (undefined1 *)quote(param_2[(long)param_1 + -1]);\n          uVar5 = dcgettext(0,\"missing operand after %s\",5);\n          puVar10 = puVar7;\n          error(0,0,uVar5);\n          if (param_1 - optind != 2) goto LAB_00102ee7;\n          pcVar13 = \"Special files require major and minor device numbers.\";\n          goto LAB_00102f5e;\n        }\n        if (uVar4 != 4) goto LAB_001031b9;\n      }\n    }\n    else {\n      if (uVar4 < 2) goto LAB_00103274;\n      if (uVar4 != 2) {\n        uVar5 = param_2[lVar11 + 2];\nLAB_00102f19:\n        puVar7 = (undefined1 *)quote(uVar5);\n        uVar5 = dcgettext(0,\"extra operand %s\",5);\n        puVar10 = puVar7;\n        error(0,0,uVar5);\n        pcVar13 = \"Fifos do not have major and minor device numbers.\";\n        if (param_1 - optind != 4) goto LAB_00102ee7;\nLAB_00102f5e:\n        puVar10 = (undefined1 *)dcgettext(0,pcVar13,5);\n        __fprintf_chk(stderr,1,\"%s\\n\");\n        goto LAB_00102ee7;\n      }\n    }\n    if (lVar15 == 0) goto LAB_00102d8a;\n    cVar1 = is_smack_enabled();\n    if (cVar1 == '\\0') goto LAB_00102fdb;\n    iVar3 = smack_set_label_for_self_isra_0();\n    while( true ) {\n      cVar1 = (char)puVar7;\n      lVar11 = (long)optind;\n      if (iVar3 < 0) break;\nLAB_00102d8a:\n      lVar6 = (long)(int)lVar11 + 1;\n      puVar10 = (undefined1 *)(lVar6 * 8);\n      cVar2 = *(char *)param_2[lVar6];\n      if (cVar2 != 'p') {\n        if ('p' < cVar2) goto LAB_00102ef1;\n        uVar14 = 0x6000;\n        if (cVar2 == 'b') goto LAB_00102dbc;\n        uVar14 = 0x2000;\n        if (cVar2 == 'c') goto LAB_00102dbc;\n        goto LAB_00102ebb;\n      }\n      if (cVar1 != '\\0') {\n        defaultcon((param_2 + -1)[lVar6],0x1000);\n        lVar11 = (long)optind;\n      }\n      iVar3 = mkfifo((char *)param_2[lVar11],__mode);\n      if (iVar3 == 0) goto LAB_00102e5d;\n      puVar7 = (undefined1 *)quotearg_n_style_colon(0,3,param_2[optind]);\n      piVar9 = __errno_location();\n      error(1,*piVar9,\"%s\",puVar7);\nLAB_00102fdb:\n      uVar5 = se_const(lVar15);\n      iVar3 = setfscreatecon(uVar5);\n    }\n    uVar14 = quote(lVar15);\n    uVar5 = dcgettext(0,\"failed to set default file creation context to %s\",5);\n    piVar9 = __errno_location();\n    error(1,*piVar9,uVar5,uVar14);\n  }\n  else {\n    __ptr = (undefined1 *)mode_compile();\n    if (__ptr != (undefined1 *)0x0) {\n      __mask = umask(0);\n      umask(__mask);\n      puVar10 = __ptr;\n      __mode = mode_adjust(0x1b6,0,__mask,__ptr,0);\n      free(__ptr);\n      local_60 = __ptr;\n      if ((__mode & 0xfffffe00) != 0) goto LAB_001030a9;\n      goto LAB_00102d20;\n    }\n  }\n  uVar5 = dcgettext(0,\"invalid mode\",5);\n  error(1,0,uVar5);\nLAB_001030a9:\n  uVar5 = dcgettext(0,\"mode must specify only file permission bits\",5);\n  error(1,0,uVar5);\nLAB_001030cd:\n  uVar5 = dcgettext(0,\"invalid device %s %s\",5);\n  error(1,0,uVar5,local_60);\nLAB_001030f9:\n  puVar7 = (undefined1 *)quote(param_2[uVar14 - 1]);\n  pcVar13 = \"missing operand after %s\";\nLAB_00102ecf:\n  do {\n    uVar5 = dcgettext(0,pcVar13,5);\n    puVar10 = puVar7;\n    error(0,0,uVar5);\nLAB_00102ee7:\n    while( true ) {\n      cVar1 = (char)puVar7;\n      cVar2 = usage(1);\nLAB_00102ef1:\n      if (cVar2 != 'u') break;\n      uVar14 = 0x2000;\nLAB_00102dbc:\n      local_60 = *(undefined1 **)((long)(param_2 + 1) + (long)puVar10);\n      uVar5 = *(undefined8 *)((long)(param_2 + 2) + (long)puVar10);\n      iVar3 = xstrtoumax(local_60,0,0,&local_50,0);\n      if ((iVar3 != 0) || (CONCAT44(uStack_4c,local_50) != (ulong)local_50)) goto LAB_00103185;\n      iVar3 = xstrtoumax(uVar5,0,0,&local_48,0);\n      if ((iVar3 != 0) || (local_48 != (local_48 & 0xffffffff))) goto LAB_00103153;\n      puVar7 = (undefined1 *)gnu_dev_makedev(local_50,(uint)local_48);\n      if (puVar7 == (undefined1 *)0xffffffffffffffff) goto LAB_001030cd;\n      if (cVar1 != '\\0') {\n        defaultcon(param_2[optind],uVar14);\n        local_60 = puVar7;\n      }\n      iVar3 = mknod((char *)param_2[optind],(uint)uVar14 | __mode,(__dev_t)puVar7);\n      if (iVar3 != 0) goto LAB_0010311c;\nLAB_00102e5d:\n      if ((lVar12 == 0) || (iVar3 = chmod((char *)param_2[optind],__mode), iVar3 == 0)) {\n        if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n          return 0;\n        }\n                    /* WARNING: Subroutine does not return */\n        __stack_chk_fail();\n      }\n      puVar10 = (undefined1 *)quotearg_style(4,param_2[optind]);\n      puVar7 = (undefined1 *)dcgettext(0,\"cannot set permissions of %s\",5);\n      piVar9 = __errno_location();\n      error(1,*piVar9,puVar7);\nLAB_00103274:\n      uVar5 = dcgettext(0,\"missing operand\",5);\n      error(0,0,uVar5);\n    }\nLAB_00102ebb:\n    puVar7 = (undefined1 *)quote();\n    pcVar13 = \"invalid device type %s\";\n  } while( true );\nLAB_0010311c:\n  uVar8 = quotearg_n_style_colon(0,3,param_2[optind]);\n  piVar9 = __errno_location();\n  error(1,*piVar9,\"%s\",uVar8);\nLAB_00103153:\n  uVar5 = quote(uVar5);\n  uVar8 = dcgettext(0,\"invalid minor device number %s\",5);\n  error(1,0,uVar8,uVar5);\nLAB_00103185:\n  uVar5 = quote(local_60);\n  uVar8 = dcgettext(0,\"invalid major device number %s\",5);\n  error(1,0,uVar8,uVar5);\n  lVar11 = extraout_RDX;\nLAB_001031b9:\n  puVar7 = (undefined1 *)quote(param_2[lVar11 + 4]);\n  pcVar13 = \"extra operand %s\";\n  goto LAB_00102ecf;\n}\n\n", 
    "00103f90": "\nundefined4 seen_triple(long *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined4 uVar1;\n  long lVar2;\n  \n  lVar2 = *param_1;\n  if (lVar2 == 0) {\n    lVar2 = hash_initialize(7,0,triple_hash,triple_compare_ino_str,triple_free);\n    *param_1 = lVar2;\n    if (lVar2 == 0) {\n                    /* WARNING: Subroutine does not return */\n      xalloc_die(0);\n    }\n  }\n  uVar1 = seen_file(lVar2,param_2,param_3);\n  if ((char)uVar1 == '\\0') {\n    record_file(*param_1,param_2,param_3);\n  }\n  return uVar1;\n}\n\n", 
    "00114270": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid exit(int __status)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* exit@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00102b2c": "\nvoid leave_dir_isra_0_cold(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "00105440": "\nvoid hash_free(long **param_1)\n\n{\n  void *pvVar1;\n  void *__ptr;\n  long *plVar2;\n  long *plVar3;\n  long *plVar4;\n  long lVar5;\n  \n  plVar4 = *param_1;\n  plVar2 = param_1[1];\n  if ((param_1[8] != (long *)0x0) && (param_1[4] != (long *)0x0)) {\n    if (plVar2 <= plVar4) goto LAB_001054ec;\n    do {\n      while (lVar5 = *plVar4, plVar3 = plVar4, lVar5 == 0) {\n        plVar4 = plVar4 + 2;\n        if (plVar2 <= plVar4) goto LAB_001054af;\n      }\n      while( true ) {\n        (*(code *)param_1[8])(lVar5);\n        plVar3 = (long *)plVar3[1];\n        if (plVar3 == (long *)0x0) break;\n        lVar5 = *plVar3;\n      }\n      plVar2 = param_1[1];\n      plVar4 = plVar4 + 2;\n    } while (plVar4 < plVar2);\nLAB_001054af:\n    plVar4 = *param_1;\n  }\n  if (plVar4 < plVar2) {\n    do {\n      __ptr = (void *)plVar4[1];\n      while (__ptr != (void *)0x0) {\n        pvVar1 = *(void **)((long)__ptr + 8);\n        free(__ptr);\n        __ptr = pvVar1;\n      }\n      plVar4 = plVar4 + 2;\n    } while (plVar4 <= param_1[1] && param_1[1] != plVar4);\n  }\nLAB_001054ec:\n  plVar4 = param_1[9];\n  while (plVar4 != (long *)0x0) {\n    plVar2 = (long *)plVar4[1];\n    free(plVar4);\n    plVar4 = plVar2;\n  }\n  free(*param_1);\n  (*(code *)PTR_free_00112fb8)(param_1);\n  return;\n}\n\n", 
    "0010c800": "\nint lstat(char *__file,stat *__buf)\n\n{\n  int iVar1;\n  \n  iVar1 = __lxstat(1,__file,__buf);\n  return iVar1;\n}\n\n", 
    "00114238": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fseeko(FILE *__stream,__off_t __off,int __whence)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fseeko@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00103380": "\nvoid frame_dummy(void)\n\n{\n  register_tm_clones();\n  return;\n}\n\n", 
    "001027d0": "\nvoid matchpathcon(void)\n\n{\n  (*(code *)PTR_matchpathcon_00112e28)();\n  return;\n}\n\n", 
    "001026b0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t strlen(char *__s)\n\n{\n  size_t sVar1;\n  \n  sVar1 = (*(code *)PTR_strlen_00112d98)();\n  return sVar1;\n}\n\n", 
    "00114118": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint closedir(DIR *__dirp)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* closedir@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00114120": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid matchpathcon(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n  halt_baddata();\n}\n\n", 
    "00114240": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nuintmax_t strtoumax(char *__nptr,char **__endptr,int __base)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strtoumax@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001028f0": "\nvoid setfscreatecon(void)\n\n{\n  (*(code *)PTR_setfscreatecon_00112eb8)();\n  return;\n}\n\n", 
    "00102a50": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid exit(int __status)\n\n{\n  (*(code *)PTR_exit_00112f68)();\n  return;\n}\n\n", 
    "00109ba0": "\nvoid cwd_advance_fd(long param_1,int param_2,char param_3)\n\n{\n  int iVar1;\n  \n  iVar1 = *(int *)(param_1 + 0x2c);\n  if ((iVar1 == param_2) && (iVar1 != -100)) {\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  if (param_3 == '\\0') {\n    if (((*(byte *)(param_1 + 0x48) & 4) == 0) && (-1 < iVar1)) {\n      close(iVar1);\nLAB_00109bec:\n      *(int *)(param_1 + 0x2c) = param_2;\n      return;\n    }\n  }\n  else {\n    iVar1 = i_ring_push(param_1 + 0x60);\n    if (-1 < iVar1) {\n      close(iVar1);\n      goto LAB_00109bec;\n    }\n  }\n  *(int *)(param_1 + 0x2c) = param_2;\n  return;\n}\n\n", 
    "00114000": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid is_selinux_enabled(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n  halt_baddata();\n}\n\n", 
    "00114128": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid getcon(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n  halt_baddata();\n}\n\n", 
    "00114248": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nDIR * fdopendir(int __fd)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fdopendir@@GLIBC_2.4 */\n  halt_baddata();\n}\n\n", 
    "001028e0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\ndirent * readdir(DIR *__dirp)\n\n{\n  dirent *pdVar1;\n  \n  pdVar1 = (dirent *)(*(code *)PTR_readdir_00112eb0)();\n  return pdVar1;\n}\n\n", 
    "001027c0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint closedir(DIR *__dirp)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_closedir_00112e20)();\n  return iVar1;\n}\n\n", 
    "001026a0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t __ctype_get_mb_cur_max(void)\n\n{\n  size_t sVar1;\n  \n  sVar1 = (*(code *)PTR___ctype_get_mb_cur_max_00112d90)();\n  return sVar1;\n}\n\n", 
    "00114008": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid abort(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* abort@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00114010": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint * __errno_location(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __errno_location@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00114130": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __libc_start_main(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __libc_start_main@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00114250": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fstatfs(int __fildes,statfs *__buf)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fstatfs@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00102a40": "\nvoid freecon(void)\n\n{\n  (*(code *)PTR_freecon_00112f60)();\n  return;\n}\n\n", 
    "001081e0": "\nvoid quotearg_n_style_mem\n               (undefined4 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  long in_FS_OFFSET;\n  undefined auStack_68 [56];\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  quoting_options_from_style(auStack_68);\n  quotearg_n_options(param_1,param_3,param_4,auStack_68);\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00109900": "\nvoid fd_ring_clear(undefined8 param_1)\n\n{\n  char cVar1;\n  int __fd;\n  \n  while( true ) {\n    cVar1 = i_ring_empty(param_1);\n    if (cVar1 != '\\0') break;\n    __fd = i_ring_pop(param_1);\n    if (-1 < __fd) {\n      close(__fd);\n    }\n  }\n  return;\n}\n\n", 
    "00104650": "\nvoid close_stdout_set_ignore_EPIPE(undefined param_1)\n\n{\n  ignore_EPIPE = param_1;\n  return;\n}\n\n", 
    "00102590": "\nvoid __cxa_finalize(void)\n\n{\n  (*(code *)PTR___cxa_finalize_00112fe0)();\n  return;\n}\n\n", 
    "00104770": "\nundefined * mdir_name(void *param_1)\n\n{\n  size_t __n;\n  undefined *__dest;\n  \n  __n = dir_len();\n  __dest = (undefined *)malloc(__n + 1 + (ulong)(__n == 0));\n  if (__dest != (undefined *)0x0) {\n    __dest = (undefined *)memcpy(__dest,param_1,__n);\n    if (__n == 0) {\n      *__dest = 0x2e;\n      __n = 1;\n    }\n    __dest[__n] = 0;\n  }\n  return __dest;\n}\n\n", 
    "0010c1b0": "\nbool hard_locale(int param_1)\n\n{\n  byte *pbVar1;\n  long lVar2;\n  byte *pbVar3;\n  bool bVar4;\n  bool bVar5;\n  byte bVar6;\n  \n  bVar6 = 0;\n  pbVar1 = (byte *)setlocale(param_1,(char *)0x0);\n  bVar4 = true;\n  if (pbVar1 != (byte *)0x0) {\n    bVar4 = *pbVar1 < 0x43;\n    bVar5 = *pbVar1 == 0x43;\n    if (bVar5) {\n      bVar4 = false;\n      bVar5 = pbVar1[1] == 0;\n      if (bVar5) {\n        return false;\n      }\n    }\n    lVar2 = 6;\n    pbVar3 = (byte *)\"POSIX\";\n    do {\n      if (lVar2 == 0) break;\n      lVar2 = lVar2 + -1;\n      bVar4 = *pbVar1 < *pbVar3;\n      bVar5 = *pbVar1 == *pbVar3;\n      pbVar1 = pbVar1 + (ulong)bVar6 * -2 + 1;\n      pbVar3 = pbVar3 + (ulong)bVar6 * -2 + 1;\n    } while (bVar5);\n    bVar4 = (!bVar4 && !bVar5) != bVar4;\n  }\n  return bVar4;\n}\n\n", 
    "001029b0": "\nvoid error(void)\n\n{\n  (*(code *)PTR_error_00112f18)();\n  return;\n}\n\n", 
    "0010a0f0": "\nvoid free_dir_isra_0(uint param_1,long param_2)\n\n{\n  if ((param_1 & 0x102) == 0) {\n    (*(code *)PTR_free_00112fb8)(param_2);\n    return;\n  }\n  if (param_2 != 0) {\n    hash_free();\n    return;\n  }\n  return;\n}\n\n", 
    "00102b18": "\nvoid version_etc_arn_cold(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "00102b13": "\nvoid set_custom_quoting_cold(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "00114218": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * memmove(void *__dest,void *__src,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* memmove@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00104e10": "\nundefined8 hash_get_n_buckets_used(long param_1)\n\n{\n  return *(undefined8 *)(param_1 + 0x18);\n}\n\n", 
    "00114100": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * getcwd(char *__buf,size_t __size)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* getcwd@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00114220": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid error(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* error@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "0010bac0": "\nuint map_to_failure(uint param_1,byte **param_2)\n\n{\n  int *piVar1;\n  long lVar2;\n  byte *pbVar3;\n  byte *pbVar4;\n  bool bVar5;\n  bool bVar6;\n  \n  if (param_1 == 0) {\n    piVar1 = __errno_location();\n    *piVar1 = 0x5f;\n    return 0xffffffff;\n  }\n  bVar5 = param_1 < 10;\n  bVar6 = param_1 == 10;\n  if (bVar6) {\n    lVar2 = 10;\n    pbVar3 = *param_2;\n    pbVar4 = (byte *)\"unlabeled\";\n    do {\n      if (lVar2 == 0) break;\n      lVar2 = lVar2 + -1;\n      bVar5 = *pbVar3 < *pbVar4;\n      bVar6 = *pbVar3 == *pbVar4;\n      pbVar3 = pbVar3 + 1;\n      pbVar4 = pbVar4 + 1;\n    } while (bVar6);\n    if ((!bVar5 && !bVar6) == bVar5) {\n      freecon(*param_2);\n      *param_2 = (byte *)0x0;\n      piVar1 = __errno_location();\n      *piVar1 = 0x3d;\n      return 0xffffffff;\n    }\n  }\n  return param_1;\n}\n\n", 
    "00109ca0": "\nvoid fts_padjust_isra_0(long param_1,long param_2,long param_3)\n\n{\n  long lVar1;\n  \n  for (; param_1 != 0; param_1 = *(long *)(param_1 + 0x10)) {\n    if (*(long *)(param_1 + 0x30) != param_1 + 0x108) {\n      *(long *)(param_1 + 0x30) = (*(long *)(param_1 + 0x30) - *(long *)(param_1 + 0x38)) + param_2;\n    }\n    *(long *)(param_1 + 0x38) = param_2;\n  }\n  do {\n    if (*(long *)(param_3 + 0x58) < 0) {\n      return;\n    }\n    while( true ) {\n      if (*(long *)(param_3 + 0x30) != param_3 + 0x108) {\n        *(long *)(param_3 + 0x30) =\n             (*(long *)(param_3 + 0x30) - *(long *)(param_3 + 0x38)) + param_2;\n      }\n      lVar1 = *(long *)(param_3 + 0x10);\n      *(long *)(param_3 + 0x38) = param_2;\n      if (lVar1 == 0) break;\n      param_3 = lVar1;\n      if (*(long *)(lVar1 + 0x58) < 0) {\n        return;\n      }\n    }\n    param_3 = *(long *)(param_3 + 8);\n  } while( true );\n}\n\n", 
    "001084f0": "\nvoid quote_mem(undefined8 param_1,undefined8 param_2)\n\n{\n  quote_n_mem(0,param_1,param_2);\n  return;\n}\n\n", 
    "00104640": "\nvoid close_stdout_set_file_name(undefined8 param_1)\n\n{\n  file_name = param_1;\n  return;\n}\n\n", 
    "0010b940": "\nlong fts_children(long *param_1,uint param_2)\n\n{\n  int __fd;\n  int iVar1;\n  int *piVar2;\n  long lVar3;\n  long lVar4;\n  undefined8 uVar5;\n  \n  piVar2 = __errno_location();\n  if ((param_2 & 0xffffdfff) != 0) {\n    *piVar2 = 0x16;\n    return 0;\n  }\n  lVar4 = *param_1;\n  *piVar2 = 0;\n  if ((*(byte *)((long)param_1 + 0x49) & 0x40) == 0) {\n    if (*(short *)(lVar4 + 0x70) == 9) {\n      return *(long *)(lVar4 + 0x10);\n    }\n    lVar3 = 0;\n    if (*(short *)(lVar4 + 0x70) == 1) {\n      if (param_1[1] != 0) {\n        fts_lfree();\n      }\n      uVar5 = 1;\n      if (param_2 == 0x2000) {\n        *(uint *)(param_1 + 9) = *(uint *)(param_1 + 9) | 0x2000;\n        uVar5 = 2;\n      }\n      if (((*(long *)(lVar4 + 0x58) == 0) && (**(char **)(lVar4 + 0x30) != '/')) &&\n         ((*(uint *)(param_1 + 9) & 4) == 0)) {\n        __fd = diropen_isra_0(*(undefined4 *)((long)param_1 + 0x2c),*(uint *)(param_1 + 9),\n                              &DAT_0010e6c4);\n        if (__fd < 0) {\n          param_1[1] = 0;\n          lVar3 = 0;\n        }\n        else {\n          lVar4 = fts_build(param_1,uVar5);\n          param_1[1] = lVar4;\n          if ((*(byte *)((long)param_1 + 0x49) & 2) == 0) {\n            iVar1 = fchdir(__fd);\n            if (iVar1 != 0) {\n              iVar1 = *piVar2;\n              close(__fd);\n              *piVar2 = iVar1;\n              return 0;\n            }\n            close(__fd);\n          }\n          else {\n            cwd_advance_fd(param_1,__fd,1);\n          }\n          lVar3 = param_1[1];\n        }\n      }\n      else {\n        lVar3 = fts_build(param_1,uVar5);\n        param_1[1] = lVar3;\n      }\n    }\n    return lVar3;\n  }\n  return 0;\n}\n\n", 
    "00102b09": "\nvoid quotearg_buffer_restyled_cold(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "001094e0": "\nlong fts_maxarglen(char **param_1)\n\n{\n  size_t sVar1;\n  ulong uVar2;\n  char *__s;\n  \n  __s = *param_1;\n  if (__s != (char *)0x0) {\n    uVar2 = 0;\n    do {\n      sVar1 = strlen(__s);\n      if (uVar2 < sVar1) {\n        uVar2 = sVar1;\n      }\n      __s = param_1[1];\n      param_1 = param_1 + 1;\n    } while (__s != (char *)0x0);\n    return uVar2 + 1;\n  }\n  return 1;\n}\n\n", 
    "00102580": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid free(void *__ptr)\n\n{\n  (*(code *)PTR_free_00112fb8)();\n  return;\n}\n\n", 
    "001029a0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * memmove(void *__dest,void *__src,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = (void *)(*(code *)PTR_memmove_00112f10)();\n  return pvVar1;\n}\n\n", 
    "00102b04": "\nvoid quoting_options_from_style_cold(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "00104e00": "\nundefined8 hash_get_n_buckets(long param_1)\n\n{\n  return *(undefined8 *)(param_1 + 0x10);\n}\n\n", 
    "00114108": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint close(int __fd)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* close@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00114228": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid fsetfilecon(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n  halt_baddata();\n}\n\n", 
    "00114230": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint open(char *__file,int __oflag,...)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* open@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00114110": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t strspn(char *__s,char *__accept)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strspn@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "001084e0": "\nvoid quote_n_mem(void)\n\n{\n  quotearg_n_options();\n  return;\n}\n\n", 
    "00103340": "\nvoid __do_global_dtors_aux(void)\n\n{\n  if (completed_8061 == '\\0') {\n    if (PTR___cxa_finalize_00112fe0 != (undefined *)0x0) {\n      __cxa_finalize(__dso_handle);\n    }\n    deregister_tm_clones();\n    completed_8061 = 1;\n    return;\n  }\n  return;\n}\n\n", 
    "0010b910": "\nundefined8 fts_set(undefined8 param_1,long param_2,uint param_3)\n\n{\n  int *piVar1;\n  \n  if (param_3 < 5) {\n    *(short *)(param_2 + 0x74) = (short)param_3;\n    return 0;\n  }\n  piVar1 = __errno_location();\n  *piVar1 = 0x16;\n  return 1;\n}\n\n", 
    "001094b0": "\nulong fts_compare_ino(long *param_1,long *param_2)\n\n{\n  ulong uVar1;\n  ulong uVar2;\n  bool bVar3;\n  \n  uVar2 = 0xffffffff;\n  uVar1 = *(ulong *)(*param_2 + 0x80);\n  bVar3 = uVar1 <= *(ulong *)(*param_1 + 0x80);\n  if (bVar3) {\n    uVar2 = (ulong)(bVar3 && *(ulong *)(*param_1 + 0x80) != uVar1);\n  }\n  return uVar2;\n}\n\n", 
    "001028b0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint __xmknod(int __ver,char *__path,__mode_t __mode,__dev_t *__dev)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR___xmknod_00112e98)();\n  return iVar1;\n}\n\n", 
    "001029d0": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint open(char *__file,int __oflag,...)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_open_00112f28)();\n  return iVar1;\n}\n\n", 
    "00102b36": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid i_ring_pop_cold(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "0010c2b0": "\nundefined4 i_ring_pop(long param_1)\n\n{\n  undefined4 *puVar1;\n  uint uVar2;\n  undefined4 uVar3;\n  char cVar4;\n  \n  cVar4 = i_ring_empty();\n  if (cVar4 != '\\0') {\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  uVar2 = *(uint *)(param_1 + 0x14);\n  puVar1 = (undefined4 *)(param_1 + (ulong)uVar2 * 4);\n  uVar3 = *puVar1;\n  *puVar1 = *(undefined4 *)(param_1 + 0x10);\n  if (uVar2 != *(uint *)(param_1 + 0x18)) {\n    *(uint *)(param_1 + 0x14) = uVar2 + 3 & 3;\n    return uVar3;\n  }\n  *(undefined *)(param_1 + 0x1c) = 1;\n  return uVar3;\n}\n\n", 
    "00102a10": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fstatfs(int __fildes,statfs *__buf)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_fstatfs_00112f48)();\n  return iVar1;\n}\n\n", 
    "00102b31": "\nvoid fts_read_cold(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "00104e30": "\nulong hash_get_max_bucket_length(long **param_1)\n\n{\n  long lVar1;\n  long *plVar2;\n  ulong uVar3;\n  ulong uVar4;\n  \n  plVar2 = *param_1;\n  uVar4 = 0;\n  do {\n    if (param_1[1] <= plVar2) {\n      return uVar4;\n    }\n    while (*plVar2 != 0) {\n      uVar3 = 1;\n      for (lVar1 = plVar2[1]; lVar1 != 0; lVar1 = *(long *)(lVar1 + 8)) {\n        uVar3 = uVar3 + 1;\n      }\n      if (uVar4 < uVar3) {\n        uVar4 = uVar3;\n      }\n      plVar2 = plVar2 + 2;\n      if (param_1[1] <= plVar2) {\n        return uVar4;\n      }\n    }\n    plVar2 = plVar2 + 2;\n  } while( true );\n}\n\n", 
    "00114200": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * setlocale(int __category,char *__locale)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* setlocale@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00108dd0": "\nvoid xnrealloc(undefined8 param_1,ulong param_2,ulong param_3)\n\n{\n  if ((-1 < SUB168(ZEXT816(param_2) * ZEXT816(param_3),0)) &&\n     (SUB168(ZEXT816(param_2) * ZEXT816(param_3) >> 0x40,0) == 0)) {\n    xrealloc();\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  xalloc_die();\n}\n\n", 
    "001083f0": "\nvoid quotearg_n_custom_mem\n               (undefined4 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n               undefined8 param_5)\n\n{\n  long in_FS_OFFSET;\n  undefined8 local_68;\n  undefined8 uStack_60;\n  undefined8 local_58;\n  undefined8 uStack_50;\n  undefined8 local_48;\n  undefined8 uStack_40;\n  undefined8 local_38;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  local_68 = default_quoting_options._0_8_;\n  uStack_60 = default_quoting_options._8_8_;\n  local_38 = default_quoting_options._48_8_;\n  local_58 = default_quoting_options._16_8_;\n  uStack_50 = default_quoting_options._24_8_;\n  local_48 = default_quoting_options._32_8_;\n  uStack_40 = default_quoting_options._40_8_;\n  set_custom_quoting(&local_68);\n  quotearg_n_options(param_1,param_4,param_5,&local_68);\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00102b1d": "\nvoid fts_set_stat_required_cold(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "00102000": "\nint _init(EVP_PKEY_CTX *ctx)\n\n{\n  undefined *puVar1;\n  \n  puVar1 = PTR___gmon_start___00112fd0;\n  if (PTR___gmon_start___00112fd0 != (undefined *)0x0) {\n    puVar1 = (undefined *)(*(code *)PTR___gmon_start___00112fd0)();\n  }\n  return (int)puVar1;\n}\n\n", 
    "00106960": "\nchar * gettext_quote(char *param_1,int param_2)\n\n{\n  int iVar1;\n  char *pcVar2;\n  undefined8 uVar3;\n  \n  pcVar2 = (char *)dcgettext(0,param_1,5);\n  if (param_1 == pcVar2) {\n    uVar3 = locale_charset();\n    iVar1 = strcaseeq0_constprop_0(uVar3,\"UTF-8\",0x55,0x54,0x46,0x2d,0x38,0,0);\n    if (iVar1 == 0) {\n      iVar1 = strcaseeq0_constprop_0(uVar3,\"GB18030\",0x47,0x42,0x31,0x38,0x30,0x33,0x30);\n      if (iVar1 == 0) {\n        pcVar2 = \"\\\"\";\n        if (param_2 != 9) {\n          pcVar2 = \"\\'\";\n        }\n        return pcVar2;\n      }\n      if (*pcVar2 == '`') {\n        pcVar2 = &DAT_0010da19;\n      }\n      else {\n        pcVar2 = &DAT_0010da16;\n      }\n    }\n    else if (*pcVar2 == '`') {\n      pcVar2 = &DAT_0010da1d;\n    }\n    else {\n      pcVar2 = &DAT_0010da12;\n    }\n  }\n  return pcVar2;\n}\n\n", 
    "00103690": "\nvoid usage(int param_1)\n\n{\n  FILE *pFVar1;\n  undefined8 uVar2;\n  char *pcVar3;\n  undefined8 uVar4;\n  \n  uVar4 = program_name;\n  if (param_1 == 0) {\n    uVar2 = dcgettext(0,\"Usage: %s [OPTION]... NAME TYPE [MAJOR MINOR]\\n\",5);\n    __printf_chk(1,uVar2,uVar4);\n    pFVar1 = stdout;\n    pcVar3 = (char *)dcgettext(0,\"Create the special file NAME of the given TYPE.\\n\",5);\n    fputs_unlocked(pcVar3,pFVar1);\n    emit_mandatory_arg_note();\n    pFVar1 = stdout;\n    pcVar3 = (char *)dcgettext(0,\n                               \"  -m, --mode=MODE    set file permission bits to MODE, not a=rw - umask\\n\"\n                               ,5);\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = stdout;\n    pcVar3 = (char *)dcgettext(0,\n                               \"  -Z                   set the SELinux security context to default type\\n      --context[=CTX]  like -Z, or if CTX is specified then set the SELinux\\n                         or SMACK security context to CTX\\n\"\n                               ,5);\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = stdout;\n    pcVar3 = (char *)dcgettext(0,\"      --help     display this help and exit\\n\",5);\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = stdout;\n    pcVar3 = (char *)dcgettext(0,\"      --version  output version information and exit\\n\",5);\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = stdout;\n    pcVar3 = (char *)dcgettext(0,\n                               \"\\nBoth MAJOR and MINOR must be specified when TYPE is b, c, or u, and they\\nmust be omitted when TYPE is p.  If MAJOR or MINOR begins with 0x or 0X,\\nit is interpreted as hexadecimal; otherwise, if it begins with 0, as octal;\\notherwise, as decimal.  TYPE may be:\\n\"\n                               ,5);\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = stdout;\n    pcVar3 = (char *)dcgettext(0,\n                               \"\\n  b      create a block (buffered) special file\\n  c, u   create a character (unbuffered) special file\\n  p      create a FIFO\\n\"\n                               ,5);\n    fputs_unlocked(pcVar3,pFVar1);\n    uVar4 = dcgettext(0,\n                      \"\\nNOTE: your shell may have its own version of %s, which usually supersedes\\nthe version described here.  Please refer to your shell\\'s documentation\\nfor details about the options it supports.\\n\"\n                      ,5);\n    __printf_chk(1,uVar4,\"mknod\");\n    emit_ancillary_info_constprop_0();\n  }\n  else {\n    uVar2 = dcgettext(0,\"Try \\'%s --help\\' for more information.\\n\",5);\n    __fprintf_chk(stderr,1,uVar2,uVar4);\n  }\n                    /* WARNING: Subroutine does not return */\n  exit(param_1);\n}\n\n", 
    "00105990": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nlong hash_delete(long param_1,undefined8 param_2)\n\n{\n  void *pvVar1;\n  void *__ptr;\n  char cVar2;\n  long lVar3;\n  ulong uVar4;\n  ulong uVar5;\n  float *pfVar6;\n  long in_FS_OFFSET;\n  float fVar7;\n  float fVar8;\n  long *local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  lVar3 = hash_find_entry(param_1,param_2,&local_28,1);\n  if ((lVar3 == 0) || (*(long *)(param_1 + 0x20) = *(long *)(param_1 + 0x20) + -1, *local_28 != 0))\n  goto LAB_001059d3;\n  uVar4 = *(long *)(param_1 + 0x18) - 1;\n  *(ulong *)(param_1 + 0x18) = uVar4;\n  if ((long)uVar4 < 0) {\n    uVar5 = *(ulong *)(param_1 + 0x10);\n    fVar7 = (float)(uVar4 >> 1 | (ulong)((uint)uVar4 & 1));\n    pfVar6 = *(float **)(param_1 + 0x28);\n    fVar7 = fVar7 + fVar7;\n    if ((long)uVar5 < 0) goto LAB_00105b0a;\nLAB_00105a24:\n    fVar8 = (float)uVar5;\n  }\n  else {\n    pfVar6 = *(float **)(param_1 + 0x28);\n    fVar7 = (float)uVar4;\n    uVar5 = *(ulong *)(param_1 + 0x10);\n    if (-1 < (long)uVar5) goto LAB_00105a24;\nLAB_00105b0a:\n    fVar8 = (float)(uVar5 >> 1 | (ulong)((uint)uVar5 & 1));\n    fVar8 = fVar8 + fVar8;\n  }\n  if (fVar7 < fVar8 * *pfVar6) {\n    check_tuning_isra_0(param_1 + 0x28);\n    uVar4 = *(ulong *)(param_1 + 0x10);\n    pfVar6 = *(float **)(param_1 + 0x28);\n    if ((long)uVar4 < 0) {\n      fVar7 = (float)(uVar4 >> 1 | (ulong)((uint)uVar4 & 1));\n      fVar7 = fVar7 + fVar7;\n    }\n    else {\n      fVar7 = (float)uVar4;\n    }\n    uVar4 = *(ulong *)(param_1 + 0x18);\n    if ((long)uVar4 < 0) {\n      fVar8 = (float)(uVar4 >> 1 | (ulong)((uint)uVar4 & 1));\n      fVar8 = fVar8 + fVar8;\n    }\n    else {\n      fVar8 = (float)uVar4;\n    }\n    if (fVar8 < *pfVar6 * fVar7) {\n      fVar7 = fVar7 * pfVar6[1];\n      if (*(char *)(pfVar6 + 4) == '\\0') {\n        fVar7 = fVar7 * pfVar6[2];\n      }\n      if (_DAT_0010d93c <= fVar7) {\n        uVar4 = (long)(fVar7 - _DAT_0010d93c) ^ 0x8000000000000000;\n      }\n      else {\n        uVar4 = (ulong)fVar7;\n      }\n      cVar2 = hash_rehash(param_1,uVar4);\n      if (cVar2 == '\\0') {\n        __ptr = *(void **)(param_1 + 0x48);\n        while (__ptr != (void *)0x0) {\n          pvVar1 = *(void **)((long)__ptr + 8);\n          free(__ptr);\n          __ptr = pvVar1;\n        }\n        *(undefined8 *)(param_1 + 0x48) = 0;\n      }\n    }\n  }\nLAB_001059d3:\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return lVar3;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00104660": "\nvoid close_stdout(void)\n\n{\n  int iVar1;\n  int *piVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  \n  iVar1 = close_stream(stdout);\n  if (iVar1 != 0) {\n    piVar2 = __errno_location();\n    if ((ignore_EPIPE == '\\0') || (*piVar2 != 0x20)) {\n      uVar3 = dcgettext(0,\"write error\",5);\n      if (file_name == 0) {\n        error(0,*piVar2,\"%s\",uVar3);\n      }\n      else {\n        uVar4 = quotearg_colon();\n        error(0,*piVar2,\"%s: %s\",uVar4,uVar3);\n      }\n      goto LAB_001046e8;\n    }\n  }\n  iVar1 = close_stream(stderr);\n  if (iVar1 == 0) {\n    return;\n  }\nLAB_001046e8:\n                    /* WARNING: Subroutine does not return */\n  _exit(exit_failure);\n}\n\n", 
    "001028a0": "\nvoid getfilecon(void)\n\n{\n  (*(code *)PTR_getfilecon_00112e90)();\n  return;\n}\n\n", 
    "00102b27": "\nvoid cwd_advance_fd_cold(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "00114208": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __printf_chk(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __printf_chk@@GLIBC_2.3.4 */\n  halt_baddata();\n}\n\n", 
    "001029c0": "\nvoid fsetfilecon(void)\n\n{\n  (*(code *)PTR_fsetfilecon_00112f20)();\n  return;\n}\n\n", 
    "00104e20": "\nundefined8 hash_get_n_entries(long param_1)\n\n{\n  return *(undefined8 *)(param_1 + 0x20);\n}\n\n", 
    "00102b22": "\nvoid filesystem_type_cold(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "00102a00": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nDIR * fdopendir(int __fd)\n\n{\n  DIR *pDVar1;\n  \n  pDVar1 = (DIR *)(*(code *)PTR_fdopendir_00112f40)();\n  return pDVar1;\n}\n\n", 
    "00114210": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint chmod(char *__file,__mode_t __mode)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* chmod@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00102b0e": "\nvoid quotearg_n_options_cold(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "00102670": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fclose(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_fclose_00112d78)();\n  return iVar1;\n}\n\n", 
    "00104730": "\nvoid dir_len(char *param_1)\n\n{\n  char cVar1;\n  long lVar2;\n  ulong uVar3;\n  \n  cVar1 = *param_1;\n  lVar2 = last_component();\n  uVar3 = lVar2 - (long)param_1;\n  do {\n    if (uVar3 <= (cVar1 == '/')) {\n      return;\n    }\n    lVar2 = uVar3 - 1;\n    uVar3 = uVar3 - 1;\n  } while (param_1[lVar2] == '/');\n  return;\n}\n\n", 
    "00102790": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * getcwd(char *__buf,size_t __size)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_getcwd_00112e08)();\n  return pcVar1;\n}\n\n", 
    "00108090": "\nvoid quotearg_free(void)\n\n{\n  void **ppvVar1;\n  void *__ptr;\n  undefined *__ptr_00;\n  void **ppvVar2;\n  \n  __ptr_00 = slotvec;\n  if (1 < nslots) {\n    ppvVar2 = (void **)(slotvec + 0x18);\n    ppvVar1 = (void **)(slotvec + (ulong)(nslots - 2) * 0x10 + 0x28);\n    do {\n      __ptr = *ppvVar2;\n      ppvVar2 = ppvVar2 + 2;\n      free(__ptr);\n    } while (ppvVar2 != ppvVar1);\n  }\n  if (*(undefined1 **)(__ptr_00 + 8) != slot0) {\n    free(*(undefined1 **)(__ptr_00 + 8));\n    slotvec0._8_8_ = slot0;\n    slotvec0._0_8_ = 0x100;\n  }\n  if (__ptr_00 != slotvec0) {\n    free(__ptr_00);\n    slotvec = slotvec0;\n  }\n  nslots = 1;\n  return;\n}\n\n", 
    "001086f0": "\nundefined8\nversion_etc_arn(FILE *param_1,long param_2,undefined8 param_3,undefined8 param_4,undefined8 *param_5\n               ,undefined8 param_6)\n\n{\n  undefined8 uVar1;\n  char *pcVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  undefined8 uVar5;\n  undefined8 uVar6;\n  undefined8 local_60;\n  undefined8 local_58;\n  undefined8 local_50;\n  undefined8 local_48;\n  \n  if (param_2 == 0) {\n    __fprintf_chk(param_1,1,\"%s %s\\n\",param_3,param_4);\n  }\n  else {\n    __fprintf_chk(param_1,1,\"%s (%s) %s\\n\",param_2,param_3,param_4);\n  }\n  uVar1 = dcgettext(0,&DAT_0010e15b,5);\n  __fprintf_chk(param_1,1,\"Copyright %s %d Free Software Foundation, Inc.\",uVar1,0x7e2);\n  pcVar2 = (char *)dcgettext(0,\n                             \"\\nLicense GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>.\\nThis is free software: you are free to change and redistribute it.\\nThere is NO WARRANTY, to the extent permitted by law.\\n\\n\"\n                             ,5);\n  fputs_unlocked(pcVar2,param_1);\n  switch(param_6) {\n  case 0:\n                    /* WARNING: Subroutine does not return */\n    abort();\n  case 1:\n    uVar1 = *param_5;\n    uVar4 = dcgettext(0,\"Written by %s.\\n\",5);\n    uVar1 = __fprintf_chk(param_1,1,uVar4,uVar1);\n    return uVar1;\n  case 2:\n    uVar1 = param_5[1];\n    uVar4 = *param_5;\n    uVar5 = dcgettext(0,\"Written by %s and %s.\\n\",5);\n    uVar1 = __fprintf_chk(param_1,1,uVar5,uVar4,uVar1);\n    return uVar1;\n  case 3:\n    uVar1 = param_5[2];\n    uVar4 = param_5[1];\n    uVar5 = *param_5;\n    uVar6 = dcgettext(0,\"Written by %s, %s, and %s.\\n\",5);\n    uVar1 = __fprintf_chk(param_1,1,uVar6,uVar5,uVar4,uVar1);\n    return uVar1;\n  case 4:\n    uVar1 = param_5[3];\n    uVar4 = param_5[2];\n    uVar5 = param_5[1];\n    uVar6 = *param_5;\n    uVar3 = dcgettext(0,\"Written by %s, %s, %s,\\nand %s.\\n\",5);\n    goto LAB_001089b9;\n  case 5:\n    uVar1 = param_5[3];\n    uVar4 = param_5[2];\n    uVar5 = param_5[1];\n    uVar6 = *param_5;\n    uVar3 = dcgettext(0,\"Written by %s, %s, %s,\\n%s, and %s.\\n\",5);\nLAB_001089b9:\n    __fprintf_chk(param_1,1,uVar3,uVar6,uVar5,uVar4);\n    return uVar1;\n  case 6:\n    local_58 = param_5[5];\n    local_60 = param_5[4];\n    uVar1 = param_5[3];\n    uVar4 = param_5[2];\n    uVar5 = param_5[1];\n    uVar6 = *param_5;\n    uVar3 = dcgettext(0,\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\",5);\n    goto LAB_00108a5b;\n  case 7:\n    local_58 = param_5[5];\n    local_60 = param_5[4];\n    uVar1 = param_5[3];\n    uVar4 = param_5[2];\n    uVar5 = param_5[1];\n    uVar6 = *param_5;\n    uVar3 = dcgettext(0,\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\",5);\nLAB_00108a5b:\n    uVar1 = __fprintf_chk(param_1,1,uVar3,uVar6,uVar5,uVar4,uVar1,local_60,local_58);\n    return uVar1;\n  case 8:\n    local_48 = param_5[7];\n    local_50 = param_5[6];\n    local_58 = param_5[5];\n    local_60 = param_5[4];\n    uVar1 = param_5[3];\n    uVar4 = param_5[2];\n    uVar5 = param_5[1];\n    uVar6 = *param_5;\n    uVar3 = dcgettext(0,\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\",5);\n    goto LAB_0010880d;\n  case 9:\n    local_48 = param_5[7];\n    pcVar2 = \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\";\n    local_50 = param_5[6];\n    local_58 = param_5[5];\n    local_60 = param_5[4];\n    uVar1 = param_5[3];\n    uVar4 = param_5[2];\n    uVar5 = param_5[1];\n    uVar6 = *param_5;\n    break;\n  default:\n    local_48 = param_5[7];\n    pcVar2 = \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\";\n    local_50 = param_5[6];\n    local_58 = param_5[5];\n    local_60 = param_5[4];\n    uVar1 = param_5[3];\n    uVar4 = param_5[2];\n    uVar5 = param_5[1];\n    uVar6 = *param_5;\n  }\n  uVar3 = dcgettext(0,pcVar2,5);\nLAB_0010880d:\n  uVar1 = __fprintf_chk(param_1,1,uVar3,uVar6,uVar5,uVar4,uVar1,local_60,local_58,local_50,local_48)\n  ;\n  return uVar1;\n}\n\n", 
    "00105930": "\nundefined8 hash_insert(undefined8 param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  undefined8 local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = hash_insert_if_absent(param_1,param_2,&local_18);\n  if (iVar1 == -1) {\n    param_2 = 0;\n  }\n  else if (iVar1 == 0) {\n    param_2 = local_18;\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return param_2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "0010bde0": "\nbool c_isalpha(int param_1)\n\n{\n  if (param_1 < 0x5b) {\n    return 0x40 < param_1;\n  }\n  return param_1 - 0x61U < 0x1a;\n}\n\n", 
    "00102780": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * memset(void *__s,int __c,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = (void *)(*(code *)PTR_memset_00112e00)();\n  return pvVar1;\n}\n\n", 
    "00102660": "\nvoid context_new(void)\n\n{\n  (*(code *)PTR_context_new_00112d70)();\n  return;\n}\n\n", 
    "00104840": "\nvoid base_len(char *param_1)\n\n{\n  long lVar1;\n  ulong uVar2;\n  \n  uVar2 = strlen(param_1);\n  do {\n    if (uVar2 < 2) {\n      return;\n    }\n    lVar1 = uVar2 - 1;\n    uVar2 = uVar2 - 1;\n  } while (param_1[lVar1] == '/');\n  return;\n}\n\n", 
    "00104960": "\nulong is_prime(ulong param_1)\n\n{\n  ulong uVar1;\n  ulong uVar2;\n  ulong uVar3;\n  ulong uVar4;\n  long lVar5;\n  \n  uVar1 = param_1 - (param_1 / 3 +\n                    (SUB168(ZEXT816(param_1) * ZEXT816(0xaaaaaaaaaaaaaaab) >> 0x40,0) &\n                    0xfffffffffffffffe));\n  uVar3 = uVar1;\n  if ((9 < param_1) && (uVar1 != 0)) {\n    lVar5 = 0x10;\n    uVar4 = 9;\n    uVar2 = 3;\n    do {\n      uVar2 = uVar2 + 2;\n      uVar4 = uVar4 + lVar5;\n      uVar1 = param_1 / uVar2;\n      uVar3 = param_1 % uVar2;\n      if (param_1 <= uVar4) break;\n      lVar5 = lVar5 + 8;\n    } while (uVar3 != 0);\n  }\n  return uVar1 & 0xffffffffffffff00 | (ulong)(uVar3 != 0);\n}\n\n", 
    "00104af0": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nulong compute_bucket_size_isra_0(float param_1,ulong param_2,char param_3)\n\n{\n  ulong uVar1;\n  float fVar2;\n  \n  if (param_3 == '\\0') {\n    if ((long)param_2 < 0) {\n      fVar2 = (float)(param_2 >> 1 | (ulong)((uint)param_2 & 1));\n      fVar2 = fVar2 + fVar2;\n    }\n    else {\n      fVar2 = (float)param_2;\n    }\n    fVar2 = fVar2 / param_1;\n    if (_DAT_0010d938 <= fVar2) {\n      return 0;\n    }\n    if (fVar2 < _DAT_0010d93c) {\n      param_2 = (ulong)fVar2;\n    }\n    else {\n      param_2 = (long)(fVar2 - _DAT_0010d93c) ^ 0x8000000000000000;\n    }\n  }\n  uVar1 = next_prime(param_2);\n  if (((uVar1 >> 0x3c & 1) == 0) && (uVar1 >> 0x3d == 0)) {\n    return uVar1;\n  }\n  return 0;\n}\n\n", 
    "00105be0": "\nundefined8 triple_compare(undefined8 *param_1,undefined8 *param_2)\n\n{\n  undefined8 uVar1;\n  \n  if ((param_1[1] == param_2[1]) && (param_1[2] == param_2[2])) {\n    uVar1 = same_name(*param_1,*param_2);\n    return uVar1;\n  }\n  return 0;\n}\n\n", 
    "001094a0": "\nulong dev_type_compare(ulong *param_1,ulong *param_2)\n\n{\n  return *param_2 & 0xffffffffffffff00 | (ulong)(*param_1 == *param_2);\n}\n\n", 
    "00109080": "\nuint bkm_scale_by_power(undefined8 param_1,uint param_2,int param_3)\n\n{\n  uint uVar1;\n  uint uVar2;\n  ulong uVar3;\n  \n  uVar3 = (ulong)param_2;\n  param_3 = param_3 + -1;\n  uVar2 = 0;\n  do {\n    uVar1 = bkm_scale(param_1,uVar3 & 0xffffffff);\n    param_3 = param_3 + -1;\n    uVar2 = uVar2 | uVar1;\n  } while (param_3 != -1);\n  return uVar2;\n}\n\n", 
    "0010c3c0": "\nuint fd_safer(uint param_1)\n\n{\n  int iVar1;\n  uint uVar2;\n  int *piVar3;\n  \n  if (2 < param_1) {\n    return param_1;\n  }\n  uVar2 = dup_safer();\n  piVar3 = __errno_location();\n  iVar1 = *piVar3;\n  close(param_1);\n  *piVar3 = iVar1;\n  return uVar2;\n}\n\n", 
    "00108080": "\nvoid quotearg_alloc(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  quotearg_alloc_mem(param_1,param_2,0,param_3);\n  return;\n}\n\n", 
    "001084a0": "\nvoid quotearg_custom(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  quotearg_n_custom(0,param_1,param_2,param_3);\n  return;\n}\n\n", 
    "00108ca0": "\nvoid emit_bug_reporting_address(void)\n\n{\n  FILE *__stream;\n  undefined8 uVar1;\n  char *__s;\n  \n  uVar1 = dcgettext(0,\"\\nReport bugs to: %s\\n\",5);\n  __printf_chk(1,uVar1,\"bug-coreutils@gnu.org\");\n  uVar1 = dcgettext(0,\"%s home page: <%s>\\n\",5);\n  __printf_chk(1,uVar1,\"GNU coreutils\",\"https://www.gnu.org/software/coreutils/\");\n  __stream = stdout;\n  __s = (char *)dcgettext(0,\"General help using GNU software: <https://www.gnu.org/gethelp/>\\n\",5);\n  fputs_unlocked(__s,__stream);\n  return;\n}\n\n", 
    "00104710": "\nvoid dir_name(void)\n\n{\n  long lVar1;\n  \n  lVar1 = mdir_name();\n  if (lVar1 != 0) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  xalloc_die();\n}\n\n", 
    "00104870": "\nvoid record_file(long param_1,undefined8 param_2,undefined8 *param_3)\n\n{\n  undefined8 *puVar1;\n  undefined8 uVar2;\n  undefined8 *puVar3;\n  \n  if (param_1 == 0) {\n    return;\n  }\n  puVar1 = (undefined8 *)xmalloc(0x18);\n  uVar2 = xstrdup(param_2);\n  *puVar1 = uVar2;\n  puVar1[1] = param_3[1];\n  puVar1[2] = *param_3;\n  puVar3 = (undefined8 *)hash_insert(param_1,puVar1);\n  if (puVar3 != (undefined8 *)0x0) {\n    if (puVar1 != puVar3) {\n      triple_free(puVar1);\n      return;\n    }\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  xalloc_die();\n}\n\n", 
    "00103300": "\n/* WARNING: Removing unreachable block (ram,0x00103324) */\n/* WARNING: Removing unreachable block (ram,0x00103330) */\n\nvoid register_tm_clones(void)\n\n{\n  return;\n}\n\n", 
    "00102690": "\nvoid dcgettext(void)\n\n{\n  (*(code *)PTR_dcgettext_00112d88)();\n  return;\n}\n\n", 
    "00107df0": "\nvoid clone_quoting_options(undefined1 *param_1)\n\n{\n  int iVar1;\n  int *piVar2;\n  \n  piVar2 = __errno_location();\n  iVar1 = *piVar2;\n  if (param_1 == (undefined1 *)0x0) {\n    param_1 = default_quoting_options;\n  }\n  xmemdup(param_1,0x38);\n  *piVar2 = iVar1;\n  return;\n}\n\n", 
    "0010c4b0": "\n/* WARNING: Restarted to delay deadcode elimination for space: stack */\n\nint rpl_fcntl(ulong param_1,int param_2,ulong param_3)\n\n{\n  long lVar1;\n  int iVar2;\n  uint uVar3;\n  int iVar4;\n  int *piVar5;\n  int __fd;\n  long in_FS_OFFSET;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_2 != 0x406) {\n    iVar2 = fcntl((int)param_1,param_2,param_3);\n    goto LAB_0010c534;\n  }\n  if (have_dupfd_cloexec_3397 < 0) {\n    iVar2 = rpl_fcntl(param_1,0,param_3 & 0xffffffff);\n    if ((iVar2 < 0) || (__fd = iVar2, have_dupfd_cloexec_3397 != -1)) goto LAB_0010c534;\nLAB_0010c571:\n    uVar3 = fcntl(__fd,1);\n    if (-1 < (int)uVar3) {\n      iVar4 = fcntl(__fd,2,(ulong)(uVar3 | 1));\n      iVar2 = __fd;\n      if (iVar4 != -1) goto LAB_0010c534;\n    }\n    piVar5 = __errno_location();\n    iVar2 = -1;\n    iVar4 = *piVar5;\n    close(__fd);\n    *piVar5 = iVar4;\n  }\n  else {\n    iVar2 = fcntl((int)param_1,0x406);\n    if (iVar2 < 0) {\n      piVar5 = __errno_location();\n      if (*piVar5 == 0x16) {\n        iVar2 = rpl_fcntl(param_1 & 0xffffffff,0,param_3 & 0xffffffff);\n        if (iVar2 < 0) goto LAB_0010c534;\n        have_dupfd_cloexec_3397 = -1;\n        __fd = iVar2;\n        goto LAB_0010c571;\n      }\n    }\n    have_dupfd_cloexec_3397 = 1;\n  }\nLAB_0010c534:\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "0010a1b0": "\nundefined8 enter_dir_isra_0(uint param_1,undefined8 *param_2,undefined8 *param_3)\n\n{\n  undefined8 uVar1;\n  undefined8 *__ptr;\n  undefined8 *puVar2;\n  undefined8 uVar3;\n  \n  if ((param_1 & 0x102) == 0) {\n    uVar3 = cycle_check(*param_2,param_3 + 0xf);\n    if ((char)uVar3 != '\\0') {\n      *param_3 = param_3;\n      *(undefined2 *)(param_3 + 0xe) = 2;\n      return uVar3;\n    }\n  }\n  else {\n    __ptr = (undefined8 *)malloc(0x18);\n    if (__ptr == (undefined8 *)0x0) {\n      return 0;\n    }\n    uVar3 = param_3[0xf];\n    uVar1 = *param_2;\n    __ptr[2] = param_3;\n    *__ptr = uVar3;\n    __ptr[1] = param_3[0x10];\n    puVar2 = (undefined8 *)hash_insert(uVar1,__ptr);\n    if (__ptr != puVar2) {\n      free(__ptr);\n      if (puVar2 == (undefined8 *)0x0) {\n        return 0;\n      }\n      uVar3 = puVar2[2];\n      *(undefined2 *)(param_3 + 0xe) = 2;\n      *param_3 = uVar3;\n    }\n  }\n  return 1;\n}\n\n", 
    "00109050": "\nbool bkm_scale(ulong *param_1,int param_2)\n\n{\n  ulong uVar1;\n  bool bVar2;\n  \n  uVar1 = SUB168(ZEXT816((ulong)(long)param_2) * ZEXT816(*param_1),0);\n  bVar2 = SUB168(ZEXT816((ulong)(long)param_2) * ZEXT816(*param_1) >> 0x40,0) != 0;\n  if (bVar2) {\n    uVar1 = 0xffffffffffffffff;\n  }\n  *param_1 = uVar1;\n  return bVar2;\n}\n\n", 
    "0010c080": "\nundefined8 cycle_check(long *param_1,long *param_2)\n\n{\n  char cVar1;\n  long lVar2;\n  long *extraout_RDX;\n  long *extraout_RDX_00;\n  long *plVar3;\n  long lVar4;\n  \n  if (*(int *)(param_1 + 3) != 0x95f616) {\n                    /* WARNING: Subroutine does not return */\n    __assert_fail(\"state->magic == 9827862\",\"lib/cycle-check.c\",0x3c,\"cycle_check\");\n  }\n  if (param_1[2] == 0) {\n    param_1[2] = 1;\n    cVar1 = is_zero_or_power_of_two(1);\n    if (cVar1 == '\\0') {\n      return 0;\n    }\n    lVar4 = param_2[1];\n    plVar3 = extraout_RDX_00;\n  }\n  else {\n    lVar4 = param_2[1];\n    if ((lVar4 == *param_1) && (*param_2 == param_1[1])) {\n      return 1;\n    }\n    lVar2 = param_1[2] + 1;\n    param_1[2] = lVar2;\n    cVar1 = is_zero_or_power_of_two(lVar2);\n    if (cVar1 == '\\0') {\n      return 0;\n    }\n    plVar3 = extraout_RDX;\n    if (lVar2 == 0) {\n      return 1;\n    }\n  }\n  lVar2 = *param_2;\n  *plVar3 = lVar4;\n  plVar3[1] = lVar2;\n  return 0;\n}\n\n", 
    "0010bee0": "\nbool c_isspace(int param_1)\n\n{\n  if (param_1 < 0xe) {\n    return 8 < param_1;\n  }\n  return param_1 == 0x20;\n}\n\n", 
    "00102680": "\nvoid bindtextdomain(void)\n\n{\n  (*(code *)PTR_bindtextdomain_00112d80)();\n  return;\n}\n\n", 
    "00104f00": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid hash_print_statistics(undefined8 param_1,undefined8 param_2)\n\n{\n  undefined8 uVar1;\n  ulong uVar2;\n  ulong uVar3;\n  undefined8 uVar4;\n  double dVar5;\n  double dVar6;\n  \n  uVar1 = hash_get_n_entries();\n  uVar2 = hash_get_n_buckets();\n  uVar3 = hash_get_n_buckets_used();\n  uVar4 = hash_get_max_bucket_length();\n  __fprintf_chk(param_2,1,\"# entries:         %lu\\n\",uVar1);\n  __fprintf_chk(param_2,1,\"# buckets:         %lu\\n\",uVar2);\n  if ((long)uVar3 < 0) {\n    dVar5 = (double)(uVar3 >> 1 | (ulong)((uint)uVar3 & 1));\n    dVar5 = dVar5 + dVar5;\n  }\n  else {\n    dVar5 = (double)uVar3;\n  }\n  if ((long)uVar2 < 0) {\n    dVar6 = (double)(uVar2 >> 1 | (ulong)((uint)uVar2 & 1));\n    dVar6 = dVar6 + dVar6;\n  }\n  else {\n    dVar6 = (double)uVar2;\n  }\n  __fprintf_chk((dVar5 * _DAT_0010d940) / dVar6,param_2,1,\"# buckets used:    %lu (%.2f%%)\\n\",uVar3)\n  ;\n  __fprintf_chk(param_2,1,\"max bucket length: %lu\\n\",uVar4);\n  return;\n}\n\n", 
    "001084c0": "\nvoid quotearg_custom_mem(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4\n                        )\n\n{\n  quotearg_n_custom_mem(0,param_1,param_2,param_3,param_4);\n  return;\n}\n\n", 
    "00108fe0": "\nbool cycle_warning_required(long param_1,long param_2)\n\n{\n  uint uVar1;\n  bool bVar2;\n  \n  bVar2 = true;\n  uVar1 = *(uint *)(param_1 + 0x48) & 0x11;\n  if ((uVar1 != 0x10) && (bVar2 = false, uVar1 == 0x11)) {\n    return *(long *)(param_2 + 0x58) != 0;\n  }\n  return bVar2;\n}\n\n", 
    "001062e0": "\nint * quoting_options_from_style(int *param_1,int param_2)\n\n{\n  if (param_2 != 10) {\n    *param_1 = param_2;\n    param_1[1] = 0;\n    *(undefined8 *)(param_1 + 2) = 0;\n    *(undefined8 *)(param_1 + 4) = 0;\n    *(undefined8 *)(param_1 + 6) = 0;\n    *(undefined8 *)(param_1 + 8) = 0;\n    *(undefined8 *)(param_1 + 10) = 0;\n    *(undefined8 *)(param_1 + 0xc) = 0;\n    return param_1;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "001050d0": "\nlong hash_get_next(long param_1,long param_2)\n\n{\n  long lVar1;\n  long *plVar2;\n  long *plVar3;\n  \n  plVar2 = (long *)safe_hasher();\n  plVar3 = plVar2;\n  do {\n    lVar1 = *plVar3;\n    plVar3 = (long *)plVar3[1];\n    if (lVar1 == param_2) {\n      if (plVar3 != (long *)0x0) {\n        return *plVar3;\n      }\n      break;\n    }\n  } while (plVar3 != (long *)0x0);\n  do {\n    plVar2 = plVar2 + 2;\n    if (*(long **)(param_1 + 8) <= plVar2) {\n      return 0;\n    }\n  } while (*plVar2 == 0);\n  return *plVar2;\n}\n\n", 
    "00108ec0": "\nvoid xcalloc(size_t param_1,ulong param_2)\n\n{\n  void *pvVar1;\n  \n  if ((-1 < SUB168(ZEXT816(param_1) * ZEXT816(param_2),0)) &&\n     (SUB168(ZEXT816(param_1) * ZEXT816(param_2) >> 0x40,0) == 0)) {\n    pvVar1 = calloc(param_1,param_2);\n    if (pvVar1 != (void *)0x0) {\n      return;\n    }\n  }\n                    /* WARNING: Subroutine does not return */\n  xalloc_die();\n}\n\n", 
    "00109d90": "\nulong setup_dir_isra_0(uint param_1,void **param_2)\n\n{\n  void *pvVar1;\n  \n  if ((param_1 & 0x102) != 0) {\n    pvVar1 = (void *)hash_initialize(0x1f,0,AD_hash,AD_compare,PTR_free_00112fb8);\n    *param_2 = pvVar1;\n    return (ulong)pvVar1 & 0xffffffffffffff00 | (ulong)(pvVar1 != (void *)0x0);\n  }\n  pvVar1 = malloc(0x20);\n  *param_2 = pvVar1;\n  if (pvVar1 != (void *)0x0) {\n    cycle_check_init(pvVar1);\n    return 1;\n  }\n  return 0;\n}\n\n", 
    "00102990": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint chmod(char *__file,__mode_t __mode)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_chmod_00112f08)();\n  return iVar1;\n}\n\n", 
    "00102870": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\n__mode_t umask(__mode_t __mask)\n\n{\n  __mode_t _Var1;\n  \n  _Var1 = (*(code *)PTR_umask_00112e78)();\n  return _Var1;\n}\n\n", 
    "0010bda0": "\nuint rotr8(uint param_1,byte param_2)\n\n{\n  return param_1 & 0xffffff00 |\n         (uint)(byte)((byte)param_1 >> (param_2 & 7) | (byte)param_1 << 8 - (param_2 & 7));\n}\n\n", 
    "00102750": "\nvoid fgetfilecon(void)\n\n{\n  (*(code *)PTR_fgetfilecon_00112de8)();\n  return;\n}\n\n", 
    "00107eb0": "\nundefined4 set_quoting_flags(undefined1 *param_1,undefined4 param_2)\n\n{\n  undefined4 uVar1;\n  \n  if (param_1 == (undefined1 *)0x0) {\n    param_1 = default_quoting_options;\n  }\n  uVar1 = *(undefined4 *)(param_1 + 4);\n  *(undefined4 *)(param_1 + 4) = param_2;\n  return uVar1;\n}\n\n", 
    "00108170": "\nvoid quotearg_mem(undefined8 param_1,undefined8 param_2)\n\n{\n  quotearg_n_mem(0,param_1,param_2);\n  return;\n}\n\n", 
    "001063b0": "\nundefined8 strcaseeq7(long param_1,undefined8 param_2,byte param_3,char param_4)\n\n{\n  char cVar1;\n  byte bVar2;\n  undefined8 uVar3;\n  \n  cVar1 = c_isupper((int)(char)param_3);\n  bVar2 = *(byte *)(param_1 + 7);\n  if (cVar1 != '\\0') {\n    bVar2 = bVar2 & 0xdf;\n  }\n  if (param_3 != bVar2) {\n    return 0;\n  }\n  if (param_3 == 0) {\n    return 1;\n  }\n  uVar3 = strcaseeq8(param_1,param_2,(int)param_4);\n  return uVar3;\n}\n\n", 
    "0010c060": "\nvoid cycle_check_init(long param_1)\n\n{\n  *(undefined8 *)(param_1 + 0x10) = 0;\n  *(undefined4 *)(param_1 + 0x18) = 0x95f616;\n  return;\n}\n\n", 
    "001064d0": "\nundefined8\nstrcaseeq5(long param_1,undefined8 param_2,byte param_3,char param_4,char param_5,char param_6)\n\n{\n  char cVar1;\n  byte bVar2;\n  undefined8 uVar3;\n  \n  cVar1 = c_isupper((int)(char)param_3);\n  bVar2 = *(byte *)(param_1 + 5);\n  if (cVar1 != '\\0') {\n    bVar2 = bVar2 & 0xdf;\n  }\n  if (param_3 != bVar2) {\n    return 0;\n  }\n  if (param_3 == 0) {\n    return 1;\n  }\n  uVar3 = strcaseeq6(param_1,param_2,(int)param_4,(int)param_5,(int)param_6);\n  return uVar3;\n}\n\n", 
    "00102740": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * strrchr(char *__s,int __c)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_strrchr_00112de0)();\n  return pcVar1;\n}\n\n", 
    "0010bfe0": "\nulong close_stream(FILE *param_1)\n\n{\n  int iVar1;\n  long lVar2;\n  ulong uVar3;\n  int *piVar4;\n  \n  lVar2 = __fpending();\n  iVar1 = ferror_unlocked(param_1);\n  uVar3 = rpl_fclose(param_1);\n  if (iVar1 == 0) {\n    if ((int)uVar3 == 0) {\n      return uVar3;\n    }\n    if (lVar2 == 0) {\n      piVar4 = __errno_location();\n      return (ulong)-(uint)(*piVar4 != 9);\n    }\n  }\n  else if ((int)uVar3 == 0) {\n    piVar4 = __errno_location();\n    *piVar4 = 0;\n    return 0xffffffff;\n  }\n  return 0xffffffff;\n}\n\n", 
    "00102620": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid qsort(void *__base,size_t __nmemb,size_t __size,__compar_fn_t __compar)\n\n{\n  (*(code *)PTR_qsort_00112d50)();\n  return;\n}\n\n", 
    "00109c80": "\nvoid set_stat_type_isra_0(undefined4 *param_1,int param_2)\n\n{\n  undefined4 uVar1;\n  \n  uVar1 = 0;\n  if (param_2 - 1U < 0xc) {\n    uVar1 = *(undefined4 *)(CSWTCH_49 + (ulong)(param_2 - 1U) * 4);\n  }\n  *param_1 = uVar1;\n  return;\n}\n\n", 
    "00102980": "\nvoid __printf_chk(void)\n\n{\n  (*(code *)PTR___printf_chk_00112f00)();\n  return;\n}\n\n", 
    "00102860": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint mkfifo(char *__path,__mode_t __mode)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_mkfifo_00112e70)();\n  return iVar1;\n}\n\n", 
    "00105cc0": "\nvoid * mode_compile(byte *param_1)\n\n{\n  char cVar1;\n  uint uVar2;\n  uint uVar3;\n  undefined4 uVar4;\n  void *pvVar5;\n  byte *pbVar6;\n  byte bVar7;\n  uint uVar8;\n  uint extraout_EDX;\n  long extraout_RDX;\n  byte *pbVar9;\n  long lVar10;\n  byte bVar11;\n  long lVar12;\n  undefined *puVar13;\n  bool bVar14;\n  \n  bVar11 = *param_1;\n  uVar2 = (uint)(char)bVar11;\n  if ((byte)(bVar11 - 0x30) < 8) {\n    uVar8 = 0;\n    pbVar6 = param_1;\n    do {\n      uVar8 = (uVar2 - 0x30) + uVar8 * 8;\n      pbVar6 = pbVar6 + 1;\n      if (0xfff < uVar8) {\n        return (void *)0x0;\n      }\n      bVar11 = *pbVar6;\n      uVar2 = (uint)(char)bVar11;\n    } while ((byte)(bVar11 - 0x30) < 8);\n    if (bVar11 != 0) {\n      return (void *)0x0;\n    }\n    uVar8 = octal_to_mode();\n    uVar2 = uVar8 & 0xc00 | 0x3ff;\n    if (4 < extraout_RDX - (long)param_1) {\n      uVar2 = 0xfff;\n    }\n    pvVar5 = (void *)make_node_op_equals(uVar8,uVar2);\n    return pvVar5;\n  }\n  lVar10 = 1;\n  pbVar6 = param_1;\n  while (bVar11 != 0) {\n    pbVar6 = pbVar6 + 1;\n    lVar10 = lVar10 + (ulong)((byte)uVar2 == 0x2b || ((byte)uVar2 & 0xef) == 0x2d);\n    bVar11 = *pbVar6;\n    uVar2 = (uint)bVar11;\n  }\n  pvVar5 = (void *)xnmalloc(lVar10,0x10);\n  lVar10 = 0;\n  puVar13 = &DAT_0010d948;\nLAB_00105d2a:\n  bVar11 = *param_1;\n  uVar8 = 0;\n  cVar1 = bVar11 + 0x99;\n  bVar14 = bVar11 == 0x67;\n  uVar2 = 0;\n  if (bVar14) goto LAB_00105d8a;\n  do {\n    uVar8 = (uint)bVar11;\n    if (bVar14 || SBORROW1(bVar11,'g') != cVar1 < '\\0') {\n      if (bVar11 != 0x61) break;\n      uVar8 = 0xfff;\n      param_1 = param_1 + 1;\n    }\n    else if (bVar11 == 0x6f) {\n      uVar8 = uVar2 | 0x207;\n      param_1 = param_1 + 1;\n    }\n    else {\n      if (bVar11 != 0x75) goto LAB_00105d44;\n      uVar8 = uVar2 | 0x9c0;\n      param_1 = param_1 + 1;\n    }\n    while( true ) {\n      bVar11 = *param_1;\n      cVar1 = bVar11 + 0x99;\n      bVar14 = cVar1 == '\\0';\n      uVar2 = uVar8;\n      if (!bVar14) break;\nLAB_00105d8a:\n      uVar8 = uVar8 | 0x438;\n      param_1 = param_1 + 1;\n    }\n  } while( true );\n  if (((char)bVar11 < 'b') && (((bVar11 & 0xef) == 0x2d || (bVar11 == 0x2b)))) {\n    bVar7 = param_1[1];\n    lVar12 = lVar10 + 1;\n    pbVar6 = (byte *)(lVar10 * 0x10 + (long)pvVar5);\n    cVar1 = bVar7 + 0x91;\n    bVar14 = bVar7 == 0x6f;\n    lVar10 = lVar12;\n    if (bVar14) goto LAB_00105e5a;\n    do {\n      bVar11 = (byte)uVar8;\n      uVar8 = (uint)(char)bVar7;\n      if (bVar14 || SBORROW1(bVar7,'o') != cVar1 < '\\0') {\n        if ((char)bVar7 < '8') {\n          if ('/' < (char)bVar7) {\n            uVar3 = 0;\n            pbVar9 = param_1 + 1;\n            goto LAB_00105eb2;\n          }\n        }\n        else {\n          pbVar9 = param_1 + 2;\n          uVar3 = 0x38;\n          if (bVar7 == 0x67) goto LAB_00105e7a;\n        }\n      }\n      else {\n        pbVar9 = param_1 + 2;\n        uVar3 = 0x1c0;\n        if (bVar7 == 0x75) goto LAB_00105e7a;\n      }\n      uVar3 = 0;\n      if ((byte)(uVar8 - 0x58) < 0x21) {\n                    /* WARNING: Could not recover jumptable at 0x00105e01. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n        pvVar5 = (void *)(*(code *)(puVar13 + *(int *)(puVar13 + (ulong)(uVar8 - 0x58 & 0xff) * 4)))\n                                   ();\n        return pvVar5;\n      }\n      pbVar6[1] = 1;\n      *(uint *)(pbVar6 + 4) = uVar2;\n      *(undefined4 *)(pbVar6 + 8) = 0;\n      *pbVar6 = bVar11;\n      pbVar9 = param_1 + 1;\n      while( true ) {\n        if (uVar2 != 0) {\n          uVar3 = uVar3 & uVar2;\n        }\nLAB_00105e26:\n        *(uint *)(pbVar6 + 0xc) = uVar3;\n        lVar12 = lVar10 + 1;\n        pbVar6 = pbVar6 + 0x10;\n        bVar11 = (byte)uVar8;\n        if (((bVar11 & 0xef) != 0x2d) && (bVar11 != 0x2b)) {\n          if (bVar11 != 0x2c) {\n            if (bVar11 == 0) {\n              *(undefined *)((long)pvVar5 + lVar10 * 0x10 + 1) = 0;\n              return pvVar5;\n            }\n            goto LAB_00105d44;\n          }\n          param_1 = pbVar9 + 1;\n          goto LAB_00105d2a;\n        }\n        bVar7 = pbVar9[1];\n        cVar1 = bVar7 + 0x91;\n        bVar14 = cVar1 == '\\0';\n        param_1 = pbVar9;\n        lVar10 = lVar12;\n        if (!bVar14) break;\nLAB_00105e5a:\n        pbVar9 = param_1 + 2;\n        uVar3 = 7;\n        lVar10 = lVar12;\nLAB_00105e7a:\n        *pbVar6 = bVar11;\n        uVar8 = (uint)param_1[2];\n        pbVar6[1] = 3;\n        *(uint *)(pbVar6 + 4) = uVar2;\n        *(uint *)(pbVar6 + 8) = uVar3;\n      }\n    } while( true );\n  }\n  goto LAB_00105d44;\n  while( true ) {\n    bVar7 = *pbVar9;\n    uVar8 = (uint)(char)bVar7;\n    if (7 < (byte)(bVar7 - 0x30)) break;\nLAB_00105eb2:\n    uVar3 = (uVar8 - 0x30) + uVar3 * 8;\n    pbVar9 = pbVar9 + 1;\n    if (0xfff < uVar3) goto LAB_00105d44;\n  }\n  if ((uVar2 == 0) && ((bVar7 == 0 || (bVar7 == 0x2c)))) {\n    uVar4 = octal_to_mode();\n    uVar2 = 0xfff;\n    *pbVar6 = bVar11;\n    *(undefined4 *)(pbVar6 + 8) = uVar4;\n    uVar3 = 0xfff;\n    pbVar6[1] = 1;\n    *(undefined4 *)(pbVar6 + 4) = 0xfff;\n    uVar8 = extraout_EDX;\n    goto LAB_00105e26;\n  }\nLAB_00105d44:\n  free(pvVar5);\n  return (void *)0x0;\n}\n\n", 
    "00108160": "\nvoid quotearg(undefined8 param_1)\n\n{\n  quotearg_n(0,param_1);\n  return;\n}\n\n", 
    "00108280": "\nvoid quotearg_char_mem(undefined8 param_1,undefined8 param_2,char param_3,undefined8 param_4)\n\n{\n  undefined8 *puVar1;\n  long in_FS_OFFSET;\n  undefined8 local_48;\n  undefined8 uStack_40;\n  undefined8 local_38;\n  undefined8 uStack_30;\n  undefined8 local_28;\n  undefined8 uStack_20;\n  undefined8 local_18;\n  long local_10;\n  \n  puVar1 = &local_48;\n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_48 = default_quoting_options._0_8_;\n  uStack_40 = default_quoting_options._8_8_;\n  local_38 = default_quoting_options._16_8_;\n  uStack_30 = default_quoting_options._24_8_;\n  local_28 = default_quoting_options._32_8_;\n  uStack_20 = default_quoting_options._40_8_;\n  local_18 = default_quoting_options._48_8_;\n  set_char_quoting(&local_48,(int)param_3,1,param_4,param_1,param_2);\n  quotearg_n_options(0,param_1,param_2,puVar1);\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "00102aff": "\nvoid hash_insert_if_absent_cold(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "00102afa": "\nvoid hash_rehash_cold(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "00108ea0": "\nvoid xzalloc(size_t param_1)\n\n{\n  void *__s;\n  \n  __s = (void *)xmalloc();\n  memset(__s,0,param_1);\n  return;\n}\n\n", 
    "00102850": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint dirfd(DIR *__dirp)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_dirfd_00112e68)();\n  return iVar1;\n}\n\n", 
    "0010bdb0": "\nulong c_isalnum(int param_1)\n\n{\n  ulong in_RAX;\n  ulong uVar1;\n  \n  if (param_1 < 0x5b) {\n    uVar1 = 1;\n    if (param_1 < 0x41) {\n      return (ulong)(param_1 - 0x30U < 10);\n    }\n  }\n  else {\n    uVar1 = in_RAX & 0xffffffffffffff00 | (ulong)(param_1 - 0x61U < 0x1a);\n  }\n  return uVar1;\n}\n\n", 
    "00102730": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint __fxstatat(int __ver,int __fildes,char *__filename,stat *__stat_buf,int __flag)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR___fxstatat_00112dd8)();\n  return iVar1;\n}\n\n", 
    "00102610": "\nvoid lsetfilecon(void)\n\n{\n  (*(code *)PTR_lsetfilecon_00112d48)();\n  return;\n}\n\n", 
    "00102890": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * memcpy(void *__dest,void *__src,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = (void *)(*(code *)PTR_memcpy_00112e88)();\n  return pvVar1;\n}\n\n", 
    "00102770": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid __assert_fail(char *__assertion,char *__file,uint __line,char *__function)\n\n{\n  (*(code *)PTR___assert_fail_00112df8)();\n  return;\n}\n\n", 
    "00102650": "\nvoid textdomain(void)\n\n{\n  (*(code *)PTR_textdomain_00112d68)();\n  return;\n}\n\n", 
    "00108b60": "\nvoid version_etc_va(void)\n\n{\n  uint uVar1;\n  long *plVar2;\n  long lVar3;\n  uint *in_R8;\n  long lVar4;\n  long in_FS_OFFSET;\n  long local_68 [11];\n  long local_10;\n  \n  lVar4 = 0;\n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  do {\n    uVar1 = *in_R8;\n    if (uVar1 < 0x30) {\n      *in_R8 = uVar1 + 8;\n      lVar3 = *(long *)((ulong)uVar1 + *(long *)(in_R8 + 4));\n      local_68[lVar4] = lVar3;\n    }\n    else {\n      plVar2 = *(long **)(in_R8 + 2);\n      *(long **)(in_R8 + 2) = plVar2 + 1;\n      lVar3 = *plVar2;\n      local_68[lVar4] = lVar3;\n    }\n  } while ((lVar3 != 0) && (lVar4 = lVar4 + 1, lVar4 != 10));\n  version_etc_arn();\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "001140e8": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\n__off_t lseek(int __fd,__off_t __offset,int __whence)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* lseek@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00107ed0": "\nvoid set_custom_quoting(undefined1 *param_1,long param_2,long param_3)\n\n{\n  if ((undefined4 *)param_1 == (undefined4 *)0x0) {\n    param_1 = default_quoting_options;\n  }\n  *(undefined4 *)param_1 = 10;\n  if ((param_2 != 0) && (param_3 != 0)) {\n    *(long *)((long)param_1 + 0x28) = param_2;\n    *(long *)((long)param_1 + 0x30) = param_3;\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n", 
    "001098b0": "\nvoid fts_lfree(void *param_1)\n\n{\n  void *pvVar1;\n  \n  if (param_1 == (void *)0x0) {\n    return;\n  }\n  do {\n    pvVar1 = *(void **)((long)param_1 + 0x10);\n    if (*(DIR **)((long)param_1 + 0x18) != (DIR *)0x0) {\n      closedir(*(DIR **)((long)param_1 + 0x18));\n    }\n    free(param_1);\n    param_1 = pvVar1;\n  } while (pvVar1 != (void *)0x0);\n  return;\n}\n\n", 
    "001140e0": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid fgetfilecon(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n  halt_baddata();\n}\n\n", 
    "00109490": "\nulong dev_type_hash(ulong *param_1,ulong param_2)\n\n{\n  return *param_1 % param_2;\n}\n\n", 
    "0010c7c0": "\nint stat(char *__file,stat *__buf)\n\n{\n  int iVar1;\n  \n  iVar1 = __xstat(1,__file,__buf);\n  return iVar1;\n}\n\n", 
    "001086d0": "\nvoid same_name(undefined8 param_1,undefined8 param_2)\n\n{\n  same_nameat(0xffffff9c,param_1,0xffffff9c,param_2);\n  return;\n}\n\n", 
    "00102880": "\nvoid context_free(void)\n\n{\n  (*(code *)PTR_context_free_00112e80)();\n  return;\n}\n\n", 
    "00102760": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\n__off_t lseek(int __fd,__off_t __offset,int __whence)\n\n{\n  __off_t _Var1;\n  \n  _Var1 = (*(code *)PTR_lseek_00112df0)();\n  return _Var1;\n}\n\n", 
    "00102640": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fcntl(int __fd,int __cmd,...)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_fcntl_00112d60)();\n  return iVar1;\n}\n\n", 
    "001140f8": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * memset(void *__s,int __c,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* memset@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00105bc0": "\nulong triple_hash_no_name(long param_1,ulong param_2)\n\n{\n  return *(ulong *)(param_1 + 8) % param_2;\n}\n\n", 
    "0010c7e0": "\nint fstat(int __fd,stat *__buf)\n\n{\n  int iVar1;\n  \n  iVar1 = __fxstat(1,__fd,__buf);\n  return iVar1;\n}\n\n", 
    "001140f0": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid __assert_fail(char *__assertion,char *__file,uint __line,char *__function)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __assert_fail@@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n", 
    "00108180": "\nvoid quotearg_n_style(undefined4 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  long in_FS_OFFSET;\n  undefined auStack_58 [56];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  quoting_options_from_style(auStack_58);\n  quotearg_n_options(param_1,param_3,0xffffffffffffffff,auStack_58);\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n", 
    "0010c050": "\nulong is_zero_or_power_of_two(ulong param_1)\n\n{\n  return param_1 - 1 & 0xffffffffffffff00 | (ulong)((param_1 - 1 & param_1) == 0);\n}\n\n", 
    "00109020": "\nchar * xgetcwd(void)\n\n{\n  char *pcVar1;\n  int *piVar2;\n  \n  pcVar1 = getcwd((char *)0x0,0);\n  if (pcVar1 == (char *)0x0) {\n    piVar2 = __errno_location();\n    if (*piVar2 == 0xc) {\n                    /* WARNING: Subroutine does not return */\n      xalloc_die();\n    }\n  }\n  return pcVar1;\n}\n\n", 
    "00102630": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nssize_t readlink(char *__path,char *__buf,size_t __len)\n\n{\n  ssize_t sVar1;\n  \n  sVar1 = (*(code *)PTR_readlink_00112d58)();\n  return sVar1;\n}\n\n", 
    "00103840": "\nundefined4 computecon(undefined8 param_1,undefined4 param_2,undefined8 param_3)\n\n{\n  short sVar1;\n  int iVar2;\n  undefined4 uVar3;\n  void *__ptr;\n  long in_FS_OFFSET;\n  undefined8 local_30;\n  undefined8 local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_30 = 0;\n  local_28 = 0;\n  __ptr = (void *)dir_name();\n  if (__ptr != (void *)0x0) {\n    iVar2 = getcon(&local_30);\n    if (-1 < iVar2) {\n      iVar2 = rpl_getfilecon(__ptr,&local_28);\n      if (-1 < iVar2) {\n        sVar1 = mode_to_security_class(param_2);\n        if (sVar1 != 0) {\n          uVar3 = security_compute_create(local_30,local_28,sVar1,param_3);\n          goto LAB_001038c6;\n        }\n      }\n    }\n  }\n  uVar3 = 0xffffffff;\nLAB_001038c6:\n  free(__ptr);\n  freecon(local_30);\n  freecon(local_28);\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar3;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n"
}